{"id": "4c33b0ff-a073-4db9-92a4-a04ae316f6ef", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), bounds.lb, bounds.ub)\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = self.c1 * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        self.velocity[idx] = 0.5 * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization (DE-PSO) that leverages the exploration of DE and exploitation of PSO for efficient global optimization.", "configspace": "", "generation": 0, "fitness": 0.8706959245953468, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.87 with standard deviation 0.01.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8840946432535317, 0.857297205937162]}, "mutation_prompt": null}
{"id": "474709d7-904b-4627-90bb-24c5ddf80ae9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), bounds.lb, bounds.ub)\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = self.c1 * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        self.velocity[idx] = 0.5 * self.velocity[idx] + cognitive + social\n\n    def local_search(self, individual, bounds):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_individual = np.clip(individual + perturbation, bounds.lb, bounds.ub)\n        return new_individual\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    break\n\n            # Local search exploit phase\n            if eval_count < self.budget:\n                for i in range(self.population_size):\n                    local_trial = self.local_search(self.population[i], bounds)\n                    local_score = func(local_trial)\n                    eval_count += 1\n                    if local_score < scores[i]:\n                        self.population[i] = local_trial\n                        scores[i] = local_score\n                    \n                    if eval_count >= self.budget:\n                        break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "An enhanced DE-PSO algorithm integrating adaptive parameters and a local search exploit to improve convergence rates and solution accuracy.", "configspace": "", "generation": 1, "fitness": 0.8245961555532322, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.03.", "error": "", "parent_id": "4c33b0ff-a073-4db9-92a4-a04ae316f6ef", "metadata": {"aucs": [0.8591525705759295, 0.7900397405305349]}, "mutation_prompt": null}
{"id": "be7f65b2-1a9c-4a4f-a5a8-440689fe835f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.1 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = self.c1 * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        self.velocity[idx] = 0.3 * self.velocity[idx] + cognitive + social  # Reduced inertia weight\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced Hybrid DE-PSO by incorporating a dynamic mutation factor and adaptive velocity adjustment for improved convergence.", "configspace": "", "generation": 2, "fitness": 0.8760582089437634, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.01.", "error": "", "parent_id": "4c33b0ff-a073-4db9-92a4-a04ae316f6ef", "metadata": {"aucs": [0.8662781176084593, 0.8858383002790675]}, "mutation_prompt": null}
{"id": "c97cae02-afcf-4ea7-b932-00eb70e9444f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.1 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = self.c1 * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.2 * np.cos(np.pi * idx / self.budget)\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social  # Dynamic inertia weight\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Fine-tuned the inertia weight for the PSO component to dynamically change based on generations, enhancing balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.8306623334790917, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.02.", "error": "", "parent_id": "be7f65b2-1a9c-4a4f-a5a8-440689fe835f", "metadata": {"aucs": [0.8074548223836336, 0.8538698445745498]}, "mutation_prompt": null}
{"id": "dc2f011a-3c84-4603-966c-cc946e93e392", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.1 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = self.c1 * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced Hybrid DE-PSO with dynamic inertia weight adjustment to balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.8952953038149309, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.01.", "error": "", "parent_id": "be7f65b2-1a9c-4a4f-a5a8-440689fe835f", "metadata": {"aucs": [0.8832377788123303, 0.9073528288175315]}, "mutation_prompt": null}
{"id": "8de73e4f-af57-408b-9caa-dd4c16086c14", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.1 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = self.c1 * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved HybridDEPSO with adaptive crossover rate to enhance exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.9156443253821942, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "dc2f011a-3c84-4603-966c-cc946e93e392", "metadata": {"aucs": [0.9030706039108045, 0.928218046853584]}, "mutation_prompt": null}
{"id": "b54cfedc-558c-4788-b925-0a29d0f3929a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.1 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved balance by using a dynamic personal-best influence via time-varying cognitive coefficient in PSO update.", "configspace": "", "generation": 6, "fitness": 0.9211795045098459, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "8de73e4f-af57-408b-9caa-dd4c16086c14", "metadata": {"aucs": [0.920262362656239, 0.9220966463634527]}, "mutation_prompt": null}
{"id": "e12305d6-a90c-4de6-bec9-e72f876066c0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.1 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Adjusted\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced adaptability through a dynamically tuned social coefficient in PSO update.", "configspace": "", "generation": 7, "fitness": 0.8944007519837378, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.04.", "error": "", "parent_id": "b54cfedc-558c-4788-b925-0a29d0f3929a", "metadata": {"aucs": [0.9298934610670906, 0.8589080429003851]}, "mutation_prompt": null}
{"id": "e3ae898b-7624-4123-bc3a-63d64e983b13", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.1 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved balance by using a dynamic personal-best influence via time-varying cognitive coefficient in PSO update.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b54cfedc-558c-4788-b925-0a29d0f3929a", "metadata": {"aucs": [0.920262362656239, 0.9220966463634527]}, "mutation_prompt": null}
{"id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a slightly more adaptive DE mutation factor for enhanced exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.9447131241607178, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.00.", "error": "", "parent_id": "b54cfedc-558c-4788-b925-0a29d0f3929a", "metadata": {"aucs": [0.9467048017972667, 0.942721446524169]}, "mutation_prompt": null}
{"id": "fd4b07c2-edc6-4117-8a3c-536dc74019d1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.55  # Base DE mutation factor (adjusted)\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Adjusted base DE mutation factor to 0.55 for improved exploration.", "configspace": "", "generation": 10, "fitness": 0.9009381448781757, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9022943935900739, 0.8995818961662774]}, "mutation_prompt": null}
{"id": "2bc78b41-2e99-4048-b685-210a2f7685ed", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                decay_factor = 0.9 ** (self.budget / (self.budget + 1))  # Slightly modified line\n                self.personal_best_scores[i] = scores[i] * decay_factor\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic personal_best update strategy to improve convergence by using an exponential decay factor.", "configspace": "", "generation": 11, "fitness": 0.9172543508006197, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9256123007396232, 0.908896400861616]}, "mutation_prompt": null}
{"id": "59b7b53b-9efd-4db6-829a-88c9698b7a16", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size) + 0.2 * np.cos(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced the PSO cognitive coefficient with a sinusoidal modulation to slightly improve exploration.", "configspace": "", "generation": 12, "fitness": 0.9263826576592432, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9369402059842173, 0.9158251093342691]}, "mutation_prompt": null}
{"id": "3f02e255-9a47-4154-a7e3-ed78df05ecc4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.6  # PSO social coefficient (changed from 1.5 to 1.6)\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the PSO social coefficient for improved convergence in swarm interactions.", "configspace": "", "generation": 13, "fitness": 0.9250261584273124, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9398302278680788, 0.910222088986546]}, "mutation_prompt": null}
{"id": "de8a5b3c-e6ea-4d73-8d23-76f1eb9e961c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.17 * np.sin(np.pi * gen / self.budget)  # Slightly further increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Further refined the dynamic amplitude for the DE mutation factor to maintain better balance between exploration and exploitation.", "configspace": "", "generation": 14, "fitness": 0.92059039627127, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201479189479055, 0.9210328735946346]}, "mutation_prompt": null}
{"id": "89dcf74b-97c5-4f25-95d2-db4da1de765d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.25 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight (Adjusted)\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic adjustment to the PSO inertia weight to enhance convergence speed.", "configspace": "", "generation": 15, "fitness": 0.8981565108826104, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.914830350142589, 0.8814826716226317]}, "mutation_prompt": null}
{"id": "24120277-7177-4d2a-b0a7-8e533ff1cf5b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / (0.8 * self.budget))  # Adjusted dynamic mutation factor\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n\n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n\n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved the dynamic mutation factor for better adaptability.", "configspace": "", "generation": 16, "fitness": 0.9206275306837883, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201270113698202, 0.9211280499977565]}, "mutation_prompt": null}
{"id": "e03a35e4-9e5a-4604-9aa5-1b99c23aa91c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(1.5 * np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced the dynamic mutation factor in DE for improved exploration capabilities.", "configspace": "", "generation": 17, "fitness": 0.9165427327427428, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.920082033093073, 0.9130034323924126]}, "mutation_prompt": null}
{"id": "ac89bfd8-0463-417e-a8b5-08ec753d03d4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.cos(np.pi * gen / self.budget)  # Changed from sin to cos\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved exploration by adjusting DE mutation factor with cosine function instead of sine for balanced diversity.", "configspace": "", "generation": 18, "fitness": 0.9113374546772556, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.93446918247391, 0.8882057268806012]}, "mutation_prompt": null}
{"id": "33e2c11e-3def-4d4d-9078-7b013796e18f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.3 * np.cos(np.pi * idx / self.population_size)  # More flexible inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a more flexible inertia weight adaptation in PSO for improved convergence speed.", "configspace": "", "generation": 19, "fitness": 0.8821781489923618, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8737169527271341, 0.8906393452575895]}, "mutation_prompt": null}
{"id": "9ae656dd-4d02-4e63-8525-18c018ce5bd4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget) + 0.05 * np.cos(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation factor by adding a cosine component for improved dynamic adaptability.", "configspace": "", "generation": 20, "fitness": 0.9009314077215627, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9022954962950975, 0.8995673191480278]}, "mutation_prompt": null}
{"id": "6102bf76-de0a-4356-a6b6-d0757085aa6b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.6  # Enhanced: Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhance global exploration by altering the base DE mutation factor.", "configspace": "", "generation": 21, "fitness": 0.9163512646558393, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9226212734754178, 0.9100812558362608]}, "mutation_prompt": null}
{"id": "af297084-d35b-4000-8620-3674ff91c34b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.4  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Reduced the base DE mutation factor to enhance the exploration potential at early stages.", "configspace": "", "generation": 22, "fitness": 0.9182228377112174, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9213241389700417, 0.915121536452393]}, "mutation_prompt": null}
{"id": "866930e2-c3e5-45b2-a895-eeb780346e92", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.55  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration by slightly increasing the base DE mutation factor to 0.55.", "configspace": "", "generation": 23, "fitness": 0.9009381448781757, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9022943935900739, 0.8995818961662774]}, "mutation_prompt": null}
{"id": "efc236ac-e181-41ea-b470-51eb968242ed", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size) * 0.5) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic personal best attraction coefficient in PSO to enhance local exploration.", "configspace": "", "generation": 24, "fitness": 0.926765327100959, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9461661740016238, 0.9073644802002943]}, "mutation_prompt": null}
{"id": "36b777de-c3d8-4024-b8a8-d5e9084e6a8f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Nonlinear adaptive mutation factor\n        F = self.F_base + 0.15 * (np.sin(np.pi * gen / self.budget) ** 2)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a nonlinear adaptive DE mutation factor for improved exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.9199713164706258, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9214093214682265, 0.918533311473025]}, "mutation_prompt": null}
{"id": "286a71b1-13a9-4657-a5c3-7b6775089dbd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.2 * np.cos(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Adjusted social coefficient\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration with a dynamic social coefficient in PSO for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.9245945893766497, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9081520858490859, 0.9410370929042136]}, "mutation_prompt": null}
{"id": "6ffd6529-c6fd-4f02-bfde-236928656343", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.7  # PSO cognitive coefficient (Adjusted from 1.5 to 1.7)\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced PSO cognitive coefficient to improve convergence speed while adhering to the 1.2% change constraint.", "configspace": "", "generation": 27, "fitness": 0.8697639509717595, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.87 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8492021923241329, 0.8903257096193862]}, "mutation_prompt": null}
{"id": "ab70aa15-174e-40c8-98bb-40eeafbe80b5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly adjusted DE mutation factor for enhanced exploration by increasing the amplitude.", "configspace": "", "generation": 28, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "fbd4606d-06e3-430d-9524-31e77c6c33a3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size) + 0.05 * np.cos(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic adaptive PSO cognitive coefficient to further enhance exploration.", "configspace": "", "generation": 29, "fitness": 0.9154404542127864, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.03.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9460892497143729, 0.8847916587111999]}, "mutation_prompt": null}
{"id": "0e52eccc-4773-43a0-b095-8650a46f08d9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Increased amplitude to 0.2\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved DE mutation strategy by slightly adjusting the dynamic factor for better exploration.", "configspace": "", "generation": 30, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "4675ad7b-3a28-4084-bf9a-c23393ea13e2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(4, int(10 * self.dim * (1 - eval_count / self.budget)))  # Dynamic population size\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced global exploration by introducing a more dynamic population size adjustment during the evolution process.", "configspace": "", "generation": 31, "fitness": 0.8958673803708139, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9000093959537323, 0.8917253647878957]}, "mutation_prompt": null}
{"id": "a7b45a8f-43c0-4741-a1b8-6e415dbf2e1a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        F = self.F_base + 0.25 * np.sin(np.pi * gen / (2 * self.budget))  # Enhanced adaptation\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.85 - 0.15 * np.cos(np.pi * gen / self.budget)  # Adjusted adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.2 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # More adaptation\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.4 + 0.6 * np.cos(np.pi * idx / self.population_size)  # Adjusted inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced dynamic adaptation in DE's mutation factor and PSO's inertia weight to better balance exploration and exploitation.", "configspace": "", "generation": 32, "fitness": 0.8309042913582592, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8094856221697142, 0.8523229605468042]}, "mutation_prompt": null}
{"id": "2851c9a2-ec85-403e-ab2d-5d585f06c61e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.cos(np.pi * gen / self.budget)  # Changed sine to cosine\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploitation by varying the DE base mutation factor with a cosine instead of sine.", "configspace": "", "generation": 33, "fitness": 0.9113374546772556, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.93446918247391, 0.8882057268806012]}, "mutation_prompt": null}
{"id": "879a4249-0cdf-45d2-a71e-b8830c909f60", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration by increasing the DE mutation amplitude for diverse search.", "configspace": "", "generation": 34, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "b41a9f51-6e0f-44f3-9b9b-b6165d770226", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.6  # Base DE mutation factor adjusted\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced the dynamic mutation factor by adjusting its base value for improved exploration.", "configspace": "", "generation": 35, "fitness": 0.9163512646558393, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9226212734754178, 0.9100812558362608]}, "mutation_prompt": null}
{"id": "dcfe9e2f-da5d-433e-9b20-93b98d80722a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.05 * np.cos(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Adjusted\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic and slightly adaptive PSO social coefficient to enhance convergence.", "configspace": "", "generation": 36, "fitness": 0.9083927320461016, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8905799823844427, 0.9262054817077606]}, "mutation_prompt": null}
{"id": "f60f391c-7883-4698-bad2-a02b24cb4cbb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.25 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved the dynamic adaptation of DE mutation factor for better exploration and convergence.", "configspace": "", "generation": 37, "fitness": 0.9166617852422192, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9200518075447758, 0.9132717629396627]}, "mutation_prompt": null}
{"id": "601df9b1-bc38-4808-81b1-ed2fa9280671", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c) * (1 + 0.2 * gen / self.budget), bounds.lb, bounds.ub)  # Dynamic scaling factor\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation strategy by introducing a dynamic scaling factor based on generation count to improve exploration.", "configspace": "", "generation": 38, "fitness": 0.9206159308304013, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.92013374099044, 0.9210981206703626]}, "mutation_prompt": null}
{"id": "4735c1ae-4c6a-44cd-ad32-73ee80128e66", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration by slightly increasing the DE mutation factor amplitude.", "configspace": "", "generation": 39, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "df6724d4-1ca8-4480-9b8d-da5abea1f922", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.17 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Refined the DE mutation factor's dynamic adaptation to enhance performance marginally.", "configspace": "", "generation": 40, "fitness": 0.92059039627127, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201479189479055, 0.9210328735946346]}, "mutation_prompt": null}
{"id": "359fab6a-61c7-4b19-a52d-507e148a86c0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration-exploitation balance by increasing the DE mutation factor amplitude slightly.", "configspace": "", "generation": 41, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "fe6d96cc-0ac6-4490-a077-0e3b120c357f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.05 * np.sin(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Dynamic social coefficient\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic adjustment to the PSO social coefficient for better convergence.", "configspace": "", "generation": 42, "fitness": 0.9236106292067467, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9287769857178615, 0.9184442726956319]}, "mutation_prompt": null}
{"id": "215eb0c3-3abc-4c9c-aa47-06281fb64529", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.6  # Base DE mutation factor increased slightly\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation factor with a dynamic base value to further improve exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.9163512646558393, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9226212734754178, 0.9100812558362608]}, "mutation_prompt": null}
{"id": "900d332a-99e4-4a3a-87ec-58934e1cbf4b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Dynamic social coefficient\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduce a dynamic PSO social coefficient for improved adaptation to current swarm behavior.", "configspace": "", "generation": 44, "fitness": 0.8949208166912659, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.03.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9298949243989513, 0.8599467089835805]}, "mutation_prompt": null}
{"id": "9f1235a9-cd97-440f-9f9a-f7e89564e7f1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.3 * np.cos(np.pi * idx / self.population_size)  # More dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a more dynamic PSO inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 45, "fitness": 0.8821781489923618, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8737169527271341, 0.8906393452575895]}, "mutation_prompt": null}
{"id": "d30fe110-2652-4bb6-9a2a-46f4fb50009c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.6  # PSO social coefficient, slight increase\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly adjusted the PSO social coefficient for better exploration in high-dimensional spaces.", "configspace": "", "generation": 46, "fitness": 0.9250261584273124, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9398302278680788, 0.910222088986546]}, "mutation_prompt": null}
{"id": "9294e20e-0795-435f-873b-501c54311cb3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base * np.exp(-0.005 * gen)  # Exponential decay for gradual adaptation\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a more dynamic DE mutation factor using an exponential decay function for gradual adaptation over time.", "configspace": "", "generation": 47, "fitness": 0.9241509855948331, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9388522821606826, 0.9094496890289835]}, "mutation_prompt": null}
{"id": "566cde68-044a-4019-a891-0d21d8536143", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 * 0.9 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced dynamic scaling for PSO's cognitive coefficient to enhance convergence adaptability.", "configspace": "", "generation": 48, "fitness": 0.9042087414585276, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9066774365671374, 0.9017400463499178]}, "mutation_prompt": null}
{"id": "d4e082af-86ad-4d11-a272-fe3f70077052", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly improved exploratory behavior by adjusting the DE mutation factor's dynamic range.", "configspace": "", "generation": 49, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "faf09c44-e616-4fa5-ae04-e08e84df1471", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a slightly more adaptive DE mutation factor for enhanced exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9467048017972667, 0.942721446524169]}, "mutation_prompt": null}
{"id": "33a4b22c-9420-47d9-81cc-91ff77febdd9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.55  # PSO social coefficient (increased from 1.5 to 1.55)\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a slight increase in PSO social coefficient to enhance convergence speed.", "configspace": "", "generation": 51, "fitness": 0.9141852880817877, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9196711670595756, 0.9086994091039997]}, "mutation_prompt": null}
{"id": "685181fa-8042-4b4e-b89a-c29a5da1a104", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced the DE mutation strategy by slightly increasing the dynamic mutation factor to improve global exploration.", "configspace": "", "generation": 52, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "b2df38ab-11ed-47bf-92ed-7b436448561d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.8 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE crossover probability dynamics for improved adaptation in convergence.", "configspace": "", "generation": 53, "fitness": 0.9252928526119883, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9317926727105791, 0.9187930325133975]}, "mutation_prompt": null}
{"id": "7adab052-c869-4516-a1ed-3a4be318afb3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(2 * np.pi * gen / self.budget)  # Change: increased frequency\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation factor to improve exploration during early iterations.", "configspace": "", "generation": 54, "fitness": 0.9167758144375271, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.919894492994977, 0.913657135880077]}, "mutation_prompt": null}
{"id": "76ebca49-f058-421f-ad23-858301152424", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-3, 3, (self.population_size, self.dim))  # Increase diversity of initial velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved exploration by increasing the diversity of the initial velocity vectors.", "configspace": "", "generation": 55, "fitness": 0.9092525277853851, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9066723224606554, 0.9118327331101147]}, "mutation_prompt": null}
{"id": "05727d83-5509-4695-93b8-1ef71e6615a5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.17 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the DE mutation factor amplitude to enhance exploration.", "configspace": "", "generation": 56, "fitness": 0.92059039627127, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201479189479055, 0.9210328735946346]}, "mutation_prompt": null}
{"id": "403588de-8fac-4168-bfaf-040f98bd02ce", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.18 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation factor variability by slightly increasing its dynamic amplitude for better exploration.", "configspace": "", "generation": 57, "fitness": 0.9206117414962874, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201359489019777, 0.9210875340905972]}, "mutation_prompt": null}
{"id": "ab6efe11-47f3-4b45-be05-766f1fba1f85", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * (np.sin(np.pi * gen / self.budget) + np.cos(np.pi * gen / self.budget))  # Modified\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a more dynamic DE mutation factor using a cosine component for improved adaptability.", "configspace": "", "generation": 58, "fitness": 0.9072693131912642, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9270704976099237, 0.8874681287726048]}, "mutation_prompt": null}
{"id": "3a3fcd8a-fd00-42a1-9545-5e26b74f7bbd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.55  # Base DE mutation factor (adjusted)\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Adjusted the base DE mutation factor to potentially enhance exploration further.", "configspace": "", "generation": 59, "fitness": 0.9009381448781757, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9022943935900739, 0.8995818961662774]}, "mutation_prompt": null}
{"id": "063d896c-dd9d-46ec-a828-a4efc6dc2a7c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.85 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate, changed slightly\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly modified the DE crossover rate to improve adaptability and enhance convergence.", "configspace": "", "generation": 60, "fitness": 0.9281797727356418, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9332873336250037, 0.9230722118462797]}, "mutation_prompt": null}
{"id": "81abc675-fe25-41b4-bdf8-35ed8f5d12f4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation factor oscillation for improved performance.", "configspace": "", "generation": 61, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "804bb9a4-340e-4759-a2c7-4dd93b1facb7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.15 * np.cos(np.pi * gen / self.budget)  # Adjusted amplitude for adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced the DE crossover probability adaptation to further improve the exploration and exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.9281797727356418, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9332873336250037, 0.9230722118462797]}, "mutation_prompt": null}
{"id": "e3b06a89-7d22-4fdd-84cc-9013d1ac69e2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly more dynamic\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced slightly more dynamic adaptation in the DE mutation factor to enhance exploration-exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "03bb17b2-8c57-4a25-9f4e-ef2ea382a1c0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.c3 = 0.05  # New global learning coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        r3 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        global_learning = self.c3 * r3 * (np.mean(self.population, axis=0) - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social + global_learning\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a global learning factor in PSO to enhance collective intelligence.", "configspace": "", "generation": 64, "fitness": 0.9275180465158236, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9402519480955172, 0.91478414493613]}, "mutation_prompt": null}
{"id": "2f1afff2-d74f-40c6-adfa-b6db8edf9a4a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.6  # PSO cognitive coefficient (slightly increased)\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Fine-tuned PSO cognitive coefficient to enhance exploration.", "configspace": "", "generation": 65, "fitness": 0.8488867757438989, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.04.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8093555088535247, 0.888418042634273]}, "mutation_prompt": null}
{"id": "c587c8dc-d81c-4252-9e7d-66c8f09e544e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 - 0.1 * np.cos(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Changed\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a time-varying factor to the PSO social coefficient for improved convergence speed.", "configspace": "", "generation": 66, "fitness": 0.9153611079323087, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9189964174711884, 0.911725798393429]}, "mutation_prompt": null}
{"id": "d816ea25-188d-4a31-86f7-067b5aaf80a2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + (0.15 + 0.01 * np.random.rand()) * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude with randomness\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced slight randomness in the DE mutation factor amplitude to enhance exploration.", "configspace": "", "generation": 67, "fitness": 0.8546974268169346, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.03.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8292820332697632, 0.880112820364106]}, "mutation_prompt": null}
{"id": "61244808-ecd8-4f82-82e4-8eece6941938", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.25 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        momentum = 0.1 * self.velocity[idx]  # New momentum term\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social + momentum\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced dynamic DE mutation factor and introduced momentum term in PSO velocity for improved convergence.", "configspace": "", "generation": 68, "fitness": 0.8190070471648073, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.03.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.7898056385133656, 0.848208455816249]}, "mutation_prompt": null}
{"id": "e0ff7273-8035-4543-8a5f-95333d4fb6e9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor with increased amplitude\n        F = self.F_base + 0.18 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly adjusted the DE mutation factor's amplitude for potentially better global exploration.", "configspace": "", "generation": 69, "fitness": 0.9206117414962874, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201359489019777, 0.9210875340905972]}, "mutation_prompt": null}
{"id": "11262e29-bbf5-4ec7-a490-39a31bb65c84", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        self.c2 = 1.5 + 0.2 * np.sin(np.pi * idx / self.population_size)  # Time-varying social coefficient\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a time-varying PSO social coefficient for improved convergence dynamics.", "configspace": "", "generation": 70, "fitness": 0.9196807220881286, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9232247141418377, 0.9161367300344194]}, "mutation_prompt": null}
{"id": "7ec1eae7-e75d-45ba-b3f0-5e652c052314", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.7  # PSO social coefficient  # Increased from 1.5 to 1.7\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Increased PSO social coefficient to enhance convergence speed by leveraging global best more strongly.", "configspace": "", "generation": 71, "fitness": 0.9234753094259838, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9143567058250739, 0.9325939130268935]}, "mutation_prompt": null}
{"id": "df3d1f94-8225-41a8-b1b2-d028806a1f42", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Adjusted amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Adjusted the DE mutation factor's amplitude for improved diversity.", "configspace": "", "generation": 72, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "80a84593-25de-4c86-b141-030b2f447431", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.3 * np.cos(np.pi * idx / self.population_size)  # Adjusted dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced adaptive inertia weight amplitude in PSO for better exploration-exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.8821781489923618, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8737169527271341, 0.8906393452575895]}, "mutation_prompt": null}
{"id": "838a7716-2fe6-46bb-96c9-64d74f4cbd47", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.25 * np.sin(np.pi * gen / self.budget)  # Increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation factor dynamics by modifying the oscillation amplitude for improved exploration.", "configspace": "", "generation": 74, "fitness": 0.9166617852422192, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9200518075447758, 0.9132717629396627]}, "mutation_prompt": null}
{"id": "073a7d43-61bc-43b8-9da9-6e1b3c96db9d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(2 * np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced DE mutation factor with a dynamic, phase-based adjustment to improve convergence.", "configspace": "", "generation": 75, "fitness": 0.9167758144375271, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.919894492994977, 0.913657135880077]}, "mutation_prompt": null}
{"id": "77bcab70-556b-48e2-a78f-d923fcdf11b5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size) + 0.5 * np.sin(2 * np.pi * idx / self.population_size)  # Nonlinear time-varying inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced nonlinear time-varying inertia weight for improved balance in PSO.", "configspace": "", "generation": 76, "fitness": 0.8685279944207064, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.87 with standard deviation 0.03.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8427595063006749, 0.8942964825407379]}, "mutation_prompt": null}
{"id": "dbd4328d-2fe8-4273-a574-18dec642d412", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.1 * np.cos(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Dynamic\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a more dynamic PSO social coefficient to enhance convergence speed.", "configspace": "", "generation": 77, "fitness": 0.9184286886016182, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9096902081073008, 0.9271671690959356]}, "mutation_prompt": null}
{"id": "7cd9ed19-cd67-4aa3-ad29-8ddd3d2c1481", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration by increasing the amplitude of the dynamic mutation factor slightly more.", "configspace": "", "generation": 78, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "0c44c0e3-f6af-43ae-aab4-6aad09135075", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Dynamic social coefficient\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced the PSO social coefficient for better convergence by making it adaptive.", "configspace": "", "generation": 79, "fitness": 0.8949208166912659, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.03.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9298949243989513, 0.8599467089835805]}, "mutation_prompt": null}
{"id": "4c700280-889c-426c-92d2-dfd3b46f1db5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.55  # PSO cognitive coefficient adjusted\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly adjusted the PSO cognitive coefficient for better exploration-exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.9251679845921157, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9154713089533976, 0.9348646602308339]}, "mutation_prompt": null}
{"id": "aab484c7-dbdc-45cc-989b-417b74f89411", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly refined the DE mutation factor function for improved exploration-exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "bcba08f9-2a25-418a-885d-2a8c9c418acd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            self.population_size = int(10 * dim * (1 - gen / self.budget)) + 1  # Dynamic population size adjustment\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic population size adjustment to balance exploration and exploitation.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'dim' is not defined\").", "error": "NameError(\"name 'dim' is not defined\")", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {}, "mutation_prompt": null}
{"id": "4490ab5e-c4aa-4608-adfc-adf8c9598265", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)\n        if np.random.rand() < 0.05:\n            inertia_weight += np.random.uniform(-0.1, 0.1)  # Random perturbation for diversity\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhance exploration by adaptive inertia weight and integrate a random perturbation for diversity.", "configspace": "", "generation": 83, "fitness": 0.8607963933107068, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8839789137991335, 0.83761387282228]}, "mutation_prompt": null}
{"id": "cda7e28e-2d88-4027-877b-52814fd43fa1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        noise = np.random.normal(0, 0.01, self.dim)  # Gaussian perturbation\n        mutant = np.clip(a + F * (b - c) + noise, bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size) + 0.05 * np.cos(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration by introducing Gaussian perturbation in DE mutation and adaptive cognitive component in PSO.", "configspace": "", "generation": 84, "fitness": 0.8529510699949454, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8347479065824677, 0.8711542334074232]}, "mutation_prompt": null}
{"id": "3decb74b-8f20-43e7-9063-324bff9eff6e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.1 * np.cos(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Slightly adjusted\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced slight modifications to improve convergence by adaptively scaling PSO coefficients based on generation.", "configspace": "", "generation": 85, "fitness": 0.7927008720153367, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.11.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9071496711568872, 0.6782520728737862]}, "mutation_prompt": null}
{"id": "e3730bca-40f7-4992-8be4-5798064bb9a9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.55 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight updated\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Utilized a slightly more dynamic inertia weight in PSO for improved convergence.", "configspace": "", "generation": 86, "fitness": 0.9103712360959906, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9058282261866508, 0.9149142460053303]}, "mutation_prompt": null}
{"id": "7923895a-cf45-47e4-b15c-da8eb29cb41d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.20 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Adjusted DE mutation factor amplitude for improved exploration-exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "d6d246e3-6826-4760-b685-c6e624653452", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.18 * np.sin(np.pi * gen / self.budget)  # Fine-tuned amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Fine-tuned the DE mutation factor formula for a subtle improvement in exploration capabilities.", "configspace": "", "generation": 88, "fitness": 0.9206117414962874, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201359489019777, 0.9210875340905972]}, "mutation_prompt": null}
{"id": "78622b4d-4353-4482-8e80-9f82f685e0d4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social + np.random.normal(0, 0.01, self.dim)  # Added Gaussian noise\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Added a small Gaussian noise during PSO velocity update to enhance exploration.", "configspace": "", "generation": 89, "fitness": 0.8639283577346645, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8843565640970235, 0.8435001513723055]}, "mutation_prompt": null}
{"id": "805d948b-dc81-4fa4-9477-0aaaad56d0f3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.budget)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Utilize a sine function for dynamic adjustment of the PSO cognitive coefficient for improved convergence.", "configspace": "", "generation": 90, "fitness": 0.9305829383433722, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9255216657710711, 0.9356442109156734]}, "mutation_prompt": null}
{"id": "191528ac-99ea-4555-9bfd-e8cc33e267dc", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c) + 0.1 * (self.personal_best[idx] - a), bounds.lb, bounds.ub)  # Added dependency on personal best\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhance the DE mutation strategy by adding a dependency on the personal best to improve convergence rate.", "configspace": "", "generation": 91, "fitness": 0.918453793281635, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9293761821798786, 0.9075314043833915]}, "mutation_prompt": null}
{"id": "3c82d9a9-6883-4f9b-8c78-ff526402c376", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.18 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced adaptive DE mutation factor tuning by slightly increasing the dynamic range.", "configspace": "", "generation": 92, "fitness": 0.9206117414962874, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201359489019777, 0.9210875340905972]}, "mutation_prompt": null}
{"id": "0b25e49d-7634-4644-b798-fc322d87a4ac", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Adjusted initial velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced an adaptive strategy for handling initial velocities to enhance convergence.", "configspace": "", "generation": 93, "fitness": 0.9364009912459097, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9351895248004607, 0.9376124576913586]}, "mutation_prompt": null}
{"id": "1d3cead6-1505-4cde-b8e7-a1572a895696", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.2 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced the dynamic mutation factor for better adaptability during optimization.", "configspace": "", "generation": 94, "fitness": 0.9206539262321577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201120623376506, 0.9211957901266647]}, "mutation_prompt": null}
{"id": "5afae594-2498-44b7-aa5d-ed2c01ccc6bc", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor with phase shift\n        F = self.F_base + 0.15 * np.sin(np.pi * (gen + 0.25) / self.budget)  # Phase shift added\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a phase-shifted adaptive DE mutation factor for better exploration, improving convergence.", "configspace": "", "generation": 95, "fitness": 0.9205194513245885, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201308545106686, 0.9209080481385082]}, "mutation_prompt": null}
{"id": "b9b22e74-1f23-4247-9883-05849c0d6370", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        self.c2 = 1.5 + 0.1 * np.sin(np.pi * idx / self.budget)  # Dynamic social coefficient\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Improved exploration by making the PSO social coefficient adaptive based on the generation count.", "configspace": "", "generation": 96, "fitness": 0.9322999021061928, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9311414362949308, 0.9334583679174547]}, "mutation_prompt": null}
{"id": "ea587e95-eea3-479c-a08e-584ddc23475a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.55  # Slightly increased base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the base DE mutation factor to enhance exploration capabilities.", "configspace": "", "generation": 97, "fitness": 0.9009381448781757, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9022943935900739, 0.8995818961662774]}, "mutation_prompt": null}
{"id": "019c6b90-6acf-41a1-b39a-16e43f1eafde", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.18 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = self.c2 * r2 * (self.global_best - self.population[idx])\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Enhanced global exploration by modifying the DE mutation factor's amplitude slightly, improving diversity.", "configspace": "", "generation": 98, "fitness": 0.9206117414962874, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.9201359489019777, 0.9210875340905972]}, "mutation_prompt": null}
{"id": "40ab26a3-1c26-49ea-a27e-7fc08c2f82a4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.c1 = 1.5  # PSO cognitive coefficient\n        self.c2 = 1.5  # PSO social coefficient\n        self.population = None\n        self.velocity = None\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with small random velocities\n        self.personal_best = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best[i] = self.population[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best = self.population[i].copy()\n        return scores\n\n    def de_mutation_and_crossover(self, idx, bounds, gen):\n        # Dynamic mutation factor\n        F = self.F_base + 0.15 * np.sin(np.pi * gen / self.budget)  # Slightly increased amplitude\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + F * (b - c), bounds.lb, bounds.ub)\n        self.CR = 0.9 - 0.1 * np.cos(np.pi * gen / self.budget)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover, mutant, self.population[idx])\n        return trial\n\n    def pso_update_velocity(self, idx):\n        r1 = np.random.rand(self.dim)\n        r2 = np.random.rand(self.dim)\n        cognitive = (self.c1 + 0.1 * np.sin(np.pi * idx / self.population_size)) * r1 * (self.personal_best[idx] - self.population[idx])  # Adjusted\n        social = (self.c2 + 0.05 * np.cos(np.pi * idx / self.population_size)) * r2 * (self.global_best - self.population[idx])  # Slightly dynamic social coefficient\n        inertia_weight = 0.5 + 0.5 * np.cos(np.pi * idx / self.population_size)  # Dynamic inertia weight\n        self.velocity[idx] = inertia_weight * self.velocity[idx] + cognitive + social\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        eval_count = 0\n        gen = 0\n        \n        while eval_count < self.budget:\n            scores = self.evaluate_population(func)\n            eval_count += self.population_size\n            gen += 1\n            \n            for i in range(self.population_size):\n                trial = self.de_mutation_and_crossover(i, bounds, gen)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                    \n                if eval_count >= self.budget:\n                    break\n\n            # PSO update\n            for i in range(self.population_size):\n                self.pso_update_velocity(i)\n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], bounds.lb, bounds.ub)\n\n        return self.global_best, self.global_best_score", "name": "HybridDEPSO", "description": "Introduced a minor improvement by making the social coefficient in PSO slightly dynamic to enhance adaptability.", "configspace": "", "generation": 99, "fitness": 0.9083927320461016, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.02.", "error": "", "parent_id": "922abb2e-d884-4301-a7e4-c15f9145dce7", "metadata": {"aucs": [0.8905799823844427, 0.9262054817077606]}, "mutation_prompt": null}
