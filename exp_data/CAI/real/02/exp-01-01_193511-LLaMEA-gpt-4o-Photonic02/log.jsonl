{"id": "ea099aa9-90cf-4994-86e7-dc0ba1269453", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.7   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Hybrid Particle Swarm and Differential Evolution algorithm combining swarm intelligence with mutation and crossover for diverse global search.", "configspace": "", "generation": 0, "fitness": 0.7014744435564004, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7014744435564004, 0.7014744435564004]}, "mutation_prompt": null}
{"id": "8fba14ab-6438-46c2-a824-81e430067327", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.7   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i])) * np.random.uniform(0.9, 1.1)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Incorporate a random scaling factor to particle velocities for enhanced exploration.", "configspace": "", "generation": 1, "fitness": 0.6950530341820249, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "ea099aa9-90cf-4994-86e7-dc0ba1269453", "metadata": {"aucs": [0.6950530341820249, 0.6950530341820249]}, "mutation_prompt": null}
{"id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a dynamic strategy by slightly enhancing the inertia weight for improved exploration.", "configspace": "", "generation": 2, "fitness": 0.8143230870284524, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.00.", "error": "", "parent_id": "ea099aa9-90cf-4994-86e7-dc0ba1269453", "metadata": {"aucs": [0.8143230870284524, 0.8143230870284524]}, "mutation_prompt": null}
{"id": "62f181ee-c3b2-48e2-9b93-282d96d34ab2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.95  # crossover probability (increased from 0.9 to 0.95)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the crossover probability for enhanced diversity and exploration.", "configspace": "", "generation": 3, "fitness": 0.6732253214418595, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6732253214418595, 0.6732253214418595]}, "mutation_prompt": null}
{"id": "edbc9d65-9f95-42ca-8240-adbe1168675a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance individual learning capability.", "configspace": "", "generation": 4, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "67434192-8a09-4568-8c8d-eb8e963f3893", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (np.random.rand() * self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Increase exploration by adjusting the velocity update with a random scaling factor.", "configspace": "", "generation": 5, "fitness": 0.764993921332686, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.76 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.764993921332686, 0.764993921332686]}, "mutation_prompt": null}
{"id": "ba617abb-fdab-4c69-9732-6b62a5601eb9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance local exploration by adjusting the cognitive parameter slightly.", "configspace": "", "generation": 6, "fitness": 0.7272782549757077, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7272782549757077, 0.7272782549757077]}, "mutation_prompt": null}
{"id": "02f440d5-f5fc-475e-bde1-580fea968630", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                F_adaptive = self.F + 0.1 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce adaptive mutation factor in Differential Evolution to enhance local exploration.", "configspace": "", "generation": 7, "fitness": 0.6025736551560854, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6025736551560854, 0.6025736551560854]}, "mutation_prompt": null}
{"id": "69f31637-8715-4268-84d7-1aa7cc227e4b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        self.chaotic_sequence = self._initialize_chaotic_sequence()  # Chaotic sequence for randomness\n\n    def _initialize_chaotic_sequence(self):\n        sequence = np.zeros(self.budget)\n        sequence[0] = 0.7  # Initial condition\n        for t in range(1, self.budget):\n            sequence[t] = 4 * sequence[t-1] * (1 - sequence[t-1])  # Logistic map\n        return sequence\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Adaptive learning factors\n                adaptive_c1 = self.c1 * self.chaotic_sequence[eval_count % self.budget]\n                adaptive_c2 = self.c2 * (1 - self.chaotic_sequence[eval_count % self.budget])\n\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      adaptive_c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      adaptive_c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive learning factors and chaotic maps for enhanced exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.6555457661046082, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6555457661046082, 0.6555457661046082]}, "mutation_prompt": null}
{"id": "d962af96-1ae9-4940-b72b-f77414c8a714", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improve convergence by adjusting the cognitive parameter slightly for better individual learning.", "configspace": "", "generation": 9, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "550ec6db-9c96-4c52-bed3-559b8b060cf5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.1  # social parameter (changed from 2.0 to 2.1)\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly adjust the social parameter (c2) to boost convergence speed.", "configspace": "", "generation": 10, "fitness": 0.715222241049327, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.715222241049327, 0.715222241049327]}, "mutation_prompt": null}
{"id": "016be118-0113-4fc9-8757-2c09d54a46ca", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 1.8  # cognitive parameter (changed from 2.0 to 1.8)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly tweak the cognitive parameter to balance exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.6843789908071156, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6843789908071156, 0.6843789908071156]}, "mutation_prompt": null}
{"id": "e18a2676-f70b-4a6b-b49f-0e57ccf35bf1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (increased from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance individual exploration capability.", "configspace": "", "generation": 12, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "e27b83a2-17a0-4408-af8c-bf323f9c54c6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamically adjusted inertia weight\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjusted the inertia weight dynamically for better balance between exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.69457267959333, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.69457267959333, 0.69457267959333]}, "mutation_prompt": null}
{"id": "613ae6d7-7eed-41a9-b8ba-d1285f2b6754", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # initial crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < (self.CR * (1 - eval_count / self.budget))\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhancing exploration by adjusting crossover probability dynamically based on evaluation progress.", "configspace": "", "generation": 14, "fitness": 0.6733305466260846, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6733305466260846, 0.6733305466260846]}, "mutation_prompt": null}
{"id": "4f613c84-a8ba-455b-b909-3667b788d46d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.95 # crossover probability (changed from 0.9 to 0.95)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced exploration by adjusting the crossover probability for better diversity.", "configspace": "", "generation": 15, "fitness": 0.6732253214418595, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6732253214418595, 0.6732253214418595]}, "mutation_prompt": null}
{"id": "c68355af-a085-4cd2-bfb2-d0a1536fab1c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.95 # crossover probability (changed from 0.9 to 0.95)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the crossover probability to enhance exploration diversity.", "configspace": "", "generation": 16, "fitness": 0.6732253214418595, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6732253214418595, 0.6732253214418595]}, "mutation_prompt": null}
{"id": "5545b0db-76e3-4ad6-b688-e92fb0f28667", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improved exploration by slightly adjusting the cognitive parameter.", "configspace": "", "generation": 17, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "adb4769b-f5e0-4415-8d70-e9b998670a94", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance individual exploration.", "configspace": "", "generation": 18, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "fd6b383a-1355-4098-af93-e1107ca75122", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.95  # crossover probability (changed from 0.9 to 0.95)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a dynamic strategy by slightly enhancing the crossover probability for better exploration.", "configspace": "", "generation": 19, "fitness": 0.6732253214418595, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6732253214418595, 0.6732253214418595]}, "mutation_prompt": null}
{"id": "236f7c99-91c1-4b5c-b3d4-3758e240c760", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter (c1) to enhance individual exploration.", "configspace": "", "generation": 20, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "38aef967-f3a9-4690-8a9b-9b5fb128b2f8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.92  # crossover probability (changed from 0.9 to 0.92)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the crossover probability to enhance exploration capabilities.", "configspace": "", "generation": 21, "fitness": 0.6957339825330247, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6957339825330247, 0.6957339825330247]}, "mutation_prompt": null}
{"id": "1f9cfa26-baf7-4195-a351-8f8f7a4d4682", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.w = 0.5 + (0.5 * (self.budget - eval_count) / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhancing the algorithm by introducing adaptive inertia weight for balancing exploration and exploitation dynamically.", "configspace": "", "generation": 22, "fitness": 0.6907022096764117, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6907022096764117, 0.6907022096764117]}, "mutation_prompt": null}
{"id": "48457200-4873-4f2f-892d-8551df84a572", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1 for more personal exploration)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Fine-tuning the cognitive parameter for enhanced individual learning and adaptability.", "configspace": "", "generation": 23, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "a4d564ab-7e36-45c3-bf7b-f3cf1cddb273", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.95  # crossover probability (changed from 0.9 to 0.95)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a slight adjustment to the crossover probability to enhance exploration capabilities.", "configspace": "", "generation": 24, "fitness": 0.6732253214418595, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6732253214418595, 0.6732253214418595]}, "mutation_prompt": null}
{"id": "4b35c51a-32e9-461c-acc2-191165fcf6a4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Fine-tuning the cognitive parameter to enhance convergence speed.", "configspace": "", "generation": 25, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "bc098d61-e71c-4e6e-bbf1-011838d6ce4a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.92  # crossover probability (changed from 0.9 to 0.92)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance exploitation by increasing the crossover probability slightly.", "configspace": "", "generation": 26, "fitness": 0.6957339825330247, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6957339825330247, 0.6957339825330247]}, "mutation_prompt": null}
{"id": "55d27afe-de38-4d2a-ac24-691e2af1f787", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                self.F = 0.5 + 0.5 * np.sin((np.pi * eval_count) / (2 * self.budget))  # Adaptive differential weight\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive differential weight for balancing exploration and exploitation in HybridPSODE.", "configspace": "", "generation": 27, "fitness": 0.6169373547174286, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6169373547174286, 0.6169373547174286]}, "mutation_prompt": null}
{"id": "5184a0fe-4cec-4492-8347-a7cb8b6cffca", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                self.F = 0.2 + 0.3 * (eval_count / self.budget)  # Adaptive differential weight\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive differential weight to balance exploration and exploitation in HybridPSODE.", "configspace": "", "generation": 28, "fitness": 0.7085700940129845, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7085700940129845, 0.7085700940129845]}, "mutation_prompt": null}
{"id": "4cefdec8-6587-49bc-a6a6-da41d65aee47", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increased the cognitive parameter (c1) to promote individual exploration and refinement.", "configspace": "", "generation": 29, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "fc081c94-f8b4-4925-9912-577aa4b7cfa5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.92  # crossover probability (changed from 0.9 to 0.92)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly enhance the crossover probability for improved exploration in differential evolution.", "configspace": "", "generation": 30, "fitness": 0.6957339825330247, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6957339825330247, 0.6957339825330247]}, "mutation_prompt": null}
{"id": "f7f15825-824c-404a-8903-8aabad93141e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a dynamic strategy by enhancing both inertia weight and cognitive parameter for improved exploration.", "configspace": "", "generation": 31, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "d013d1cb-1bff-487c-9c8c-9a0437bcef9a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.55  # differential weight (changed from 0.5 to 0.55)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly boost the differential weight for improved exploitation.", "configspace": "", "generation": 32, "fitness": 0.642604080651147, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.642604080651147, 0.642604080651147]}, "mutation_prompt": null}
{"id": "beb6aa5f-e2a4-48f9-b17b-936424e0baeb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.6   # differential weight (changed from 0.5 to 0.6)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced convergence by adjusting the differential weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.6059645918641157, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6059645918641157, 0.6059645918641157]}, "mutation_prompt": null}
{"id": "91d467ed-15f2-4ef4-b3fe-c673f3f0d2f3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.55  # differential weight (changed from 0.5 to 0.55)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhancing exploration by increasing the differential weight slightly in the DE mutation step.", "configspace": "", "generation": 34, "fitness": 0.642604080651147, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.642604080651147, 0.642604080651147]}, "mutation_prompt": null}
{"id": "ca811a67-aa69-4f59-a07b-9147a160523d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 35  # Adjusted from 30 to 35 for better initial exploration\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjusting the initial particle swarm size for enhanced initial exploration.", "configspace": "", "generation": 35, "fitness": 0.6559990038192098, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6559990038192098, 0.6559990038192098]}, "mutation_prompt": null}
{"id": "2e77a0b0-d649-420d-a320-8286dd966882", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.1  # social parameter (changed from 2.0 to 2.1)\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced exploration by slightly adjusting the social parameter for better convergence.", "configspace": "", "generation": 36, "fitness": 0.7725998136408614, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7725998136408614, 0.7725998136408614]}, "mutation_prompt": null}
{"id": "7e6ad01f-a5d6-4405-acb7-3ec3f314e4b1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            self.w = 0.9 - 0.5 * eval_count / self.budget  # Dynamic inertia weight adjustment\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a dynamic inertia weight adjustment based on evaluation progress for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.6775204975670076, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6775204975670076, 0.6775204975670076]}, "mutation_prompt": null}
{"id": "9ff999e7-fd43-4c66-af81-6dbea8d12393", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.85 # crossover probability, changed from 0.9 to 0.85\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Fine-tune the crossover probability to enhance exploration and exploitation balance in the HybridPSODE algorithm.", "configspace": "", "generation": 38, "fitness": 0.637708859407981, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.637708859407981, 0.637708859407981]}, "mutation_prompt": null}
{"id": "8a27f43b-b247-4188-8e14-bd9044767243", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.1  # social parameter (changed from 2.0 to 2.1)\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a dynamic strategy by slightly enhancing the social parameter for improved exploration.", "configspace": "", "generation": 39, "fitness": 0.715222241049327, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.715222241049327, 0.715222241049327]}, "mutation_prompt": null}
{"id": "3e2bc46f-0164-4768-b946-56347d47e9d2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < np.random.rand()  # Stochastic adjustment\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a stochastic adjustment to the crossover probability for enhanced global exploration.", "configspace": "", "generation": 40, "fitness": 0.7471412074609873, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7471412074609873, 0.7471412074609873]}, "mutation_prompt": null}
{"id": "b728363f-5891-42e1-8fa7-677266abbd6c", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1_initial = 2.0  # initial cognitive parameter\n        self.c2_initial = 2.0  # initial social parameter\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n        \n        nonlinear_decay = lambda t: (self.w_max - self.w_min) * (1 - (t / self.budget) ** 2) + self.w_min\n\n        while eval_count < self.budget:\n            # Update parameters adaptively\n            w = nonlinear_decay(eval_count)\n            c1 = self.c1_initial - (self.c1_initial - 1.5) * (eval_count / self.budget)\n            c2 = self.c2_initial + (2.5 - self.c2_initial) * (eval_count / self.budget)\n\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "EnhancedHybridPSODE", "description": "Introducing a nonlinear inertia weight and adaptive parameters for enhanced exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.6382560610426613, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6382560610426613, 0.6382560610426613]}, "mutation_prompt": null}
{"id": "03a331f6-e7b6-4a76-8d99-2d368c473b41", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.2  # social parameter (changed from 2.0 to 2.2)\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance global exploration by increasing the social parameter for improved convergence.", "configspace": "", "generation": 42, "fitness": 0.7006044031408866, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7006044031408866, 0.7006044031408866]}, "mutation_prompt": null}
{"id": "f01c4e18-de3b-404a-a413-16d2d49e4af8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to facilitate better personal exploration and diversity.", "configspace": "", "generation": 43, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "8bf4efba-fd69-4242-a67f-89a4359f9e48", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (np.random.uniform(0.7, 0.9) * self.velocities[i] +  # Randomized inertia weight\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing a slight randomization in inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 44, "fitness": 0.7142987118812341, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7142987118812341, 0.7142987118812341]}, "mutation_prompt": null}
{"id": "0d526eb9-b010-4734-8d73-d2493255a98f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adaptively adjust the cognitive parameter to enhance convergence speed.", "configspace": "", "generation": 45, "fitness": 0.7272782549757077, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7272782549757077, 0.7272782549757077]}, "mutation_prompt": null}
{"id": "7b5e46c4-7d9b-4ce1-bc3e-d64617a639ec", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 31  # increased from 30 to 31\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the population size to enhance exploration capability within the budget constraints.", "configspace": "", "generation": 46, "fitness": 0.6422411572699638, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6422411572699638, 0.6422411572699638]}, "mutation_prompt": null}
{"id": "a663764e-f64a-4970-865a-a082ecba2eef", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.55  # differential weight (changed from 0.5 to 0.55)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the differential weight to enhance the convergence speed in differential evolution.", "configspace": "", "generation": 47, "fitness": 0.6487516800298067, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6487516800298067, 0.6487516800298067]}, "mutation_prompt": null}
{"id": "91abf611-ddd0-4d77-9fe1-f193cce2a3f9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.92  # crossover probability (changed from 0.9 to 0.92)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the crossover probability (CR) for enhanced diversity in solution exploration.", "configspace": "", "generation": 48, "fitness": 0.6957339825330247, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6957339825330247, 0.6957339825330247]}, "mutation_prompt": null}
{"id": "b340e1b0-149b-4df3-898d-99edd04ff4e0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 1.8  # cognitive parameter (changed from 2.0 to 1.8)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjusting the learning factors (c1 and c2) to enhance balance between exploration and exploitation.", "configspace": "", "generation": 49, "fitness": 0.6843789908071156, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6843789908071156, 0.6843789908071156]}, "mutation_prompt": null}
{"id": "91a7fae8-5b96-49a3-ae2d-9d5e479fa2b0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changing dynamically)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.w = 0.4 + 0.4 * (1 - eval_count / self.budget)  # Dynamically adjust inertia weight\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refine the inertia weight dynamically based on the iteration progress to balance exploration and exploitation.", "configspace": "", "generation": 50, "fitness": 0.7287578437675852, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7287578437675852, 0.7287578437675852]}, "mutation_prompt": null}
{"id": "c9279391-7b42-4fb0-a430-f5c732f1e759", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.w = 0.4 + (0.9 - 0.4) * (self.budget - eval_count) / self.budget  # Adaptive inertia weight\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.6945726795933164, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6945726795933164, 0.6945726795933164]}, "mutation_prompt": null}
{"id": "e2bfdbc4-a2b8-4d52-b7a7-b15f37bb4da6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.95 # crossover probability (changed from 0.9 to 0.95)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjusting the crossover probability to 0.95 to enhance the exploration capability of the algorithm.", "configspace": "", "generation": 52, "fitness": 0.6732253214418595, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6732253214418595, 0.6732253214418595]}, "mutation_prompt": null}
{"id": "9755e9e8-a464-4cab-a6d9-f477c86dddb3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance the individual exploration of each particle.", "configspace": "", "generation": 53, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "21be7b82-a6c0-4914-9592-7662e16f59a0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.85  # crossover probability (changed from 0.9 to 0.85)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced exploitation by reducing the crossover probability from 0.9 to 0.85.", "configspace": "", "generation": 54, "fitness": 0.637708859407981, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.637708859407981, 0.637708859407981]}, "mutation_prompt": null}
{"id": "c9803784-7460-40cd-b6a9-1d13c6143fed", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.c1 = 2.0 - (2.0 * eval_count / self.budget)  # Adaptive cognitive parameter\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhancing the algorithm by introducing adaptive cognitive and social parameters for better convergence.", "configspace": "", "generation": 55, "fitness": 0.6713023162816598, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6713023162816598, 0.6713023162816598]}, "mutation_prompt": null}
{"id": "f087605d-7e4c-42c3-a0f1-1bf8177bcfd0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance exploration by adjusting the cognitive parameter for improved local search.", "configspace": "", "generation": 56, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "fcc9933d-91e7-4ed3-89d0-e3de49d6c6df", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly adjust the cognitive parameter to enhance exploration and convergence balance.", "configspace": "", "generation": 57, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "505e5838-2530-4534-9b61-4870ad2dabbf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.92  # crossover probability (changed from 0.9 to 0.92)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Further enhance the diversity of the swarm by slightly increasing the crossover probability for better exploration.", "configspace": "", "generation": 58, "fitness": 0.6957339825330247, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6957339825330247, 0.6957339825330247]}, "mutation_prompt": null}
{"id": "6731cdf3-87d2-4be1-bb98-f6fae9d1a19a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive F\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive differential weight F to enhance solution diversity.", "configspace": "", "generation": 59, "fitness": 0.6380600082323248, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6380600082323248, 0.6380600082323248]}, "mutation_prompt": null}
{"id": "ac0545fa-1f04-45d1-a579-2de66bf291be", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.9   # adaptive inertia weight (enhanced from original)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            diversity = np.std(self.positions, axis=0).mean()  # Calculate diversity\n            self.w = 0.5 + (0.4 * (diversity / self.dim))  # Adaptive inertia based on diversity\n            self.F = 0.3 + (0.4 * (diversity / self.dim))  # Adaptive differential weight\n\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "A novel approach incorporates adaptive inertia and mutation rates based on diversity to enhance balance between exploration and exploitation.", "configspace": "", "generation": 60, "fitness": 0.4703854141293148, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.4703854141293148, 0.4703854141293148]}, "mutation_prompt": null}
{"id": "969eca86-8cff-4047-b162-e286c1e0c0d6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance exploration by slightly increasing the cognitive parameter for better local searches.", "configspace": "", "generation": 61, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "94dbda53-63d3-45ec-86ef-9cfc7cd8d9c3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.6   # differential weight (changed from 0.5 to 0.6)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly adjust the differential weight to enhance exploration and exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.6059645918641157, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6059645918641157, 0.6059645918641157]}, "mutation_prompt": null}
{"id": "df977131-0b21-425c-aab9-9436ed8004b3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.85 # crossover probability (changed from 0.9 to 0.85)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refined HybridPSODE by adjusting crossover probability to improve solution diversity.", "configspace": "", "generation": 63, "fitness": 0.637708859407981, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.637708859407981, 0.637708859407981]}, "mutation_prompt": null}
{"id": "f2100eae-90f6-41de-b1c5-5dd344cc0200", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Increase the cognitive parameter slightly to improve personal adaptation.", "configspace": "", "generation": 64, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "227a9f94-3a5f-413a-91d1-2eae5703b543", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.92  # crossover probability (changed from 0.9 to 0.92)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly enhance the crossover probability to improve exploration efficiency.", "configspace": "", "generation": 65, "fitness": 0.6957339825330247, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6957339825330247, 0.6957339825330247]}, "mutation_prompt": null}
{"id": "76d6331f-91bf-4969-9f4b-ebabb24dcc46", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                self.F = 0.6  # Changed differential weight\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive differential weight for enhanced exploitation.", "configspace": "", "generation": 66, "fitness": 0.6059645918641157, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6059645918641157, 0.6059645918641157]}, "mutation_prompt": null}
{"id": "ce5b2987-3eda-4dfc-892b-4c4465b19415", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.91  # crossover probability (increased from 0.9 to 0.91)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increased the crossover probability to enhance exploration in the search space.", "configspace": "", "generation": 67, "fitness": 0.6538839074208304, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6538839074208304, 0.6538839074208304]}, "mutation_prompt": null}
{"id": "22ed61b7-87a7-474d-8232-28164eb5b08d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.w = 0.4 + 0.4 * (1 - eval_count / self.budget)  # Adjusted dynamically\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjusted the inertia weight dynamically based on evaluation progress to balance exploration and exploitation.", "configspace": "", "generation": 68, "fitness": 0.7287578437675852, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7287578437675852, 0.7287578437675852]}, "mutation_prompt": null}
{"id": "38d22c1b-be68-4530-aa2b-b07347c297a5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly improve exploration by adjusting the cognitive parameter for better convergence.", "configspace": "", "generation": 69, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "b5100b1d-4298-4924-8af9-40d7e15ef40a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly adjusted the cognitive parameter to improve individual exploration.", "configspace": "", "generation": 70, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "ec9bebd0-a13c-40df-9ec4-ce79699275a9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.55  # differential weight (changed from 0.5 to 0.55)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refine the optimization by slightly increasing the differential weight for enhanced exploration.", "configspace": "", "generation": 71, "fitness": 0.642604080651147, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.642604080651147, 0.642604080651147]}, "mutation_prompt": null}
{"id": "42d5446e-ac1f-412d-a1e2-38434fb74687", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w_initial = 0.9  # initial inertia weight\n        self.w_final = 0.4  # final inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Calculate dynamic inertia weight\n                self.w = self.w_initial - (self.w_initial - self.w_final) * (eval_count / self.budget)\n                \n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced exploration by updating the inertia weight to dynamically decrease linearly.", "configspace": "", "generation": 72, "fitness": 0.69457267959333, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.69457267959333, 0.69457267959333]}, "mutation_prompt": null}
{"id": "aa88e6bc-87e0-431c-966e-5fe1d53b748d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                self.w *= 0.99  # Adjusted inertia weight dynamically\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce a dynamic decrease in inertia weight for better convergence over time.", "configspace": "", "generation": 73, "fitness": 0.8020768477292779, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.8020768477292779, 0.8020768477292779]}, "mutation_prompt": null}
{"id": "5a86b9e5-ffb7-4154-80c7-5e516b423cb2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 1.9  # social parameter (changed from 2.0 to 1.9)\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Fine-tune the social parameter for enhanced convergence by slightly reducing it.", "configspace": "", "generation": 74, "fitness": 0.6746876062385194, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6746876062385194, 0.6746876062385194]}, "mutation_prompt": null}
{"id": "ec15e122-66e5-49e8-a897-67119a5cedf3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.w = 0.8 - 0.5 * (eval_count / self.budget)  # Dynamically adjust inertia weight\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjust the inertia weight dynamically to balance exploration and exploitation over iterations.", "configspace": "", "generation": 75, "fitness": 0.7187200263263824, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7187200263263824, 0.7187200263263824]}, "mutation_prompt": null}
{"id": "1368b78c-27e7-4b42-8eb4-1688e1b55223", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.1  # social parameter (changed from 2.0 to 2.1)\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the social parameter to enhance global convergence capability.", "configspace": "", "generation": 76, "fitness": 0.715222241049327, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.715222241049327, 0.715222241049327]}, "mutation_prompt": null}
{"id": "345efaf9-10c8-47b4-a7c0-fa094efb627d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjust the cognitive parameter slightly to enhance the particles' independent exploration.", "configspace": "", "generation": 77, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "722e9dce-1dc1-4815-a7a3-30ecd39e7e94", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.95  # crossover probability (increased from 0.9 to 0.95)\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Adjust the balance between exploration and exploitation by increasing the crossover probability for enhanced diversity.", "configspace": "", "generation": 78, "fitness": 0.6732253214418595, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6732253214418595, 0.6732253214418595]}, "mutation_prompt": null}
{"id": "9a835bef-e4c5-4c55-89ab-dda4c2ca3f8e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.1  # social parameter (changed from 2.0 to 2.1)\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced exploration by adjusting the social parameter to 2.1.", "configspace": "", "generation": 79, "fitness": 0.715222241049327, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.715222241049327, 0.715222241049327]}, "mutation_prompt": null}
{"id": "e806f606-9de6-4b1a-a6fb-8b64b6047f6d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.1  # social parameter (changed from 2.0 to 2.1)\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increased the social parameter to enhance collaboration among particles.", "configspace": "", "generation": 80, "fitness": 0.715222241049327, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.715222241049327, 0.715222241049327]}, "mutation_prompt": null}
{"id": "fd390410-bf3b-4e74-9d07-2a89a4ca51b0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter c1 to enhance exploration capabilities.", "configspace": "", "generation": 81, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "fadcb138-037e-4f09-8be1-d0c8045e2dd3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance the local search capability.", "configspace": "", "generation": 82, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "7ec74d24-136e-437f-a3d5-07b23d30220e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.85  # inertia weight (changed from 0.8 to 0.85)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Optimize exploration by increasing particle velocity scaling with a revised inertia weight.", "configspace": "", "generation": 83, "fitness": 0.6687557116296884, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6687557116296884, 0.6687557116296884]}, "mutation_prompt": null}
{"id": "0be813e2-81ed-408d-9741-a0b6c72fd66b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Adaptive inertia weight\n                self.w = 0.8 - 0.4 * (eval_count / self.budget)  # Line changed\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce adaptive inertia weight decreasing linearly from 0.8 to 0.4 to balance exploration and exploitation.", "configspace": "", "generation": 84, "fitness": 0.7287578437672662, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7287578437672662, 0.7287578437672662]}, "mutation_prompt": null}
{"id": "b6a81afd-e380-411f-80ac-80134fa67499", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.6   # differential weight (changed from 0.5 to 0.6)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase differential weight to balance exploration and exploitation.", "configspace": "", "generation": 85, "fitness": 0.6059645918641157, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6059645918641157, 0.6059645918641157]}, "mutation_prompt": null}
{"id": "0649a836-9915-4b57-8082-0a582fb331bb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.85  # inertia weight (changed from 0.8 to 0.85)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Fine-tuning exploration by increasing the inertia weight from 0.8 to 0.85 for better global search.", "configspace": "", "generation": 86, "fitness": 0.6687557116296884, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6687557116296884, 0.6687557116296884]}, "mutation_prompt": null}
{"id": "71ca43dd-8e9c-4f3e-9cb6-14d26586f2f7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.45  # differential weight (changed from 0.5 to 0.45)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly reduce the differential weight F for balanced exploration and exploitation.", "configspace": "", "generation": 87, "fitness": 0.6767440212633522, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6767440212633522, 0.6767440212633522]}, "mutation_prompt": null}
{"id": "bd66f6bf-1514-4610-bf7f-a63ce3a02dcd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance individual exploration capabilities.", "configspace": "", "generation": 88, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "1ef5efba-b8d6-4747-bdc5-5193e06d071e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            self.w = max(0.4, self.w * 0.99)  # Adaptive inertia weight reduction\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introduce adaptive inertia weight reduction for improved convergence.", "configspace": "", "generation": 89, "fitness": 0.729882362592529, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.729882362592529, 0.729882362592529]}, "mutation_prompt": null}
{"id": "6789f0c5-c460-4c74-9b45-727473ef37e3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.55  # differential weight (slightly increased from 0.5 to 0.55)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the differential weight factor to enhance the exploration capability of the algorithm.", "configspace": "", "generation": 90, "fitness": 0.642604080651147, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.642604080651147, 0.642604080651147]}, "mutation_prompt": null}
{"id": "47d2f362-8377-4014-9baa-c9db58d2470c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance individual exploration and potentially improve convergence.", "configspace": "", "generation": 91, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "f4d5dbd2-0d8b-4b94-88a6-7859051eed1f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            self.w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Refine the inertia weight dynamically based on the iteration count for improved balance between exploration and exploitation.", "configspace": "", "generation": 92, "fitness": 0.6775204975670076, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6775204975670076, 0.6775204975670076]}, "mutation_prompt": null}
{"id": "0ea0f0fc-154a-4b4b-96c4-337e539d5648", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight (changed from 0.7 to 0.8)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.w = 0.5 + 0.3 * (self.budget - eval_count) / self.budget  # Adaptive inertia weight\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Introducing adaptive inertia weight to dynamically balance exploration and exploitation.", "configspace": "", "generation": 93, "fitness": 0.7472276240359743, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7472276240359743, 0.7472276240359743]}, "mutation_prompt": null}
{"id": "e3001f2a-1c3e-4849-9a97-3f32e03ba7d3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance local exploration and convergence.", "configspace": "", "generation": 94, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "ea467d38-14c3-41a0-bb25-76280338d566", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.6   # differential weight (changed from 0.5 to 0.6)\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhanced exploration by slightly increasing the differential weight in the DE mutation.", "configspace": "", "generation": 95, "fitness": 0.6059645918641157, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6059645918641157, 0.6059645918641157]}, "mutation_prompt": null}
{"id": "b6c4a52b-9e8f-485c-8890-8a57c524aefd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.1  # social parameter (changed from 2.0 to 2.1)\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhancing global learning by slightly increasing the social parameter for better convergence.", "configspace": "", "generation": 96, "fitness": 0.715222241049327, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.715222241049327, 0.715222241049327]}, "mutation_prompt": null}
{"id": "e743a29f-f576-4234-98de-da8356b8ba2f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.1  # cognitive parameter (changed from 2.0 to 2.1)\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Slightly increase the cognitive parameter to enhance individual exploration.", "configspace": "", "generation": 97, "fitness": 0.6372139348846898, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6372139348846898, 0.6372139348846898]}, "mutation_prompt": null}
{"id": "0384455b-3a14-48f5-92f0-43d0cd1aae1f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.85  # inertia weight (changed from 0.8 to 0.85)\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Improved exploration by increasing the inertia weight to 0.85 for better convergence.", "configspace": "", "generation": 98, "fitness": 0.6687557116296884, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.6687557116296884, 0.6687557116296884]}, "mutation_prompt": null}
{"id": "05c7869e-e24b-43a9-a71e-82de700e942f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particles = 30\n        self.c1 = 2.0  # cognitive parameter\n        self.c2 = 2.0  # social parameter\n        self.w = 0.8   # initial inertia weight\n        self.F = 0.5   # differential weight\n        self.CR = 0.9  # crossover probability\n        self.positions = None\n        self.velocities = None\n        self.personal_best = None\n        self.personal_best_value = None\n        self.global_best = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize the swarm\n        self.positions = np.random.uniform(lb, ub, (self.particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.particles, self.dim))\n        self.personal_best = self.positions.copy()\n        self.personal_best_value = np.array([func(pos) for pos in self.positions])\n        \n        # Update global best\n        min_idx = np.argmin(self.personal_best_value)\n        self.global_best = self.personal_best[min_idx].copy()\n        self.global_best_value = self.personal_best_value[min_idx]\n\n        eval_count = self.particles\n\n        while eval_count < self.budget:\n            # Dynamically adjust inertia weight based on evaluation progress\n            self.w = 0.8 - 0.5 * (eval_count / self.budget)\n            for i in range(self.particles):\n                # Particle Swarm Optimization update\n                rp = np.random.uniform(0, 1, self.dim)\n                rg = np.random.uniform(0, 1, self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * rp * (self.personal_best[i] - self.positions[i]) +\n                                      self.c2 * rg * (self.global_best - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                a, b, c = np.random.choice(self.particles, 3, replace=False)\n                mutant = np.clip(self.positions[a] + self.F * (self.positions[b] - self.positions[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < self.personal_best_value[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_value[i] = trial_value\n\n                    if trial_value < self.global_best_value:\n                        self.global_best = trial\n                        self.global_best_value = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best", "name": "HybridPSODE", "description": "Enhance the balance between exploration and exploitation by dynamically adjusting the inertia weight based on the evaluation count.", "configspace": "", "generation": 99, "fitness": 0.7316666691170339, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.00.", "error": "", "parent_id": "fa834d0f-550f-43c6-b5c8-b98d72a7c352", "metadata": {"aucs": [0.7316666691170339, 0.7316666691170339]}, "mutation_prompt": null}
