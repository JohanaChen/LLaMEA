{"id": "0fcf5768-16f8-441b-ab62-108e07b7b016", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.5  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm that adaptively balances exploration and exploitation using dynamic neighborhood topology and velocity adjustments.", "configspace": "", "generation": 0, "fitness": 0.06429594935193872, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.06285456939834799, 0.06544778527306339, 0.06458549338440478]}, "mutation_prompt": null}
{"id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with enhanced global influence through increased social constant for improved convergence.", "configspace": "", "generation": 1, "fitness": 0.06628473126164343, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "0fcf5768-16f8-441b-ab62-108e07b7b016", "metadata": {"aucs": [0.0673872399830584, 0.06504104271815214, 0.06642591108371976]}, "mutation_prompt": null}
{"id": "de46367f-1d62-4486-9ed8-cc332691da4d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.9 - eval_count / self.budget * 0.5) * self.velocities[i]  # Dynamically adjust inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with a dynamically adjusted inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.0633762334760476, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.06266784258344782, 0.06358120494689623, 0.06387965289779873]}, "mutation_prompt": null}
{"id": "ba838c11-3362-4950-97a6-b5439c9147f4", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.8  # Inertia weight (increased from 0.7 to 0.8)\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with increased inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.06311062478033709, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.06451211259337308, 0.06465780896489759, 0.06016195278274061]}, "mutation_prompt": null}
{"id": "e6875e81-6dc7-4aa4-81d8-9b386e8cf6d8", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                self.inertia_weight = 0.4 + 0.3 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced dynamic inertia weight adjustment for improved exploration-exploitation balance in AdaptiveSwarmOptimization.", "configspace": "", "generation": 4, "fitness": 0.06520471509288599, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.06302862000230314, 0.06565790646372538, 0.06692761881262943]}, "mutation_prompt": null}
{"id": "18962949-0c90-490b-91d6-ce1dc37db943", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.9  # Inertia weight (changed from 0.7 to 0.9)\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with refined inertia weight for improved search balance between exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.06019838510809198, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.05814430420486827, 0.06168857400938421, 0.060762277110023466]}, "mutation_prompt": null}
{"id": "0f3cfeeb-81eb-4f70-83bb-2d260c515fa2", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                self.inertia_weight = 0.9 - (0.9 - 0.4) * eval_count / self.budget  # Adaptive inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "An adaptive inertia weight strategy is introduced to the swarm-based optimization algorithm for enhanced exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.0633762334760476, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.06266784258344782, 0.06358120494689623, 0.06387965289779873]}, "mutation_prompt": null}
{"id": "261e775c-cc3f-4c42-a926-b39c0b01efe8", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with dynamic inertia weight adaptation for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.0633762334760476, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.06266784258344782, 0.06358120494689623, 0.06387965289779873]}, "mutation_prompt": null}
{"id": "04503e3a-5d81-4360-bf24-d7f57aa020b4", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.9  # Inertia weight (changed from 0.7 to 0.9)\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with enhanced inertia weight adaptation for improved exploration and convergence.", "configspace": "", "generation": 8, "fitness": 0.06019838510809198, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.05814430420486827, 0.06168857400938421, 0.060762277110023466]}, "mutation_prompt": null}
{"id": "3f4d0e5c-1354-4c2e-b9e3-1a0dbb36c98f", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.75  # Inertia weight (increased from 0.7 to 0.75)\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with enhanced exploration by slightly increasing inertia weight for better global search capability.", "configspace": "", "generation": 9, "fitness": 0.06497447520982795, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.063682454901003, 0.06573574176613073, 0.06550522896235011]}, "mutation_prompt": null}
{"id": "34ee3e5d-3b80-4933-8308-ce9faf478155", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                self.inertia_weight = 0.9 - (0.9 - 0.4) * (eval_count / self.budget)  # Adaptive inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with adaptive inertia weight for balanced exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.0633762334760476, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.06266784258344782, 0.06358120494689623, 0.06387965289779873]}, "mutation_prompt": null}
{"id": "a470c7bb-8193-47d4-9654-d8e5b6a75820", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.8  # Inertia weight (increased from 0.7 to 0.8)\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced particle update rule by increasing the inertia weight for improved exploration.", "configspace": "", "generation": 11, "fitness": 0.06311062478033709, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.06451211259337308, 0.06465780896489759, 0.06016195278274061]}, "mutation_prompt": null}
{"id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with dynamic inertia weight adjustment for better balance between exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.06744582624360844, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ccba3513-292a-4745-ac25-a5b0d08a02bc", "metadata": {"aucs": [0.065054198797447, 0.06906859505721907, 0.06821468487615923]}, "mutation_prompt": null}
{"id": "81ea52f8-3d3d-4d1d-9937-a1ea3cc282ed", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (increased from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with dynamic inertia weight adjustment and slightly increased social influence for improved convergence.", "configspace": "", "generation": 13, "fitness": 0.06569025987564081, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06588813252645964, 0.06385315870265551, 0.06732948839780728]}, "mutation_prompt": null}
{"id": "0c0e5394-a0ce-434f-9e03-c6f7b7c394bb", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i]) * 0.9\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced a deceleration factor to the cognitive component to enhance convergence speed.", "configspace": "", "generation": 14, "fitness": 0.06627973561548162, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06594027952689174, 0.06576062030411245, 0.06713830701544066]}, "mutation_prompt": null}
{"id": "a46c9c5a-9baa-4b83-af1d-d2a6060acccd", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + 0.5 * (cognitive + social)  # Slightly adjusted velocity update\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with enhanced velocity update for improved exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.06729109829096043, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06603093724374143, 0.06607358312876688, 0.069768774500373]}, "mutation_prompt": null}
{"id": "012b34eb-b96a-45fd-8381-fe3c4de3022b", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant * (1 - eval_count / self.budget)) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Decay in cognitive constant\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced a decay factor to the cognitive constant to enhance convergence in later iterations.", "configspace": "", "generation": 16, "fitness": 0.06567941208038626, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06493026605039542, 0.06627061377665311, 0.06583735641411026]}, "mutation_prompt": null}
{"id": "61b54633-fb1f-4bf8-80c9-09e08dbf585f", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        # Introduce perturbation to avoid premature convergence\n                        self.global_best = self.positions[i] + 0.01 * np.random.randn(self.dim)\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce a small random perturbation to global_best update for improved exploration.", "configspace": "", "generation": 17, "fitness": 0.06720662878532857, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06629270832296352, 0.06640410016173781, 0.06892307787128438]}, "mutation_prompt": null}
{"id": "69a4087b-1bc7-4729-8eb9-6b3960b8567a", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (increased from 1.5 to 1.6)\n        self.social_constant = 1.7  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved Adaptive Swarm Optimization by slightly increasing the cognitive constant for enhanced solution diversity.", "configspace": "", "generation": 18, "fitness": 0.06472953424446622, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.061552557095787774, 0.06507456051774596, 0.06756148511986493]}, "mutation_prompt": null}
{"id": "d74bf08b-c738-454a-a563-d3dfb1bf705d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.7  # Cognitive constant (increased from 1.5 to 1.7)\n        self.social_constant = 1.7  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "A swarm-based optimization algorithm with enhanced cognitive exploration using a larger cognitive constant for improved local search efficiency.", "configspace": "", "generation": 19, "fitness": 0.06556874125737851, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06153987322982979, 0.0660611774791009, 0.06910517306320485]}, "mutation_prompt": null}
{"id": "9197b474-7cf6-44b0-88c9-55fed15444c5", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.5  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved swarm-based optimization with balanced exploration and exploitation using dynamic social constant.", "configspace": "", "generation": 20, "fitness": 0.06699813665364303, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.0690050301282884, 0.06362492496339067, 0.06836445486925002]}, "mutation_prompt": null}
{"id": "877fc727-4fe6-4164-9067-e97050ab95ff", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (increased from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced social attraction by increasing the social constant for improved global search capabilities.", "configspace": "", "generation": 21, "fitness": 0.06569025987564081, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06588813252645964, 0.06385315870265551, 0.06732948839780728]}, "mutation_prompt": null}
{"id": "ccb046b4-d29f-43e3-9852-029871c80ca2", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (increased from 1.5 to 1.6)\n        self.social_constant = 1.7  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improve swarm convergence by slightly increasing the cognitive constant to enhance local exploration.", "configspace": "", "generation": 22, "fitness": 0.06472953424446622, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.061552557095787774, 0.06507456051774596, 0.06756148511986493]}, "mutation_prompt": null}
{"id": "b347582c-f51f-4c1c-9bb1-3fb15b5d5f10", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.8  # Social constant (increased from 1.7 to 1.8)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced a slight increase to the social constant for enhanced global exploration capabilities.", "configspace": "", "generation": 23, "fitness": 0.0672897419577307, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06757134393980035, 0.06592250881151662, 0.06837537312187514]}, "mutation_prompt": null}
{"id": "57e45db4-ed61-4c73-ba35-2c70c8ba0959", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = (self.social_constant + np.random.uniform(-0.1, 0.1)) * np.random.rand(self.dim) * (self.global_best - self.positions[i]) # Slight adjustment here\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced a random factor to social constant for enhanced diversity in exploration.", "configspace": "", "generation": 24, "fitness": 0.06571526114729424, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06435676040013683, 0.06444214037056595, 0.06834688267117994]}, "mutation_prompt": null}
{"id": "7c1eec9a-8661-4c19-9d70-d6f95bd26e22", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.7  # Cognitive constant (increased from 1.5 to 1.7)\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced Adaptive Swarm Optimization with increased cognitive constant for improved local exploration.", "configspace": "", "generation": 25, "fitness": 0.06556874125737851, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06153987322982979, 0.0660611774791009, 0.06910517306320485]}, "mutation_prompt": null}
{"id": "cd7e6613-d576-4d1d-836b-30666b9196e7", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (increased from 1.5 to 1.6)\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "An adaptive swarm-based optimization algorithm with enhanced exploration through a slight increase in cognitive constant for improved performance.", "configspace": "", "generation": 26, "fitness": 0.06472953424446622, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.061552557095787774, 0.06507456051774596, 0.06756148511986493]}, "mutation_prompt": null}
{"id": "bab453f9-b587-4f37-9a1c-c3236d9343a7", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced velocity update with chaotic perturbation for improved exploration.", "configspace": "", "generation": 27, "fitness": 0.06768998175298135, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec73e6bb-c9cd-49d5-aa91-91d396a4af75", "metadata": {"aucs": [0.06917491679423049, 0.0660378642525391, 0.06785716421217447]}, "mutation_prompt": null}
{"id": "675f8d3d-239c-4b44-abc1-d96d8c20f0a4", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n        self.success_history = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                adaptive_cognitive = self.cognitive_constant * (1 + 0.1 * self.success_history[i])\n                adaptive_social = self.social_constant * (1 + 0.1 * self.success_history[i])\n                inertia = (0.5 + (0.5 * eval_count / self.budget)) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = adaptive_cognitive * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = adaptive_social * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    self.success_history[i] += 1\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced adaptive learning rates based on success history to enhance convergence efficiency.", "configspace": "", "generation": 28, "fitness": 0.06592379268456194, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bab453f9-b587-4f37-9a1c-c3236d9343a7", "metadata": {"aucs": [0.06698285789831593, 0.06570552896166248, 0.06508299119370742]}, "mutation_prompt": null}
{"id": "9558cbee-25e3-4650-b200-9efb724f8adf", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.7  # Social constant (increased from 1.5 to 1.7)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Incorporate adaptive learning factors and a Gaussian mutation operator to enhance convergence.", "configspace": "", "generation": 29, "fitness": 0.06899762957225453, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bab453f9-b587-4f37-9a1c-c3236d9343a7", "metadata": {"aucs": [0.0685044598530431, 0.06975128684816456, 0.06873714201555592]}, "mutation_prompt": null}
{"id": "3fac8f12-6ffe-428f-9496-62d2ab8b7cee", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i]\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tune social constant to improve the algorithm's convergence speed.", "configspace": "", "generation": 30, "fitness": 0.06904371239668579, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "9558cbee-25e3-4650-b200-9efb724f8adf", "metadata": {"aucs": [0.06860037292847421, 0.06955478455536102, 0.06897597970622216]}, "mutation_prompt": null}
{"id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introducing a small perturbation to the global best position to escape local optima.", "configspace": "", "generation": 31, "fitness": 0.06924804126843472, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3fac8f12-6ffe-428f-9496-62d2ab8b7cee", "metadata": {"aucs": [0.06889909567007435, 0.06964896851838576, 0.06919605961684405]}, "mutation_prompt": null}
{"id": "91c06adc-8123-44da-b8d8-9835a5490e94", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation + np.random.uniform(-0.005, 0.005, self.dim)  # Adding small random perturbation to velocity\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce a small random velocity perturbation to each particle to enhance exploration.", "configspace": "", "generation": 32, "fitness": 0.0689477969578229, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06909462909122366, 0.06910959985079745, 0.06863916193144759]}, "mutation_prompt": null}
{"id": "3da2d4af-2b84-46b3-97e1-facd6d73e2ea", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + np.tanh(cognitive + social) + perturbation  # Non-linear damping\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce a small non-linear damping factor to the velocity update to improve exploration.", "configspace": "", "generation": 33, "fitness": 0.0606668358622097, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.059269134634768794, 0.06104025588794437, 0.061691117063915946]}, "mutation_prompt": null}
{"id": "eb009b4e-d51d-4308-aad6-bbd58f1922ce", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Chaotic perturbation (adjusted from 0.01 to 0.02)\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Increase the perturbation factor to enhance exploration and escape local optima.", "configspace": "", "generation": 34, "fitness": 0.06922816364681483, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06887475970668633, 0.06964737197722615, 0.06916235925653202]}, "mutation_prompt": null}
{"id": "ff3bd0d0-204c-4717-8742-165aaf036c23", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation + np.random.normal(0, 0.01, self.dim)\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Add a small random perturbation to the velocity update to enhance exploration.", "configspace": "", "generation": 35, "fitness": 0.06892359478287742, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06864029970404306, 0.06956490323699704, 0.06856558140759217]}, "mutation_prompt": null}
{"id": "c6766a12-5928-4c26-8fe4-fd9ad7e7bc58", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = (self.social_constant - dynamic_factor) * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * (0.01 + dynamic_factor)  # Dynamic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improve exploration-exploitation balance by dynamically adjusting constants and perturbation magnitude.", "configspace": "", "generation": 36, "fitness": 0.06472522960579723, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06594657412836324, 0.062332781505179846, 0.06589633318384858]}, "mutation_prompt": null}
{"id": "3727282a-4784-4e1c-ab33-9b781d28fd82", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.015  # Chaotic perturbation (adjusted)\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tuning the chaotic perturbation to enhance exploration capabilities.", "configspace": "", "generation": 37, "fitness": 0.06923541194783019, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06886887521082397, 0.06965365591111006, 0.06918370472155655]}, "mutation_prompt": null}
{"id": "b1c28dc1-7f4e-418c-9851-bf54513ec1fa", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhance global exploration by increasing the perturbation's standard deviation slightly.", "configspace": "", "generation": 38, "fitness": 0.06922816364681483, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06887475970668633, 0.06964737197722615, 0.06916235925653202]}, "mutation_prompt": null}
{"id": "1a5d8284-c751-4491-85c6-87d2a099da85", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.001, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tuning the chaotic perturbation to enhance exploration and escape local optima.", "configspace": "", "generation": 39, "fitness": 0.06922816364681483, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06887475970668633, 0.06964737197722615, 0.06916235925653202]}, "mutation_prompt": null}
{"id": "700c787d-7e7c-4870-bf42-f2862a0f40f4", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improve exploration by increasing Gaussian mutation variance.", "configspace": "", "generation": 40, "fitness": 0.06926515500069907, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3a1f358c-ad5a-4262-8948-f53fc9348fcb", "metadata": {"aucs": [0.06889913839072404, 0.06964863711296254, 0.06924768949841065]}, "mutation_prompt": null}
{"id": "d6f3c4ae-e296-45c6-935a-6c1ede473d99", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improve exploration by increasing Gaussian mutation variance.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "700c787d-7e7c-4870-bf42-f2862a0f40f4", "metadata": {"aucs": [0.06889913839072404, 0.06964863711296254, 0.06924768949841065]}, "mutation_prompt": null}
{"id": "4e270503-9edd-46a9-9bb3-346f8e8e85cd", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Chaotic perturbation adjusted to 0.02\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tune the chaotic perturbation magnitude to balance exploration and exploitation.", "configspace": "", "generation": 42, "fitness": 0.06923534084816756, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "700c787d-7e7c-4870-bf42-f2862a0f40f4", "metadata": {"aucs": [0.0688744494596546, 0.06964767713560804, 0.06918389594924002]}, "mutation_prompt": null}
{"id": "a008ef11-78c1-4a87-a492-6333e49222fa", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (changed from 1.5 to 1.6)\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhance global exploration by increasing the cognitive constant slightly.", "configspace": "", "generation": 43, "fitness": 0.06911716328119306, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "700c787d-7e7c-4870-bf42-f2862a0f40f4", "metadata": {"aucs": [0.06867735951931353, 0.0699227102211133, 0.06875142010315238]}, "mutation_prompt": null}
{"id": "905d6771-ce7c-4bb9-afcd-091f9ff15264", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.015  # Chaotic perturbation adjustment\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.01, self.dim)  # Gaussian mutation adjustment\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhance swarm diversity by adjusting the chaotic perturbation and Gaussian mutation.", "configspace": "", "generation": 44, "fitness": 0.06922495396927901, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "700c787d-7e7c-4870-bf42-f2862a0f40f4", "metadata": {"aucs": [0.06886055031187865, 0.06964355858631432, 0.06917075300964404]}, "mutation_prompt": null}
{"id": "cd1bc6ca-d8b7-4fcd-a6a6-eac96bd0babc", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (adjusted from 1.5 to 1.6)\n        self.social_constant = 1.9  # Social constant (adjusted from 1.7 to 1.9)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improve convergence by slightly adjusting the cognitive constant to enhance local search capability.", "configspace": "", "generation": 45, "fitness": 0.06911716328119306, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "700c787d-7e7c-4870-bf42-f2862a0f40f4", "metadata": {"aucs": [0.06867735951931353, 0.0699227102211133, 0.06875142010315238]}, "mutation_prompt": null}
{"id": "ce8a28ad-9230-4cbb-9c15-d5b0b0396c16", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.1  # Social constant (adjusted from 1.9 to 2.1)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Adaptive Swarm Optimization with enhanced social influence adjustment.", "configspace": "", "generation": 46, "fitness": 0.06933092163332122, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "700c787d-7e7c-4870-bf42-f2862a0f40f4", "metadata": {"aucs": [0.06902752040581239, 0.06959283616417122, 0.06937240832998004]}, "mutation_prompt": null}
{"id": "5918d963-b508-4c16-a8a7-152253c95edf", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tune the social constant to enhance convergence speed and accuracy.", "configspace": "", "generation": 47, "fitness": 0.0692446687363153, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ce8a28ad-9230-4cbb-9c15-d5b0b0396c16", "metadata": {"aucs": [0.06892936091982182, 0.06958129046745287, 0.06922335482167119]}, "mutation_prompt": null}
{"id": "4cc96aa2-d072-4973-a171-f352ce035d80", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.1  # Social constant (adjusted from 1.9 to 2.1)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Adaptive Swarm Optimization enhanced with dynamic cognitive strategy and refined chaotic perturbation.", "configspace": "", "generation": 48, "fitness": 0.06933303631115444, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ce8a28ad-9230-4cbb-9c15-d5b0b0396c16", "metadata": {"aucs": [0.06904623038882862, 0.06968564618238493, 0.06926723236224974]}, "mutation_prompt": null}
{"id": "4af3e7e9-4e9e-4bca-b434-1ed8eb8a05cf", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.1  # Social constant (adjusted from 1.9 to 2.1)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.00015, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced Adaptive Swarm Optimization by introducing a small perturbation to the global best position.", "configspace": "", "generation": 49, "fitness": 0.0693330350955587, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "4cc96aa2-d072-4973-a171-f352ce035d80", "metadata": {"aucs": [0.06904622965779161, 0.06968564539943733, 0.06926723022944714]}, "mutation_prompt": null}
{"id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tuning social influence by adjusting the social constant to improve convergence speed.", "configspace": "", "generation": 50, "fitness": 0.06940706965354178, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "4cc96aa2-d072-4973-a171-f352ce035d80", "metadata": {"aucs": [0.06912350705325099, 0.06974415440707582, 0.06935354750029854]}, "mutation_prompt": null}
{"id": "399bd35a-07f2-4f49-9d57-3cdfe3be2f45", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced a learning rate adaptation based on performance to enhance convergence speed.", "configspace": "", "generation": 51, "fitness": 0.06940706965354178, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "metadata": {"aucs": [0.06912350705325099, 0.06974415440707582, 0.06935354750029854]}, "mutation_prompt": null}
{"id": "33c17661-be80-4bd5-844a-27e8d3bf407e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.25  # Social constant (adjusted from 2.2 to 2.25)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce a slight increase in social constant for enhanced exploration capability.", "configspace": "", "generation": 52, "fitness": 0.06914929995740964, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "metadata": {"aucs": [0.06835263035338524, 0.06976000190698206, 0.0693352676118616]}, "mutation_prompt": null}
{"id": "5f184e24-2b0d-4736-8126-e2aae2be5153", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                adaptive_social_constant = self.social_constant * (1 + 0.5 * dynamic_factor)  # Adaptive learning\n                social = adaptive_social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introducing an adaptive learning rate for social influence to enhance convergence precision.", "configspace": "", "generation": 53, "fitness": 0.06914099768758881, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "metadata": {"aucs": [0.06832272765093661, 0.06974494959153221, 0.06935531582029764]}, "mutation_prompt": null}
{"id": "c84f25e8-db8a-4bf4-83b0-ce9ca7a9b4b2", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.global_best - self.positions[i])  # Changed line\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introducing a dynamic social constant to enhance swarm adaptability and convergence.", "configspace": "", "generation": 54, "fitness": 0.06425920782094219, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "metadata": {"aucs": [0.06492518365339639, 0.062279337339253615, 0.06557310247017656]}, "mutation_prompt": null}
{"id": "ab863192-dea3-4b37-aba3-d5e725b1b191", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.006, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introducing a slight increase in cognitive randomness for enhanced exploration.", "configspace": "", "generation": 55, "fitness": 0.06940662194856213, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "metadata": {"aucs": [0.06912336290110233, 0.06974399943598097, 0.06935250350860311]}, "mutation_prompt": null}
{"id": "50cfb2dc-8b9f-47b4-a262-e6c472e1b3c0", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.3  # Social constant (adjusted from 2.2 to 2.3)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced convergence by slightly increasing the social constant to intensify global influence.", "configspace": "", "generation": 56, "fitness": 0.06921762751871796, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "metadata": {"aucs": [0.0684638365742457, 0.06978399807730162, 0.06940504790460655]}, "mutation_prompt": null}
{"id": "c3b75b2d-a649-4b9d-b016-87ded043907e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.3 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = self.cognitive_constant * (1 + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced a slight adaptive adjustment to the inertia weight to enhance exploration.", "configspace": "", "generation": 57, "fitness": 0.06941356623601709, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "604c5519-9bc9-42e7-afd9-174e66a303b5", "metadata": {"aucs": [0.06886693499814278, 0.06988649784554557, 0.06948726586436293]}, "mutation_prompt": null}
{"id": "ea706218-c2a2-482f-a147-18738c12ea8e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.3 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced dynamic adjustment to cognitive constant for better exploration-exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.06941413482486185, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c3b75b2d-a649-4b9d-b016-87ded043907e", "metadata": {"aucs": [0.06882782631756679, 0.0698667342452941, 0.06954784391172464]}, "mutation_prompt": null}
{"id": "ea00ee47-2b85-4b16-b0e5-2a1fd20b1281", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.3 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        # Small perturbation added to global best for exploration\n        self.global_best += np.random.normal(0, 0.0001, self.dim)\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Added slight random perturbation to the global best position for enhanced exploration.", "configspace": "", "generation": 59, "fitness": 0.06941413482486185, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ea706218-c2a2-482f-a147-18738c12ea8e", "metadata": {"aucs": [0.06882782631756679, 0.0698667342452941, 0.06954784391172464]}, "mutation_prompt": null}
{"id": "5a6864c7-728d-4265-933f-53266c73a69d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.6 + 0.2 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight (slightly adjusted)\n                cognitive = (self.cognitive_constant + 0.4 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * (1 - dynamic_factor) * np.random.rand(self.dim) * (self.global_best - self.positions[i])  # Adjusted social influence\n                perturbation = np.random.standard_normal(self.dim) * 0.015  # Further refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.004, self.dim)  # Tweaked Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced adaptive mechanism by adjusting dynamic factors and refining mutation strategy for improved convergence.", "configspace": "", "generation": 60, "fitness": 0.06829256976594256, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ea706218-c2a2-482f-a147-18738c12ea8e", "metadata": {"aucs": [0.06906213611971623, 0.06724370107445965, 0.06857187210365179]}, "mutation_prompt": null}
{"id": "2acc8578-e377-460b-b3ad-ef628ed6c366", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.3 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.5 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * (1 - dynamic_factor) * np.random.rand(self.dim) * (self.global_best - self.positions[i])  # Adaptive social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced convergence through adaptive social factor scaling for improved solution accuracy.", "configspace": "", "generation": 61, "fitness": 0.06707027540392067, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ea706218-c2a2-482f-a147-18738c12ea8e", "metadata": {"aucs": [0.06611595117328095, 0.06594124025635029, 0.06915363478213077]}, "mutation_prompt": null}
{"id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced position update with dynamic inertia and cognitive factors.", "configspace": "", "generation": 62, "fitness": 0.0694366315463955, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ea706218-c2a2-482f-a147-18738c12ea8e", "metadata": {"aucs": [0.06892590594047499, 0.06985951674301061, 0.06952447195570088]}, "mutation_prompt": null}
{"id": "7fde93f9-34c3-4718-b8bb-d1d9ed5ea438", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * (0.02 + 0.01 * dynamic_factor)  # Refined chaotic perturbation with dynamic adjustment\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced position update with dynamic inertia and cognitive factors, with improved use of chaotic perturbation for exploration.", "configspace": "", "generation": 63, "fitness": 0.0694362811906506, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06892585771959647, 0.06985868848529075, 0.06952429736706456]}, "mutation_prompt": null}
{"id": "005e626b-90da-4fa9-933e-dc44b2d00c5e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.03  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.007, self.dim)  # Increased Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Refined swarm strategy with enhanced exploration via chaotic perturbation.", "configspace": "", "generation": 64, "fitness": 0.06943292003832535, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06892565473527368, 0.06986130438687665, 0.06951180099282572]}, "mutation_prompt": null}
{"id": "d4ddece8-0c2f-4b96-b7e0-e066c0556ecb", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.004, self.dim)  # Gaussian mutation (reduced from 0.005)\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved convergence by slightly reducing the Gaussian mutation standard deviation for more precise position updates.", "configspace": "", "generation": 65, "fitness": 0.06943649780199257, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06892556646606374, 0.06985951523856115, 0.06952441170135282]}, "mutation_prompt": null}
{"id": "44d0bb62-7652-47aa-922d-c5e44ed2b7a1", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.3  # Social constant (adjusted from 2.2 to 2.3)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Adjusted social constant for improved convergence behavior.", "configspace": "", "generation": 66, "fitness": 0.06941950107216177, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06891789133877924, 0.06976129232394046, 0.06957931955376562]}, "mutation_prompt": null}
{"id": "c93fbc39-8e60-49d1-9ab8-b003dae2f73e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = (self.social_constant + 0.2 * dynamic_factor) * np.random.rand(self.dim) * (self.global_best - self.positions[i])  # Refined adaptive social scaling\n                perturbation = np.random.standard_normal(self.dim) * 0.01  # Further refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced adaptive social factor scaling and refined chaotic perturbation for enhanced exploration.", "configspace": "", "generation": 67, "fitness": 0.06737357954285213, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06834482237135231, 0.06634739895655695, 0.06742851730064714]}, "mutation_prompt": null}
{"id": "c89b177f-4372-4be9-b962-e4107d8e4bc3", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.03  # Refined chaotic perturbation from 0.02 to 0.03\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced a small modification in the perturbation to avoid local optima traps.", "configspace": "", "generation": 68, "fitness": 0.06943244179698253, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06892547359785062, 0.06986129455418844, 0.06951055723890853]}, "mutation_prompt": null}
{"id": "a0ba5041-c582-4c6a-b451-59290e12087b", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 2.2\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            elite_indices = np.argsort(self.local_best_values)[:self.population_size // 5]  # Elite selection\n            for i in range(self.population_size):\n                dynamic_factor = eval_count / self.budget\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02\n                differential_update = 0.5 * (self.positions[np.random.choice(elite_indices)] - self.positions[np.random.choice(elite_indices)])\n                self.velocities[i] = inertia + cognitive + social + perturbation + differential_update\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)\n\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce differential evolution-inspired updates and elite particles to enhance exploration and exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.06116703361479588, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06039319378551844, 0.06042791613568865, 0.06267999092318055]}, "mutation_prompt": null}
{"id": "346e5bef-d679-454e-b1ac-062b55ea912d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = (self.social_constant + 0.1 * dynamic_factor) * np.random.rand(self.dim) * (self.global_best - self.positions[i])  # Adaptive social influence\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce adaptive social influence for enhanced exploration and exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.06580537109164093, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06545052942349816, 0.06635570456456918, 0.06560987928685547]}, "mutation_prompt": null}
{"id": "b6bc6bce-4a49-42bf-8e6a-3f6fb25976be", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce a subtle mutation to the global best position to enhance exploration.", "configspace": "", "generation": 71, "fitness": 0.06943662909325894, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06892592022017896, 0.0698594960775395, 0.06952447098205838]}, "mutation_prompt": null}
{"id": "efbdbb31-6e89-4a6d-ab19-6983354bcd9d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation + np.random.normal(0, 0.01, self.dim)  # Additional random factor\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced an additional random factor in the position update to enhance exploration capability.", "configspace": "", "generation": 72, "fitness": 0.06918790426249788, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06891476444630218, 0.06931052519419711, 0.06933842314699434]}, "mutation_prompt": null}
{"id": "994f2203-9332-4695-99ee-033304b84f45", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (eval_count / self.budget) ** 1.2  # Increased influence of dynamic factor\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.rand(self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005 + 0.001 * dynamic_factor, self.dim)  # Adaptive Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0001, self.dim)  # Perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved local exploration by incorporating adaptive Gaussian mutation and enhancing dynamic factor influence.", "configspace": "", "generation": 73, "fitness": 0.06883508191631287, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06802614014306796, 0.06963727833563427, 0.06884182727023636]}, "mutation_prompt": null}
{"id": "bc5fb95e-aabf-41e0-ab2f-3e1fdd5ff90d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.9, 1.1, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.02  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tuned velocity update and enhanced global best perturbation for improved convergence.", "configspace": "", "generation": 74, "fitness": 0.06986534026014805, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7c5b55a0-8d6e-4225-a5a3-c63405a6435f", "metadata": {"aucs": [0.06947649268014888, 0.0702388444861981, 0.06988068361409716]}, "mutation_prompt": null}
{"id": "fac561e3-afe6-4ffa-8602-5114845f7ff7", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.03  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced adaptive velocity control and refined chaotic perturbation for improved global exploration.", "configspace": "", "generation": 75, "fitness": 0.06990066637779946, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bc5fb95e-aabf-41e0-ab2f-3e1fdd5ff90d", "metadata": {"aucs": [0.0695798561711064, 0.07024675122323398, 0.06987539173905799]}, "mutation_prompt": null}
{"id": "ee9e7d6a-076d-469f-a4e6-d538d858516c", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.6 + 0.25 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.035  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced perturbation strategy and adjusted inertia weight dynamics for better balance between exploration and exploitation.", "configspace": "", "generation": 76, "fitness": 0.06955560204422724, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fac561e3-afe6-4ffa-8602-5114845f7ff7", "metadata": {"aucs": [0.06891628297045205, 0.07012473892862547, 0.06962578423360422]}, "mutation_prompt": null}
{"id": "1a27b5d7-994e-42cd-9d08-03afaf68f23c", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (eval_count / self.budget)**0.5  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.03  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Minor adjustment in the dynamic factor computation to enhance convergence speed by accounting for non-linear progress.", "configspace": "", "generation": 77, "fitness": 0.06929891618211419, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fac561e3-afe6-4ffa-8602-5114845f7ff7", "metadata": {"aucs": [0.0699616967913832, 0.0682129285955615, 0.06972212315939785]}, "mutation_prompt": null}
{"id": "ec02ab0e-d53c-48fa-b87a-d45ced3dcf07", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.04  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Increased perturbation magnitude slightly to enhance global exploration capability.", "configspace": "", "generation": 78, "fitness": 0.06990080000101095, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fac561e3-afe6-4ffa-8602-5114845f7ff7", "metadata": {"aucs": [0.06957975324991006, 0.07024798014559896, 0.06987466660752384]}, "mutation_prompt": null}
{"id": "5bcb4d53-79a2-4835-9485-564d7429a937", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.04  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation + np.random.normal(0, 0.01, self.dim)  # Added Gaussian noise\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.005, self.dim)  # Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced Gaussian noise to enhance the swarm's ability to escape local minima and improve global search capabilities.", "configspace": "", "generation": 79, "fitness": 0.06963280240032377, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec02ab0e-d53c-48fa-b87a-d45ced3dcf07", "metadata": {"aucs": [0.0692625639408716, 0.06974817597589267, 0.06988766728420703]}, "mutation_prompt": null}
{"id": "d0e15fe5-f529-4571-aeae-883c2b735508", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  \n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  \n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  \n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  \n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  \n                perturbation = np.random.standard_normal(self.dim) * 0.1  # Increased chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Increased Gaussian mutation\n\n                # Ensure particles are within bounds\n                boundary_adjustment = np.random.uniform(-0.01, 0.01, self.dim)  # Dynamic boundary adjustment\n                self.positions[i] = np.clip(self.positions[i] + boundary_adjustment, lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0005, self.dim) \n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced adaptive strategy with stochastic exploration and dynamic boundary adjustments.", "configspace": "", "generation": 80, "fitness": 0.06965922946664671, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec02ab0e-d53c-48fa-b87a-d45ced3dcf07", "metadata": {"aucs": [0.0692917083891984, 0.06987895274281153, 0.0698070272679302]}, "mutation_prompt": null}
{"id": "9ab66c34-93bd-4281-8f44-b7d220888e9d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.04  # Refined chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.007, self.dim)  # Fine-tuned Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tuned the Gaussian mutation standard deviation to improve particle diversity and convergence.", "configspace": "", "generation": 81, "fitness": 0.06990086304920488, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec02ab0e-d53c-48fa-b87a-d45ced3dcf07", "metadata": {"aucs": [0.06957983814946922, 0.07024809562493162, 0.0698746553732138]}, "mutation_prompt": null}
{"id": "19a8d59e-9726-4341-b06f-255d0343fbad", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced the perturbation strategy to improve exploration.", "configspace": "", "generation": 82, "fitness": 0.06990402062750693, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "9ab66c34-93bd-4281-8f44-b7d220888e9d", "metadata": {"aucs": [0.0695793922855431, 0.07025740912725642, 0.06987526046972126]}, "mutation_prompt": null}
{"id": "d2a6b7b5-4e23-436a-8996-0d0cb99dae15", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, int(self.budget / (5 + 0.1 * dim)))  # Dynamic population size\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 2.2\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                dynamic_factor = eval_count / self.budget\n                inertia = (0.5 + 0.35 * (1 - dynamic_factor**2)) * self.velocities[i]  # Nonlinear inertia decay\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])\n                perturbation = np.random.standard_normal(self.dim) * 0.05\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)\n\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced dynamic population size and nonlinear inertia decay for enhanced exploration and convergence.", "configspace": "", "generation": 83, "fitness": 0.06726977078879388, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06683469957988109, 0.06731945110632553, 0.06765516168017505]}, "mutation_prompt": null}
{"id": "fcb52971-591e-460e-a354-43b083b8f323", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            mutation_scale = 0.008 * (1 - eval_count / self.budget)  # Adaptive mutation scale\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, mutation_scale, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced adaptive Gaussian mutation scaling based on iteration progress to improve local search.", "configspace": "", "generation": 84, "fitness": 0.0699039817490043, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06957932917647558, 0.07025736024800688, 0.0698752558225304]}, "mutation_prompt": null}
{"id": "c45ebfdb-8eef-4c2a-bf9a-d8738b4b6703", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.03  # Adjusted chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.01, self.dim)  # Adjusted Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Adjust dynamic perturbation and mutation to better balance exploration and exploitation.", "configspace": "", "generation": 85, "fitness": 0.06990058776533807, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06957988056507713, 0.07024654236278793, 0.06987534036814913]}, "mutation_prompt": null}
{"id": "33df2bb9-3c03-4972-8876-47dab1552f26", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008 * (1 - dynamic_factor), self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced perturbation by dynamically scaling Gaussian mutation based on remaining budget.", "configspace": "", "generation": 86, "fitness": 0.06990398165857332, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06957932828693536, 0.0702573593989656, 0.06987525728981903]}, "mutation_prompt": null}
{"id": "129be88c-74c9-4c78-9152-019eba23ff99", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * (1 - 0.5 * dynamic_factor) * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.00015, self.dim)  # Refined perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved social factor adaptation and refined final perturbation strategy for enhanced convergence.", "configspace": "", "generation": 87, "fitness": 0.06553449712553068, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06591622778855966, 0.06535958216170379, 0.06532768142632861]}, "mutation_prompt": null}
{"id": "e966a953-5f20-4496-b105-245438d2e21d", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.06  # Adjusted chaotic perturbation scale\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Further fine-tune the enhanced perturbation by adjusting its scale to optimize exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.06990346585075258, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06957889812925522, 0.07025719306375988, 0.06987430635924263]}, "mutation_prompt": null}
{"id": "f3a2a853-5215-48b7-b381-8d6c90556877", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation_scale = 0.05 * (1 - dynamic_factor)  # Dynamic perturbation scaling\n                perturbation = np.random.standard_normal(self.dim) * perturbation_scale  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduce dynamic perturbation scaling based on convergence to improve exploration-exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.06990062405331472, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06957949125388196, 0.0702483180083433, 0.06987406289771891]}, "mutation_prompt": null}
{"id": "a1566d28-fa78-48eb-9d9b-54b0f5b9b882", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant * (1 - dynamic_factor) + 0.3 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Dynamic cognitive constant\n                social = (self.social_constant * dynamic_factor + 1.0 * (1 - dynamic_factor)) * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Dynamic social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced dynamic social and cognitive constants for better adaptation over iterations.", "configspace": "", "generation": 90, "fitness": 0.0662703954290043, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06598691416994085, 0.06255178821932217, 0.07027248389774987]}, "mutation_prompt": null}
{"id": "95f7b743-5fc7-49c9-8e37-b3a5086cf0e3", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.08  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Increase the perturbation magnitude to enhance escape from local optima.", "configspace": "", "generation": 91, "fitness": 0.06990314240524938, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06957660763998263, 0.07025529165256705, 0.06987752792319846]}, "mutation_prompt": null}
{"id": "f5adac24-5f5d-4222-b382-ca6f84f1c0a3", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = eval_count / self.budget  # Adaptive factor based on the budget usage\n                inertia = (0.6 + 0.25 * dynamic_factor) * self.velocities[i]  # Refined dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved dynamic adaptation by refining inertia weight calculation.", "configspace": "", "generation": 92, "fitness": 0.06957050340315374, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.06895882501348949, 0.07012774915118825, 0.06962493604478348]}, "mutation_prompt": null}
{"id": "8c2ac8d5-3cce-490e-a42f-86d3bebb8213", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (1.5 * eval_count / self.budget)  # Adjusted dynamic factor\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.03  # Reduced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved balance between exploration and exploitation by adjusting the dynamic factor and perturbation.", "configspace": "", "generation": 93, "fitness": 0.0700492409253523, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "19a8d59e-9726-4341-b06f-255d0343fbad", "metadata": {"aucs": [0.0697870828389211, 0.07025670995025035, 0.07010392998688542]}, "mutation_prompt": null}
{"id": "d07743e4-c5de-4cb2-a46f-a8ff9929ae45", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5 * abs(ub-lb), 0.5 * abs(ub-lb), (self.population_size, self.dim))  # Adjusted velocity range\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (1.5 * eval_count / self.budget)  # Adjusted dynamic factor\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced exploration capabilities through improved perturbation scaling and velocity initialization adjustments.", "configspace": "", "generation": 94, "fitness": 0.07019161069578424, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8c2ac8d5-3cce-490e-a42f-86d3bebb8213", "metadata": {"aucs": [0.07020802571377516, 0.07029368173794803, 0.07007312463562954]}, "mutation_prompt": null}
{"id": "2e9750e6-c7ca-4fed-a576-4fd57300f400", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Cognitive constant\n        self.social_constant = 2.2  # Social constant (adjusted from 2.1 to 2.2)\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5 * abs(ub-lb), 0.5 * abs(ub-lb), (self.population_size, self.dim))  # Adjusted velocity range\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (1.5 * eval_count / self.budget)  # Adjusted dynamic factor\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * np.sin(dynamic_factor)) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant with sine\n                social = (self.social_constant + 0.5 * np.cos(dynamic_factor)) * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Adaptive social factor with cosine\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Introduced adaptive cognitive and social factors for enhanced convergence.", "configspace": "", "generation": 95, "fitness": 0.06304089256984291, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "d07743e4-c5de-4cb2-a46f-a8ff9929ae45", "metadata": {"aucs": [0.06299839490944725, 0.06329822032736077, 0.06282606247272071]}, "mutation_prompt": null}
{"id": "eff5fd71-b8f4-436a-8b24-28eadf49af31", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (adjusted from 1.5 to 1.6)\n        self.social_constant = 2.2  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5 * abs(ub-lb), 0.5 * abs(ub-lb), (self.population_size, self.dim))  # Adjusted velocity range\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (1.5 * eval_count / self.budget)  # Adjusted dynamic factor\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Improved balance between exploration and exploitation by increasing the cognitive constant slightly.", "configspace": "", "generation": 96, "fitness": 0.07028643242363901, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "d07743e4-c5de-4cb2-a46f-a8ff9929ae45", "metadata": {"aucs": [0.07027790377214949, 0.07052271432102253, 0.070058679177745]}, "mutation_prompt": null}
{"id": "9c91f38e-5b06-4098-8292-7ef64a8497af", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (adjusted from 1.5 to 1.6)\n        self.social_constant = 2.2  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5 * abs(ub-lb), 0.5 * abs(ub-lb), (self.population_size, self.dim))  # Adjusted velocity range\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (1.5 * eval_count / self.budget)  # Adjusted dynamic factor\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = (inertia + cognitive + social + perturbation) * 0.95  # Velocity scaling factor\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Fine-tuned velocity scaling for enhanced convergence in PSO.", "configspace": "", "generation": 97, "fitness": 0.07010927514577814, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "eff5fd71-b8f4-436a-8b24-28eadf49af31", "metadata": {"aucs": [0.06995443986547345, 0.07034503641277634, 0.07002834915908462]}, "mutation_prompt": null}
{"id": "74e8ca7f-9354-4c5d-b071-0ada4ba71d0e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.4  # Cognitive constant (adjusted from 1.6 to 1.4)\n        self.social_constant = 2.2  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5 * abs(ub-lb), 0.5 * abs(ub-lb), (self.population_size, self.dim))  # Adjusted velocity range\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (1.5 * eval_count / self.budget)  # Adjusted dynamic factor\n                inertia = (0.6 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight (adjusted from 0.5)\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.008, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced swarm exploration by reducing cognitive constant and dynamic inertia adjustment.", "configspace": "", "generation": 98, "fitness": 0.06841416611787192, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "eff5fd71-b8f4-436a-8b24-28eadf49af31", "metadata": {"aucs": [0.06991266169069088, 0.06526432575582752, 0.07006551090709734]}, "mutation_prompt": null}
{"id": "2c8843f1-d3cf-4800-a867-4bbd79e762f3", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 5)  # Set population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Cognitive constant (adjusted from 1.5 to 1.6)\n        self.social_constant = 2.2  # Social constant\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.local_best = None\n        self.local_best_values = None\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        eval_count = 0\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5 * abs(ub-lb), 0.5 * abs(ub-lb), (self.population_size, self.dim))  # Adjusted velocity range\n        self.local_best = np.copy(self.positions)\n        self.local_best_values = np.full(self.population_size, float('inf'))\n\n        # Evaluate initial positions\n        for i in range(self.population_size):\n            value = func(self.positions[i])\n            eval_count += 1\n            self.local_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best = self.positions[i]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                dynamic_factor = (1.5 * eval_count / self.budget)  # Adjusted dynamic factor\n                inertia = (0.5 + 0.35 * dynamic_factor) * self.velocities[i]  # Dynamic inertia weight\n                cognitive = (self.cognitive_constant + 0.6 * dynamic_factor) * np.random.rand(self.dim) * (self.local_best[i] - self.positions[i])  # Updated cognitive constant\n                social = self.social_constant * dynamic_factor * np.random.uniform(0.85, 1.15, self.dim) * (self.global_best - self.positions[i])  # Fine-tuned social factor\n                perturbation = np.random.standard_normal(self.dim) * 0.05  # Enhanced chaotic perturbation\n                self.velocities[i] = inertia + cognitive + social + perturbation\n                self.positions[i] = self.positions[i] + self.velocities[i]\n                self.positions[i] += np.random.normal(0, 0.01, self.dim)  # Enhanced Gaussian mutation\n\n                # Ensure particles are within bounds\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Evaluate new position\n                value = func(self.positions[i])\n                eval_count += 1\n                if value < self.local_best_values[i]:\n                    self.local_best_values[i] = value\n                    self.local_best[i] = self.positions[i]\n                    if value < self.global_best_value:\n                        self.global_best_value = value\n                        self.global_best = self.positions[i] + np.random.normal(0, 0.0002, self.dim)  # Enhanced perturbation\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best, self.global_best_value", "name": "AdaptiveSwarmOptimization", "description": "Enhanced the algorithm's exploration capability by slightly increasing the Gaussian mutation standard deviation to improve global search efficiency.", "configspace": "", "generation": 99, "fitness": 0.07028583000788624, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "eff5fd71-b8f4-436a-8b24-28eadf49af31", "metadata": {"aucs": [0.07027788168974758, 0.07052103832039813, 0.07005857001351301]}, "mutation_prompt": null}
