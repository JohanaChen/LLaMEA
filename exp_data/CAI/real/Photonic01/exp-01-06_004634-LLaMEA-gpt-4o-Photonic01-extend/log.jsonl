{"id": "35acb2b6-3aa8-4e0b-883c-c4768707542d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5\n        self.cross_prob = 0.9 * (1 - progress)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n                \n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A stochastic optimization algorithm combining adaptive differential evolution and random search for efficient exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.05997001939141341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.05948025848356808, 0.06306732968678341, 0.05736247000388872]}, "mutation_prompt": null}
{"id": "83279ff8-2af1-4ba4-9b30-4d1982e1c925", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.6 + progress * 0.4  # Changed line\n        self.cross_prob = 0.8 * (1 - progress) + 0.2  # Changed line\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n                \n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced differential evolution algorithm with dynamic mutation and crossover probabilities tailored to optimize photonic structures.", "configspace": "", "generation": 1, "fitness": 0.05909705465538673, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "35acb2b6-3aa8-4e0b-883c-c4768707542d", "metadata": {"aucs": [0.059676897061258116, 0.06137762358326149, 0.05623664332164058]}, "mutation_prompt": null}
{"id": "ed0bbe59-811f-43fd-b87a-fe6c41d7bc5a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.6 + progress * 0.4  # Changed line\n        self.cross_prob = 0.95 * (1 - progress)  # Changed line\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n                \n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Adaptive Differential Evolution algorithm using dynamic mutation factors for improved exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.05893800647759628, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "35acb2b6-3aa8-4e0b-883c-c4768707542d", "metadata": {"aucs": [0.05885944712676039, 0.06137762358326149, 0.05657694872276697]}, "mutation_prompt": null}
{"id": "85fc6649-798c-4d63-ab90-f5b8fb628d20", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5\n        self.cross_prob = 0.9 * (1 - progress)\n        self.population_size = int(10 * self.dim * (1 - progress)) + 1  # Dynamic adjustment line\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n                \n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm with dynamic population size adjustment for improved exploration and exploitation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "35acb2b6-3aa8-4e0b-883c-c4768707542d", "metadata": {}, "mutation_prompt": null}
{"id": "2150f633-20b6-4bc7-a278-75ea06446f43", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5\n        self.cross_prob = 0.9 * (1 - progress)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n                \n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with increased crossover probability for improved exploration.", "configspace": "", "generation": 4, "fitness": 0.06010643479568375, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "35acb2b6-3aa8-4e0b-883c-c4768707542d", "metadata": {"aucs": [0.05753423126835466, 0.06090677528660038, 0.061878297832096196]}, "mutation_prompt": null}
{"id": "192d1198-2795-49f3-b800-cde26c632a0d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5\n        self.cross_prob = 0.9 * (1 - progress)\n        self.population_size = max(5, int(10 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic population size adjustment for improved convergence.", "configspace": "", "generation": 5, "fitness": 0.06121026545552055, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2150f633-20b6-4bc7-a278-75ea06446f43", "metadata": {"aucs": [0.06144571690275358, 0.05986799262016451, 0.062317086843643565]}, "mutation_prompt": null}
{"id": "2f01034a-e111-4927-8e38-05fcbfb7ea05", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5\n        self.cross_prob = 0.9 * (1 - progress)\n        self.population_size = max(5, int(10 * self.dim * (1 - progress)))\n\n    def local_search(self, solution, func):\n        # Simple local search around the solution\n        perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n        new_solution = np.clip(solution + perturbation, self.bounds.lb, self.bounds.ub)\n        new_fitness = func(new_solution)\n        if new_fitness < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n\n                # Apply local search to improve promising solutions\n                if self.evaluation_count < self.budget and np.random.rand() < 0.1:\n                    self.population[i] = self.local_search(self.population[i], func)\n                    self.evaluation_count += 1\n\n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a local search mechanism to refine promising solutions for enhanced convergence.", "configspace": "", "generation": 6, "fitness": 0.05902293769303365, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "192d1198-2795-49f3-b800-cde26c632a0d", "metadata": {"aucs": [0.05698157692418648, 0.059878849561553094, 0.06020838659336136]}, "mutation_prompt": null}
{"id": "8ffbc5ea-062e-4631-bd46-7084e54bcc22", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n        self.archive = []\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        self.archive = np.copy(self.population)  # Initialize archive\n\n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.archive.append(target)\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Nonlinear parameter adaptation based on archive diversity\n        progress = self.evaluation_count / self.budget\n        diversity = np.std(self.archive, axis=0).mean()\n        self.mutation_factor = 0.5 + (diversity * 0.5)\n        self.cross_prob = 0.9 * (1 - progress**2)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with nonlinear parameter adaptation and multi-archive strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'numpy.ndarray' object has no attribute 'append'\").", "error": "AttributeError(\"'numpy.ndarray' object has no attribute 'append'\")", "parent_id": "192d1198-2795-49f3-b800-cde26c632a0d", "metadata": {}, "mutation_prompt": null}
{"id": "af13efe4-0ece-4760-b42d-0627af1b31c8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c] + np.random.randn(self.dim) * 0.05)  # Adding Gaussian noise\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5\n        self.cross_prob = 0.9 * (1 - progress)\n        self.population_size = max(5, int(10 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refined Adaptive Differential Evolution with enhanced mutation strategy for improved exploration.", "configspace": "", "generation": 8, "fitness": 0.059773652189276584, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "192d1198-2795-49f3-b800-cde26c632a0d", "metadata": {"aucs": [0.058632657190369586, 0.05979371561604996, 0.060894583761410215]}, "mutation_prompt": null}
{"id": "ea4897f5-69c5-4f4d-a7a4-d3435c75f74b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n        self.fitness_memory = []\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def calculate_diversity(self):\n        mean_individual = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_individual, axis=1))\n        return diversity\n\n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        self.fitness_memory.append(trial_fitness)\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        diversity = self.calculate_diversity()\n        self.mutation_factor = 0.5 + progress * (0.5 / (1 + diversity))\n        self.cross_prob = max(0.5, 0.9 * (1 - progress))\n        self.population_size = max(5, int(10 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive strategy parameters and fitness memory to improve convergence efficiency.", "configspace": "", "generation": 9, "fitness": 0.06100618680356099, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "192d1198-2795-49f3-b800-cde26c632a0d", "metadata": {"aucs": [0.05634958113909183, 0.06183694142778218, 0.06483203784380898]}, "mutation_prompt": null}
{"id": "83fb3f64-bd10-43d7-85c0-8c45ce8a7e0b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness or np.random.rand() < 0.1:  # Accept worse solutions with a small probability\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.6 + progress * 0.4  # Slightly modified adaptation range\n        self.cross_prob = 0.95 * (1 - progress)  # Adjusted crossover probability adaptation\n        self.population_size = max(5, int(10 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A modified Adaptive Differential Evolution with improved parameter adaptation and trial solution acceptance to increase optimization performance.", "configspace": "", "generation": 10, "fitness": 0.060215793864445234, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "192d1198-2795-49f3-b800-cde26c632a0d", "metadata": {"aucs": [0.0630930447135587, 0.05943552512430339, 0.05811881175547362]}, "mutation_prompt": null}
{"id": "20f6abe8-c529-4a96-ae4d-325cb6ba726d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.6 + progress * 0.4  # Adjusted mutation factor\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)  # Adjusted crossover probability\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))  # Reduced dynamic population size\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with enhanced parameter adaptation and reduced evaluation overhead.", "configspace": "", "generation": 11, "fitness": 0.06175019178849909, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "192d1198-2795-49f3-b800-cde26c632a0d", "metadata": {"aucs": [0.0607544438641644, 0.06293276590863117, 0.0615633655927017]}, "mutation_prompt": null}
{"id": "ecc45735-b8dd-458a-ba40-1c767cc28175", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Changed line\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.6 + progress * 0.4  # Adjusted mutation factor\n        self.cross_prob = 0.7 + 0.2 * np.sin(progress * np.pi)  # Changed line\n        self.population_size = max(5, int(10 * self.dim * (1 - progress)))  # Changed line\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic crossover probability and adaptive population size based on evaluation progress.", "configspace": "", "generation": 12, "fitness": 0.05793677520390439, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "20f6abe8-c529-4a96-ae4d-325cb6ba726d", "metadata": {"aucs": [0.05667578271591245, 0.05786836554022046, 0.05926617735558026]}, "mutation_prompt": null}
{"id": "423a3ac7-2af3-4d1a-b7a7-70599535bf6c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Slightly increased population size\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.cross_prob = 0.85  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5  # More refined mutation factor calculation\n        self.cross_prob = 0.95 * (1 - 0.5 * progress)  # More refined crossover probability calculation\n        self.population_size = max(6, int(10 * self.dim * (1 - progress)))  # Slightly different dynamic population size\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with strategic sampling and refined parameter adjustments for improved global search efficacy.", "configspace": "", "generation": 13, "fitness": 0.06091450330597514, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "20f6abe8-c529-4a96-ae4d-325cb6ba726d", "metadata": {"aucs": [0.06421280326164602, 0.05736481701095075, 0.06116588964532865]}, "mutation_prompt": null}
{"id": "17b40959-df5b-4671-9061-77a0cc34e423", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        progress = self.evaluation_count / self.budget\n        cross_prob_dynamic = self.cross_prob * (1 - progress)  # Dynamic crossover probability\n        mask = np.random.rand(self.dim) < cross_prob_dynamic\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        return target  # Improved selection with reduced function evaluations\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.6 + progress * 0.4\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n\n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic crossover strategy and improved selection mechanism.", "configspace": "", "generation": 14, "fitness": 0.06008459245691833, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "20f6abe8-c529-4a96-ae4d-325cb6ba726d", "metadata": {"aucs": [0.05595691464187258, 0.06042425025560172, 0.06387261247328069]}, "mutation_prompt": null}
{"id": "fb4db421-aafe-474f-bf36-dbbb250100af", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.5 + progress * 0.5  # More aggressive mutation factor adjustment\n        self.cross_prob = 0.85 * (1 - 0.3 * progress)  # Enhanced adaptive crossover probability\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))  # Reduced dynamic population size\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refined Adaptive Differential Evolution with improved dynamic parameter adaptation for better exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.06058612858300579, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "20f6abe8-c529-4a96-ae4d-325cb6ba726d", "metadata": {"aucs": [0.058013934401988876, 0.06081222895565708, 0.06293222239137142]}, "mutation_prompt": null}
{"id": "36037308-ac41-42f8-ad0e-35bcd02942a4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + 0.1 * np.random.randn(self.dim)  # Dynamic mutation strategy\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            return trial\n        else:\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.mutation_factor = 0.6 + progress * 0.4\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic mutation strategy for improved exploration-exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.06043373479190831, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "20f6abe8-c529-4a96-ae4d-325cb6ba726d", "metadata": {"aucs": [0.058615143174969075, 0.06306875170317716, 0.05961730949757871]}, "mutation_prompt": null}
{"id": "78cc0837-81b6-462c-bb1c-18c249ea5169", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Increase mutation factor\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.05)  # Decrease mutation factor\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)  # Adjusted crossover probability\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))  # Reduced dynamic population size\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introducing dynamic mutation control based on fitness improvement to enhance convergence speed.", "configspace": "", "generation": 17, "fitness": 0.06396788618953138, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "20f6abe8-c529-4a96-ae4d-325cb6ba726d", "metadata": {"aucs": [0.0611755963342161, 0.0665470979079269, 0.06418096432645115]}, "mutation_prompt": null}
{"id": "83323ae4-bbd0-490c-a3fc-421cfb2ecece", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.1)  # Increased mutation adjustment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.1)  # Increased mutation adjustment\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.95 * (1 - 0.5 * progress)  # Slightly increased base crossover probability\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refining parameter adaptation by varying mutation factor and crossover probability based on current improvement.", "configspace": "", "generation": 18, "fitness": 0.06375082939751164, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "78cc0837-81b6-462c-bb1c-18c249ea5169", "metadata": {"aucs": [0.05891072224487526, 0.06572616860489677, 0.0666155973427629]}, "mutation_prompt": null}
{"id": "fb6feefe-2703-4b25-9f13-335504d51956", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.8  # Increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Increase mutation factor\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.05)  # Decrease mutation factor\n            return target\n\n    def adapt_parameters(self):\n        # Adapt parameters based on evaluation progress\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)  # Adjusted crossover probability\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))  # Reduced dynamic population size\n        if progress < 0.5:  # Explore boundaries more in the early phase\n            self.bounds.lb *= 0.9\n            self.bounds.ub *= 1.1\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive boundary exploration to improve diversity and convergence.", "configspace": "", "generation": 19, "fitness": 0.06208229326339606, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "78cc0837-81b6-462c-bb1c-18c249ea5169", "metadata": {"aucs": [0.060670138418865927, 0.06282805870040642, 0.06274868267091582]}, "mutation_prompt": null}
{"id": "fe72103f-0bac-4503-a362-77f9278cebc0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced balance between exploration and exploitation by slightly increasing population diversity and adjusting mutation adaptivity.", "configspace": "", "generation": 20, "fitness": 0.06561363537211069, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "78cc0837-81b6-462c-bb1c-18c249ea5169", "metadata": {"aucs": [0.06538659638660871, 0.06514772058580776, 0.06630658914391563]}, "mutation_prompt": null}
{"id": "2b44d71c-d207-4c3d-9636-29499139bd04", "solution": "class AdaptiveDifferentialEvolution:\n    # ... (previous code remains unchanged) ...\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.05)  # Slightly increased decrement\n            return target\n\n    # ... (subsequent code remains unchanged) ...", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increased mutation factor adaptivity for improved convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('AdaptiveDifferentialEvolution() takes no arguments').", "error": "TypeError('AdaptiveDifferentialEvolution() takes no arguments')", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {}, "mutation_prompt": null}
{"id": "46b2893b-136a-4a87-a04d-478afb11ea5f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced balance between exploration and exploitation by slightly increasing population diversity and adjusting mutation adaptivity.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06538659638660871, 0.06514772058580776, 0.06630658914391563]}, "mutation_prompt": null}
{"id": "862c0ffd-9103-4688-940e-8bc869ff9bfb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.mutation_factor = 0.85\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.03)  # Adjusted mutation factor increment\n            return trial\n        else:\n            self.mutation_factor = max(0.5, self.mutation_factor - 0.03)  # Adjusted mutation factor decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(6 * self.dim * (1 - progress)))  # Adjusted population size reduction\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly enhanced exploration by adjusting population size reduction and added a dynamic mutation factor range.", "configspace": "", "generation": 23, "fitness": 0.06321435123728054, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06336139128058271, 0.0645423755487089, 0.06173928688255004]}, "mutation_prompt": null}
{"id": "b7f4165f-2249-42ad-8e31-dc6a948799ac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.85  # Slightly increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increased the crossover probability to enhance solution diversity and convergence.", "configspace": "", "generation": 24, "fitness": 0.06354716516639818, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06497953513682675, 0.0625085175334763, 0.06315344282889146]}, "mutation_prompt": null}
{"id": "9c29b92e-0822-4c87-ad05-761dcd8577d6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.85  # Slightly increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increased crossover probability to enhance exploration during early stages of optimization.", "configspace": "", "generation": 25, "fitness": 0.06354716516639818, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06497953513682675, 0.0625085175334763, 0.06315344282889146]}, "mutation_prompt": null}
{"id": "c80407fc-4ecd-4f0a-a250-f1d2473d445b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.7 * progress)  # Modified from 0.5 to 0.7 for dynamic variation\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved exploration by adjusting the crossover probability to vary more dynamically with progress.", "configspace": "", "generation": 26, "fitness": 0.0645957627225271, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06512460699862976, 0.06269633019613974, 0.06596635097281178]}, "mutation_prompt": null}
{"id": "8b8acf3b-96df-40b6-a311-a643fed75f0e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.45, self.mutation_factor - 0.04)  # Slightly adjusted decrement from 0.4\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Minor adjustment in mutation factor decrement to improve convergence.", "configspace": "", "generation": 27, "fitness": 0.0640678376784342, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06387948614967243, 0.06495791738090229, 0.06336610950472787]}, "mutation_prompt": null}
{"id": "8fdd7dd4-4e4d-4f8e-a007-a7d9c3803367", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Initial mutation factor adjusted for better exploration\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration by adjusting the mutation factor initialization for better diversity.  ", "configspace": "", "generation": 28, "fitness": 0.0647611034526235, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06564299308214505, 0.06439867734293814, 0.06424163993278731]}, "mutation_prompt": null}
{"id": "bac21b73-9004-4f0c-9fed-3899b04bdbfc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.3, self.mutation_factor - 0.04)  # Adjusted decrement range\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly adjust the mutation factor range to improve adaptability and convergence.", "configspace": "", "generation": 29, "fitness": 0.0649516722615453, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06457810318849377, 0.06533889031858464, 0.06493802327755749]}, "mutation_prompt": null}
{"id": "02da9bdd-6b24-4eca-a303-9e8187e94a39", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.75 * progress)  # Adjusted to better balance exploration/exploitation\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability to better balance exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.06459824778899899, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06466075580714281, 0.06288893007855223, 0.06624505748130194]}, "mutation_prompt": null}
{"id": "b9c3500d-8cff-422b-b227-47c6ed9ca2d4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced balance between exploration and exploitation by slightly increasing population diversity and adjusting mutation adaptivity.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06538659638660871, 0.06514772058580776, 0.06630658914391563]}, "mutation_prompt": null}
{"id": "5d68ceeb-b97c-49e5-aca4-c2f885944243", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.045)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.035)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation adaptivity and crossover probability to enhance convergence speed.", "configspace": "", "generation": 32, "fitness": 0.06376044050856262, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06489563311576918, 0.0631646562184367, 0.06322103219148201]}, "mutation_prompt": null}
{"id": "8c90a5a5-e3b1-4cb8-b8a4-8eabb145e8d9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress) + 0.05 * np.sin(0.5 * self.evaluation_count)  # Enhanced adaptability\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic crossover probability adjustment based on evaluation count to enhance adaptability.", "configspace": "", "generation": 33, "fitness": 0.0653112241692549, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06533663455652794, 0.06483856166475066, 0.06575847628648612]}, "mutation_prompt": null}
{"id": "7eeb91d6-10bd-4770-adf7-a9a63a8122f3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.045)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly adjusted mutation increment for faster convergence under constraints.", "configspace": "", "generation": 34, "fitness": 0.06335087288996955, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06485907096938759, 0.0642898414732872, 0.060903706227233845]}, "mutation_prompt": null}
{"id": "d2599bfc-6e64-4f0a-b65c-389cdf0dfb04", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04 + np.random.uniform(-0.02, 0.02))\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04 + np.random.uniform(-0.02, 0.02))\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a random component to mutation factor adjustment for improved exploration.", "configspace": "", "generation": 35, "fitness": 0.06356305985717958, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06253789248114028, 0.06431633577747164, 0.06383495131292682]}, "mutation_prompt": null}
{"id": "ced86be8-56af-4a8b-986b-5dfd3352cc62", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n        \n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            self.cross_prob = min(0.9, self.cross_prob + 0.02)  # Dynamic adjustment for cross_prob\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic adjustment for the crossover probability based on fitness improvement to better balance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": 0.06406276698760831, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06502962170077364, 0.0642641489064617, 0.06289453035558956]}, "mutation_prompt": null}
{"id": "81809954-b75b-468f-b5f8-c30097228a3b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.045)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation factor adjustment for improved convergence rate in diverse scenarios.", "configspace": "", "generation": 37, "fitness": 0.06335087288996955, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06485907096938759, 0.0642898414732872, 0.060903706227233845]}, "mutation_prompt": null}
{"id": "6c6265a6-54b4-4e3a-91a4-3dbc2c9280be", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress) + 0.05 * progress  # Increased by 0.05 during late stages\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly enhance exploitation by increasing crossover probability during late stages of optimization.", "configspace": "", "generation": 38, "fitness": 0.06466026663393931, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06423588317429008, 0.0661080036750823, 0.06363691305244557]}, "mutation_prompt": null}
{"id": "07381c96-4181-4388-b42f-87ee96cee0ab", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Further enhance exploration by slightly increasing mutation adaptivity to improve convergence.", "configspace": "", "generation": 39, "fitness": 0.0631560722228008, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06437423690451338, 0.06232248514807737, 0.06277149461581166]}, "mutation_prompt": null}
{"id": "9c3d0432-d743-413e-840b-16dfd1f52579", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.87  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved adaptive strategy by slightly increasing the mutation factor for enhanced exploration.", "configspace": "", "generation": 40, "fitness": 0.06485857796525833, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06483599066516699, 0.06433425034900131, 0.06540549288160669]}, "mutation_prompt": null}
{"id": "41521b03-b60b-45a7-a1f3-c69170cf332b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increased mutation factor for enhanced exploration.", "configspace": "", "generation": 41, "fitness": 0.0647611034526235, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06564299308214505, 0.06439867734293814, 0.06424163993278731]}, "mutation_prompt": null}
{"id": "53e965d5-7b9a-4c8e-9f18-630bcd37846f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.45, self.mutation_factor - 0.04)  # Changed decrement rate\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploitation by slightly adjusting the mutation factor decrement rate to improve convergence. ", "configspace": "", "generation": 42, "fitness": 0.0640678376784342, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06387948614967243, 0.06495791738090229, 0.06336610950472787]}, "mutation_prompt": null}
{"id": "51b4ead8-c334-45b4-a185-11c8c0f51f30", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.85  # Slightly increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration by increasing the crossover probability slightly for better diversity.", "configspace": "", "generation": 43, "fitness": 0.06354716516639818, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06497953513682675, 0.0625085175334763, 0.06315344282889146]}, "mutation_prompt": null}
{"id": "b71018cf-2754-4ef4-835d-d4144a73e8db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.05)  # Slightly increased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor increment/decrement to enhance exploration capabilities.", "configspace": "", "generation": 44, "fitness": 0.0651352524573906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06603570615099297, 0.06422989096942833, 0.06514016025175051]}, "mutation_prompt": null}
{"id": "d114856b-a3e5-4d04-a93a-c16201c6f514", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by slightly increasing mutation factor adaptivity.", "configspace": "", "generation": 45, "fitness": 0.0631560722228008, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06437423690451338, 0.06232248514807737, 0.06277149461581166]}, "mutation_prompt": null}
{"id": "6ae798e6-1f64-42fc-a17e-190adcaee381", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.85  # Adjusted crossover probability for better convergence\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced strategy by slightly adjusting crossover probability for better convergence.", "configspace": "", "generation": 46, "fitness": 0.06354716516639818, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06497953513682675, 0.0625085175334763, 0.06315344282889146]}, "mutation_prompt": null}
{"id": "52309c7d-7e42-466a-987f-333a386dacfd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.02)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly enhance population adaptability by reducing the mutation factor decrement to maintain diversity longer.", "configspace": "", "generation": 47, "fitness": 0.0626439127935426, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06169924269372784, 0.06326550361329386, 0.06296699207360612]}, "mutation_prompt": null}
{"id": "f4296a76-88e2-4ede-86ab-7c9fd8c74aff", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor increment when a trial vector improves upon a target vector to enhance exploration.", "configspace": "", "generation": 48, "fitness": 0.0631560722228008, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06437423690451338, 0.06232248514807737, 0.06277149461581166]}, "mutation_prompt": null}
{"id": "a52fe736-f099-4058-9bd6-b58efe2d5346", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Change: Increased mutation factor baseline\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incrementally enhance exploration by slightly increasing the mutation factor's baseline.", "configspace": "", "generation": 49, "fitness": 0.0647611034526235, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06564299308214505, 0.06439867734293814, 0.06424163993278731]}, "mutation_prompt": null}
{"id": "c4bee39e-fa4f-49ce-a3ea-ca32031cf951", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Changed mutation factor to further enhance exploration\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence speed by increasing the mutation factor to slightly boost exploration.", "configspace": "", "generation": 50, "fitness": 0.0647611034526235, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06564299308214505, 0.06439867734293814, 0.06424163993278731]}, "mutation_prompt": null}
{"id": "6c62406d-8c2e-4daa-891d-42d8b29a91a2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.82  # Slightly increased crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Increase crossover probability slightly to enhance the exploitation phase.", "configspace": "", "generation": 51, "fitness": 0.06480305036396994, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06626786803002349, 0.06502783521859812, 0.0631134478432882]}, "mutation_prompt": null}
{"id": "87f0bb39-148c-4218-bb89-cea27c072040", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tuned the mutation factor adjustment to subtly refine exploration-exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.0631560722228008, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06437423690451338, 0.06232248514807737, 0.06277149461581166]}, "mutation_prompt": null}
{"id": "3e2ec6b0-956e-4e07-832d-a0fcc3b514dc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.2, self.mutation_factor + 0.04)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation adaptation by increasing mutation factor bounds for better exploration.", "configspace": "", "generation": 53, "fitness": 0.06551696928871824, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06538659638660871, 0.066323411578045, 0.06484089990150099]}, "mutation_prompt": null}
{"id": "0d73acd2-bb5b-4443-b986-6c54a208879f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.06)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration capability by increasing mutation factor adaptation rate.", "configspace": "", "generation": 54, "fitness": 0.06324163909112039, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.0653418319279, 0.061672019970194114, 0.06271106537526705]}, "mutation_prompt": null}
{"id": "e873f6f4-afc9-43c1-b2a9-e52292a62ddb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced adaptive strategy by incrementing mutation factor more aggressively.", "configspace": "", "generation": 55, "fitness": 0.0631560722228008, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06437423690451338, 0.06232248514807737, 0.06277149461581166]}, "mutation_prompt": null}
{"id": "a888dd85-3e0f-4ffb-9814-c2fdb07489c2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Increased mutation factor for better exploration\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor for enhanced exploration.", "configspace": "", "generation": 56, "fitness": 0.0647611034526235, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06564299308214505, 0.06439867734293814, 0.06424163993278731]}, "mutation_prompt": null}
{"id": "87e75b7a-05d7-432d-98e7-a746f7ba9bb5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.5, self.mutation_factor - 0.04)  # Adjusted decrement value\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adjust mutation factor decrement for improved convergence.", "configspace": "", "generation": 57, "fitness": 0.064208349329968, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06536966178202652, 0.0632682228048087, 0.06398716340306876]}, "mutation_prompt": null}
{"id": "19064ef9-185d-4a5e-be1c-1b97adbb8885", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.05)  # Slightly increased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase mutation factor change rate for better adaptability.", "configspace": "", "generation": 58, "fitness": 0.0651352524573906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06603570615099297, 0.06422989096942833, 0.06514016025175051]}, "mutation_prompt": null}
{"id": "c5c43e24-6d50-48e7-8ee5-1aec8cbc03ea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refined strategy to enhance adaptive parameter adjustment with a minor modification to mutation factor increment.", "configspace": "", "generation": 59, "fitness": 0.0631560722228008, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06437423690451338, 0.06232248514807737, 0.06277149461581166]}, "mutation_prompt": null}
{"id": "06cee197-a129-4833-8dcb-276cb8ce9fb1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress) + 0.05 * np.random.rand()  # Added slight randomness\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a small adaptive scaling factor for crossover probability to improve convergence speed.", "configspace": "", "generation": 60, "fitness": 0.06539331878517429, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06462458632553802, 0.06507475141723096, 0.0664806186127539]}, "mutation_prompt": null}
{"id": "0eddd385-a4a1-4d0b-8465-18d214a4a0d9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased by 3 * dim for enhanced diversity\n        self.mutation_factor = 0.85  # Kept the same\n        self.cross_prob = 0.9  # Increased initial crossover probability\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.02)  # Reduced increment\n            return trial\n        else:\n            self.mutation_factor = max(0.5, self.mutation_factor - 0.02)  # Increased minimum decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.7 + 0.2 * np.sin(3.14 * progress)  # Adaptive crossover with progressive fluctuation\n        self.population_size = max(5, int(10 * self.dim * (1 - 0.5 * progress)))  # Adjusted progressive resizing\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved exploration through adaptive strategy by including dynamic population resizing and adaptive crossover probability enhancement.", "configspace": "", "generation": 61, "fitness": 0.061179903589519156, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06137478110225747, 0.06207743584858594, 0.060087493817714055]}, "mutation_prompt": null}
{"id": "20ae2071-bbb4-486c-ab35-385bdca582d9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by slightly increasing the mutation factor.", "configspace": "", "generation": 62, "fitness": 0.0647611034526235, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06564299308214505, 0.06439867734293814, 0.06424163993278731]}, "mutation_prompt": null}
{"id": "60a94b67-bf6c-4de5-91bc-552a787e5923", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.87  # Increased mutation factor slightly\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration by slightly increasing the mutation factor, potentially improving convergence speed.", "configspace": "", "generation": 63, "fitness": 0.06485857796525833, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06483599066516699, 0.06433425034900131, 0.06540549288160669]}, "mutation_prompt": null}
{"id": "4d4a3dfc-f017-4c5d-a7b3-0ee6ee8704fb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tuned the mutation factor adaptivity range for enhanced exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.0631560722228008, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06437423690451338, 0.06232248514807737, 0.06277149461581166]}, "mutation_prompt": null}
{"id": "db461f8d-a408-4dfd-9adb-3532ea0d5747", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.85 * (1 - 0.5 * progress)  # Reduced baseline cross_prob decay\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Minor adjustment to crossover probability decay for improved exploration in later stages of optimization.", "configspace": "", "generation": 65, "fitness": 0.0651760474586806, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06637370826110645, 0.06542384074162833, 0.063730593373307]}, "mutation_prompt": null}
{"id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incrementally increase mutation variability to enhance convergence speed.", "configspace": "", "generation": 66, "fitness": 0.0657869635857035, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "fe72103f-0bac-4503-a362-77f9278cebc0", "metadata": {"aucs": [0.06513828079349815, 0.06641936237501311, 0.06580324758859923]}, "mutation_prompt": null}
{"id": "91e2acee-a9ba-41f3-95f2-83da43d6303e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Increase mutation factor slightly when trial is successful to enhance exploration.", "configspace": "", "generation": 67, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "926c23fb-d172-480f-99d5-0b97cca2bc53", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Changed increment to 0.05\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor increment to improve exploration.", "configspace": "", "generation": 68, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "e4fa0c5c-0a1f-43c5-8964-ec15a8e37309", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n            self.population_size = max(5, int(self.population_size * 1.01))  # Dynamic adjustment\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting population size based on performance.", "configspace": "", "generation": 69, "fitness": 0.0657869635857035, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06513828079349815, 0.06641936237501311, 0.06580324758859923]}, "mutation_prompt": null}
{"id": "ade74e4d-3817-42d8-a3eb-3b18b3690d6e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.3 * progress)  # Reduced from 0.5 to 0.3\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adjust crossover probability dynamically based on progress to improve exploration-exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.06514591544772812, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06459667622201959, 0.06481440958183426, 0.06602666053933048]}, "mutation_prompt": null}
{"id": "89827c7c-5ec8-4632-bf42-d541cb8c308f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a slight increase to mutation factor's adjustment increment for improved exploration.", "configspace": "", "generation": 71, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "2a628344-59da-41c0-ab12-e00dfdd41d7b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress) * 0.95  # Added adaptive decay\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability decay based on the remaining budget to balance exploration and exploitation.", "configspace": "", "generation": 72, "fitness": 0.06437400348922884, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06569943757186203, 0.0640409619377953, 0.06338161095802919]}, "mutation_prompt": null}
{"id": "fedf9992-c3ef-423e-8b9e-1cdef536d4cc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.06)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation rate adaptation for improved convergence.", "configspace": "", "generation": 73, "fitness": 0.06379761352812363, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06609837081578085, 0.06237129987772394, 0.0629231698908661]}, "mutation_prompt": null}
{"id": "8d27dbf7-2c59-4d61-a011-a3b2eaf1d80d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor increment to enhance convergence adaptability.", "configspace": "", "generation": 74, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "d988ec46-0aa9-45f5-8472-356b5521a8e2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.045)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor increment to enhance exploration.", "configspace": "", "generation": 75, "fitness": 0.06446757937481162, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.0656836387428289, 0.06425418906198033, 0.06346491031962564]}, "mutation_prompt": null}
{"id": "21fefb43-e55a-4bd3-aded-9c009b3c0a77", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n        prev_best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n\n                fitness_improvement = prev_best_fitness - best_fitness\n                if fitness_improvement > 0:\n                    self.mutation_factor *= (1 + 0.05 * fitness_improvement)  # Change this line\n\n                prev_best_fitness = best_fitness\n\n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation rate scaling based on fitness improvement to enhance convergence stability.", "configspace": "", "generation": 76, "fitness": 0.06372912727521625, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06553424597329682, 0.062134252239204324, 0.06351888361314761]}, "mutation_prompt": null}
{"id": "820123a5-2d5c-4272-b48e-e96706837427", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.03)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refine mutation variability increment to enhance convergence precision.", "configspace": "", "generation": 77, "fitness": 0.06438181633204172, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06532707683753614, 0.0647569438462181, 0.06306142831237094]}, "mutation_prompt": null}
{"id": "57bd13fb-c2a4-408d-9497-81fa7caff28c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Adjusted initial mutation factor for more exploration\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introducing slight diversity by adjusting the initial mutation factor for better exploration.", "configspace": "", "generation": 78, "fitness": 0.06404822045420355, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06527210857684429, 0.06359097340518427, 0.0632815793805821]}, "mutation_prompt": null}
{"id": "7b321361-149f-4035-9364-f11d4b254333", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.03)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation factor adjustment for more stable convergence.", "configspace": "", "generation": 79, "fitness": 0.06438181633204172, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06532707683753614, 0.0647569438462181, 0.06306142831237094]}, "mutation_prompt": null}
{"id": "381f466e-98a2-4ac1-9fd5-96a41382fb0a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.02)  # Reduced decrement to enhance exploration\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce slight improvement by reducing mutation factor decrement to enhance exploration.", "configspace": "", "generation": 80, "fitness": 0.06269259077051514, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06195963156981077, 0.06203491578574172, 0.06408322495599295]}, "mutation_prompt": null}
{"id": "d388fcb2-eab6-439b-8aba-a5e4503fe159", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor adjustment to improve convergence stability.", "configspace": "", "generation": 81, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "836cc8de-2db4-486f-9213-f5816111d4db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n            self.cross_prob = max(0.1, min(0.9, self.cross_prob + 0.01))  # Self-adapting crossover probability\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a self-adapting crossover probability to enhance search efficiency.  ", "configspace": "", "generation": 82, "fitness": 0.06408738107721908, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06369439184220815, 0.0662916345208604, 0.06227611686858869]}, "mutation_prompt": null}
{"id": "5d3f41a6-01c3-49d9-a7ec-76515e5aed12", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.015  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce subtle adaptation to mutation factor for enhanced convergence efficiency.", "configspace": "", "generation": 83, "fitness": 0.06514657823831967, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06418267396305188, 0.06611448163136102, 0.0651425791205461]}, "mutation_prompt": null}
{"id": "dd7b6185-d7c7-46c4-953a-ac6cdc7b3397", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress/2)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population scaling to enhance adaptability throughout the optimization process.", "configspace": "", "generation": 84, "fitness": 0.06329633057153398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06523560693915387, 0.06011058967426042, 0.06454279510118766]}, "mutation_prompt": null}
{"id": "3ed77386-f5ca-431a-85b1-0351b65e095b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.02)  # Refined increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.02)  # Refined decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        diversity = np.std(self.population, axis=0).mean()\n        self.cross_prob = 0.6 + 0.4 * (1 - diversity)  # Dynamic adjustment\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.005  # Reduced incremental change\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adaptation of crossover probability and mutation factor, guided by population diversity, to enhance exploration and exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.05429887188126529, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.053630609182173106, 0.05682701792091316, 0.05243898854070961]}, "mutation_prompt": null}
{"id": "edde3f9e-f595-4b29-abc2-8fe9ecf233b5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress) + 0.05  # Minor adaptation here\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a minor crossover probability adaptation for improved exploration.", "configspace": "", "generation": 86, "fitness": 0.06405790534076176, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.0663212982088347, 0.06283443658264709, 0.06301798123080349]}, "mutation_prompt": null}
{"id": "f9a0fc49-499b-492a-b6ad-1478fb7da245", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase mutation factor adjustment to improve exploration capabilities.", "configspace": "", "generation": 87, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "2cf47494-ff8c-490c-a9f1-e45286196848", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly adjusted mutation factor increment to enhance convergence efficiency.", "configspace": "", "generation": 88, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "e6ca78b8-53ac-44e6-85ad-d84251a6a6c2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01 + np.random.uniform(-0.005, 0.005)  # Incremental change with fluctuation\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce slight random fluctuation to the mutation factor for improved exploration.", "configspace": "", "generation": 89, "fitness": 0.06488358880752487, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.064583936818976, 0.06456450696801463, 0.06550232263558398]}, "mutation_prompt": null}
{"id": "22ef0790-2618-479e-af46-7db0653d968d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n        self.archive = []  # Introduce archive for historical solutions\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            if trial not in self.archive:\n                self.archive.append(trial)  # Store successful trials\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.6 + 0.3 * np.sin(np.pi * progress)  # Dynamic crossover based on progress\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            if self.archive and len(self.archive) > self.population_size // 2:  # Use archive for diversity\n                for j in range(len(self.archive) // 4):\n                    self.population[np.random.randint(self.population_size)] = self.archive.pop(np.random.randint(len(self.archive)))\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration-exploitation balance by dynamically adjusting crossover probability and introducing archive-based memory.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {}, "mutation_prompt": null}
{"id": "28dcae5b-a10a-40bc-8cbc-b1165bc31cb1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.85 * (1 - 0.5 * progress)  # Adjusted decrement factor\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the crossover probability decrement to enhance convergence rate.", "configspace": "", "generation": 91, "fitness": 0.06410391466407062, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06494417343780268, 0.06320968826945284, 0.06415788228495634]}, "mutation_prompt": null}
{"id": "883be9d5-7373-432d-876f-9f62704196d2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Slightly increased initial mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a minor adjustment to balance exploration and exploitation more effectively by modifying the initial mutation factor.", "configspace": "", "generation": 92, "fitness": 0.06404822045420355, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06527210857684429, 0.06359097340518427, 0.0632815793805821]}, "mutation_prompt": null}
{"id": "f6e9069e-d2cf-4b6a-aa70-2c0ef44032fc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n        self.success_count = 0  # Track successful mutations\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.success_count += 1  # Increment success on better trial\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def update_mutation_factor(self):\n        if self.success_count / self.population_size < 0.2:  # Adjust mutation factor based on success rate\n            self.mutation_factor *= 0.95\n        else:\n            self.mutation_factor *= 1.05\n        self.success_count = 0  # Reset success count after adjustment\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.update_mutation_factor()  # Call the new function to adjust mutation factor\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive mutation factor based on success ratio to improve convergence.", "configspace": "", "generation": 93, "fitness": 0.06567710918032159, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06522172321778419, 0.06613368302196798, 0.06567592130121258]}, "mutation_prompt": null}
{"id": "f0873807-5e42-400c-aae8-db0d208770bd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.02  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incrementally enhance mutation variability while preserving a diverse population. ", "configspace": "", "generation": 94, "fitness": 0.06529291303964035, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06418266958944074, 0.06593748958879864, 0.06575857994068168]}, "mutation_prompt": null}
{"id": "2ce9196a-7bcc-4bf2-9154-4d719b7d5864", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.03)  # Fine-tuned increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation variability by adjusting the mutation factor increment, enhancing convergence precision.", "configspace": "", "generation": 95, "fitness": 0.06438181633204172, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06532707683753614, 0.0647569438462181, 0.06306142831237094]}, "mutation_prompt": null}
{"id": "6746845a-0bcb-42ff-b6ae-a3e3e27069aa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.005  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation incremental change for smoother convergence.", "configspace": "", "generation": 96, "fitness": 0.06572752234333439, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06535226033855002, 0.06661082276654062, 0.0652194839249125]}, "mutation_prompt": null}
{"id": "9f938db8-4b95-4334-8eee-9bec2e44d2da", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)  # Slightly increased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a slight increase to the mutation factor's adaptive increment to enhance exploration.", "configspace": "", "generation": 97, "fitness": 0.0637213986308129, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06414259521639298, 0.06370575718022731, 0.06331584349581842]}, "mutation_prompt": null}
{"id": "15ef5d33-9b60-45d6-b575-1b8ed02272f1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.03)  # Adjusted increment for fine-tuning\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation factor adjustment for better convergence.", "configspace": "", "generation": 98, "fitness": 0.06438181633204172, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06532707683753614, 0.0647569438462181, 0.06306142831237094]}, "mutation_prompt": null}
{"id": "dd1cffc1-cbfa-4f81-b80b-5510f5e4557b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased by 2 * dim for more diversity\n        self.mutation_factor = 0.9  # Increased mutation factor\n        self.cross_prob = 0.8\n        self.population = None\n        self.bounds = None\n        self.evaluation_count = 0\n\n    def initialize_population(self, lower_bounds, upper_bounds):\n        self.population = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n    \n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.cross_prob\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        target = self.population[target_idx]\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        self.evaluation_count += 2\n        if trial_fitness < target_fitness:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.04)  # Slightly decreased increment\n            return trial\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.04)  # Slightly decreased decrement\n            return target\n\n    def adapt_parameters(self):\n        progress = self.evaluation_count / self.budget\n        self.cross_prob = 0.9 * (1 - 0.5 * progress)\n        self.population_size = max(5, int(8 * self.dim * (1 - progress)))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population(self.bounds.lb, self.bounds.ub)\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        while self.evaluation_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                self.population[i] = self.select(i, trial, func)\n\n                trial_fitness = func(self.population[i])\n                self.evaluation_count += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = self.population[i]\n                    \n                if self.evaluation_count >= self.budget:\n                    break\n\n            self.adapt_parameters()\n            self.mutation_factor += 0.01  # Incremental change to enhance convergence\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor to enhance exploration.", "configspace": "", "generation": 99, "fitness": 0.06404822045420355, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bf7f245f-942e-4c58-82f7-b90317004cd1", "metadata": {"aucs": [0.06527210857684429, 0.06359097340518427, 0.0632815793805821]}, "mutation_prompt": null}
