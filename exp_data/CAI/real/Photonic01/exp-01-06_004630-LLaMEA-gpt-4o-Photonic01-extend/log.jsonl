{"id": "e10f26e7-abeb-4b24-b026-6391a8544175", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub):\n        beta = 0.05\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub)\n            population = self.differential_evolution(quantum_population, lb, ub)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Hybrid Quantum-Inspired Differential Evolution (QIDE) combining quantum superposition principles with differential evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 134, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 41, in __call__\n  File \"<string>\", line 16, in quantum_superposition\n  File \"<string>\", line 16, in <listcomp>\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 134, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 41, in __call__\n  File \"<string>\", line 16, in quantum_superposition\n  File \"<string>\", line 16, in <listcomp>\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "3522384a-69ed-4a22-afdd-3574dd232132", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Enhanced QIDE with a more adaptive quantum coefficient (beta) for improved convergence.", "configspace": "", "generation": 1, "fitness": 0.057415016115471985, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "e10f26e7-abeb-4b24-b026-6391a8544175", "metadata": {"aucs": [0.05862122912782586, 0.059733192517019806, 0.0538906267015703]}, "mutation_prompt": null}
{"id": "701a26ac-0b91-421c-a3bf-5b0b7dcd83cc", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8 + 0.1 * np.log(dim)  # Small adjustment to diff_weight based on dimensionality\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improved adaptive hyperparameter adjustment for balancing exploration and exploitation in QIDE.", "configspace": "", "generation": 2, "fitness": 0.054673620787183554, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "3522384a-69ed-4a22-afdd-3574dd232132", "metadata": {"aucs": [0.0524861439854688, 0.05731844894307492, 0.05421626943300695]}, "mutation_prompt": null}
{"id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Introduced a dynamic adjustment of the differential weight (diff_weight) to improve exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.060754226948100766, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3522384a-69ed-4a22-afdd-3574dd232132", "metadata": {"aucs": [0.05927327877158328, 0.0627708081434184, 0.06021859392930062]}, "mutation_prompt": null}
{"id": "929aafbf-ead7-473e-8939-145c18498ae9", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.cbrt(self.dim)  # Changed from sqrt to cbrt for more sensitive dimensionality adaptation\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            self.diff_weight = 0.5 + 0.4 * np.random.rand()  # Changed from 0.3 to 0.4 to allow larger adjustments\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Enhanced exploration by adaptive control of quantum step size and mutation strategy to improve convergence.", "configspace": "", "generation": 4, "fitness": 0.05944480629458778, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.05535151037984043, 0.0632309283331206, 0.0597519801708023]}, "mutation_prompt": null}
{"id": "60a236f7-c3ba-4221-8494-f7ea8859c81e", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0)\n            self.cross_prob = 0.5 + 0.4 * np.mean(diversity)  # Adjust cross_prob based on diversity\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Improved exploration by dynamically adjusting the crossover probability based on population diversity.", "configspace": "", "generation": 5, "fitness": 0.059418946666695005, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.057522964591284365, 0.06166319273159648, 0.05907068267720417]}, "mutation_prompt": null}
{"id": "62c6436a-a02a-4c2d-af7e-5eeacf08bd87", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            self.cross_prob = 0.7 + 0.3 * np.random.rand()  # Dynamic adaptive crossover probability\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduced a dynamic adaptive crossover probability to balance exploration and exploitation capabilities.", "configspace": "", "generation": 6, "fitness": 0.060652852285904, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.05918279119339909, 0.06117682702211924, 0.06159893864219368]}, "mutation_prompt": null}
{"id": "47cf7e4e-ddbf-499f-8314-acaea75e7f6c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / (self.dim ** 2)  # Changed from 0.1 / np.sqrt(self.dim) to make beta inversely proportional to the square of the dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Adjust the quantum superposition parameter `beta` to be inversely proportional to the square of the dimensionality to improve convergence speed.", "configspace": "", "generation": 7, "fitness": 0.06068770498387669, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.057576352121783025, 0.06474972364962972, 0.05973703918021733]}, "mutation_prompt": null}
{"id": "c431f8b6-6b93-4b3c-92cd-5cfbe69b27b4", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity_measure = np.std(population, axis=0).mean()  \n            self.cross_prob = 0.7 + 0.3 * (1 - diversity_measure)  # Adaptive cross_prob\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce a diversity-based adaptive crossover probability to enhance exploration in QIDE.", "configspace": "", "generation": 8, "fitness": 0.05924762511894355, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.058904359947617224, 0.05786323208345967, 0.06097528332575375]}, "mutation_prompt": null}
{"id": "bb847f2d-8dc4-44ba-a589-4a25c58b8061", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight\n            self.diff_weight = 0.6 + 0.3 * np.random.rand()  # Changed from 0.5 to 0.6\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Tweaked the adaptation formula for diff_weight to potentially enhance exploration and exploitation balance further.", "configspace": "", "generation": 9, "fitness": 0.058954056060666095, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.05535409490347276, 0.05954621722749909, 0.06196185605102644]}, "mutation_prompt": null}
{"id": "ca0878a9-fd04-4dd2-92fb-8ec152184f30", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def local_search(self, individual, lb, ub, func):\n        step_size = 0.05 * (ub - lb)\n        candidate = np.clip(individual + step_size * np.random.uniform(-1, 1, self.dim), lb, ub)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            population = np.array([self.local_search(ind, lb, ub, func) for ind in population])\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Added a local search refinement strategy after the differential evolution step to improve convergence speed.", "configspace": "", "generation": 10, "fitness": 0.06058740682805178, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.05832037793382794, 0.06380042138341635, 0.05964142116691107]}, "mutation_prompt": null}
{"id": "401ff446-5002-485d-8747-426448507d4f", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()\n            mutant = a + self.diff_weight * (b - c)\n            np.clip(mutant, lb, ub, out=mutant)  # Enhanced boundary handling\n            cross_prob_adaptive = np.clip(self.cross_prob + 0.1 * np.random.randn(), 0, 1)  # Adaptive crossover probability\n            cross_points = np.random.rand(self.dim) < cross_prob_adaptive\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduced an adaptive crossover probability and enhanced boundary handling to improve diversity and solution robustness.", "configspace": "", "generation": 11, "fitness": 0.05894366986731122, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.05616106418319067, 0.058720059220145115, 0.06194988619859787]}, "mutation_prompt": null}
{"id": "0451683f-2a17-4889-b2ee-377434a8c46d", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.95  # Changed from 0.9 for higher crossover rate\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()  \n            mutant = np.clip(a + self.diff_weight * (b - c + a - b), lb, ub)  # Modified mutation strategy\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhanced exploration by modifying the mutation strategy and crossover probability for better diversity and convergence.", "configspace": "", "generation": 12, "fitness": 0.05667517549778297, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.05830969472661718, 0.05714979787657193, 0.05456603389015979]}, "mutation_prompt": null}
{"id": "cf583111-2b49-430e-8df9-77a534dd2a82", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight with distance-based scaling\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.5 + 0.3 * np.random.rand() * d  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Enhanced exploration by incorporating a distance-based scaling factor in the differential mutation process.", "configspace": "", "generation": 13, "fitness": 0.06187217674165021, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41b96e1b-929c-498e-b121-6aa36b78e31c", "metadata": {"aucs": [0.06231376258363097, 0.06218284781996086, 0.06111991982135878]}, "mutation_prompt": null}
{"id": "ae8d264f-73c1-4fa0-bfa3-611d190ccf8c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            # Tournament selection for increased diversity\n            tournament = np.random.choice(idxs, 5, replace=False)\n            a, b, c = population[np.argsort([func(population[j]) for j in tournament])[:3]]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.5 + 0.3 * np.random.rand() * d  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Enhanced population diversity by introducing a tournament selection mechanism in the differential evolution process.", "configspace": "", "generation": 14, "fitness": 0.056401036723782015, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "cf583111-2b49-430e-8df9-77a534dd2a82", "metadata": {"aucs": [0.05071961912696721, 0.05905920242444118, 0.05942428861993765]}, "mutation_prompt": null}
{"id": "20ca3d49-861e-4fa1-b155-44254ce3cdec", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Changed from 10 to 15 to improve exploration\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight with distance-based scaling\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.5 + 0.3 * np.random.rand() * d  \n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]\n\n# Example of use:\n# optimizer = QIDE(budget=1000, dim=10)\n# best_solution = optimizer(func)", "name": "QIDE", "description": "Enhanced exploration by increasing population size based on dimensionality to improve diversity and solution quality.", "configspace": "", "generation": 15, "fitness": 0.06013426086060444, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "cf583111-2b49-430e-8df9-77a534dd2a82", "metadata": {"aucs": [0.05724085769756626, 0.06047391540949876, 0.06268800947474829]}, "mutation_prompt": null}
{"id": "a2bd325d-b324-4da5-9114-731997066571", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight with distance-based scaling\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.5 + 0.3 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))  # Adaptive crossover\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduced elite replacement and adaptive crossover for improved convergence in diverse scenarios.", "configspace": "", "generation": 16, "fitness": 0.062575402029115, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "cf583111-2b49-430e-8df9-77a534dd2a82", "metadata": {"aucs": [0.06214138697433724, 0.060766776186760296, 0.06481804292624749]}, "mutation_prompt": null}
{"id": "21b2c4cf-3f9f-4d60-8199-996665a77ae3", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased from 10*dim to 12*dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Changed from 0.05 to make beta adaptive to dimensionality\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            # Dynamic adjustment of diff_weight with distance-based scaling\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.5 + 0.3 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))  # Adaptive crossover\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Slightly increased the population size to enhance exploration capabilities.", "configspace": "", "generation": 17, "fitness": 0.061613905094386356, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a2bd325d-b324-4da5-9114-731997066571", "metadata": {"aucs": [0.061507832306616494, 0.06325474278924181, 0.06007914018730076]}, "mutation_prompt": null}
{"id": "2734b3c3-9728-4f6a-824a-508641fb80dc", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.5 + 0.5 * np.random.rand() * d  # Changed scaling factor\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n            # Added a simple local search exploration step\n            for j in range(self.dim):\n                candidate = np.copy(trial)\n                candidate[j] += np.random.uniform(-0.1, 0.1) * (ub[j] - lb[j])\n                candidate = np.clip(candidate, lb, ub)\n                if func(candidate) < func(new_population[i]):\n                    new_population[i] = candidate\n\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhanced dynamic parameter adaptation and introduced local search to improve exploitation and exploration balance.", "configspace": "", "generation": 18, "fitness": 0.05865500738445084, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a2bd325d-b324-4da5-9114-731997066571", "metadata": {"aucs": [0.057378665412633034, 0.05717771592398735, 0.06140864081673214]}, "mutation_prompt": null}
{"id": "2ce1a1a5-e0ae-4817-9a85-d60cbd5119ad", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.15 / np.sqrt(self.dim)  # Increased beta for enhanced exploration\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhanced adaptive mutation strategy and refined quantum superposition to improve convergence and exploration.", "configspace": "", "generation": 19, "fitness": 0.06374557322865475, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a2bd325d-b324-4da5-9114-731997066571", "metadata": {"aucs": [0.06357889624781088, 0.06293011329162046, 0.06472771014653289]}, "mutation_prompt": null}
{"id": "0b0c6e96-3dda-4ace-bf50-5b44c0d85252", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.15 / np.sqrt(self.dim)  # Increased beta for enhanced exploration\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            self.cross_prob = 0.8 + 0.2 * np.random.rand()  # Dynamic adaptation of crossover probability\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Apply dynamic adaptation to the crossover probability in differential evolution for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 20, "fitness": 0.06348031946358897, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2ce1a1a5-e0ae-4817-9a85-d60cbd5119ad", "metadata": {"aucs": [0.06331136539827276, 0.06507809745800908, 0.06205149553448508]}, "mutation_prompt": null}
{"id": "72dc5a98-5482-4e65-a20c-ee95429ca97c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.15 / np.sqrt(self.dim)  # Increased beta for enhanced exploration\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.5 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "QIDE with enhanced dynamic scaling of differential weight for better adaptation to search space.", "configspace": "", "generation": 21, "fitness": 0.062270252122192137, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2ce1a1a5-e0ae-4817-9a85-d60cbd5119ad", "metadata": {"aucs": [0.060755098543500474, 0.06172087807379967, 0.06433477974927626]}, "mutation_prompt": null}
{"id": "3909534d-491a-48b2-a0e4-c8c801acad79", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.15 / np.sqrt(self.dim)  # Increased beta for enhanced exploration\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.5 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Minor adjustment to mutation strategy enhances convergence by fine-tuning differential weight dynamics.", "configspace": "", "generation": 22, "fitness": 0.062270252122192137, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2ce1a1a5-e0ae-4817-9a85-d60cbd5119ad", "metadata": {"aucs": [0.060755098543500474, 0.06172087807379967, 0.06433477974927626]}, "mutation_prompt": null}
{"id": "4c586277-2c95-4df5-888c-4866f652791c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        diversity = np.std(population, axis=0).mean()\n        beta = 0.15 / np.sqrt(self.dim) * (1 + diversity)  # Dynamically adjust beta based on diversity\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improve exploration by adapting quantum superposition's beta based on population diversity.", "configspace": "", "generation": 23, "fitness": 0.05356285192917017, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "2ce1a1a5-e0ae-4817-9a85-d60cbd5119ad", "metadata": {"aucs": [0.049147875288189535, 0.057742294080490364, 0.05379838641883061]}, "mutation_prompt": null}
{"id": "c2f10227-eede-4ff6-b848-740e9954e252", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhanced exploration by slightly modifying beta to balance exploration-exploitation.", "configspace": "", "generation": 24, "fitness": 0.0640407589300757, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2ce1a1a5-e0ae-4817-9a85-d60cbd5119ad", "metadata": {"aucs": [0.06499615198893693, 0.06360174239609961, 0.06352438240519054]}, "mutation_prompt": null}
{"id": "d8e7ba0d-218d-427b-88a3-38261e5b7c0f", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.22 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Fine-tuning beta to improve exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.06331836949345444, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06331013137175301, 0.06260945650755201, 0.06403552060105833]}, "mutation_prompt": null}
{"id": "d8bf0f35-f3e1-4161-9be6-a7a43bf599ca", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c) * np.random.randn(), lb, ub)  # Introduced stochastic variation\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce stochastic variation in the differential evolution to enhance robustness.", "configspace": "", "generation": 26, "fitness": 0.06268562013535058, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06182304454144949, 0.06282435335502123, 0.06340946250958102]}, "mutation_prompt": null}
{"id": "6762a496-2e46-4828-a8a2-e9cab9f2c671", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.1 / np.sqrt(self.dim)  # Adjusted beta for improved exploration\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            self.diff_weight = 0.5 + np.random.rand() * 0.3  # Adapted weight for dynamic balance\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_prob = self.cross_prob * (1 - i/self.population_size)  # Adaptive crossover probability\n            cross_points = np.random.rand(self.dim) < cross_prob\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introducing adaptive mutation and crossover strategies to enhance convergence and diversity balance in QIDE.", "configspace": "", "generation": 27, "fitness": 0.05988687939983942, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06040908325988492, 0.058639035901037584, 0.06061251903859577]}, "mutation_prompt": null}
{"id": "9ed4970b-4d51-4240-a2b6-7cd73a61e0ed", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        evaluations_ratio = evaluations / self.budget\n        beta = (0.18 / np.sqrt(self.dim)) * (1 - evaluations_ratio)  # Adjusted beta based on evaluations\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improved search by dynamically adjusting exploration parameter beta based on budget and evaluations.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {}, "mutation_prompt": null}
{"id": "138fbd17-d313-4830-b9ea-e559ee57f2f4", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhanced exploration by introducing a probabilistic mutation scaling factor for diversity.", "configspace": "", "generation": 29, "fitness": 0.0640407589300757, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06499615198893693, 0.06360174239609961, 0.06352438240519054]}, "mutation_prompt": null}
{"id": "8707180b-26e7-449e-8471-ec3969998a0c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c) + np.random.normal(0, 0.1, self.dim), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improved exploration by adjusting mutation strategy in differential evolution.", "configspace": "", "generation": 30, "fitness": 0.06216168448700273, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06080984634997111, 0.06282977227483433, 0.06284543483620275]}, "mutation_prompt": null}
{"id": "5943a167-a5f5-40d1-9d93-dd9dd61ba633", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.chaos_sequence = self.generate_chaos_sequence()\n\n    def generate_chaos_sequence(self):\n        x = 0.7  # Initial value for chaos sequence\n        sequence = []\n        for _ in range(self.initial_population_size):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        self.population_size = int(self.initial_population_size * self.chaos_sequence[int(self.budget / 100) % self.initial_population_size])\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Leveraging adaptive population size and chaotic sequence for diversity in exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (60,6) (11,6) ').", "error": "ValueError('operands could not be broadcast together with shapes (60,6) (11,6) ')", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {}, "mutation_prompt": null}
{"id": "68bc517a-a08f-4c65-8de3-4d26d9e4f0b9", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        diversity = np.mean(np.std(population, axis=0))\n        beta = 0.18 / np.sqrt(self.dim) * (1 + diversity)  # Adjusted beta for improved exploration\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improved exploration by dynamically adjusting beta based on population diversity.", "configspace": "", "generation": 32, "fitness": 0.053827795864623905, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.04950408790674099, 0.057984333852251546, 0.05399496583487917]}, "mutation_prompt": null}
{"id": "4d940637-bfa2-48a6-b627-01e7a0eba747", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c) + 0.1 * np.random.randn(self.dim), lb, ub)  # Add gaussian noise for mutation\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhanced exploration-exploitation balance by adjusting mutation strategy for varied search pressure.", "configspace": "", "generation": 33, "fitness": 0.06216168448700273, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06080984634997111, 0.06282977227483433, 0.06284543483620275]}, "mutation_prompt": null}
{"id": "433c8b82-ad01-4593-a603-bdb34b3851d2", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        best_solution = None\n        best_value = float('inf')\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            \n            current_best_idx = np.argmin([func(ind) for ind in population])\n            current_best_value = func(population[current_best_idx])\n            if current_best_value < best_value:\n                best_value = current_best_value\n                best_solution = population[current_best_idx]\n\n            evaluations += self.population_size\n\n        return best_solution", "name": "QIDE", "description": "Introduce adaptive quantum parameters and incorporate elitism to enhance convergence speed and solution quality.", "configspace": "", "generation": 34, "fitness": 0.06259387175782616, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06337115841539043, 0.06196548164821514, 0.06244497520987291]}, "mutation_prompt": null}
{"id": "670bad53-79a1-434a-af78-5508d4514b39", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            # Adaptively adjust cross_prob\n            current_eval_ratio = i / self.population_size\n            self.cross_prob = 0.9 - 0.4 * current_eval_ratio\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Refinement strategy focuses on adapting crossover probability dynamically based on iteration progress to enhance convergence speed.", "configspace": "", "generation": 35, "fitness": 0.061975670848566776, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.05889932662560826, 0.06284059527170782, 0.06418709064838424]}, "mutation_prompt": null}
{"id": "45effedc-8ece-46e2-84dd-6c7001aab228", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 0.5, (self.population_size, self.dim))  # Changed standard deviation from 1 to 0.5\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Refined the quantum superposition process by adjusting the normal distribution's standard deviation for enhanced diversity.", "configspace": "", "generation": 36, "fitness": 0.06290636195827726, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06052386715388747, 0.0632641369678687, 0.0649310817530756]}, "mutation_prompt": null}
{"id": "94cbdd7d-ceac-4c2f-8e34-acd2be0c926d", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Compute population diversity\n            self.cross_prob = 0.5 + 0.4 * (1 - diversity / (ub - lb).mean())  # Dynamically adjust cross_prob\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance adaptability by dynamically adjusting the crossover probability based on population diversity.", "configspace": "", "generation": 37, "fitness": 0.06325302220632205, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06455676026106083, 0.06291598247997354, 0.06228632387793176]}, "mutation_prompt": null}
{"id": "9cc11071-e949-4e15-baa7-dfe6ef98bf20", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / (np.sqrt(self.dim) + np.std(population, axis=0).mean())  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improved adaptive beta scaling in quantum superposition for enhanced convergence.", "configspace": "", "generation": 38, "fitness": 0.063725797247506, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06378020358070902, 0.060892981191534856, 0.06650420697027415]}, "mutation_prompt": null}
{"id": "5b73bce9-1e25-4f53-b9a6-0dc5a9c9e530", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        diversity = np.std(population, axis=0).mean()  # Calculate population diversity\n        beta = 0.18 / np.sqrt(self.dim) * (1 + diversity)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhanced quantum superposition by adjusting beta dynamically based on population diversity.", "configspace": "", "generation": 39, "fitness": 0.053827795864623905, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.04950408790674099, 0.057984333852251546, 0.05399496583487917]}, "mutation_prompt": null}
{"id": "f062bd68-a739-4ef6-96b5-a64a16b7c3eb", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improved adaptive differential weight scaling for better exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.061780506068747375, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.061694174246816114, 0.060579247325465935, 0.06306809663396007]}, "mutation_prompt": null}
{"id": "6aee0a57-e737-4a24-858e-20fc1023a50f", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c) * np.random.rand(), lb, ub)  # Added random factor\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introducing adaptive mutation scaling in the differential evolution phase for enhanced convergence.", "configspace": "", "generation": 41, "fitness": 0.06326687603730452, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.062227892328340806, 0.06438345803719736, 0.0631892777463754]}, "mutation_prompt": null}
{"id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Further enhance the exploration-exploitation balance by adjusting the cross probability dynamically based on diversity.", "configspace": "", "generation": 42, "fitness": 0.06597353639389299, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c2f10227-eede-4ff6-b848-740e9954e252", "metadata": {"aucs": [0.06494856596493082, 0.066796870734385, 0.06617517248236315]}, "mutation_prompt": null}
{"id": "d074dac5-f189-400d-8e71-f44857296c80", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            mean_fitness = np.mean([func(ind) for ind in population])  # Calculate mean fitness\n            self.cross_prob = (0.5 + 0.4 * diversity) * (1.0 + 0.1 * np.tanh(mean_fitness))  # Include scaling factor\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improve adaptive crossover strategy by introducing a scaling factor based on mean population fitness.", "configspace": "", "generation": 43, "fitness": 0.05631852840067945, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.04866607361331565, 0.05714979787657193, 0.06313971371215077]}, "mutation_prompt": null}
{"id": "e9c228af-8189-4d47-9713-8d107c7bdc2e", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            diversity = np.std(population, axis=0).mean()\n            self.diff_weight = 0.3 + 0.5 * np.random.rand() * d  # Adjusted weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            self.cross_prob = 0.5 + 0.4 * diversity / (1 + diversity)  # Enhanced diversity management\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive scaling factor and enhance dynamic diversity management in quantum-enhanced differential evolution.", "configspace": "", "generation": 44, "fitness": 0.062334006671683796, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.059873446190145674, 0.06278445756666118, 0.06434411625824454]}, "mutation_prompt": null}
{"id": "5f6a0fc6-fe28-457b-a251-2f18d557810d", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Reduced initial population size for more generations\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improved population diversity by reducing the initial population size, allowing more generations within the budget for better convergence.", "configspace": "", "generation": 45, "fitness": 0.0628980800697998, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.06188675645929753, 0.06365555025270564, 0.06315193349739623]}, "mutation_prompt": null}
{"id": "a951c9ca-35a2-4ad5-8231-8a4f41f621cb", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        avg_fitness = np.mean([func(ind) for ind in population])  # Line added: Calculate average fitness\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            self.diff_weight *= func(population[i]) / avg_fitness  # Line modified: Scale weight by relative fitness\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance diversity and convergence by introducing adaptive learning rate for differential mutation.", "configspace": "", "generation": 46, "fitness": 0.06380589057155284, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.06248352162571513, 0.06312804177505182, 0.06580610831389155]}, "mutation_prompt": null}
{"id": "ae55bd65-5153-4717-806f-6423a97b1e91", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        diversity = np.std(population, axis=0).mean()  # Calculate diversity\n        beta = (0.18 / np.sqrt(self.dim)) * (1 + diversity)  # Adjusted beta dynamically based on diversity\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Further enhance exploration-exploitation by adapting beta dynamically based on population diversity.", "configspace": "", "generation": 47, "fitness": 0.05530428921812425, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.05467229463183332, 0.05789717776720604, 0.05334339525533338]}, "mutation_prompt": null}
{"id": "cea75a17-137b-4da7-98bd-b36bb40bac32", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        fitness_values = np.array([func(ind) for ind in population])\n        fitness_variance = np.var(fitness_values)\n        beta = (0.18 / np.sqrt(self.dim)) * (1 + fitness_variance)  # Adjust beta dynamically based on fitness variance\n        best_solution = population[np.argmin(fitness_values)]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improve exploration by adjusting the beta parameter dynamically based on population fitness variance.", "configspace": "", "generation": 48, "fitness": 0.0659022597221881, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.06493382438875328, 0.0665444451631173, 0.06622850961469373]}, "mutation_prompt": null}
{"id": "ccd40b14-4f66-48d5-8d59-1ed28d523eda", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        diversity = np.std(population, axis=0).mean()  # Calculate diversity\n        beta = 0.18 / np.sqrt(self.dim) * (1 + diversity)  # Adjust beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Improve exploration by adjusting beta dynamically based on population diversity.", "configspace": "", "generation": 49, "fitness": 0.05530428921812425, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.05467229463183332, 0.05789717776720604, 0.05334339525533338]}, "mutation_prompt": null}
{"id": "75a4b5cd-a97f-4920-8088-b8db8a7cd644", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        # Changed line: Adjust beta dynamically based on diversity\n        beta = 0.18 / np.sqrt(self.dim) * (1 + np.std(population, axis=0).mean())  \n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Incorporate adaptive beta scaling in quantum superposition to enhance convergence speed.", "configspace": "", "generation": 50, "fitness": 0.05530428921812425, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.05467229463183332, 0.05789717776720604, 0.05334339525533338]}, "mutation_prompt": null}
{"id": "1ade2c0f-3271-4994-b3a0-105ee85263f9", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance convergence by refining the mutation strategy for better exploration and exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.06597353639389299, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.06494856596493082, 0.066796870734385, 0.06617517248236315]}, "mutation_prompt": null}
{"id": "66e0975e-c393-4b3c-8d28-02409e315f2c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim) * np.random.uniform(0.8, 1.2)  # Adjusted beta with slight random scaling for enhanced adaptability\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * np.random.rand() * d  # Adjusted weight range for more dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance exploration-exploitation balance by further refining quantum superposition with adaptive beta scaling.", "configspace": "", "generation": 52, "fitness": 0.06486570233433442, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.06580109371068887, 0.06683617491158844, 0.06195983838072594]}, "mutation_prompt": null}
{"id": "8239e29c-4ac0-4e95-8925-7f6fe52a1e4b", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.4 * d * diversity  # Use diversity in mutation scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive mutation scaling from population diversity for improved convergence in QIDE.", "configspace": "", "generation": 53, "fitness": 0.055491817939502454, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.0523922568426588, 0.05982290276535196, 0.05426029421049661]}, "mutation_prompt": null}
{"id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Refine the mutation strategy by introducing adaptive scaling to increase diversity in exploration.", "configspace": "", "generation": 54, "fitness": 0.0667401426294187, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "678a109b-d77a-4e22-a82f-2ac5d3a76973", "metadata": {"aucs": [0.06447409126666481, 0.0671251114972502, 0.0686212251243411]}, "mutation_prompt": null}
{"id": "d1c55322-bde1-4a64-b1b9-a0e600264bc4", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            improvement = (func(population[i]) - func(mutant)) / max(np.abs(func(population[i])), 1e-8)\n            self.cross_prob = 0.5 + 0.4 * improvement  # Adjust cross probability based on improvement\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce a dynamic crossover rate scaling based on function value improvements to enhance local exploitation. ", "configspace": "", "generation": 55, "fitness": 0.05965544558772636, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.05568348952116098, 0.05866576539579815, 0.06461708184621995]}, "mutation_prompt": null}
{"id": "17e549cc-56bc-47ac-a464-b943c2914e70", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.7 * np.random.rand() * d  # Adjust weight range for better dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance the balance between exploration and exploitation by refining the adaptive scaling of mutation and crossover probabilities.", "configspace": "", "generation": 56, "fitness": 0.0640305739570081, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06551222019611291, 0.062095835827654766, 0.06448366584725662]}, "mutation_prompt": null}
{"id": "96b94283-fad9-443e-a38f-8a401438f6b3", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim) * (0.8 + 0.4 * np.random.rand())  # Adjusted beta dynamically\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce dynamic adjustment of quantum superposition scaling factor to balance exploration and exploitation.", "configspace": "", "generation": 57, "fitness": 0.06500715247531608, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.0661986135921695, 0.06488837732934827, 0.06393446650443046]}, "mutation_prompt": null}
{"id": "b9ed2448-879f-4df2-8b6d-308affa2096e", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 10 * dim)  # Ensure minimum size for diversity\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            self.cross_prob = 0.5 + 0.4 * diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            if evaluations % (self.budget // 10) == 0:  # Adjust every 10% of budget\n                self.population_size = min(self.population_size, int(self.population_size * 1.05))\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce dynamic population size adjustment based on convergence to enhance exploration and exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.0667401426294187, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06447409126666481, 0.0671251114972502, 0.0686212251243411]}, "mutation_prompt": null}
{"id": "07b8848f-41bb-4613-a6b3-1a7524545b35", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim) * (1 + np.std(population))  # Adaptive beta scaling\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introducing \"adaptive beta scaling\" to balance exploration and exploitation dynamically in quantum superposition.", "configspace": "", "generation": 59, "fitness": 0.054352224685233375, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.04926135507671814, 0.05714979787657193, 0.05664552110241006]}, "mutation_prompt": null}
{"id": "0ca3ff90-ab8e-4998-b601-5584e05b30db", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.15 / np.sqrt(self.dim) + 0.05 * np.random.rand()  # Adjusted beta dynamically\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce a dynamic adjustment of the quantum superposition beta factor based on performance feedback to enhance exploration.", "configspace": "", "generation": 60, "fitness": 0.06438535945855128, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06587147488823641, 0.06351886435905352, 0.06376573912836392]}, "mutation_prompt": null}
{"id": "a884083b-4e1d-48f8-806e-2997dec1f7ef", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        prev_best = float('inf')\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            # Update: Adaptive mutation based on convergence speed\n            current_best = min([func(ind) for ind in population])\n            adaptation_factor = 1.0 if current_best >= prev_best else 0.5\n            self.diff_weight *= adaptation_factor\n            prev_best = current_best\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive mutation based on convergence speed to enhance dynamic exploration.", "configspace": "", "generation": 61, "fitness": 0.05631906673409778, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.04862568523717259, 0.05714979787657193, 0.0631817170885488]}, "mutation_prompt": null}
{"id": "bd59b5d2-8045-477c-bd21-1b775c27eab3", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            convergence = np.exp(-np.var([func(ind) for ind in population]))  # Calculate convergence\n            self.diff_weight = 0.3 + convergence * np.random.rand() * 0.6  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Incorporate adaptive mutation scaling based on population convergence to enhance exploration and exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.05534141323091827, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.048995450593439904, 0.05714979787657193, 0.05987899122274298]}, "mutation_prompt": null}
{"id": "4cc330e7-074e-423d-af79-d665df72b478", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            if evaluations < self.budget // 3:  # Early stage exploration\n                self.population_size = int(1.2 * 10 * self.dim)  # Adaptive population size\n            quantum_population = self.quantum_superposition(population, lb, ub, lambda x: func(x) + np.random.normal(0, 0.01))  # Stochastic evaluation\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce stochastic evaluation and adaptive population size to enhance exploration in early stages.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (60,6) (72,6) ').", "error": "ValueError('operands could not be broadcast together with shapes (60,6) (72,6) ')", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {}, "mutation_prompt": null}
{"id": "6dba67f0-c5db-4a22-89ee-5d26e2cb7aa8", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            self.cross_prob = 0.5 + 0.4 * diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.population_size = max(4, int(self.population_size * 0.5 if np.std(population, axis=0).mean() < 0.1 else self.population_size))  # Dynamic adjustment\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce a dynamic adjustment to the population size based on diversity to improve adaptability.", "configspace": "", "generation": 64, "fitness": 0.0667401426294187, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06447409126666481, 0.0671251114972502, 0.0686212251243411]}, "mutation_prompt": null}
{"id": "0d2f53a6-b473-4e09-a07e-34e7912da8c8", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.2 / np.sqrt(self.dim)  # Adjusted beta to further improve balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Fine-tune the quantum superposition step's beta parameter for better exploration-exploitation balance.", "configspace": "", "generation": 65, "fitness": 0.06608104726580395, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06415223769549716, 0.06520614437874295, 0.06888475972317176]}, "mutation_prompt": null}
{"id": "dec5d330-2309-482e-b5f4-994602d6f2e9", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.beta(2, 5) * d  # Use beta distribution for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance exploration by adjusting the mutation factor's distribution to more effectively balance exploration and exploitation.", "configspace": "", "generation": 66, "fitness": 0.06354765073387818, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06334536854718953, 0.0657929169749214, 0.06150466667952359]}, "mutation_prompt": null}
{"id": "20b23b92-eca2-4cc1-8cb2-073348f89f92", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.5 + 0.3 * np.random.rand() * d  # Slightly reduced random scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Fine-tune the mutation scaling factor to reduce randomness and increase convergence efficiency.", "configspace": "", "generation": 67, "fitness": 0.06300076880560279, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.061622783190810826, 0.06347844317707996, 0.06390108004891759]}, "mutation_prompt": null}
{"id": "4341d88a-f370-4e38-9437-e1301e5db429", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Adjust the scaling factor calculation in quantum superposition to improve convergence.", "configspace": "", "generation": 68, "fitness": 0.0667401426294187, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06447409126666481, 0.0671251114972502, 0.0686212251243411]}, "mutation_prompt": null}
{"id": "51ab4b66-4ac3-4b93-ae2f-82eed47860f9", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim) * (1 + np.std(population))  # Adjusted beta for improved balance and diversity\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance diversity by dynamically adapting the quantum superposition scaling factor.", "configspace": "", "generation": 69, "fitness": 0.054352224685233375, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.04926135507671814, 0.05714979787657193, 0.05664552110241006]}, "mutation_prompt": null}
{"id": "d98525cf-f3bc-4887-a999-0f804c98ffa3", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            fitness_variability = np.std([func(ind) for ind in population])  # Calculate fitness variability\n            self.cross_prob = 0.5 + 0.4 * diversity * (1 + fitness_variability)  # Adjust cross probability based on diversity and fitness\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance diversity management by introducing dynamic adjustment based on fitness variability.", "configspace": "", "generation": 70, "fitness": 0.05631906673409778, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.04862568523717259, 0.05714979787657193, 0.0631817170885488]}, "mutation_prompt": null}
{"id": "05722f56-e97c-44c8-8689-d5f373787536", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.85  # Reduced for better exploitation\n        self.diff_weight = 0.7  # Reduced for balanced mutation\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.5 * np.random.rand() * d  # Adjusted weight range\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            self.cross_prob = 0.55 + 0.3 * diversity  # Adjusted cross probability\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n            # Local search around the best solution\n            if np.random.rand() < 0.1:\n                local_solution = best_solution + 0.05 * np.random.normal(0, 1, self.dim)\n                np.clip(local_solution, lb, ub, out=local_solution)\n                if func(local_solution) < func(best_solution):\n                    new_population[i] = local_solution\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce local search around the best solution and fine-tune scaling factors for enhanced exploration-exploitation balance.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'best_solution' is not defined\").", "error": "NameError(\"name 'best_solution' is not defined\")", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {}, "mutation_prompt": null}
{"id": "14821fba-f1a8-4a32-ae71-37b19078b201", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            self.cross_prob = 0.5 + 0.4 * diversity\n            \n            # Change: Introduce adaptive randomization for trial solution creation\n            rand_factor = np.random.rand() * (1.0 - (func(population[i]) / np.max([func(ind) for ind in population])))\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * rand_factor)\n            \n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive randomization based on search progress to enhance exploration and balance exploitation.", "configspace": "", "generation": 72, "fitness": 0.05763744335987949, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.052605850546337485, 0.05714979787657193, 0.06315668165672905]}, "mutation_prompt": null}
{"id": "335f75dd-e1a5-4076-b2c5-ae47f2be2c67", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        scaling_factor = np.random.uniform(0.8, 1.2, (self.population_size, 1))  # Stochastic scaling\n        quantum_population *= scaling_factor\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce stochastic scaling in the quantum superposition step for enhanced exploration.", "configspace": "", "generation": 73, "fitness": 0.06343330989899809, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06196263697769733, 0.06562880822206674, 0.06270848449723021]}, "mutation_prompt": null}
{"id": "632f1267-1fa3-4492-b025-2804d88a8488", "solution": "import numpy as np\n\nclass QIDE_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.local_weight = 0.5  # New parameter for local search\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.15 / np.sqrt(self.dim)  # Adjusted beta\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def adaptive_search(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            local_indices = np.random.choice(range(self.population_size), 2, replace=False)\n            local_search = population[local_indices[0]] + self.local_weight * (population[local_indices[1]] - population[local_indices[0]])\n            global_indices = [idx for idx in range(self.population_size) if idx not in local_indices]\n            global_search = population[global_indices[np.argmin([func(population[idx]) for idx in global_indices])]]\n            combined_search = (local_search + global_search) / 2  # Combine local and global\n            trial = np.clip(combined_search, lb, ub)\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.adaptive_search(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE_Refined", "description": "Introduce multi-strategy adaptation using both local and global search components for enhanced convergence and diversity.", "configspace": "", "generation": 74, "fitness": 0.058504753917256624, "feedback": "The algorithm QIDE_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.05589303923426847, 0.05742811781682844, 0.06219310470067296]}, "mutation_prompt": null}
{"id": "0a0f459f-5b14-4e34-b1a6-2f77aff8214c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim) * (1 - 0.5 * np.random.rand())  # Progressive beta adjustment\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce a progressive adjustment of beta in quantum superposition to enhance exploration adaptively.", "configspace": "", "generation": 75, "fitness": 0.06496767378410007, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06570238055333322, 0.06575392710781214, 0.06344671369115484]}, "mutation_prompt": null}
{"id": "6b0360bf-e3a3-4cd5-aa44-2bddc325ec0c", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        quantum_population += np.random.normal(0, 0.05, quantum_population.shape)  # Add noise for exploration\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            self.cross_prob = 0.5 + 0.4 * diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive quantum superposition and exploration balance to enhance convergence efficiency.", "configspace": "", "generation": 76, "fitness": 0.06241075140215394, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.062074555397611086, 0.06326194069757274, 0.06189575811127801]}, "mutation_prompt": null}
{"id": "f2f1ab3c-dca0-4378-b151-76bacc776d8e", "solution": "import numpy as np\n\nclass RefinedQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.sub_population_count = 3  # Introduce multiple sub-populations\n        self.adaptive_beta = True  # Flag for adaptive beta\n\n    def initialize_population(self, lb, ub):\n        return [np.random.uniform(lb, ub, (self.population_size, self.dim)) for _ in range(self.sub_population_count)]\n\n    def quantum_superposition(self, populations, lb, ub, func):\n        quantum_populations = []\n        for population in populations:\n            if self.adaptive_beta:\n                beta = 0.1 / np.sqrt(self.dim) * np.random.rand()  # Adaptive beta\n            else:\n                beta = 0.18 / np.sqrt(self.dim)\n            best_solution = population[np.argmin([func(ind) for ind in population])]\n            quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n            np.clip(quantum_population, lb, ub, out=quantum_population)\n            quantum_populations.append(quantum_population)\n        return quantum_populations\n\n    def differential_evolution(self, populations, lb, ub, func):\n        new_populations = []\n        for population in populations:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n                self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n                diversity = np.std(population, axis=0).mean()\n                self.cross_prob = 0.5 + 0.4 * diversity\n                cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                if func(trial) < func(population[i]):\n                    new_population[i] = trial\n            new_populations.append(new_population)\n        return new_populations\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        populations = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_populations = self.quantum_superposition(populations, lb, ub, func)\n            populations = self.differential_evolution(quantum_populations, lb, ub, func)\n            evaluations += self.population_size * self.sub_population_count\n\n        best_individuals = [pop[np.argmin([func(ind) for ind in pop])] for pop in populations]\n        best_idx = np.argmin([func(ind) for ind in best_individuals])\n        return best_individuals[best_idx]", "name": "RefinedQIDE", "description": "Introduce multi-population cooperative strategies and adaptive parameter tuning for enhanced exploration and convergence.", "configspace": "", "generation": 77, "fitness": 0.06299337798658895, "feedback": "The algorithm RefinedQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06460114561082775, 0.061307123921618634, 0.06307186442732049]}, "mutation_prompt": null}
{"id": "fee45260-c48b-453e-a9ec-ce5ed2cfa2d2", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean() + 0.01  # Slightly adjust diversity calculation for balance\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce a dynamic adjustment to the diversity calculation method to refine exploration balance.", "configspace": "", "generation": 78, "fitness": 0.0667401426294187, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06447409126666481, 0.0671251114972502, 0.0686212251243411]}, "mutation_prompt": null}
{"id": "b279bc73-6e8c-4324-bce9-dc40e642d1aa", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.22 / np.sqrt(self.dim)  # Adjusted beta for enhanced initial exploration\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance exploration by adjusting the initial quantum superposition factor.", "configspace": "", "generation": 79, "fitness": 0.0665938074521597, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06486724679685985, 0.06582601203767657, 0.06908816352194269]}, "mutation_prompt": null}
{"id": "b06d1bc0-cf80-4473-906d-49de3909f2f9", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim) * (0.5 + np.std(population))  # Adaptive beta scaling\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive beta scaling in quantum superposition for enhanced exploration-exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.05731736103352344, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.05730724988910474, 0.05714979787657193, 0.05749503533489364]}, "mutation_prompt": null}
{"id": "8a278107-a5b4-49bf-98fe-5df0200dc4d5", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant + 0.1 * np.random.normal(0, 1, self.dim), population[i])  # Added Gaussian mutation\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce Gaussian mutation to enhance local search capabilities.", "configspace": "", "generation": 81, "fitness": 0.06346076190309517, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06474216137117261, 0.062164132981509024, 0.06347599135660387]}, "mutation_prompt": null}
{"id": "88618583-703e-4cb6-88f7-3b3b69b1dbe3", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        fitness_values = np.array([func(ind) for ind in population])  # Calculate fitness once\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(fitness_values)  # Use fitness variance for crossover probability\n            self.cross_prob = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover based on fitness variance\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < fitness_values[i]:\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive crossover probability using population fitness variance to improve exploitation-exploration balance.", "configspace": "", "generation": 82, "fitness": 0.06213052889200399, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06163169794668355, 0.06175719026642701, 0.06300269846290141]}, "mutation_prompt": null}
{"id": "95820e26-799d-402d-b554-8bceced3ead5", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.20 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Slightly increase the influence of the best solution in the quantum superposition step for enhanced convergence.", "configspace": "", "generation": 83, "fitness": 0.06608104726580395, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06415223769549716, 0.06520614437874295, 0.06888475972317176]}, "mutation_prompt": null}
{"id": "c3ad462c-988c-4609-bb54-954f91b1c95d", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)  # Adjusted beta for improved balance\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d  # Adjust weight range for dynamic scaling\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            self.cross_prob = 0.5 + 0.4 * diversity  # Adjust cross probability based on diversity\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n            self.population_size = max(4 * self.dim, self.population_size // 2)  # Adjust population size dynamically\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Incorporate dynamic adjustment of population size based on convergence trend to enhance exploration and exploitation balance.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (60,6) (30,6) ').", "error": "ValueError('operands could not be broadcast together with shapes (60,6) (30,6) ')", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {}, "mutation_prompt": null}
{"id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate  # Adaptive crossover\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive crossover rate based on historical success to enhance exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.0667685327211656, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "45bd852f-9ee7-4936-b2f4-4ab8d4133692", "metadata": {"aucs": [0.06472125484041136, 0.06697202662282753, 0.06861231670025791]}, "mutation_prompt": null}
{"id": "f5606dea-4292-4829-b72e-6cf145f9cde1", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate  # Adaptive crossover\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        dynamic_population_size = int(self.population_size * (0.5 + 0.5 * (self.budget / 10000)))  # Dynamic resizing\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce dynamic population resizing to enhance convergence efficiency.", "configspace": "", "generation": 86, "fitness": 0.0667685327211656, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "metadata": {"aucs": [0.06472125484041136, 0.06697202662282753, 0.06861231670025791]}, "mutation_prompt": null}
{"id": "b777348b-2203-4269-9e3e-d769779930aa", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate  # Adaptive crossover\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce a dynamic scaling factor for mutation to better adapt exploration with respect to population diversity.", "configspace": "", "generation": 87, "fitness": 0.0667685327211656, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "metadata": {"aucs": [0.06472125484041136, 0.06697202662282753, 0.06861231670025791]}, "mutation_prompt": null}
{"id": "cd015246-e136-4d81-a436-204386195cc7", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate  # Adaptive crossover\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i]) + np.random.normal(0, 0.01, self.dim)  # Added Gaussian noise\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce Gaussian noise to the trial vector to enhance diversity in exploration.", "configspace": "", "generation": 88, "fitness": 0.06260529023516152, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "metadata": {"aucs": [0.06351836342491457, 0.061770318976965166, 0.06252718830360482]}, "mutation_prompt": null}
{"id": "d6220567-68bc-4527-99b2-08444b4596c0", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate  # Adaptive crossover\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance adaptive mutation scaling based on population diversity to improve exploration.", "configspace": "", "generation": 89, "fitness": 0.0667685327211656, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "metadata": {"aucs": [0.06472125484041136, 0.06697202662282753, 0.06861231670025791]}, "mutation_prompt": null}
{"id": "291a7888-7599-4c90-9156-03f5106aa1b7", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate  # Adaptive crossover\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce an iteration-dependent scaling factor to improve the convergence dynamics.", "configspace": "", "generation": 90, "fitness": 0.0667685327211656, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "metadata": {"aucs": [0.06472125484041136, 0.06697202662282753, 0.06861231670025791]}, "mutation_prompt": null}
{"id": "53e228ba-2124-4d2d-b32e-a10c0a87414a", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            d = np.linalg.norm(b - c) / np.linalg.norm(lb - ub)\n            self.diff_weight = 0.3 + 0.6 * np.random.rand() * d\n            mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate  # Adaptive crossover\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive crossover rate based on historical success to enhance exploration-exploitation balance.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "metadata": {"aucs": [0.06472125484041136, 0.06697202662282753, 0.06861231670025791]}, "mutation_prompt": null}
{"id": "c215f3c3-9e78-4b91-b943-295dd4beaee9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant_strategy = np.random.choice(['normal', 'best'])  # Randomly select mutation strategy\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)  # Apply local search\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance convergence by dynamically adjusting mutation strategy and incorporating local search for refined exploitation.", "configspace": "", "generation": 92, "fitness": 0.06961820986370541, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "24ebc632-612f-4d1f-9c93-ed4e9458232d", "metadata": {"aucs": [0.07015575715356048, 0.06823592283055313, 0.07046294960700261]}, "mutation_prompt": null}
{"id": "a2ca3bea-d1ff-4af4-b3b9-5be4b5d94842", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant_strategy = np.random.choice(['normal', 'best'])  # Randomly select mutation strategy\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            if diversity < 0.1:  # Adjust population size based on diversity\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)  # Apply local search\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Enhance convergence by introducing dynamic population size adjustment based on diversity metrics.", "configspace": "", "generation": 93, "fitness": 0.06961820986370541, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c215f3c3-9e78-4b91-b943-295dd4beaee9", "metadata": {"aucs": [0.07015575715356048, 0.06823592283055313, 0.07046294960700261]}, "mutation_prompt": null}
{"id": "765924af-3aa8-4182-8059-85dbdabcc367", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        # Adaptive beta based on success history\n        beta = (0.18 / np.sqrt(self.dim)) * (1 + np.mean(self.success_history[-10:]))\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant_strategy = np.random.choice(['normal', 'best'])\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        # Dynamic adjustment of population size\n        self.population_size = min(self.initial_population_size, self.population_size + int(np.sum(self.success_history[-self.population_size:]) / self.population_size * self.dim))\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive beta for quantum superposition and dynamic adjustment of population size for improved exploration and exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.05174730167487329, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "c215f3c3-9e78-4b91-b943-295dd4beaee9", "metadata": {"aucs": [0.0462600105020492, 0.05683546251374505, 0.05214643200882563]}, "mutation_prompt": null}
{"id": "c1344a47-32a8-43db-8d77-1810dcc4ff1b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.success_history = []\n        self.elite_fraction = 0.1\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        num_elites = int(self.elite_fraction * self.population_size)\n        elite_indices = np.argsort([func(ind) for ind in population])[:num_elites]\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            self.diff_weight = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n            mutant_strategy = np.random.choice(['normal', 'best'])  # Randomly select mutation strategy\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)  # Apply local search\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        new_population[elite_indices] = population[elite_indices]  # Preserve elites\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive differential weight and use an elite preservation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 95, "fitness": 0.06865920543804027, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c215f3c3-9e78-4b91-b943-295dd4beaee9", "metadata": {"aucs": [0.06662459711879909, 0.0692743570883878, 0.07007866210693392]}, "mutation_prompt": null}
{"id": "d8d53cfd-9f2f-462e-bdb7-4b23a9661199", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant_strategy = np.random.choice(['normal', 'best'])\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        self.diff_weight = 0.5 + 0.4 * np.mean(self.success_history[-10:])  # Update differential weight\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive control over differential weight and introduce a dynamic learning mechanism to balance exploration and exploitation.", "configspace": "", "generation": 96, "fitness": 0.07074006977350016, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c215f3c3-9e78-4b91-b943-295dd4beaee9", "metadata": {"aucs": [0.07123343947345273, 0.0699736031706586, 0.07101316667638913]}, "mutation_prompt": null}
{"id": "61e9a1e6-10a9-48e7-a9d3-54108e60a503", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim) * (0.5 + 0.5 * np.mean(self.success_history[-10:]))  # Adaptive quantum factor\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant_strategy = np.random.choice(['normal', 'best'])\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        self.diff_weight = 0.5 + 0.4 * np.mean(self.success_history[-10:])  # Update differential weight\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introducing adaptive adjustment to the quantum superposition factor based on success rate to enhance convergence.", "configspace": "", "generation": 97, "fitness": 0.05592504776339583, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_id": "d8d53cfd-9f2f-462e-bdb7-4b23a9661199", "metadata": {"aucs": [0.0552656065858359, 0.06376138169545043, 0.04874815500890117]}, "mutation_prompt": null}
{"id": "eef0fd8f-d455-4235-ab44-5fdae0d72aef", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.18 / np.sqrt(self.dim)\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        adaptive_step_size = 0.1 + 0.4 * np.std(individual)  # Adaptive step size\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B', options={'eps': adaptive_step_size})\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant_strategy = np.random.choice(['normal', 'best'])\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        self.diff_weight = 0.5 + 0.4 * np.mean(self.success_history[-10:])  # Update differential weight\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Introduce adaptive step size in local search and refine mutation selection to enhance convergence speed and solution robustness.", "configspace": "", "generation": 98, "fitness": 0.06976327770082447, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "d8d53cfd-9f2f-462e-bdb7-4b23a9661199", "metadata": {"aucs": [0.0704681883489684, 0.06891713245502984, 0.06990451229847516]}, "mutation_prompt": null}
{"id": "646ff407-8b70-4254-a7b2-56c0a751e628", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n        self.success_history = []\n\n    def initialize_population(self, lb, ub):\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population, lb, ub, func):\n        beta = 0.20 / np.sqrt(self.dim)  # Slightly increased beta\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        quantum_population = population + beta * (best_solution - population) * np.random.normal(0, 1, (self.population_size, self.dim))\n        np.clip(quantum_population, lb, ub, out=quantum_population)\n        return quantum_population\n\n    def local_search(self, individual, lb, ub, func):\n        result = minimize(func, individual, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')\n        return result.x\n\n    def differential_evolution(self, population, lb, ub, func):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant_strategy = np.random.choice(['normal', 'best'])\n            if mutant_strategy == 'best':\n                best = population[np.argmin([func(ind) for ind in population])]\n                mutant = np.clip(best + self.diff_weight * (b - c), lb, ub)\n            else:\n                mutant = np.clip(a + self.diff_weight * (b - c), lb, ub)\n            diversity = np.std(population, axis=0).mean()\n            recent_success_rate = np.mean(self.success_history[-10:]) if self.success_history else 0.5\n            self.cross_prob = 0.5 + 0.4 * diversity * recent_success_rate\n            cross_points = np.random.rand(self.dim) < (self.cross_prob * (0.5 + 0.5 * np.random.rand()))\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, population[i])\n            trial = self.local_search(trial, lb, ub, func)\n            if func(trial) < func(population[i]):\n                new_population[i] = trial\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n        self.diff_weight = 0.5 + 0.4 * np.mean(self.success_history[-10:])  # Update differential weight\n        return new_population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            quantum_population = self.quantum_superposition(population, lb, ub, func)\n            population = self.differential_evolution(quantum_population, lb, ub, func)\n            evaluations += self.population_size\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        return population[best_idx]", "name": "QIDE", "description": "Slightly increase the quantum superposition beta to enhance exploration capability.", "configspace": "", "generation": 99, "fitness": 0.07077556853503364, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "d8d53cfd-9f2f-462e-bdb7-4b23a9661199", "metadata": {"aucs": [0.07126053068699234, 0.06994294912812549, 0.07112322578998309]}, "mutation_prompt": null}
