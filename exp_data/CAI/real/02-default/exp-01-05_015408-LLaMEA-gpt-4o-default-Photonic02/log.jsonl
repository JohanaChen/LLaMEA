{"id": "64548eae-f532-4f28-ab46-a6c8bc80a165", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.7\n        self.local_search_probability = 0.3\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.mutation_factor * (x1 - x2), lb, ub)\n                \n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(self.dim)] = True\n                \n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations < self.budget and np.random.rand() < self.local_search_probability:\n                    local_trial = trial + np.random.normal(0, 0.1, self.dim)\n                    local_trial = np.clip(local_trial, lb, ub)\n                    local_fitness = func(local_trial)\n                    evaluations += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_trial\n                        fitness[i] = local_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Local Search that balances exploration and exploitation for efficient convergence.", "configspace": "", "generation": 0, "fitness": 0.8729637491964659, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.87 with standard deviation 0.05.", "error": "", "parent_id": null, "metadata": {"aucs": [0.9207382974886135, 0.8251892009043185]}, "mutation_prompt": null}
{"id": "0de785c2-1f8f-4794-af12-5cdb8b3cf86b", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.quantum_amplitude = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coeff * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Quantum-inspired update using quantum superposition\n                quantum_position = population[i] + self.quantum_amplitude * np.random.normal(0, 1, self.dim)\n                quantum_position = np.clip(quantum_position, lb, ub)\n                quantum_fitness = func(quantum_position)\n                evaluations += 1\n\n                if quantum_fitness < personal_best_scores[i]:\n                    personal_best_positions[i] = quantum_position\n                    personal_best_scores[i] = quantum_fitness\n\n                # Update personal and global bests\n                if personal_best_scores[i] < personal_best_scores[global_best_index]:\n                    global_best_index = i\n                    global_best_position = personal_best_positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "QuantumInspiredPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) with Adaptive Quantum Superposition for enhanced exploration and convergence in high-dimensional spaces.", "configspace": "", "generation": 1, "fitness": 0.8834418280351954, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.02.", "error": "", "parent_id": "64548eae-f532-4f28-ab46-a6c8bc80a165", "metadata": {"aucs": [0.9055920711983093, 0.8612915848720817]}, "mutation_prompt": null}
{"id": "fc3fb61e-7261-406b-b2c6-02381df15b36", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.quantum_amplitude = 0.1\n        self.alpha = 0.9\n        self.beta = 0.4\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic neighborhood-based social learning\n                neighbors = np.random.choice(self.population_size, size=5, replace=False)\n                local_best_index = neighbors[np.argmin(personal_best_scores[neighbors])]\n                local_best_position = personal_best_positions[local_best_index]\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = self.alpha * self.cognitive_coeff + self.beta * (1 - evaluations / self.budget)\n                self.social_coeff = self.alpha * self.social_coeff + self.beta * (1 - evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coeff * r2 * (local_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Adaptive quantum-inspired update\n                quantum_position = population[i] + self.quantum_amplitude * np.random.normal(0, 1, self.dim)\n                quantum_position = np.clip(quantum_position, lb, ub)\n                quantum_fitness = func(quantum_position)\n                evaluations += 1\n\n                if quantum_fitness < personal_best_scores[i]:\n                    personal_best_positions[i] = quantum_position\n                    personal_best_scores[i] = quantum_fitness\n\n                # Update personal and global bests\n                if personal_best_scores[i] < personal_best_scores[global_best_index]:\n                    global_best_index = i\n                    global_best_position = personal_best_positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "AdaptiveQuantumInspiredPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization (AQIPSO) with Dynamic Neighborhoods and Adaptive Learning Rates for enhanced exploration and convergence precision.", "configspace": "", "generation": 2, "fitness": 0.7772762705131345, "feedback": "The algorithm AdaptiveQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.02.", "error": "", "parent_id": "0de785c2-1f8f-4794-af12-5cdb8b3cf86b", "metadata": {"aucs": [0.7980815339449384, 0.7564710070813306]}, "mutation_prompt": null}
{"id": "2c90c687-af6a-4c37-a103-016effc4a1c0", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.9\n        self.inertia_min = 0.4\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.quantum_amplitude = 0.1\n        self.quantum_amplitude_min = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = self.inertia_min + (0.5 * (1 - evaluations / self.budget))\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coeff * r2 * (global_best_position - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Adaptive Quantum-inspired update\n                adaptive_amplitude = self.quantum_amplitude_min + (self.quantum_amplitude - self.quantum_amplitude_min) * (1 - evaluations / self.budget)\n                quantum_position = population[i] + adaptive_amplitude * np.random.normal(0, 1, self.dim)\n                quantum_position = np.clip(quantum_position, lb, ub)\n                quantum_fitness = func(quantum_position)\n                evaluations += 1\n\n                if quantum_fitness < personal_best_scores[i]:\n                    personal_best_positions[i] = quantum_position\n                    personal_best_scores[i] = quantum_fitness\n\n                # Update global best position\n                if personal_best_scores[i] < personal_best_scores[global_best_index]:\n                    global_best_index = i\n                    global_best_position = personal_best_positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "EnhancedQuantumInspiredPSO", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization (EQIPSO) with Dynamic Inertia and Adaptive Quantum Amplitude for improved balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.8874290579557689, "feedback": "The algorithm EnhancedQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.03.", "error": "", "parent_id": "0de785c2-1f8f-4794-af12-5cdb8b3cf86b", "metadata": {"aucs": [0.916601501021169, 0.8582566148903688]}, "mutation_prompt": null}
{"id": "d5d55df4-cf7e-4ecb-9fb7-2c38826e0865", "solution": "import numpy as np\n\nclass AdaptiveHybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_rate_initial = 0.1\n        self.mutation_rate_final = 0.02\n        self.crossover_rate_initial = 0.9\n        self.crossover_rate_final = 0.6\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness_scores = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        best_index = np.argmin(fitness_scores)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            # Adaptively change mutation and crossover rates\n            progress_ratio = evaluations / self.budget\n            mutation_rate = self.mutation_rate_initial * (1 - progress_ratio) + self.mutation_rate_final * progress_ratio\n            crossover_rate = self.crossover_rate_initial * (1 - progress_ratio) + self.crossover_rate_final * progress_ratio\n\n            new_population = []\n\n            for _ in range(self.population_size // 2):\n                # Select two parents\n                parents_indices = np.random.choice(self.population_size, 2, replace=False)\n                parent1, parent2 = population[parents_indices]\n\n                # Crossover\n                if np.random.rand() < crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    offspring1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    offspring2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    offspring1, offspring2 = parent1.copy(), parent2.copy()\n\n                # Mutation\n                for offspring in [offspring1, offspring2]:\n                    if np.random.rand() < mutation_rate:\n                        mutation_vector = np.random.normal(0, 0.1, self.dim)\n                        offspring += mutation_vector\n                        offspring = np.clip(offspring, lb, ub)\n\n                new_population.extend([offspring1, offspring2])\n\n            # Evaluate new population\n            new_fitness_scores = np.array([func(ind) for ind in new_population])\n            evaluations += self.population_size\n\n            # Combine and select best individuals\n            combined_population = np.vstack((population, new_population))\n            combined_fitness_scores = np.concatenate((fitness_scores, new_fitness_scores))\n            best_indices = combined_fitness_scores.argsort()[:self.population_size]\n            population = combined_population[best_indices]\n            fitness_scores = combined_fitness_scores[best_indices]\n\n            # Update best position found\n            best_index = np.argmin(fitness_scores)\n            best_position = population[best_index]\n\n        return best_position, fitness_scores[best_index]", "name": "AdaptiveHybridGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with Hybrid Mutation and Dynamic Crossover for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.46782864866423246, "feedback": "The algorithm AdaptiveHybridGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.02.", "error": "", "parent_id": "2c90c687-af6a-4c37-a103-016effc4a1c0", "metadata": {"aucs": [0.4448124626440202, 0.49084483468444473]}, "mutation_prompt": null}
{"id": "cc582fcc-02ca-4200-b567-e7970a684e6b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.mutation_factor_min = 0.3\n        self.crossover_rate_min = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three random distinct indices from the population\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                x_a, x_b, x_c = population[a], population[b], population[c]\n\n                # Perform mutation\n                self.mutation_factor = self.mutation_factor_min + (0.5 * (1 - evaluations / self.budget))\n                mutant_vector = x_a + self.mutation_factor * (x_b - x_c)\n                mutant_vector = np.clip(mutant_vector, lb, ub)\n\n                # Perform crossover\n                self.crossover_rate = self.crossover_rate_min + (0.5 * (1 - evaluations / self.budget))\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                # Update best position\n                if trial_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = trial_vector\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution with Self-Adaptive Mutation and Crossover Strategies to maintain a balance between exploration and exploitation dynamically.", "configspace": "", "generation": 5, "fitness": 0.9337170275623903, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "2c90c687-af6a-4c37-a103-016effc4a1c0", "metadata": {"aucs": [0.9231989553290898, 0.9442350997956908]}, "mutation_prompt": null}
{"id": "6e3ec98f-d484-4969-9bdd-58304712f155", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor_min = 0.3\n        self.crossover_rate_min = 0.5\n        self.archive = []\n        self.archive_size = dim\n\n    def crowding_distance(self, population, fitness):\n        distances = np.zeros(self.population_size)\n        sorted_indices = np.argsort(fitness)\n        for i in range(1, self.population_size - 1):\n            distances[sorted_indices[i]] = (fitness[sorted_indices[i + 1]] - fitness[sorted_indices[i - 1]]) / (fitness[sorted_indices[-1]] - fitness[sorted_indices[0]] + 1e-12)\n        return distances\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            distances = self.crowding_distance(population, fitness)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                x_a, x_b, x_c = population[a], population[b], population[c]\n\n                self.mutation_factor = self.mutation_factor_min + (0.5 * (1 - evaluations / self.budget))\n                mutant_vector = x_a + self.mutation_factor * (x_b - x_c)\n                mutant_vector = np.clip(mutant_vector, lb, ub)\n\n                self.crossover_rate = self.crossover_rate_min + (0.5 * (1 - evaluations / self.budget))\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i] or distances[i] < np.median(distances):\n                    if trial_fitness < fitness[i]:\n                        self.archive.append(population[i])\n                        if len(self.archive) > self.archive_size:\n                            self.archive.pop(np.random.randint(len(self.archive)))\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = trial_vector\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce population diversity control via crowding distance and adaptive memory archive to enhance exploration and maintain diversity.", "configspace": "", "generation": 6, "fitness": 0.7504848763665817, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.05.", "error": "", "parent_id": "cc582fcc-02ca-4200-b567-e7970a684e6b", "metadata": {"aucs": [0.7968710333330407, 0.7040987194001227]}, "mutation_prompt": null}
{"id": "73029e6d-9bee-4c97-b513-0a0d7a30091c", "solution": "import numpy as np\n\nclass DualPopulationAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.mutation_factor_min = 0.3\n        self.crossover_rate_min = 0.5\n        self.secondary_population_size = self.population_size // 2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        primary_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        secondary_population = np.random.uniform(lb, ub, (self.secondary_population_size, self.dim))\n        \n        primary_fitness = np.array([func(ind) for ind in primary_population])\n        secondary_fitness = np.array([func(ind) for ind in secondary_population])\n        \n        evaluations = self.population_size + self.secondary_population_size\n        best_index = np.argmin(primary_fitness)\n        best_position = primary_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three random distinct indices from the primary population\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                x_a, x_b, x_c = primary_population[a], primary_population[b], primary_population[c]\n\n                # Perform mutation\n                self.mutation_factor = self.mutation_factor_min + (0.5 * (1 - evaluations / self.budget))\n                mutant_vector = x_a + self.mutation_factor * (x_b - x_c)\n                mutant_vector = np.clip(mutant_vector, lb, ub)\n\n                # Perform crossover\n                self.crossover_rate = self.crossover_rate_min + (0.5 * (1 - evaluations / self.budget))\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(cross_points, mutant_vector, primary_population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection\n                if trial_fitness < primary_fitness[i]:\n                    primary_population[i] = trial_vector\n                    primary_fitness[i] = trial_fitness\n\n                # Update best position\n                if trial_fitness < primary_fitness[best_index]:\n                    best_index = i\n                    best_position = trial_vector\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update secondary population for diversity\n            if evaluations < self.budget:\n                for j in range(self.secondary_population_size):\n                    indices = list(range(self.secondary_population_size))\n                    indices.remove(j)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    y_a, y_b, y_c = secondary_population[a], secondary_population[b], secondary_population[c]\n\n                    mutant_vector = y_a + self.mutation_factor * (y_b - y_c)\n                    mutant_vector = np.clip(mutant_vector, lb, ub)\n\n                    cross_points = np.random.rand(self.dim) < self.crossover_rate\n                    trial_vector = np.where(cross_points, mutant_vector, secondary_population[j])\n\n                    trial_fitness = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_fitness < secondary_fitness[j]:\n                        secondary_population[j] = trial_vector\n                        secondary_fitness[j] = trial_fitness\n\n                    if trial_fitness < primary_fitness[best_index]:\n                        best_index = np.argmin(np.append(primary_fitness, secondary_fitness))\n                        best_position = trial_vector if best_index >= self.population_size else primary_population[best_index]\n\n                    if evaluations >= self.budget:\n                        break\n\n        return best_position, primary_fitness[best_index]", "name": "DualPopulationAdaptiveDifferentialEvolution", "description": "Introduce a Dual-Population Adaptive Differential Evolution with Self-Adaptive Mutation and Crossover for enhanced exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 29 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 29 is out of bounds for axis 0 with size 20')", "parent_id": "cc582fcc-02ca-4200-b567-e7970a684e6b", "metadata": {}, "mutation_prompt": null}
{"id": "bdd069d2-3839-4d85-8f73-75452e0b05f3", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.phi = 1.61803398875 # Golden ratio for adaptive neighborhood\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(ind) for ind in particles])\n        best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity with quantum behavior\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coeff * r1 * (personal_best_positions[i] - particles[i])\n                    + self.social_coeff * r2 * (global_best_position - particles[i])\n                )\n                # Apply quantum-inspired update\n                velocities[i] = (velocities[i] + np.sin(velocities[i]) * self.phi) / 2\n\n                # Move the particle\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = particles[i]\n                    personal_best_scores[i] = score\n\n                # Update global best\n                if score < personal_best_scores[best_index]:\n                    global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_scores[best_index]", "name": "QuantumInspiredPSO", "description": "Quantum-Inspired Particle Swarm Optimization with Adaptive Neighborhoods that leverage quantum behaviors and adaptive neighborhood sizes for improved exploration and convergence stability.", "configspace": "", "generation": 8, "fitness": 0.564440555074853, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.11.", "error": "", "parent_id": "cc582fcc-02ca-4200-b567-e7970a684e6b", "metadata": {"aucs": [0.4514197718778604, 0.6774613382718455]}, "mutation_prompt": null}
{"id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "solution": "import numpy as np\n\nclass QuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "QuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-inspired Evolutionary Algorithm (QEA) leveraging quantum bit representations and superposition states for enhanced global search capabilities.", "configspace": "", "generation": 9, "fitness": 0.9559309240748555, "feedback": "The algorithm QuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "cc582fcc-02ca-4200-b567-e7970a684e6b", "metadata": {"aucs": [0.9581204986826757, 0.9537413494670351]}, "mutation_prompt": null}
{"id": "99b23f81-3dd5-4351-b365-295015086740", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.mutation_rate = 0.05\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Introduce crossover with a randomly selected partner\n                if np.random.rand() < self.crossover_rate:\n                    partner_index = np.random.randint(self.population_size)\n                    position_population[i] = self.crossover(position_population[i], position_population[partner_index], lb, ub)\n\n                # Apply mutation\n                if np.random.rand() < self.mutation_rate:\n                    position_population[i] = self.mutate(position_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def crossover(self, individual, partner, lb, ub):\n        # Perform uniform crossover between two individuals\n        mask = np.random.rand(self.dim) > 0.5\n        child = np.where(mask, individual, partner)\n        return np.clip(child, lb, ub)\n\n    def mutate(self, individual, lb, ub):\n        # Apply mutation by adding a small random value\n        mutation_vector = np.random.normal(0, 0.1, self.dim)\n        mutant = individual + mutation_vector\n        return np.clip(mutant, lb, ub)", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) incorporating adaptive mutation and crossover operations to improve exploration and convergence.", "configspace": "", "generation": 10, "fitness": 0.6602780723553513, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.09.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.7502123577001667, 0.5703437870105359]}, "mutation_prompt": null}
{"id": "6bce3fc1-b092-442d-b943-298e7cccce4f", "solution": "import numpy as np\n\nclass ImprovedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.population_reduction_factor = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        best_fitness = fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                # Adaptive quantum rotation gate: update quantum bits\n                adaptive_beta = self.beta * (1 - evaluations / self.budget)\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], adaptive_beta)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < best_fitness:\n                    best_index = i\n                    best_position = position_population[i]\n                    best_fitness = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            if evaluations < self.budget:\n                population_size = max(2, int(population_size * self.population_reduction_factor))\n                quantum_population = quantum_population[:population_size]\n                position_population = position_population[:population_size]\n                fitness = fitness[:population_size]\n\n        return best_position, best_fitness\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, beta):\n        # Quantum rotation gate inspired update with adaptive beta\n        delta_theta = beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "ImprovedQuantumInspiredEvolutionaryAlgorithm", "description": "Improved Quantum-Inspired Evolutionary Algorithm (QEA) with adaptive quantum rotation and dynamic population size adjustment for enhanced exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 6 is out of bounds for axis 0 with size 6').", "error": "IndexError('index 6 is out of bounds for axis 0 with size 6')", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {}, "mutation_prompt": null}
{"id": "8a668017-c3d0-4c95-a3c5-c937d6fad170", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha = 0.7  # Increased probability for quantum rotation\n        self.beta = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            if evaluations % (self.budget // 3) == 0:\n                population_size = min(self.initial_population_size, self.budget - evaluations)\n                quantum_population = np.random.rand(population_size, self.dim)\n                position_population = self.quantum_to_position(quantum_population, lb, ub)\n\n            for i in range(population_size):\n                # Adaptive quantum rotation gate based on fitness\n                if np.random.rand() < self.alpha * (1 - fitness[i] / max(fitness)):\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Adaptive Quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "An enhanced Quantum-Inspired Evolutionary Algorithm utilizing adaptive quantum gate operations and dynamic population sizing for improved exploration and convergence in global optimization.", "configspace": "", "generation": 12, "fitness": 0.6313009564874976, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.07.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6987056320809846, 0.5638962808940107]}, "mutation_prompt": null}
{"id": "86cf492f-1623-480e-a8be-57d0a4e016a9", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                if np.random.rand() < self.mutation_rate:\n                    quantum_population[i] = self.differential_mutation(quantum_population, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def differential_mutation(self, quantum_population, idx):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), idx), 3, replace=False)\n        mutant = quantum_population[a] + 0.8 * (quantum_population[b] - quantum_population[c])\n        mutant = np.clip(mutant, 0, 1)\n        return mutant", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) employing adaptive quantum rotation and differential mutation for improved convergence in complex search spaces.", "configspace": "", "generation": 13, "fitness": 0.574967380901027, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.06.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6364614448379962, 0.5134733169640577]}, "mutation_prompt": null}
{"id": "a13c5223-6735-4cfb-8e99-ae9f37b62e1f", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.local_search_iterations = 5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential evolution mutation\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Local search\n                trial = self.local_search(trial, func, lb, ub, self.local_search_iterations)\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial\n\n                # Update best position\n                if trial_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def local_search(self, position, func, lb, ub, max_iter):\n        best_pos = position\n        best_fitness = func(position)\n        for _ in range(max_iter):\n            candidate = best_pos + 0.01 * (np.random.rand(self.dim) - 0.5) * (ub - lb)\n            candidate = np.clip(candidate, lb, ub)\n            candidate_fitness = func(candidate)\n            if candidate_fitness < best_fitness:\n                best_fitness = candidate_fitness\n                best_pos = candidate\n        return best_pos", "name": "AdaptiveMemeticAlgorithm", "description": "Adaptive Memetic Algorithm (AMA) combining differential evolution with local search for enhanced exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.5292761093464113, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.5734611013804105, 0.48509111731241206]}, "mutation_prompt": null}
{"id": "ce8c2371-bd9f-4d05-bdb0-3d870824aa6d", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta_initial = 0.5\n        self.beta_final = 0.1\n        self.elite_fraction = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            beta = self.update_beta(evaluations)\n            elite_indices = self.get_elite_indices(fitness)\n            \n            for i in range(self.population_size):\n                if i in elite_indices:  # Retain elite individuals\n                    continue\n                if np.random.rand() < self.alpha:\n                    best_quantum_bits = quantum_population[best_index]\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], best_quantum_bits, beta)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, beta):\n        delta_theta = beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def update_beta(self, evaluations):\n        progress = evaluations / self.budget\n        return self.beta_initial + progress * (self.beta_final - self.beta_initial)\n\n    def get_elite_indices(self, fitness):\n        num_elites = int(self.population_size * self.elite_fraction)\n        elite_indices = np.argsort(fitness)[:num_elites]\n        return elite_indices", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-Inspired Evolutionary Algorithm using adaptive beta and elite retention for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.7785886802649322, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.16.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.9367673427466642, 0.6204100177832003]}, "mutation_prompt": null}
{"id": "339c7083-2055-41b9-a4ed-e0241883a213", "solution": "import numpy as np\n\nclass BioInspiredWaveOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.amplitude = 0.5\n        self.frequency = 0.1\n        self.damping_factor = 0.99\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        wave_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.wave_to_position(wave_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update wave parameters\n                self.amplitude *= self.damping_factor\n                wave_population[i] = self.update_wave_parameters(wave_population[i], wave_population[best_index])\n\n                # Convert wave representation to classical position\n                position_population[i] = self.wave_to_position(wave_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def wave_to_position(self, wave_parameters, lb, ub):\n        # Convert wave parameters to classical positions in the search space\n        position = lb + wave_parameters * (ub - lb)\n        return position\n\n    def update_wave_parameters(self, wave_parameters, best_wave_parameters):\n        # Wave behavior emulation for updates\n        delta_wave = self.amplitude * np.sin(self.frequency * (best_wave_parameters - wave_parameters))\n        new_wave_parameters = wave_parameters + delta_wave\n        new_wave_parameters = np.clip(new_wave_parameters, 0, 1)\n        return new_wave_parameters", "name": "BioInspiredWaveOptimization", "description": "Bio-Inspired Wave Optimization (BIWO) utilizes wave behavior emulation combined with adaptive amplitude and frequency modulation to explore and exploit search spaces effectively.", "configspace": "", "generation": 16, "fitness": 0.5536189683749341, "feedback": "The algorithm BioInspiredWaveOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.08.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6364614448379962, 0.470776491911872]}, "mutation_prompt": null}
{"id": "d055f48c-6d4d-4e54-98ae-9e3d29fcb579", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.beta_decay = 0.99  # Introduce adaptive beta decay\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    position_population[i] = position_population[i]\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Elitist strategy: Introduce current best position into the population\n            worst_index = np.argmax(fitness)\n            position_population[worst_index] = best_position\n            fitness[worst_index] = fitness[best_index]\n\n            # Adaptive beta decay\n            self.beta *= self.beta_decay\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update with adaptive beta\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) with adaptive beta and elitist strategy for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.5459188253612584, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.5826493573671215, 0.5091882933553953]}, "mutation_prompt": null}
{"id": "d7d1a866-c5ee-4c01-b82c-e088ee549876", "solution": "import numpy as np\n\nclass BioInspiredFireflyAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20 * dim\n        self.alpha = 0.5  # Randomness parameter\n        self.beta0 = 1.0  # Base attractiveness\n        self.gamma = 1.0  # Absorption coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[i] > fitness[j]:  # Move firefly i towards j\n                        r = np.linalg.norm(population[i] - population[j])\n                        beta = self.beta0 * np.exp(-self.gamma * r ** 2)\n                        attraction = beta * (population[j] - population[i])\n                        random_movement = self.alpha * (np.random.uniform(size=self.dim) - 0.5)\n                        population[i] += attraction + random_movement\n                        population[i] = np.clip(population[i], lb, ub)\n\n                        # Evaluate new position\n                        new_fitness = func(population[i])\n                        evaluations += 1\n\n                        # Update fitness\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n                        # Update best position\n                        if new_fitness < fitness[best_index]:\n                            best_index = i\n                            best_position = population[i]\n\n                        if evaluations >= self.budget:\n                            break\n\n        return best_position, fitness[best_index]", "name": "BioInspiredFireflyAlgorithm", "description": "Bio-inspired Firefly Algorithm utilizing attractiveness variation and randomness for efficient global optimization.", "configspace": "", "generation": 18, "fitness": 0.6110562378924752, "feedback": "The algorithm BioInspiredFireflyAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.03.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6364614448379962, 0.5856510309469543]}, "mutation_prompt": null}
{"id": "35a38f5e-b859-411d-a056-53ad6a34e4c9", "solution": "import numpy as np\n\nclass QuantumAnnealingInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.cooling_rate = 0.9\n        self.initial_temperature = 100.0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        temperature = self.initial_temperature\n        \n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, lb, ub)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, population[i])\n                \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / temperature) > np.random.rand():\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < fitness[best_index]:\n                    best_index = i\n                    best_solution = trial_vector.copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            temperature *= self.cooling_rate\n\n        return best_solution, fitness[best_index]", "name": "QuantumAnnealingInspiredDifferentialEvolution", "description": "Quantum Annealing-Inspired Differential Evolution (QAIDE) combining quantum superposition and annealing with differential evolution strategies for robust global optimization.", "configspace": "", "generation": 19, "fitness": 0.5381991490953765, "feedback": "The algorithm QuantumAnnealingInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.5283081960971692, 0.5480901020935838]}, "mutation_prompt": null}
{"id": "ecd767d6-d373-4cfb-9f5a-97ee146b7434", "solution": "import numpy as np\n\nclass AdaptiveSwarmBasedQuantumAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.02\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        velocity_population = np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        personal_best_positions = position_population.copy()\n        personal_best_fitness = fitness.copy()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity using PSO-like rules\n                velocity_population[i] = (\n                    self.inertia_weight * velocity_population[i]\n                    + self.cognitive_coeff * np.random.rand(self.dim) * (personal_best_positions[i] - position_population[i])\n                    + self.social_coeff * np.random.rand(self.dim) * (best_position - position_population[i])\n                )\n                velocity_population[i] = np.clip(velocity_population[i], -1, 1)\n\n                # Update position from velocity\n                position_population[i] += velocity_population[i]\n                position_population[i] = np.clip(position_population[i], lb, ub)\n\n                # Quantum-inspired update\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert back to position and evaluate\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: update personal and global bests\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = position_population[i]\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "AdaptiveSwarmBasedQuantumAlgorithm", "description": "Adaptive Swarm-Based Quantum Algorithm (ASBQA) merging swarm intelligence with quantum-inspired states to dynamically explore and exploit the search space.", "configspace": "", "generation": 20, "fitness": 0.36404856517229206, "feedback": "The algorithm AdaptiveSwarmBasedQuantumAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.00.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.36128899948155235, 0.36680813086303177]}, "mutation_prompt": null}
{"id": "454a97f9-51f5-4c81-b2e3-7f76a2354a80", "solution": "import numpy as np\n\nclass QuantumEnhancedEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.learning_rate_decay = 0.99  # Adaptive learning rate decay\n        self.diversity_threshold = 0.1   # Threshold for diversity preservation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            new_quantum_population = np.empty_like(quantum_population)\n            for i in range(self.population_size):\n                # Adaptive Quantum Rotation Update\n                learning_rate = self.beta * (self.learning_rate_decay ** (evaluations / self.population_size))\n                if np.random.rand() < self.alpha:\n                    new_quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], learning_rate)\n                else:\n                    new_quantum_population[i] = quantum_population[i]\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(new_quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    quantum_population[i] = new_quantum_population[i]\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Diversity Preservation\n            if self.calculate_diversity(quantum_population) < self.diversity_threshold:\n                quantum_population += np.random.normal(0, 0.1, size=quantum_population.shape)\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, learning_rate):\n        # Quantum rotation gate inspired update with adaptive learning rate\n        delta_theta = learning_rate * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def calculate_diversity(self, quantum_population):\n        # Calculate diversity as the average pairwise Euclidean distance\n        num_individuals = quantum_population.shape[0]\n        diversity_sum = 0\n        count = 0\n        for i in range(num_individuals):\n            for j in range(i + 1, num_individuals):\n                diversity_sum += np.linalg.norm(quantum_population[i] - quantum_population[j])\n                count += 1\n        return diversity_sum / count if count > 0 else 0", "name": "QuantumEnhancedEvolutionaryAlgorithm", "description": "Quantum-Enhanced Evolutionary Algorithm (QEEA) incorporating adaptive learning rates and diversity preservation to improve exploration and exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.42264299700469965, "feedback": "The algorithm QuantumEnhancedEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.03.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.39260248422820065, 0.45268350978119865]}, "mutation_prompt": null}
{"id": "df715ebd-f6cb-4a9f-9392-fd8a15cb15d0", "solution": "import numpy as np\n\nclass BioInspiredDynamicQuantumSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.alpha = 0.5\n        self.beta = 0.3\n        self.mutation_rate = 0.05\n        self.dynamic_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Quantum inspired update with dynamic mutation\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Dynamic mutation to escape local optima\n                if np.random.rand() < self.mutation_rate:\n                    quantum_population[i] = self.apply_dynamic_mutation(quantum_population[i])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def apply_dynamic_mutation(self, quantum_bits):\n        # Apply dynamic mutation based on a pre-defined factor\n        mutation_strength = self.dynamic_factor * (np.random.rand(self.dim) - 0.5)\n        mutated_bits = quantum_bits + mutation_strength\n        mutated_bits = np.clip(mutated_bits, 0, 1)\n        return mutated_bits", "name": "BioInspiredDynamicQuantumSearch", "description": "Bio-Inspired Dynamic Quantum Search (BDQS) combining quantum-inspired updates with a dynamic mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 22, "fitness": 0.602793719562102, "feedback": "The algorithm BioInspiredDynamicQuantumSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.08.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6842620074999222, 0.521325431624282]}, "mutation_prompt": null}
{"id": "f234c2f3-8be2-47ab-a6f6-ea193b110665", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha_min = 0.3\n        self.alpha_max = 0.7\n        self.beta = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        best_fitness = fitness[best_index]\n        stagnation_count = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                # Adaptive alpha based on stagnation\n                alpha = self.adaptive_alpha(stagnation_count)\n\n                # Quantum rotation gate: update quantum bits\n                if np.random.rand() < alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < best_fitness:\n                    best_index = i\n                    best_position = position_population[i]\n                    best_fitness = new_fitness\n                    stagnation_count = 0  # reset stagnation counter\n                else:\n                    stagnation_count += 1\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic population resizing based on stagnation\n            if stagnation_count > 2 * population_size:\n                population_size = max(5 * self.dim, population_size // 2)\n                quantum_population, position_population, fitness = self.resize_population(quantum_population, position_population, fitness, population_size)\n                stagnation_count = 0\n\n        return best_position, best_fitness\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def adaptive_alpha(self, stagnation_count):\n        # Adaptive alpha adjustment\n        return self.alpha_min + (self.alpha_max - self.alpha_min) * np.tanh(stagnation_count / 10)\n\n    def resize_population(self, quantum_population, position_population, fitness, new_size):\n        # Resize populations and fitness arrays\n        sorted_indices = np.argsort(fitness)\n        quantum_population = quantum_population[sorted_indices[:new_size]]\n        position_population = position_population[sorted_indices[:new_size]]\n        fitness = fitness[sorted_indices[:new_size]]\n        return quantum_population, position_population, fitness", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm with adaptive quantum rotation and dynamic population resizing for improved global search efficiency.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {}, "mutation_prompt": null}
{"id": "b5534a93-da29-46a7-bceb-d3969425f47e", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Quantum rotation gate with adaptive update rate\n                self.beta = 0.9 * self.beta + 0.1 * np.random.rand()\n                quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection with diversity consideration\n                if new_fitness < fitness[i] or np.random.rand() < self.adaptive_rate:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update with adaptive beta\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) integrates adaptive quantum rotation and diversity-driven selection to improve convergence and exploration in global optimization tasks.", "configspace": "", "generation": 24, "fitness": 0.5408055404621581, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.5055974231187548, 0.5760136578055615]}, "mutation_prompt": null}
{"id": "83612efb-216d-483e-9100-9df9b741d9fc", "solution": "import numpy as np\n\nclass QuantumSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 10 * dim\n        self.alpha = 0.7  # Learning factor\n        self.beta = 0.3   # Entanglement influence\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_positions = np.random.rand(self.swarm_size, self.dim)\n        classical_positions = self.quantum_to_classical(quantum_positions, lb, ub)\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_best_positions = np.copy(classical_positions)\n        personal_best_fitness = np.array([func(ind) for ind in classical_positions])\n        evaluations = self.swarm_size\n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                # Update velocity with quantum-inspired dynamics\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.alpha * velocities[i] +\n                                 self.beta * r1 * (personal_best_positions[i] - classical_positions[i]) +\n                                 self.beta * r2 * (global_best_position - classical_positions[i]))\n\n                # Update quantum positions using velocities\n                quantum_positions[i] = self.update_quantum_positions(quantum_positions[i], velocities[i])\n\n                # Convert quantum representation to classical position\n                classical_positions[i] = self.quantum_to_classical(quantum_positions[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(classical_positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = classical_positions[i]\n\n                # Update global best\n                if new_fitness < personal_best_fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = classical_positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_fitness[global_best_index]\n\n    def quantum_to_classical(self, quantum_positions, lb, ub):\n        # Translate quantum positions into classical search space\n        return lb + quantum_positions * (ub - lb)\n\n    def update_quantum_positions(self, quantum_positions, velocities):\n        # Update quantum positions with a quantum-inspired velocity adjustment\n        new_quantum_positions = quantum_positions + velocities\n        new_quantum_positions = np.clip(new_quantum_positions, 0, 1)\n        return new_quantum_positions", "name": "QuantumSwarmOptimization", "description": "Quantum Swarm Optimization (QSO) utilizing quantum-inspired particle dynamics and entangled states for superior exploration and exploitation in high-dimensional spaces.", "configspace": "", "generation": 25, "fitness": 0.5957352645255312, "feedback": "The algorithm QuantumSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6373632301755883, 0.5541072988754742]}, "mutation_prompt": null}
{"id": "1288fd21-0113-432f-a850-20526ebbb29e", "solution": "import numpy as np\n\nclass DifferentialEvolutionAdaptiveDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.initial_population_size\n        best_index = np.argmin(self.fitness)\n        best_position = self.population[best_index]\n\n        while evaluations < self.budget:\n            new_population = np.copy(self.population)\n            for i in range(len(self.population)):\n                a, b, c = self.select_three_unique(i, len(self.population))\n                mutant_vector = self.mutate(self.population[a], self.population[b], self.population[c], lb, ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                new_fitness = func(trial_vector)\n                evaluations += 1\n\n                if new_fitness < self.fitness[i]:\n                    new_population[i] = trial_vector\n                    self.fitness[i] = new_fitness\n\n                if new_fitness < self.fitness[best_index]:\n                    best_index = i\n                    best_position = trial_vector\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population = new_population\n            self.dynamic_population_adjustment(evaluations)\n\n        return best_position, self.fitness[best_index]\n\n    def select_three_unique(self, idx, population_size):\n        indices = [i for i in range(population_size) if i != idx]\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, a, b, c, lb, ub):\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, lb, ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def dynamic_population_adjustment(self, evaluations):\n        if evaluations < self.budget * 0.5:\n            self.population_size = self.initial_population_size\n        elif evaluations < self.budget * 0.75:\n            self.population_size = self.initial_population_size // 2\n        else:\n            self.population_size = self.initial_population_size // 4\n\n        self.population = self.population[:self.population_size]\n        self.fitness = self.fitness[:self.population_size]", "name": "DifferentialEvolutionAdaptiveDynamicPopulation", "description": "Differential Evolution with Adaptive Dynamic Population (DEADP) adjusts the population size dynamically based on convergence rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 10')", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {}, "mutation_prompt": null}
{"id": "c7e282f5-0022-438b-95d1-ecd8bab23fdf", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.inertia_weight_min = 0.4  # Minimum inertia weight\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = np.copy(personal_best_positions[global_best_index])\n        global_best_score = personal_best_scores[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i] +\n                    self.c1 * r1 * (personal_best_positions[i] - population[i]) +\n                    self.c2 * r2 * (global_best_position - population[i])\n                )\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = population[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score:\n                    global_best_position = population[i]\n                    global_best_score = score\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight = max(self.inertia_weight_min, self.inertia_weight - 0.01)  # Dynamic update\n\n        return global_best_position, global_best_score", "name": "AdaptiveParticleSwarmOptimization", "description": "Adaptive Particle Swarm Optimization (APSO) with a dynamic inertia weight and local search refinement for enhanced exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.8544207183899095, "feedback": "The algorithm AdaptiveParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.8973213192790828, 0.8115201175007362]}, "mutation_prompt": null}
{"id": "596865dc-f298-456f-b9af-5bce0d76b8a6", "solution": "import numpy as np\n\nclass HybridQuantumCulturalEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.kappa = 0.1  # Learning rate for cultural knowledge\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        cultural_knowledge = best_position.copy()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Update quantum bits with cultural influence\n                cultural_influence = self.kappa * (cultural_knowledge - quantum_population[i])\n                quantum_population[i] += cultural_influence\n                quantum_population[i] = np.clip(quantum_population[i], 0, 1)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n                    cultural_knowledge = self.update_cultural_knowledge(cultural_knowledge, best_position)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def update_cultural_knowledge(self, cultural_knowledge, best_position):\n        # Update cultural knowledge with a bias towards the best_position found\n        new_cultural_knowledge = (1 - self.kappa) * cultural_knowledge + self.kappa * best_position\n        return new_cultural_knowledge", "name": "HybridQuantumCulturalEvolutionaryAlgorithm", "description": "Hybrid Quantum-Cultural Evolutionary Algorithm (HQCEA) utilizing quantum bits and cultural knowledge sharing to enhance convergence and global exploration.", "configspace": "", "generation": 28, "fitness": 0.5089589999180754, "feedback": "The algorithm HybridQuantumCulturalEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.00.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.5105373801095581, 0.5073806197265927]}, "mutation_prompt": null}
{"id": "91cb04d8-6bf2-437d-83d9-63b0a11dcca8", "solution": "import numpy as np\n\nclass HybridQuantumBacterialForaging:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.elimination_dispersal_rate = 0.25\n        self.step_size = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Bacterial Foraging Chemotaxis\n            for i in range(self.population_size):\n                if np.random.rand() < self.elimination_dispersal_rate:\n                    step = np.random.uniform(-1, 1, self.dim)\n                    new_position = position_population[i] + self.step_size * step\n                    new_position = np.clip(new_position, lb, ub)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n\n                    if new_fitness < fitness[i]:\n                        fitness[i] = new_fitness\n                        position_population[i] = new_position\n\n                    if new_fitness < fitness[best_index]:\n                        best_index = i\n                        best_position = new_position\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "HybridQuantumBacterialForaging", "description": "Hybrid Quantum-Bacterial Foraging Algorithm using quantum-inspired evolutionary strategies combined with bacterial foraging dynamics for effective exploration and exploitation.", "configspace": "", "generation": 29, "fitness": 0.7169840846549842, "feedback": "The algorithm HybridQuantumBacterialForaging got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.20.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.9137173707409124, 0.5202507985690561]}, "mutation_prompt": null}
{"id": "2e64dcbb-bb4d-496d-a790-412790a6e847", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta_initial = 0.5\n        self.beta_final = 0.1\n        self.reduction_factor = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            adaptive_beta = self.beta_initial - (self.beta_initial - self.beta_final) * (evaluations / self.budget)\n            for i in range(population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], adaptive_beta)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (self.budget // 5) == 0:\n                population_size = max(2, int(population_size * self.reduction_factor))\n                quantum_population = quantum_population[:population_size]\n                position_population = position_population[:population_size]\n                fitness = fitness[:population_size]\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, adaptive_beta):\n        delta_theta = adaptive_beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm using adaptive rotation angles and dynamic population size for improved exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.8443961425103671, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84 with standard deviation 0.12.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.7204538449978806, 0.9683384400228536]}, "mutation_prompt": null}
{"id": "3501f38b-4924-4409-ac7d-3cc87b025439", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta_initial = 0.5\n        self.beta_final = 0.1\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], evaluations)\n\n                if np.random.rand() < self.crossover_rate:\n                    partner = np.random.randint(self.population_size)\n                    quantum_population[i] = self.crossover_quantum_bits(quantum_population[i], quantum_population[partner])\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, evaluations):\n        beta = self.adaptive_beta(evaluations)\n        delta_theta = beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def adaptive_beta(self, evaluations):\n        progress = evaluations / self.budget\n        return self.beta_initial - (self.beta_initial - self.beta_final) * progress\n\n    def crossover_quantum_bits(self, quantum_bits1, quantum_bits2):\n        mask = np.random.rand(self.dim) < 0.5\n        new_quantum_bits = np.where(mask, quantum_bits1, quantum_bits2)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (QEA) incorporating crossover and adaptive rotation angles for improved exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": 0.6147904051347416, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.02.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6364614448379962, 0.593119365431487]}, "mutation_prompt": null}
{"id": "2575eb9e-8c61-43af-9cce-18472b0d16f4", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: create a donor vector using the best solution and two random vectors\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = indices\n                if a == best_index:\n                    a = (best_index + 1) % self.population_size\n                donor_quantum_bits = self.quantum_mutation(quantum_population[a], quantum_population[b], quantum_population[c])\n\n                # Crossover: mix donor vector with target vector\n                trial_quantum_bits = self.quantum_crossover(quantum_population[i], donor_quantum_bits)\n\n                # Convert quantum representation to classical position\n                trial_position = self.quantum_to_position(trial_quantum_bits, lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(trial_position)\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    quantum_population[i] = trial_quantum_bits\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = trial_position\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def quantum_mutation(self, a, b, c):\n        # Differential mutation in quantum space\n        mutant_quantum_bits = a + self.F * (b - c)\n        mutant_quantum_bits = np.clip(mutant_quantum_bits, 0, 1)\n        return mutant_quantum_bits\n\n    def quantum_crossover(self, target, donor):\n        # Crossover operation\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        trial_quantum_bits = np.where(crossover_mask, donor, target)\n        return trial_quantum_bits", "name": "QuantumDifferentialEvolution", "description": "Quantum Differential Evolution (QDE) combines principles of differential evolution with quantum computing to perform global search using quantum-inspired differential vectors.", "configspace": "", "generation": 32, "fitness": 0.9254233491579342, "feedback": "The algorithm QuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.9358493717841153, 0.9149973265317533]}, "mutation_prompt": null}
{"id": "f85e6268-6dd6-4ddf-90e6-088b7c956805", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.elite_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        elite_size = max(1, int(self.elite_rate * self.population_size))\n        elite_indices = np.argsort(fitness)[:elite_size]\n        elites = position_population[elite_indices]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Quantum rotation gate: adaptively update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.adaptive_quantum_rotation(quantum_population[i], elites)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Elite preservation\n                if new_fitness < fitness[elite_indices[-1]]:\n                    elite_indices[-1] = i\n                    elites = position_population[elite_indices]\n                    elite_indices = np.argsort(fitness)[:elite_size]\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return position_population[best_index], fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def adaptive_quantum_rotation(self, quantum_bits, elites):\n        # Adaptive quantum rotation gate inspired update using elites\n        elite_mean = np.mean(elites, axis=0)\n        delta_theta = self.beta * (elite_mean - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) incorporating adaptive quantum gate rotation and elite preservation for improved global optimization efficiency.", "configspace": "", "generation": 33, "fitness": 0.5099748617789971, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.468181169333457, 0.5517685542245372]}, "mutation_prompt": null}
{"id": "ecf5bd67-4cc2-4eee-9803-6815a4b8b18a", "solution": "import numpy as np\n\nclass HybridQuantumParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Quantum rotation influence\n        self.beta = 0.5   # Swarm velocity influence\n        self.omega = 0.7  # Inertia weight for velocity\n        self.phi_p = 1.5  # Personal best influence\n        self.phi_g = 1.5  # Global best influence\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        \n        personal_best_positions = np.copy(position_population)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = position_population[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities based on personal and global bests\n                r_p = np.random.rand(self.dim)\n                r_g = np.random.rand(self.dim)\n                velocity[i] = (\n                    self.omega * velocity[i] +\n                    self.phi_p * r_p * (personal_best_positions[i] - position_population[i]) +\n                    self.phi_g * r_g * (global_best_position - position_population[i])\n                )\n\n                # Quantum rotation update\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[global_best_index])\n\n                # Calculate new positions\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub) + self.beta * velocity[i]\n                position_population[i] = np.clip(position_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n                \n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = position_population[i]\n\n                # Update global best\n                if new_fitness < personal_best_fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_fitness[global_best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "HybridQuantumParticleSwarmOptimization", "description": "Hybrid Quantum-Particle Swarm Optimization (HQPSO) leveraging quantum-inspired state rotation combined with velocity-based swarm behavior for effective exploration and exploitation.", "configspace": "", "generation": 34, "fitness": 0.6801544986946498, "feedback": "The algorithm HybridQuantumParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.18.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.8648367537078784, 0.4954722436814213]}, "mutation_prompt": null}
{"id": "5b41a669-b7a7-446c-b82c-7463dce483b2", "solution": "import numpy as np\n\nclass BeeColonyOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_bees = 20 * dim\n        self.num_elite_bees = int(0.1 * self.num_bees)\n        self.num_scout_bees = int(0.2 * self.num_bees)\n        self.waggle_factor = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.num_bees, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.num_bees\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            # Recruit elite bees\n            elite_indices = np.argsort(fitness)[:self.num_elite_bees]\n            for idx in elite_indices:\n                new_position = self.explore_around(population[idx], lb, ub)\n                new_fitness = func(new_position)\n                evaluations += 1\n                if new_fitness < fitness[idx]:\n                    fitness[idx] = new_fitness\n                    population[idx] = new_position\n                    if new_fitness < fitness[best_index]:\n                        best_index = idx\n                        best_position = new_position\n\n                if evaluations >= self.budget:\n                    break\n\n            # Recruit scout bees\n            for _ in range(self.num_scout_bees):\n                scout_idx = np.random.choice(self.num_bees)\n                new_position = np.random.uniform(lb, ub, self.dim)\n                new_fitness = func(new_position)\n                evaluations += 1\n                if new_fitness < fitness[scout_idx]:\n                    fitness[scout_idx] = new_fitness\n                    population[scout_idx] = new_position\n                    if new_fitness < fitness[best_index]:\n                        best_index = scout_idx\n                        best_position = new_position\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def explore_around(self, position, lb, ub):\n        # Explore new position around the current position\n        new_position = position + self.waggle_factor * (np.random.rand(self.dim) - 0.5) * (ub - lb)\n        new_position = np.clip(new_position, lb, ub)\n        return new_position", "name": "BeeColonyOptimization", "description": "Bio-Inspired Bee Colony Optimization leveraging the foraging behavior of bees for efficient search and exploration in complex search spaces.", "configspace": "", "generation": 35, "fitness": 0.6803316808869058, "feedback": "The algorithm BeeColonyOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6906100769848762, 0.6700532847889353]}, "mutation_prompt": null}
{"id": "d9d04781-f18b-4d6a-b570-231233596b41", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        best_fitness = fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.adaptive_update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness[i], best_fitness)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < best_fitness:\n                    best_index = i\n                    best_position = position_population[i]\n                    best_fitness = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.calculate_diversity(quantum_population) < self.diversity_threshold:\n                quantum_population = self.randomize_population(quantum_population)\n\n        return best_position, best_fitness\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def adaptive_update_quantum_bits(self, quantum_bits, best_quantum_bits, current_fitness, best_fitness):\n        adaptive_beta = self.beta * (current_fitness / best_fitness)\n        delta_theta = adaptive_beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def calculate_diversity(self, population):\n        return np.mean(np.std(population, axis=0))\n\n    def randomize_population(self, population):\n        num_to_randomize = self.population_size // 2\n        indices = np.random.choice(self.population_size, num_to_randomize, replace=False)\n        for i in indices:\n            population[i] = np.random.rand(self.dim)\n        return population", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) integrating adaptive quantum rotation and diversity preservation to improve convergence and solution quality.", "configspace": "", "generation": 36, "fitness": 0.5030018283185302, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.5396774074555504, 0.4663262491815101]}, "mutation_prompt": null}
{"id": "f27719d7-75ff-4b9f-ab4d-bd4ccbaf83b7", "solution": "import numpy as np\n\nclass QuantumGeneticSwarmAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.quantum_bits = 2 * dim\n        self.alpha = 0.5  # Quantum update rate\n        self.beta = 0.9   # Inertia weight for PSO\n        self.c1, self.c2 = 2.0, 2.0  # PSO coefficients\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.quantum_bits)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        velocities = np.zeros_like(position_population)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        global_best_position = position_population[best_index]\n        personal_best_positions = position_population.copy()\n        personal_best_fitness = fitness.copy()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position using PSO dynamics\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.beta * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - position_population[i]) +\n                                 self.c2 * r2 * (global_best_position - position_population[i]))\n                position_population[i] += velocities[i]\n                position_population[i] = np.clip(position_population[i], lb, ub)\n\n                # Quantum bit rotation inspired update\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.quantum_update(quantum_population[i], global_best_position)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Update personal and global bests\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = position_population[i]\n\n                if new_fitness < personal_best_fitness[best_index]:\n                    best_index = i\n                    global_best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits[:, :self.dim] * (ub - lb)\n        return position\n\n    def quantum_update(self, quantum_bits, global_best_position):\n        # Quantum rotation and genetic mutation inspired update\n        delta_theta = self.alpha * (global_best_position - quantum_bits[:self.dim])\n        new_quantum_bits = quantum_bits[:self.dim] + delta_theta\n        mutation = np.random.normal(0, 0.1, size=self.dim)\n        new_quantum_bits = new_quantum_bits + mutation\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        quantum_bits[:self.dim] = new_quantum_bits\n        return quantum_bits", "name": "QuantumGeneticSwarmAlgorithm", "description": "Quantum Genetic Swarm Algorithm (QGSA) combining principles of quantum mechanics, genetic algorithms, and particle swarm optimization for enhanced exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.6810686159679464, "feedback": "The algorithm QuantumGeneticSwarmAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.03.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.7124047071365718, 0.649732524799321]}, "mutation_prompt": null}
{"id": "7027a2f8-158f-4d50-bb41-2a14b2241c47", "solution": "import numpy as np\n\nclass QuantumEnhancedDynamicAdaptationAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Initial rotation angle\n        self.beta = 0.5  # Initial adaptation rate\n        self.adaptation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n                    self.adapt_parameters(new_fitness, fitness[best_index])\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def adapt_parameters(self, new_fitness, best_fitness):\n        if new_fitness < best_fitness:\n            self.alpha = min(self.alpha + self.adaptation_rate, 1.0)\n            self.beta = max(self.beta - self.adaptation_rate, 0.1)\n        else:\n            self.alpha = max(self.alpha - self.adaptation_rate, 0.1)\n            self.beta = min(self.beta + self.adaptation_rate, 1.0)", "name": "QuantumEnhancedDynamicAdaptationAlgorithm", "description": "Quantum-enhanced Dynamic Adaptation Algorithm (QEDAA) combining quantum-inspired search with adaptive parameter tuning for improved convergence efficiency.", "configspace": "", "generation": 38, "fitness": 0.5097671956387193, "feedback": "The algorithm QuantumEnhancedDynamicAdaptationAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.4968930843827658, 0.5226413068946729]}, "mutation_prompt": null}
{"id": "c72fe147-8aac-436a-a81e-25150440ef17", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta_initial = 0.5\n        self.beta_final = 0.1  # Adaptive end value\n        self.epsilon = 1e-8  # Small constant to prevent division by zero\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            self.beta = self.beta_initial * (1 - progress_ratio) + self.beta_final * progress_ratio\n\n            for i in range(self.population_size):\n                # Quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update with adaptive beta\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) incorporating adaptive beta parameter for dynamic convergence improvement.", "configspace": "", "generation": 39, "fitness": 0.5974962381367689, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.10.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6933768140729826, 0.5016156622005552]}, "mutation_prompt": null}
{"id": "8b473aa9-ff61-4ea4-a855-bd5469861551", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.alpha = 0.5  # Quantum rotation factor\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: create a mutant vector\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = quantum_population[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, 0, 1)\n\n                # Crossover: mix mutant with parent\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_quantum = np.where(cross_points, mutant, quantum_population[i])\n\n                # Convert to position and evaluate\n                trial_position = self.quantum_to_position(trial_quantum, lb, ub)\n                new_fitness = func(trial_position)\n                evaluations += 1\n\n                # Selection: replace if trial is better\n                if new_fitness < fitness[i]:\n                    quantum_population[i] = trial_quantum\n                    position_population[i] = trial_position\n                    fitness[i] = new_fitness\n\n                # Update best solution\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = trial_position\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive mechanism\n            self.F = np.random.uniform(0.4, 0.9)\n            self.CR = np.random.uniform(0.7, 1.0)\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position", "name": "AdaptiveQuantumDifferentialEvolution", "description": "Adaptive Quantum Differential Evolution (AQDE) combining differential mutation strategies with quantum-inspired probability amplitudes for dynamic exploration and exploitation.", "configspace": "", "generation": 40, "fitness": 0.9302218189365172, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.9373963576224271, 0.9230472802506074]}, "mutation_prompt": null}
{"id": "e943c50a-75e3-4e21-a61e-d3eb87c0a4d7", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.dynamic_shrink_factor = 0.99  # To dynamically reduce population\n        self.adaptive_rotation_factor = 0.1  # To adaptively adjust rotation based on improvement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        best_fitness = fitness[best_index]\n\n        while evaluations < self.budget:\n            previous_best_fitness = best_fitness\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < best_fitness:\n                    best_index = i\n                    best_position = position_population[i]\n                    best_fitness = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive shrink of population size for faster convergence\n            if best_fitness < previous_best_fitness:\n                self.population_size = max(2, int(self.dynamic_shrink_factor * self.population_size))\n                quantum_population = quantum_population[:self.population_size]\n                position_population = position_population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            # Adaptive control for quantum rotation angles\n            self.beta *= (1 + self.adaptive_rotation_factor * np.sign(previous_best_fitness - best_fitness))\n\n        return best_position, best_fitness\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Adaptive Quantum rotation gate inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-Inspired Evolutionary Algorithm (EQEA) with adaptive control of quantum rotation angles and dynamic population management for improved convergence and exploration.", "configspace": "", "generation": 41, "fitness": 0.5728598992150001, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.04.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6173431885808915, 0.5283766098491087]}, "mutation_prompt": null}
{"id": "5f8b2ddd-2242-4266-85d9-288d25598f68", "solution": "import numpy as np\n\nclass DualPopulationCoEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.exploratory_population_size = 5 * dim\n        self.exploitative_population_size = 5 * dim\n        self.alpha = 0.3\n        self.beta = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize exploratory and exploitative populations\n        exploratory_population = np.random.rand(self.exploratory_population_size, self.dim)\n        exploitative_population = np.random.rand(self.exploitative_population_size, self.dim)\n\n        pos_exploratory = self.quantum_to_position(exploratory_population, lb, ub)\n        pos_exploitative = self.quantum_to_position(exploitative_population, lb, ub)\n\n        fitness_exploratory = np.array([func(ind) for ind in pos_exploratory])\n        fitness_exploitative = np.array([func(ind) for ind in pos_exploitative])\n\n        evaluations = self.exploratory_population_size + self.exploitative_population_size\n        best_index_exploratory = np.argmin(fitness_exploratory)\n        best_index_exploitative = np.argmin(fitness_exploitative)\n\n        best_overall = pos_exploratory[best_index_exploratory] if fitness_exploratory[best_index_exploratory] < fitness_exploitative[best_index_exploitative] else pos_exploitative[best_index_exploitative]\n\n        while evaluations < self.budget:\n            # Explore (divergent search)\n            for i in range(self.exploratory_population_size):\n                if np.random.rand() < self.alpha:\n                    exploratory_population[i] = self.random_mutation(exploratory_population[i])\n                pos_exploratory[i] = self.quantum_to_position(exploratory_population[i], lb, ub)\n                new_fitness = func(pos_exploratory[i])\n                evaluations += 1\n\n                if new_fitness < fitness_exploratory[i]:\n                    fitness_exploratory[i] = new_fitness\n\n                if new_fitness < fitness_exploratory[best_index_exploratory]:\n                    best_index_exploratory = i\n\n                if evaluations >= self.budget:\n                    break\n\n            # Exploit (convergent search)\n            for j in range(self.exploitative_population_size):\n                if np.random.rand() < self.beta:\n                    exploitative_population[j] = self.gradient_ascent(exploitative_population[j], pos_exploitative[best_index_exploitative])\n                pos_exploitative[j] = self.quantum_to_position(exploitative_population[j], lb, ub)\n                new_fitness = func(pos_exploitative[j])\n                evaluations += 1\n\n                if new_fitness < fitness_exploitative[j]:\n                    fitness_exploitative[j] = new_fitness\n\n                if new_fitness < fitness_exploitative[best_index_exploitative]:\n                    best_index_exploitative = j\n\n                if evaluations >= self.budget:\n                    break\n\n            # Synergistic update\n            if fitness_exploratory[best_index_exploratory] < fitness_exploitative[best_index_exploitative]:\n                best_overall = pos_exploratory[best_index_exploratory]\n            else:\n                best_overall = pos_exploitative[best_index_exploitative]\n\n        return best_overall, min(fitness_exploratory[best_index_exploratory], fitness_exploitative[best_index_exploitative])\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def random_mutation(self, quantum_bits):\n        mutation_factor = np.random.uniform(-0.5, 0.5, size=quantum_bits.shape)\n        new_bits = quantum_bits + mutation_factor\n        new_bits = np.clip(new_bits, 0, 1)\n        return new_bits\n\n    def gradient_ascent(self, quantum_bits, reference_bits):\n        delta_theta = self.alpha * (reference_bits - quantum_bits)\n        new_bits = quantum_bits + delta_theta\n        new_bits = np.clip(new_bits, 0, 1)\n        return new_bits", "name": "DualPopulationCoEvolutionaryAlgorithm", "description": "Dual-Population Co-evolutionary Algorithm (DPCA) utilizing two distinct populations for exploration-exploitation balance, with synergy-driven convergence to enhance optimization.", "configspace": "", "generation": 42, "fitness": 0.6567813965963551, "feedback": "The algorithm DualPopulationCoEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.10.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.7527693521911785, 0.5607934410015318]}, "mutation_prompt": null}
{"id": "4d59bceb-ed70-401c-a152-98d2754991af", "solution": "import numpy as np\n\nclass BioInspiredSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pheromone_trail = np.ones((self.population_size, self.dim))\n        self.evaporation_rate = 0.1\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        position_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        global_best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Generate candidate solution based on pheromone trail and local position adaptation\n                candidate_position = self.generate_position(i, global_best_position, lb, ub)\n                new_fitness = func(candidate_position)\n                evaluations += 1\n\n                # Update pheromone trails and learning\n                self.update_pheromone(i, candidate_position, new_fitness < fitness[i])\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    position_population[i] = candidate_position\n\n                # Update global best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    global_best_position = candidate_position\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, fitness[best_index]\n\n    def generate_position(self, i, global_best_position, lb, ub):\n        # Generate new position using pheromone trail influence and adaptive learning\n        direction = np.random.choice([-1, 1], self.dim)\n        influence = self.pheromone_trail[i]\n        candidate = influence * direction * (global_best_position - self.learning_rate * influence)\n        candidate_position = np.clip(candidate, lb, ub) \n        return candidate_position\n\n    def update_pheromone(self, i, candidate_position, is_improved):\n        # Update pheromone trail based on solution improvement\n        if is_improved:\n            self.pheromone_trail[i] = (1 - self.evaporation_rate) * self.pheromone_trail[i] + self.evaporation_rate * candidate_position\n        else:\n            self.pheromone_trail[i] *= (1 - self.evaporation_rate)", "name": "BioInspiredSwarmOptimizer", "description": "Bio-inspired Swarm-Based Algorithm using dynamic pheromone trails and adaptive learning for robust global optimization.", "configspace": "", "generation": 43, "fitness": 0.45779888330378254, "feedback": "The algorithm BioInspiredSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.02.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.43680473014286003, 0.47879303646470506]}, "mutation_prompt": null}
{"id": "7caec712-9c7e-4c7f-aef7-fbc8ae550cad", "solution": "import numpy as np\n\nclass QuantumParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.gamma = 1.5  # Attraction strength\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = np.random.rand(self.swarm_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.swarm_size, self.dim) * 0.1 * (ub - lb)\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        evaluations = self.swarm_size\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                # Quantum potential-based velocity update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.alpha * velocities[i]\n                                 + self.beta * r1 * (personal_best_positions[i] - positions[i])\n                                 + self.gamma * r2 * (global_best_position - positions[i]))\n\n                # Update position\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n                \n                # Evaluate new position\n                fitness = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = positions[i]\n\n                # Update global best\n                if fitness < personal_best_scores[global_best_index]:\n                    global_best_index = i\n                    global_best_position = positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "QuantumParticleSwarmOptimization", "description": "Quantum Particle Swarm Optimization (QPSO) leveraging quantum potential fields and swarm intelligence for enhanced exploration and exploitation in high-dimensional search spaces.", "configspace": "", "generation": 44, "fitness": 0.9327759142388011, "feedback": "The algorithm QuantumParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.03.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.9674356901183687, 0.8981161383592335]}, "mutation_prompt": null}
{"id": "9a3c0387-aeaf-4824-86e6-a3a2fd9783fc", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha_init = 0.5\n        self.beta_init = 0.5\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        alpha = self.alpha_init\n        beta = self.beta_init\n\n        while evaluations < self.budget:\n            diversity = self.calculate_diversity(position_population)\n            if diversity < self.diversity_threshold:\n                alpha, beta = self.adapt_parameters(alpha, beta, increase=True)\n            else:\n                alpha, beta = self.adapt_parameters(alpha, beta, increase=False)\n\n            for i in range(self.population_size):\n                if np.random.rand() < alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], beta)\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, beta):\n        delta_theta = beta * (best_quantum_bits - quantum_bits) + (np.random.rand(self.dim) - 0.5) * 0.1\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def adapt_parameters(self, alpha, beta, increase):\n        factor = 0.1\n        if increase:\n            alpha = min(1.0, alpha + factor)\n            beta = min(1.0, beta + factor)\n        else:\n            alpha = max(0.0, alpha - factor)\n            beta = max(0.0, beta - factor)\n        return alpha, beta\n\n    def calculate_diversity(self, population):\n        mean_position = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_position, axis=1))\n        return diversity", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-Inspired Evolutionary Algorithm (EQEA) with adaptive parameter tuning and a diversity-maintaining mechanism for improved exploration and convergence.", "configspace": "", "generation": 45, "fitness": 0.5489039039015993, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.5401104877735605, 0.557697320029638]}, "mutation_prompt": null}
{"id": "0427a430-8f01-43d6-bc03-ee4d0221138f", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive parameter adjustments based on evaluations\n                self.alpha = 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n                # Quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Quantum mutation\n                if np.random.rand() < self.mutation_rate:\n                    quantum_population[i] = self.mutate_quantum_bits(quantum_population[i])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def mutate_quantum_bits(self, quantum_bits):\n        # Apply a mutation by a small random perturbation\n        mutation_strength = 0.05\n        mutation = mutation_strength * (np.random.rand(*quantum_bits.shape) - 0.5)\n        mutated_quantum_bits = quantum_bits + mutation\n        mutated_quantum_bits = np.clip(mutated_quantum_bits, 0, 1)\n        return mutated_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-Inspired Evolutionary Algorithm (QEA) utilizing adaptive parameters and quantum-based mutation for improved global search efficiency.", "configspace": "", "generation": 46, "fitness": 0.8606997329648491, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86 with standard deviation 0.07.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.7924982020429885, 0.9289012638867098]}, "mutation_prompt": null}
{"id": "f2d894c2-0334-431c-9537-3efc96bbcb79", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.max_population_size = 10 * dim\n        self.min_population_size = max(5, int(0.1 * dim))\n        self.alpha = 0.5\n        self.beta_initial = 0.5\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.max_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        self.evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while self.evaluations < self.budget:\n            # Dynamically adjust the population size\n            population_size = self.adjust_population_size(population_size)\n            quantum_population, position_population, fitness = self.trim_population(quantum_population, position_population, fitness, population_size)\n\n            for i in range(population_size):\n                # Use dynamic quantum rotation influenced by the fitness landscape\n                beta = self.beta_initial * (1 - self.evaluations / self.budget)\n                \n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], beta)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                self.evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if self.evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, beta):\n        # Quantum rotation gate inspired update with dynamic beta\n        delta_theta = beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def adjust_population_size(self, current_size):\n        # Gradually reduce population size as evaluations progress\n        reduction_rate = (self.max_population_size - self.min_population_size) / self.budget\n        new_size = self.max_population_size - int(reduction_rate * self.evaluations)\n        return max(self.min_population_size, new_size)\n\n    def trim_population(self, quantum_pop, position_pop, fitness, new_size):\n        # Trim population arrays to the new size\n        quantum_pop = quantum_pop[:new_size]\n        position_pop = position_pop[:new_size]\n        fitness = fitness[:new_size]\n        return quantum_pop, position_pop, fitness", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "An Enhanced Quantum-Inspired Evolutionary Algorithm (EQEA) utilizing dynamic quantum rotation angles and adaptive population size for improved convergence efficiency.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 7 is out of bounds for axis 0 with size 7').", "error": "IndexError('index 7 is out of bounds for axis 0 with size 7')", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {}, "mutation_prompt": null}
{"id": "9a44372c-4b8f-4300-9b42-8984295c8318", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.local_search_intensity = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + np.random.rand(self.population_size, self.dim) * (ub - lb)\n        velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) * 0.1\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - positions[i]))\n                positions[i] = positions[i] + velocities[i]\n\n                # Apply boundary constraints\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                new_score = func(positions[i])\n                evaluations += 1\n\n                # Check if current position is a new personal best\n                if new_score < personal_best_scores[i]:\n                    personal_best_scores[i] = new_score\n                    personal_best_positions[i] = positions[i]\n\n                # Check if current position is a new global best\n                if new_score < personal_best_scores[global_best_index]:\n                    global_best_index = i\n                    global_best_position = positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Perform local search intensification\n            if np.random.rand() < self.local_search_intensity:\n                local_best_index = np.random.randint(self.population_size)\n                local_best_position = personal_best_positions[local_best_index]\n                local_search_radius = (ub - lb) * 0.05\n                for j in range(self.dim):\n                    perturbed_position = local_best_position + np.random.uniform(-local_search_radius[j], local_search_radius[j])\n                    perturbed_position = np.clip(perturbed_position, lb[j], ub[j])\n                    perturbed_score = func(perturbed_position)\n                    evaluations += 1\n                    \n                    if perturbed_score < personal_best_scores[local_best_index]:\n                        personal_best_scores[local_best_index] = perturbed_score\n                        personal_best_positions[local_best_index] = perturbed_position\n\n                    if perturbed_score < personal_best_scores[global_best_index]:\n                        global_best_index = local_best_index\n                        global_best_position = perturbed_position\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "AdaptiveParticleSwarmOptimization", "description": "Adaptive Particle Swarm Optimization (APSO) with local search intensification for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 48, "fitness": 0.8753363853153229, "feedback": "The algorithm AdaptiveParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.8849722497288005, 0.8657005209018452]}, "mutation_prompt": null}
{"id": "0722ca52-561a-45a5-967e-ad6cbb7bdd3c", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.initial_beta = 0.5\n        self.beta = self.initial_beta\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        generation = 0\n        while evaluations < self.budget:\n            self.update_beta(generation)\n            for i in range(self.population_size):\n                # Quantum rotation gate: update quantum bits\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Increase generation counter to adjust beta\n            generation += 1\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Quantum rotation gate inspired update with adaptive beta\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def update_beta(self, generation):\n        # Adaptive beta adjustment based on generation\n        self.beta = self.initial_beta * (1 - generation / (self.budget // self.population_size))", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-Inspired Evolutionary Algorithm incorporating adaptive beta and diversity preservation to improve convergence and exploration balance.", "configspace": "", "generation": 49, "fitness": 0.49810799581007265, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.05.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.4455843584951007, 0.5506316331250446]}, "mutation_prompt": null}
{"id": "f98e3031-1ee1-494a-964a-9c7ab9f9c204", "solution": "import numpy as np\n\nclass MultiScaleAdaptiveQuantumSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.8\n        self.beta = 0.2\n        self.gamma = 0.5\n        self.scaling_factor = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], i)\n                if np.random.rand() < self.gamma:\n                    quantum_population[i] = self.local_search(quantum_population[i])\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, index):\n        influence_scale = self.scaling_factor * (1.0 - index / self.population_size)\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits) * influence_scale\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def local_search(self, quantum_bits):\n        locality_factor = (np.random.rand(self.dim) - 0.5) * self.scaling_factor\n        local_adjusted_bits = quantum_bits + locality_factor\n        local_adjusted_bits = np.clip(local_adjusted_bits, 0, 1)\n        return local_adjusted_bits", "name": "MultiScaleAdaptiveQuantumSwarmOptimization", "description": "Multi-Scale Adaptive Quantum Swarm Optimization (MSAQSO) enhances global and local exploration using adaptive scales in quantum behavior and dynamic swarm influence.", "configspace": "", "generation": 50, "fitness": 0.6380153654236493, "feedback": "The algorithm MultiScaleAdaptiveQuantumSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.02.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.6592789579198111, 0.6167517729274876]}, "mutation_prompt": null}
{"id": "68bb2390-028c-41f3-9dcd-8c8bf80440a6", "solution": "import numpy as np\n\nclass SwarmBasedQuantumParticleOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 8 * dim\n        self.alpha = 0.4\n        self.beta = 0.6\n        self.inertia_weight = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_swarm = np.random.rand(self.swarm_size, self.dim)\n        velocity_swarm = np.zeros((self.swarm_size, self.dim))\n        position_swarm = self.quantum_to_position(quantum_swarm, lb, ub)\n        fitness = np.array([func(ind) for ind in position_swarm])\n        evaluations = self.swarm_size\n        \n        personal_best_position = np.copy(position_swarm)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = position_swarm[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                # Update velocity using cognitive and social components\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.cognitive * r1 * (personal_best_position[i] - position_swarm[i])\n                social_component = self.social * r2 * (global_best_position - position_swarm[i])\n                velocity_swarm[i] = (self.inertia_weight * velocity_swarm[i] +\n                                     cognitive_component + social_component)\n                \n                # Update quantum bits with velocity influence\n                if np.random.rand() < self.alpha:\n                    quantum_swarm[i] = self.update_quantum_bits(quantum_swarm[i], global_best_position, velocity_swarm[i])\n\n                # Convert quantum representation to classical position\n                position_swarm[i] = self.quantum_to_position(quantum_swarm[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_swarm[i])\n                evaluations += 1\n\n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_position[i] = position_swarm[i]\n\n                # Update global best\n                if new_fitness < fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = position_swarm[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_fitness[global_best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_position, velocity):\n        # Update quantum bits influenced by classical velocity\n        delta_theta = self.beta * (best_position - quantum_bits) + velocity\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "SwarmBasedQuantumParticleOptimization", "description": "Swarm-based Quantum Particle Optimization utilizes quantum-inspired particle dynamics with adaptive memory and social interaction for efficient global exploration.", "configspace": "", "generation": 51, "fitness": 0.46644183277736595, "feedback": "The algorithm SwarmBasedQuantumParticleOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.01.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.45629750708446004, 0.47658615847027186]}, "mutation_prompt": null}
{"id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: adjust based on success rate\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm with adaptive quantum rotation to dynamically balance exploration and exploitation.", "configspace": "", "generation": 52, "fitness": 0.9663988243805807, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "57b11109-048c-41c6-a805-9a52e4ee6ba9", "metadata": {"aucs": [0.9711782328701244, 0.9616194158910369]}, "mutation_prompt": null}
{"id": "67adbe77-467a-465d-9df8-bc551d72111e", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.diversity_factor = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive quantum rotation with diversity enhancement\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Introduce random diversity to avoid local minima\n                if np.random.rand() < self.diversity_factor:\n                    quantum_population[i] = np.random.rand(self.dim)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Self-adjusting parameters based on convergence\n            self.alpha = self.adaptive_update(self.alpha, fitness)\n            self.beta = self.adaptive_update(self.beta, fitness)\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def adaptive_update(self, parameter, fitness):\n        # Dynamically adjust parameters based on the fitness landscape\n        improvement = (np.max(fitness) - np.min(fitness)) / (np.max(fitness) + 1e-9)\n        return parameter * (1 + self.adaptive_factor * (0.5 - improvement))", "name": "AdaptiveQuantumInspiredEvolutionaryAlgorithm", "description": "Adaptive Quantum-Inspired Evolutionary Algorithm with diversity maintenance and self-adjusting parameters to enhance global exploration and convergence.", "configspace": "", "generation": 53, "fitness": 0.7501437028095295, "feedback": "The algorithm AdaptiveQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.11.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6364614448379962, 0.8638259607810629]}, "mutation_prompt": null}
{"id": "c8cf4d4e-0882-406d-a48c-79ad4c28bceb", "solution": "import numpy as np\n\nclass AdaptiveLevySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 1.5  # Levy exponent\n        self.beta = 0.5   # Direct movement influence\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.randn(self.population_size, self.dim) * 0.1\n        fitness = np.array([func(ind) for ind in swarm])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = swarm[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                levy_jump = self.levy_flight(self.dim, self.alpha) * (swarm[best_index] - swarm[i])\n                velocities[i] = self.beta * velocities[i] + levy_jump\n                swarm[i] = swarm[i] + velocities[i]\n\n                # Ensure particles are within bounds\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(swarm[i])\n                evaluations += 1\n\n                # Update fitness and best position\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = swarm[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def levy_flight(self, dim, alpha):\n        # Generate a Levy flight step\n        sigma_u = (np.gamma(1 + alpha) * np.sin(np.pi * alpha / 2) / \n                   (np.gamma((1 + alpha) / 2) * alpha * 2 ** ((alpha - 1) / 2))) ** (1 / alpha)\n        u = np.random.randn(dim) * sigma_u\n        v = np.random.randn(dim)\n        step = u / np.abs(v) ** (1 / alpha)\n        return step", "name": "AdaptiveLevySwarmOptimizer", "description": "Bio-inspired Swarm Intelligence Algorithm leveraging adaptive levy flights and dynamic particle interactions for efficient global optimization in complex landscapes.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "5c798833-06d6-4c5c-b370-c537c9eb649c", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic quantum gap expansion for exploration\n            if evaluations % (self.budget // 10) == 0:\n                self.beta += self.learning_rate * (1 - evaluations / self.budget)\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm with Dynamic Quantum Gap Expansion to enhance exploration and adaptive learning rate to refine exploitation.", "configspace": "", "generation": 55, "fitness": 0.8559234807012799, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86 with standard deviation 0.06.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.7936655548579177, 0.9181814065446421]}, "mutation_prompt": null}
{"id": "f393f584-6a27-443a-90a5-9d71f805e511", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.de_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Apply adaptive quantum rotation\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Apply DE-inspired mutation and crossover\n                target_idx = np.random.randint(0, self.population_size)\n                r1, r2, r3 = np.random.choice([idx for idx in range(self.population_size) if idx != target_idx], 3, replace=False)\n                mutant = quantum_population[r1] + self.de_mutation_factor * (quantum_population[r2] - quantum_population[r3])\n                mutant = np.clip(mutant, 0, 1)\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, quantum_population[target_idx])\n                position_trial = self.quantum_to_position(trial, lb, ub)\n\n                # Evaluate the trial solution\n                new_fitness = func(position_trial)\n                evaluations += 1\n\n                # Selection: replace if trial is better\n                if new_fitness < fitness[target_idx]:\n                    quantum_population[target_idx] = trial\n                    fitness[target_idx] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = target_idx\n                    best_position = position_trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm with adaptive quantum rotation and differential evolution-inspired mutation to further enhance exploration and diversity.", "configspace": "", "generation": 56, "fitness": 0.9659366559149201, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9766407902467144, 0.9552325215831257]}, "mutation_prompt": null}
{"id": "c2efe21c-95a0-4043-9a49-374f5097fee9", "solution": "import numpy as np\n\nclass HybridQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.levy_flight_prob = 0.3\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.levy_flight_prob:\n                    quantum_population[i] = self.levy_flight(quantum_population[i])\n                elif np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def levy_flight(self, quantum_bits):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        levy_step = 0.01 * step\n        new_quantum_bits = quantum_bits + levy_step\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "HybridQuantumInspiredEvolutionaryAlgorithm", "description": "Hybrid Quantum-Inspired Evolutionary Algorithm with Lévy Flights for enhanced global exploration and adaptive exploitation.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "4891dfbf-9e71-45ef-8594-28f14f7bf918", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.tunneling_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: adjust based on success rate\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Stochastic tunneling for escaping local optima\n                if np.random.rand() < self.tunneling_factor:\n                    position_population[i] += np.random.normal(0, 0.1, self.dim) * (ub - lb)\n                    position_population[i] = np.clip(position_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithmV2", "description": "Enhanced Quantum-inspired Evolutionary Algorithm with dynamic adaptive quantum rotation and stochastic tunneling to escape local optima.", "configspace": "", "generation": 58, "fitness": 0.6753595083611866, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.04.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.636188161382184, 0.7145308553401892]}, "mutation_prompt": null}
{"id": "c68ecbbd-6525-4e0f-9a7f-36e8824067f4", "solution": "import numpy as np\n\nclass QuantumSwarmHarmonyAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.harmony_memory_size = 5 * dim\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.adap_factor = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        \n        harmony_memory = position_population[:self.harmony_memory_size]\n        harmony_fitness = fitness[:self.harmony_memory_size]\n        best_index = np.argmin(harmony_fitness)\n        best_position = harmony_memory[best_index]\n\n        while evaluations < self.budget:\n            new_harmony = np.empty(self.dim)\n            for d in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    selected_index = np.random.randint(0, self.harmony_memory_size)\n                    new_harmony[d] = harmony_memory[selected_index, d]\n                    if np.random.rand() < self.par:\n                        new_harmony[d] += np.random.uniform(-self.adap_factor, self.adap_factor) * (ub[d] - lb[d])\n                else:\n                    new_harmony[d] = np.random.uniform(lb[d], ub[d])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            evaluations += 1\n\n            if new_fitness < np.max(harmony_fitness):\n                worst_index = np.argmax(harmony_fitness)\n                harmony_memory[worst_index] = new_harmony\n                harmony_fitness[worst_index] = new_fitness\n\n            if new_fitness < harmony_fitness[best_index]:\n                best_index = np.argmin(harmony_fitness)\n                best_position = harmony_memory[best_index]\n\n            if evaluations >= self.budget:\n                break\n\n        return best_position, harmony_fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position", "name": "QuantumSwarmHarmonyAlgorithm", "description": "Quantum Swarm Harmony Algorithm combines quantum-inspired encoding with harmony search principles for enhanced global exploration and convergence speed.", "configspace": "", "generation": 59, "fitness": 0.8194425187683668, "feedback": "The algorithm QuantumSwarmHarmonyAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.04.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.77829355157748, 0.8605914859592536]}, "mutation_prompt": null}
{"id": "54ac7214-fbbe-4b02-b835-cf1ea19688d3", "solution": "import numpy as np\n\nclass QuantumParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 10 * dim\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.4\n        self.social_coefficient = 1.4\n        self.entanglement_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        position = np.random.rand(self.swarm_size, self.dim) * (ub - lb) + lb\n        velocity = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_position = np.copy(position)\n        personal_best_fitness = np.array([func(ind) for ind in position])\n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_position[global_best_index]\n        evaluations = self.swarm_size\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                # Update velocity with adaptive quantum entanglement\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_position[i] - position[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - position[i])\n                velocity[i] = (self.inertia_weight * velocity[i] \n                               + cognitive_velocity \n                               + social_velocity \n                               + self.entanglement_factor * (np.random.rand(self.dim) - 0.5))\n\n                # Update position\n                position[i] = position[i] + velocity[i]\n                position[i] = np.clip(position[i], lb, ub)\n\n                # Evaluate new position\n                fitness = func(position[i])\n                evaluations += 1\n\n                # Update personal best\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = position[i]\n\n                # Update global best\n                if fitness < personal_best_fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "QuantumParticleSwarmOptimization", "description": "Quantum Particle Swarm Optimization Algorithm with Adaptive Quantum Entanglement for Enhanced Global Exploration and Local Exploitation.", "configspace": "", "generation": 60, "fitness": 0.8642991638621321, "feedback": "The algorithm QuantumParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86 with standard deviation 0.09.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9511465189903063, 0.7774518087339579]}, "mutation_prompt": null}
{"id": "58e0efff-e33a-42c1-865b-e948ef68bebb", "solution": "import numpy as np\n\nclass QuantumAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.cr = 0.9  # Crossover probability\n        self.f = 0.8   # Differential weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Generate trial vector using Differential Evolution mechanism\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = quantum_population[idxs[0]], quantum_population[idxs[1]], quantum_population[idxs[2]]\n                mutant = self.mutate(a, b, c, self.f, best_index)\n                trial = self.crossover(quantum_population[i], mutant, self.cr)\n                \n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(trial, lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    quantum_population[i] = trial\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def mutate(self, a, b, c, f, best_index):\n        # Differential mutation with base vector selection\n        mutant = a + f * (b - c)\n        mutant = np.clip(mutant, 0, 1)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        # Uniform crossover\n        crossover_mask = np.random.rand(self.dim) < cr\n        trial = np.where(crossover_mask, mutant, target)\n        return trial", "name": "QuantumAdaptiveDifferentialEvolution", "description": "Quantum Adaptive Differential Evolution Algorithm combines quantum-inspired representation with differential evolution to enhance global search capabilities.", "configspace": "", "generation": 61, "fitness": 0.9174194839562737, "feedback": "The algorithm QuantumAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9304214667216847, 0.9044175011908627]}, "mutation_prompt": null}
{"id": "ea583dde-671e-4f35-a324-1faf13bb16f2", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            diversity = self.calculate_entropy(quantum_population)\n            for i in range(self.population_size):\n                # Entropy-based adjustment to promote diversity\n                if np.random.rand() < self.alpha * (1 + diversity):\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def calculate_entropy(self, quantum_population):\n        # Calculate entropy to measure diversity in the quantum population\n        epsilon = 1e-9\n        prob = np.mean(quantum_population, axis=0)\n        entropy = -np.sum(prob * np.log(prob + epsilon) + (1 - prob) * np.log(1 - prob + epsilon))\n        max_entropy = self.dim * np.log(2)\n        normalized_entropy = entropy / max_entropy  # normalize to [0,1]\n        return normalized_entropy", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-inspired Evolutionary Algorithm with entropy-based diversity maintenance to enhance robustness and exploration in high-dimensional spaces.", "configspace": "", "generation": 62, "fitness": 0.5398748681903255, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.02.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.5210643314087933, 0.5586854049718577]}, "mutation_prompt": null}
{"id": "58bde890-7851-4ba3-a634-56a84f042567", "solution": "import numpy as np\n\nclass QuantumAnnealingSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            new_population = []\n            for i in range(self.population_size):\n                parent1, parent2 = self.select_parents(fitness)\n                child = self.crossover(quantum_population[parent1], quantum_population[parent2])\n                child = self.mutate(child)\n                new_position = self.quantum_to_position(child, lb, ub)\n                new_fitness = func(new_position)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    new_population.append((child, new_fitness))\n                else:\n                    acceptance_prob = np.exp((fitness[i] - new_fitness) / (self.temperature + 1e-9))\n                    if np.random.rand() < acceptance_prob:\n                        new_population.append((child, new_fitness))\n                    else:\n                        new_population.append((quantum_population[i], fitness[i]))\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = new_position\n\n                if evaluations >= self.budget:\n                    break\n\n            quantum_population, fitness = zip(*new_population)\n            quantum_population = np.array(quantum_population)\n            fitness = np.array(fitness)\n            self.temperature *= self.cooling_rate\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def select_parents(self, fitness):\n        probabilities = 1 / (fitness - np.min(fitness) + 1e-9)\n        probabilities /= probabilities.sum()\n        return np.random.choice(range(self.population_size), size=2, p=probabilities, replace=False)\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand(self.dim)\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n\n    def mutate(self, child):\n        if np.random.rand() < self.mutation_rate:\n            mutation_vector = np.random.normal(0, 0.1, size=self.dim)\n            child = np.clip(child + mutation_vector, 0, 1)\n        return child", "name": "QuantumAnnealingSwarmOptimization", "description": "Quantum Annealing-based Swarm Optimization with adaptive crossover and mutation for enhanced diversity and convergence.", "configspace": "", "generation": 63, "fitness": 0.7446826098445023, "feedback": "The algorithm QuantumAnnealingSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.7534514514596569, 0.7359137682293476]}, "mutation_prompt": null}
{"id": "74d485d8-f48a-4f17-a227-b55d4d682372", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.group_size = max(1, dim // 5)  # Grouping dimensions for differential evolution\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Apply differential grouping for dimensionality reduction\n                groups = self.generate_groups()\n                for group in groups:\n                    if np.random.rand() < self.alpha:\n                        quantum_population[i][group] = self.update_quantum_bits(\n                            quantum_population[i][group],\n                            quantum_population[best_index][group],\n                            fitness, i\n                        )\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def generate_groups(self):\n        # Create groups of dimensions to apply differential grouping\n        indices = np.arange(self.dim)\n        np.random.shuffle(indices)\n        return [indices[i:i + self.group_size] for i in range(0, self.dim, self.group_size)]", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm with differential grouping for dimensionality reduction to improve convergence speed and solution quality.", "configspace": "", "generation": 64, "fitness": 0.5822325297235121, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58 with standard deviation 0.06.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6433505979656275, 0.5211144614813967]}, "mutation_prompt": null}
{"id": "95265dbf-99f8-42f7-b59b-732f57ef7c89", "solution": "import numpy as np\n\nclass RefinedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.elite_reeval_factor = 0.05  # Fraction of budget used for re-evaluating elite solutions\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        elite_count = int(self.elite_reeval_factor * self.budget)\n\n        while evaluations < self.budget - elite_count:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n                if np.random.rand() < self.alpha / 2:  # Introduce dual quantum update for diversity\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], np.random.choice(quantum_population), fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget - elite_count:\n                    break\n\n        reeval_indices = np.argsort(fitness)[:elite_count]\n        for idx in reeval_indices:\n            new_fitness = func(position_population[idx])\n            evaluations += 1\n            if new_fitness < fitness[idx]:\n                fitness[idx] = new_fitness\n                if new_fitness < fitness[best_index]:\n                    best_index = idx\n                    best_position = position_population[idx]\n\n            if evaluations >= self.budget:\n                break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, ref_quantum_bits, fitness, index):\n        delta_theta = self.beta * (ref_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        return np.clip(new_quantum_bits, 0, 1)", "name": "RefinedQuantumInspiredEvolutionaryAlgorithm", "description": "Adaptive Quantum-inspired Evolutionary Algorithm with dual quantum rotation and elite re-evaluation, optimizing balance between convergence and diversity.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "8bd0d247-f429-460d-b3b8-9992802eb3a2", "solution": "import numpy as np\n\nclass CooperativeMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.local_search_rate = 0.3\n        self.global_search_rate = 0.7\n        self.local_improvement_range = 0.1\n        self.global_mutation_strength = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(population)\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_rate:\n                    new_population[i] = self.local_improvement(population[i], lb, ub)\n                else:\n                    new_population[i] = self.global_search(population[i], lb, ub)\n\n                new_fitness = func(new_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_population[i]\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = new_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def local_improvement(self, position, lb, ub):\n        perturbation = np.random.uniform(-self.local_improvement_range, self.local_improvement_range, self.dim)\n        new_position = position + perturbation * (ub - lb)\n        new_position = np.clip(new_position, lb, ub)\n        return new_position\n\n    def global_search(self, position, lb, ub):\n        mutation = np.random.normal(0, self.global_mutation_strength, self.dim)\n        new_position = position + mutation * (ub - lb)\n        new_position = np.clip(new_position, lb, ub)\n        return new_position", "name": "CooperativeMemeticAlgorithm", "description": "Cooperative Memetic Algorithm with Dynamic Neighborhood Search, fusing local and global search strategies for enhanced solution quality and convergence speed.", "configspace": "", "generation": 66, "fitness": 0.8338533129428578, "feedback": "The algorithm CooperativeMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.16.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9941572389929946, 0.6735493868927209]}, "mutation_prompt": null}
{"id": "1cc9e4ed-28c7-4000-a7ce-e350e2c1909b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.elite_fraction = 0.1  # Fraction of population to retain as elite\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            # Retain elite individuals\n            elite_size = max(1, int(self.elite_fraction * self.population_size))\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_positions = position_population[elite_indices]\n            elite_fitnesses = fitness[elite_indices]\n\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: adjust based on success rate\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Maintain diversity by introducing elite solutions back into the population\n            if evaluations < self.budget:\n                replace_indices = np.argsort(-fitness)[:elite_size]\n                position_population[replace_indices] = elite_positions\n                fitness[replace_indices] = elite_fitnesses\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm with dynamic adaptation and elitism to enhance convergence speed and solution quality.", "configspace": "", "generation": 67, "fitness": 0.6657928412618536, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6755023473114266, 0.6560833352122806]}, "mutation_prompt": null}
{"id": "0be8e1e7-5b16-4be9-9054-4769e5ea360a", "solution": "import numpy as np\n\nclass QuantumHybridParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(position_population)\n        personal_best_fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n\n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive_component = self.cognitive_coef * np.random.rand(self.dim) * (personal_best_positions[i] - position_population[i])\n                social_component = self.social_coef * np.random.rand(self.dim) * (global_best_position - position_population[i])\n                velocities[i] = inertia + cognitive_component + social_component\n\n                # Update position\n                position_population[i] += velocities[i]\n                position_population[i] = np.clip(position_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = position_population[i]\n\n                # Update global best\n                if new_fitness < personal_best_fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_fitness[global_best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position", "name": "QuantumHybridParticleSwarmOptimization", "description": "Quantum-Hybrid Particle Swarm Optimization (QHPSO) integrates quantum-inspired initialization and updates with particle swarm dynamics to enhance convergence speed and solution quality.", "configspace": "", "generation": 68, "fitness": 0.9329860145075672, "feedback": "The algorithm QuantumHybridParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9231223457879532, 0.9428496832271813]}, "mutation_prompt": null}
{"id": "06ce4ae2-347a-4f94-b2cd-63ca90e8dfdc", "solution": "import numpy as np\n\nclass MetaLearningGuidedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.meta_learning_rate = 0.05\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    self.update_meta_learning(i, True)\n                else:\n                    self.update_meta_learning(i, False)\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def update_meta_learning(self, index, improvement):\n        if len(self.history) < self.population_size:\n            self.history.append((index, improvement))\n        else:\n            self.history[index] = (index, improvement)\n\n        success_rate = sum(1 for _, success in self.history if success) / len(self.history)\n        self.alpha = np.clip(self.alpha + self.meta_learning_rate * (success_rate - 0.5), 0.1, 0.9)", "name": "MetaLearningGuidedQuantumInspiredEvolutionaryAlgorithm", "description": "Meta-Learning Guided Quantum Inspired Evolutionary Algorithm, leveraging historical performance to adaptively modulate quantum rotation and enhance convergence.", "configspace": "", "generation": 69, "fitness": 0.6695991092402771, "feedback": "The algorithm MetaLearningGuidedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.08.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.7465921978671474, 0.592606020613407]}, "mutation_prompt": null}
{"id": "6e64b180-1070-4973-bc4e-e819f5bbb55e", "solution": "import numpy as np\n\nclass ImprovedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.crossover_prob = 0.7\n        self.mutation_factor = 0.8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            new_quantum_population = quantum_population.copy()\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: adjust based on success rate\n                if np.random.rand() < self.alpha:\n                    new_quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Differential Evolution crossover\n                if np.random.rand() < self.crossover_prob:\n                    r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                    trial_quantum_bits = quantum_population[r1] + self.mutation_factor * (quantum_population[r2] - quantum_population[r3])\n                    trial_quantum_bits = np.clip(trial_quantum_bits, 0, 1)\n                    new_quantum_population[i] = np.where(np.random.rand(self.dim) < self.crossover_prob, trial_quantum_bits, new_quantum_population[i])\n\n                # Convert to classical position\n                position_population[i] = self.quantum_to_position(new_quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    quantum_population[i] = new_quantum_population[i]\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "ImprovedQuantumInspiredEvolutionaryAlgorithm", "description": "Improved Quantum-inspired Evolutionary Algorithm utilizing self-adaptive quantum rotation and differential evolution-based crossover for enhanced exploration and exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.942048697292116, "feedback": "The algorithm ImprovedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9327205155285916, 0.9513768790556406]}, "mutation_prompt": null}
{"id": "f1afa149-3742-46d9-8b45-d0e3862721b0", "solution": "import numpy as np\n\nclass QuantumInspiredSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 2.0\n        self.swarm_coeff = 2.0\n        self.inertia_decay = 0.99\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        velocity = np.random.rand(self.population_size, self.dim) * 0.1\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        personal_best_position = np.copy(position_population)\n        fitness = np.array([func(ind) for ind in position_population])\n        personal_best_fitness = np.copy(fitness)\n        evaluations = self.population_size\n        global_best_index = np.argmin(fitness)\n        global_best_position = position_population[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity considering inertia, cognitive, and swarm components\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.cognitive_coeff * r1 * (personal_best_position[i] - position_population[i])\n                swarm_component = self.swarm_coeff * r2 * (global_best_position - position_population[i])\n                \n                velocity[i] = (self.inertia_weight * velocity[i] + cognitive_component + swarm_component)\n                velocity[i] = np.clip(velocity[i], -1, 1)\n\n                # Update position with velocity and quantum-inspired influence\n                quantum_population[i] = self.update_quantum_bits(quantum_population[i], velocity[i])\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_position[i] = position_population[i]\n\n                # Update global best\n                if new_fitness < personal_best_fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Decay inertia weight to balance exploration and exploitation\n            self.inertia_weight *= self.inertia_decay\n\n        return global_best_position, personal_best_fitness[global_best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        return lb + quantum_bits * (ub - lb)\n\n    def update_quantum_bits(self, quantum_bits, velocity):\n        new_quantum_bits = quantum_bits + velocity\n        return np.clip(new_quantum_bits, 0, 1)", "name": "QuantumInspiredSwarmOptimization", "description": "Quantum-Inspired Swarm Optimization using dynamic inertia and cognitive components to enhance convergence speed and solution diversity.", "configspace": "", "generation": 71, "fitness": 0.4751910807121846, "feedback": "The algorithm QuantumInspiredSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.06.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.5376375371476829, 0.41274462427668623]}, "mutation_prompt": null}
{"id": "7c2e434b-d73b-4262-99f6-59dd8011f96b", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices[0]], population[indices[1]], population[indices[2]]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = np.copy(population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                new_fitness = func(trial)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    population[i] = trial\n\n                    if new_fitness < fitness[best_index]:\n                        best_index = i\n                        best_individual = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive strategy adjustments\n            self.adaptive_strategy(fitness, best_index)\n\n        return best_individual, fitness[best_index]\n\n    def adaptive_strategy(self, fitness, best_index):\n        # Adjust F and CR based on progress\n        progress = (np.max(fitness) - fitness[best_index]) / (np.max(fitness) + 1e-9)\n        self.F = np.clip(self.F + self.adaptive_factor * (0.5 - progress), 0.1, 1.0)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (0.5 - progress), 0.1, 1.0)", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution Algorithm with adaptive crossover and mutation strategies for enhanced diversity and convergence.", "configspace": "", "generation": 72, "fitness": 0.9049885515664593, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.05.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.8594809819856188, 0.9504961211472998]}, "mutation_prompt": null}
{"id": "da26cf09-9841-426c-85fd-c93c2110b541", "solution": "import numpy as np\n\nclass AdaptiveSymbioticOrganismsSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.interaction_probability = 0.8\n        self.adaptation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                partner_index = np.random.choice(self.population_size)\n                if partner_index == i:\n                    continue\n\n                if np.random.rand() < self.interaction_probability:\n                    new_solution = self.mutualism_phase(population[i], population[partner_index], lb, ub)\n                else:\n                    new_solution = self.commensalism_phase(population[i], best_position, lb, ub)\n\n                new_fitness = func(new_solution)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    population[i] = new_solution\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = new_solution\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive interaction probability\n            self.interaction_probability = min(1.0, self.interaction_probability + self.adaptation_rate * (1 - np.mean(fitness) / (np.min(fitness) + 1e-9)))\n\n        return best_position, fitness[best_index]\n\n    def mutualism_phase(self, organism, partner, lb, ub):\n        common_benefit = (organism + partner) / 2\n        new_solution = organism + np.random.rand() * (common_benefit - organism)\n        return np.clip(new_solution, lb, ub)\n\n    def commensalism_phase(self, organism, best_organism, lb, ub):\n        new_solution = organism + np.random.uniform(-1, 1, self.dim) * (best_organism - organism)\n        return np.clip(new_solution, lb, ub)", "name": "AdaptiveSymbioticOrganismsSearch", "description": "Adaptive Symbiotic Organisms Search with dynamic partner selection to enhance solution diversity and convergence speed.", "configspace": "", "generation": 73, "fitness": 0.6467730272770004, "feedback": "The algorithm AdaptiveSymbioticOrganismsSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.24.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.8844372195260479, 0.4091088350279528]}, "mutation_prompt": null}
{"id": "f6e689ff-7a9b-4201-980c-4a16842eabe4", "solution": "import numpy as np\n\nclass RefinedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.diversity_threshold = 0.1\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        diversity_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    diversity_counter = 0\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n                    self.learning_rate = max(self.learning_rate * 0.99, 0.01)\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.abs(new_fitness - fitness[i]) < self.diversity_threshold:\n                    diversity_counter += 1\n                    if diversity_counter > self.population_size:\n                        quantum_population = np.random.rand(self.population_size, self.dim)\n                        position_population = self.quantum_to_position(quantum_population, lb, ub)\n                        diversity_counter = 0\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + self.learning_rate * adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "RefinedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm with diversity-preserving mechanisms and adaptive learning rate to enhance convergence speed and solution quality.", "configspace": "", "generation": 74, "fitness": 0.5225070972890069, "feedback": "The algorithm RefinedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.04.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.5631810918763975, 0.4818331027016164]}, "mutation_prompt": null}
{"id": "e3bfe638-4e39-4a71-90cd-708125899163", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.diversity_threshold = 0.1  # New: threshold to trigger diversity preservation\n        self.population_scaling_factor = 0.05  # New: factor for scaling population size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.measure_diversity(position_population, lb, ub) < self.diversity_threshold:\n                quantum_population = self.maintain_diversity(quantum_population, population_size)\n            \n            population_size = int(self.initial_population_size * (1 + self.population_scaling_factor * (evaluations / self.budget)))\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def measure_diversity(self, position_population, lb, ub):\n        spread = np.ptp(position_population, axis=0) / (ub - lb)\n        return np.mean(spread)\n\n    def maintain_diversity(self, quantum_population, population_size):\n        perturbation = np.random.uniform(-0.1, 0.1, quantum_population.shape)\n        perturbed_population = quantum_population + perturbation\n        return np.clip(perturbed_population, 0, 1)", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm with diversity preservation and dynamic population scaling to improve convergence and avoid premature convergence.", "configspace": "", "generation": 75, "fitness": 0.7101568182276284, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6976888448353555, 0.7226247916199013]}, "mutation_prompt": null}
{"id": "7b53ce50-b0cf-4e04-b285-9f778718b608", "solution": "import numpy as np\n\nclass AugmentedQuantumInspiredAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.swarm_factor = 0.3\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        global_best = best_position.copy()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: adjust based on success rate\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Swarm learning: incorporate global best particle information\n                if np.random.rand() < self.swarm_factor:\n                    quantum_population[i] = self.learn_from_swarm(quantum_population[i], global_best)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n                    if new_fitness < func(global_best):\n                        global_best = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def learn_from_swarm(self, quantum_bits, global_best_quantum_bits):\n        # Swarm learning interaction based on global best particle\n        influence_factor = np.random.rand(self.dim)\n        new_quantum_bits = quantum_bits + self.swarm_factor * influence_factor * (global_best_quantum_bits - quantum_bits)\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "AugmentedQuantumInspiredAlgorithm", "description": "Augmented Quantum-Inspired Algorithm with Swarm Learning for enhanced exploration through shared intelligence from particle interactions.", "configspace": "", "generation": 76, "fitness": 0.5458855721427317, "feedback": "The algorithm AugmentedQuantumInspiredAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.555640593917413, 0.5361305503680504]}, "mutation_prompt": null}
{"id": "b561ab88-87b9-4b27-a174-4b5d838b37a5", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.6  # Increased for more exploration\n        self.beta = 0.6  # Increased to adapt faster\n        self.adaptive_factor = 0.15  # Increased for more responsive adaptation\n        self.mutation_rate = 0.1  # New parameter for diversity enhancement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive quantum rotation with mutation\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n                if np.random.rand() < self.mutation_rate:\n                    quantum_population[i] = self.mutate_quantum_bits(quantum_population[i])\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def mutate_quantum_bits(self, quantum_bits):\n        mutation_vector = np.random.normal(0, 0.1, size=self.dim)\n        new_quantum_bits = quantum_bits + mutation_vector\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithmV2", "description": "Quantum-inspired Evolutionary Algorithm with enhanced adaptive quantum rotation and fitness-based dynamic adaptation for improved exploration-exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.8492091647333013, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.13.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9782177105649841, 0.7202006189016186]}, "mutation_prompt": null}
{"id": "0c4219c6-0119-4f2a-bcbb-1ad21f2ed482", "solution": "import numpy as np\n\nclass MultiMemoryAdaptiveParticleOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.memory_coeff = 0.5\n        self.decay_rate = 0.99\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        position_population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocity_population = np.random.rand(self.population_size, self.dim) * (ub - lb) * 0.1\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n\n        personal_best_positions = np.copy(position_population)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = position_population[global_best_index]\n\n        historical_best_positions = np.copy(personal_best_positions)\n        historical_best_fitness = np.copy(personal_best_fitness)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia = self.inertia_weight * velocity_population[i]\n                cognitive = self.cognitive_coeff * r1 * (personal_best_positions[i] - position_population[i])\n                social = self.social_coeff * r2 * (global_best_position - position_population[i])\n\n                memory_r = np.random.rand()\n                memory_effect = self.memory_coeff * memory_r * (historical_best_positions[i] - position_population[i])\n                velocity_population[i] = inertia + cognitive + social + memory_effect\n\n                position_population[i] += velocity_population[i]\n                position_population[i] = np.clip(position_population[i], lb, ub)\n\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = position_population[i]\n\n                if new_fitness < historical_best_fitness[i]:\n                    historical_best_fitness[i] = new_fitness\n                    historical_best_positions[i] = position_population[i]\n\n                if new_fitness < fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= self.decay_rate\n\n        return global_best_position, fitness[global_best_index]", "name": "MultiMemoryAdaptiveParticleOptimization", "description": "Multi-Memory Adaptive Particle Optimization with Memory-Driven Perturbations, leveraging both historical best solutions and dynamic perturbations for enhanced exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.6908183785273003, "feedback": "The algorithm MultiMemoryAdaptiveParticleOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6991192489877764, 0.6825175080668242]}, "mutation_prompt": null}
{"id": "4fe6179b-4a9c-4bbe-9b2a-6ea10d1c3d6c", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20 * dim\n        self.quantum_entropy_factor = 0.1\n        self.global_attraction_weight = 0.9\n        self.personal_attraction_weight = 1.4\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particle_positions = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        particle_velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        personal_best_positions = np.copy(particle_positions)\n        personal_best_scores = np.array([func(ind) for ind in particle_positions])\n        evaluations = self.population_size\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update particle velocity with quantum-inspired dynamics\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.personal_attraction_weight * r1 * (personal_best_positions[i] - particle_positions[i])\n                social_component = self.global_attraction_weight * r2 * (global_best_position - particle_positions[i])\n                quantum_component = self.quantum_entropy_factor * np.random.randn(self.dim) * (ub - lb)\n                \n                particle_velocities[i] = 0.5 * particle_velocities[i] + cognitive_component + social_component + quantum_component\n                particle_positions[i] += particle_velocities[i]\n                particle_positions[i] = np.clip(particle_positions[i], lb, ub)\n\n                # Evaluate new position\n                current_score = func(particle_positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = particle_positions[i]\n\n                # Update global best\n                if current_score < personal_best_scores[global_best_index]:\n                    global_best_index = i\n                    global_best_position = particle_positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) incorporating quantum superposition and entanglement concepts for guided exploration and robust convergence.", "configspace": "", "generation": 79, "fitness": 0.836314156392443, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84 with standard deviation 0.08.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.7608318337964136, 0.9117964789884725]}, "mutation_prompt": null}
{"id": "fbfb3929-4f97-41f9-b058-ab4e9e42aa69", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.1\n        self.adaptive_factor = 0.1\n        self.diversity_factor = 0.05  # Parameter to maintain diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive quantum rotation gate: adjust based on success rate\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Introduce diversity by perturbing some quantum bits\n                if np.random.rand() < self.diversity_factor:\n                    quantum_population[i] += self.diversity_factor * (np.random.rand(self.dim) - 0.5)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update with learning rate adjustment\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm with diversity preservation and adaptive learning rates to improve exploration and convergence.", "configspace": "", "generation": 80, "fitness": 0.6889106121284632, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.02.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.672368113728, 0.7054531105289263]}, "mutation_prompt": null}
{"id": "3303f884-ce96-414b-bf89-0b15f34c4459", "solution": "import numpy as np\n\nclass QuantumParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 10 * dim\n        self.alpha = 0.5  # Exploration factor\n        self.phi_p = 1.5  # Personal influence\n        self.phi_g = 1.5  # Global influence\n        self.quantum_adjustment = 0.1\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_states = np.random.rand(self.swarm_size, self.dim)\n        positions = self.quantum_to_position(quantum_states, lb, ub)\n        velocities = np.random.rand(self.swarm_size, self.dim) * (ub - lb) / 10\n        fitness = np.array([func(pos) for pos in positions])\n        evaluations = self.swarm_size\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                # Update velocities based on personal and global best\n                inertia = velocities[i]\n                cognitive_component = self.phi_p * np.random.rand(self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = self.phi_g * np.random.rand(self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia + cognitive_component + social_component\n                \n                # Quantum state adjustment for balance\n                quantum_adjustment = self.alpha * (global_best_position - positions[i]) * self.quantum_adjustment\n                quantum_states[i] = np.clip(quantum_states[i] + quantum_adjustment, 0, 1)\n                \n                # Update positions\n                positions[i] = self.quantum_to_position(quantum_states[i], lb, ub) + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = positions[i]\n\n                # Update global best\n                if new_fitness < fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, fitness[global_best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position", "name": "QuantumParticleSwarmOptimization", "description": "Quantum Particle Swarm Optimization with Adaptive Quantum State Adjustments to Balance Exploration and Exploitation.", "configspace": "", "generation": 81, "fitness": 0.7004366668405819, "feedback": "The algorithm QuantumParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.7094486242547838, 0.6914247094263799]}, "mutation_prompt": null}
{"id": "a35be6a0-4480-45ae-9719-f9edb6970163", "solution": "import numpy as np\n\nclass AdvancedQuantumEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.elite_fraction = 0.1  # Fraction of the population considered elite\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        elite_size = max(1, int(self.elite_fraction * self.population_size))\n        \n        while evaluations < self.budget:\n            elite_indices = np.argsort(fitness)[:elite_size]\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[elite_indices], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return position_population[best_index], fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        return lb + quantum_bits * (ub - lb)\n\n    def update_quantum_bits(self, quantum_bits, elite_quantum_bits, fitness, index):\n        elite_best_bits = elite_quantum_bits[np.random.choice(elite_quantum_bits.shape[0])]\n        delta_theta = self.beta * (elite_best_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "AdvancedQuantumEvolutionaryAlgorithm", "description": "Advanced Quantum-Evolutionary Algorithm with dynamic learning coefficients and elite offspring to enhance convergence speed and solution quality.", "configspace": "", "generation": 82, "fitness": 0.9628589409315514, "feedback": "The algorithm AdvancedQuantumEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9550448365614124, 0.9706730453016905]}, "mutation_prompt": null}
{"id": "d5c5e0c9-96ec-49e6-b163-8acf8ff012d0", "solution": "import numpy as np\n\nclass ImprovedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.elitism_rate = 0.2\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        elite_size = int(self.elitism_rate * self.population_size)\n        \n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        \n        while evaluations < self.budget:\n            # Preserve elite members\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_quantum = quantum_population[elite_indices]\n            \n            for i in range(self.population_size):\n                if i not in elite_indices:\n                    # Adaptive quantum rotation gate with diversity preservation\n                    if np.random.rand() < self.alpha:\n                        quantum_population[i] = self.update_quantum_bits(\n                            quantum_population[i], quantum_population[best_index], fitness, i)\n                    \n                    # Convert quantum representation to classical position\n                    position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                    \n                    # Evaluate new position\n                    new_fitness = func(position_population[i])\n                    evaluations += 1\n                    \n                    # Selection: keep the better solution\n                    if new_fitness < fitness[i]:\n                        fitness[i] = new_fitness\n\n                    # Update best position\n                    if new_fitness < fitness[best_index]:\n                        best_index = i\n                        best_position = position_population[i]\n                    \n                    # Diversity enhancement\n                    if np.std(position_population, axis=0).mean() < self.diversity_threshold:\n                        quantum_population[i] = np.random.rand(self.dim)\n\n                if evaluations >= self.budget:\n                    break\n\n            # Reinsert elite solutions\n            quantum_population[:elite_size] = elite_quantum\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "ImprovedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm with adaptive elitism and diversity preservation for enhanced convergence and global exploration.", "configspace": "", "generation": 83, "fitness": 0.8760730048054379, "feedback": "The algorithm ImprovedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.07.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9447858703214709, 0.8073601392894049]}, "mutation_prompt": null}
{"id": "0e364aff-fd0f-4386-a8dc-f3dedd2d0503", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = position_population[idxs]\n                mutant = np.clip(x1 + self.F * (x2 - x3), lb, ub)\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, position_population[i])\n\n                new_fitness = func(trial)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    position_population[i] = trial\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution (QIDE) incorporating adaptive mutation and crossover for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 84, "fitness": 0.9349951936142469, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9434723302820016, 0.926518056946492]}, "mutation_prompt": null}
{"id": "b2cc8e66-9f6c-4b84-883c-5b53f5a24797", "solution": "import numpy as np\n\nclass HybridQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.niching_radius = 0.1 * (func.bounds.ub - func.bounds.lb)\n        self.niche_capacity = int(0.1 * self.population_size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.dynamic_niching(quantum_population, position_population, fitness)\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def dynamic_niching(self, quantum_population, position_population, fitness):\n        niches = []\n        for i, pos in enumerate(position_population):\n            placed_in_niche = False\n            for niche in niches:\n                if np.linalg.norm(pos - niche['center']) < self.niching_radius:\n                    if len(niche['members']) < self.niche_capacity:\n                        niche['members'].append(i)\n                    placed_in_niche = True\n                    break\n\n            if not placed_in_niche:\n                niches.append({'center': pos, 'members': [i]})\n\n        for niche in niches:\n            niche_fitness = [fitness[i] for i in niche['members']]\n            best_niche_index = niche['members'][np.argmin(niche_fitness)]\n            quantum_population[niche['members']] = quantum_population[best_niche_index]", "name": "HybridQuantumInspiredEvolutionaryAlgorithm", "description": "Hybrid Quantum-inspired Evolutionary Algorithm with Dynamic Niching and Adaptive Quantum Rotation for improved diversity and convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "eacb36d2-1775-4648-99aa-7f4dac4c0c7d", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.mutation_rate = 0.1\n        self.dynamic_population = True\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            if self.dynamic_population and evaluations > self.budget / 2:\n                population_size = max(5, population_size // 2)\n\n            for i in range(population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                if np.random.rand() < self.mutation_rate:\n                    quantum_population[i] = self.mutate_quantum_bits(quantum_population[i])\n                \n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def mutate_quantum_bits(self, quantum_bits):\n        mutation_strength = np.random.randn(*quantum_bits.shape) * 0.05\n        mutated_quantum_bits = quantum_bits + mutation_strength\n        mutated_quantum_bits = np.clip(mutated_quantum_bits, 0, 1)\n        return mutated_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm with Adaptive Mutation and Dynamic Population for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 86, "fitness": 0.9059624181738926, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.09.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [1.0, 0.8119248363477851]}, "mutation_prompt": null}
{"id": "85de4b73-5e89-4e84-8fa1-67ac86ec5e33", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.rotation_adaptive_factor = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                success_rate = np.mean(fitness < fitness[i])\n                \n                if np.random.rand() < self.alpha * (1 - success_rate):\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i, success_rate)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index, success_rate):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        rotation_effect = self.rotation_adaptive_factor * (1 - success_rate)\n        new_quantum_bits = quantum_bits + adaptive_delta + rotation_effect\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-inspired Evolutionary Algorithm with Dual Adaptive Strategies for enhanced convergence through dual progression balancing and fitness-driven adaptation.", "configspace": "", "generation": 87, "fitness": 0.5888648218301001, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.03.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.619642665468138, 0.5580869781920623]}, "mutation_prompt": null}
{"id": "70cc1904-2893-4e9e-ad79-f3d774b37aab", "solution": "import numpy as np\n\nclass QuantumInterferenceOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.interference_strength = 0.5\n        self.mutation_rate = 0.1\n        self.phase_shift = np.pi / 4\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            new_quantum_population = self.apply_interference_pattern(quantum_population, best_index)\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    new_quantum_population[i] = self.mutate_quantum_bits(new_quantum_population[i])\n\n                position_population[i] = self.quantum_to_position(new_quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    quantum_population[i] = new_quantum_population[i]\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def apply_interference_pattern(self, quantum_population, best_index):\n        best_quantum_bits = quantum_population[best_index]\n        interference_population = quantum_population + self.interference_strength * np.sin(2 * np.pi * (quantum_population - best_quantum_bits) + self.phase_shift)\n        interference_population = np.clip(interference_population, 0, 1)\n        return interference_population\n\n    def mutate_quantum_bits(self, quantum_bits):\n        mutation_vector = np.random.normal(0, 0.1, size=self.dim)\n        mutated_bits = quantum_bits + mutation_vector\n        mutated_bits = np.clip(mutated_bits, 0, 1)\n        return mutated_bits", "name": "QuantumInterferenceOptimization", "description": "Quantum Interference-Inspired Optimization Algorithm using interference patterns to explore and exploit the solution space dynamically.", "configspace": "", "generation": 88, "fitness": 0.5536189683749341, "feedback": "The algorithm QuantumInterferenceOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.08.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6364614448379962, 0.470776491911872]}, "mutation_prompt": null}
{"id": "dbefa3ab-bb9c-4ea5-af22-62f5a53017c4", "solution": "import numpy as np\n\nclass RefinedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.learning_rate = 0.1  # New parameter for learning adaptation\n        self.hyperparameter_tuning()\n\n    def hyperparameter_tuning(self):\n        # Method to adaptively tune hyperparameters based on budget and dimension\n        self.alpha = np.clip(self.alpha + self.learning_rate * np.random.randn(), 0.1, 0.9)\n        self.beta = np.clip(self.beta + self.learning_rate * np.random.randn(), 0.1, 0.9)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            self.hyperparameter_tuning()  # Update hyperparameters dynamically\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "RefinedQuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-inspired Evolutionary Algorithm with adaptive learning and hyperparameter tuning for enhanced convergence.", "configspace": "", "generation": 89, "fitness": 0.7004716830058381, "feedback": "The algorithm RefinedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.03.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6731413322102748, 0.7278020338014013]}, "mutation_prompt": null}
{"id": "515df5e4-dd61-4eda-a749-621f1076b8eb", "solution": "import numpy as np\n\nclass QuantumInspiredMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.local_search_radius = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n        \n            if evaluations < self.budget:\n                best_position, best_fitness = self.local_search(best_position, best_fitness, func, lb, ub)\n                evaluations += self.dim  # Approximate evaluations used in local search\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        delta_theta = self.alpha * (best_quantum_bits - quantum_bits)\n        new_quantum_bits = quantum_bits + delta_theta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def local_search(self, position, fitness, func, lb, ub):\n        best_position = position\n        best_fitness = fitness\n        for _ in range(self.dim):\n            perturbation = np.random.uniform(-self.local_search_radius, self.local_search_radius, self.dim)\n            candidate_position = np.clip(position + perturbation, lb, ub)\n            candidate_fitness = func(candidate_position)\n            if candidate_fitness < best_fitness:\n                best_position = candidate_position\n                best_fitness = candidate_fitness\n        return best_position, best_fitness", "name": "QuantumInspiredMemeticAlgorithm", "description": "Quantum-inspired Memetic Algorithm combines quantum-inspired representation with local search to enhance convergence in complex landscapes.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'best_fitness' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'best_fitness' where it is not associated with a value\")", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "217124a8-0b0d-49f7-b748-63c02365de76", "solution": "import numpy as np\n\nclass AdaptiveSwarmIntelligence:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 15 * dim\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.pareto_front_weight = 0.4\n        self.velocities = np.random.rand(self.swarm_size, self.dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + np.random.rand(self.swarm_size, self.dim) * (ub - lb)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.swarm_size\n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[i] = (\n                    self.inertia_weight * self.velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best_positions[i] - positions[i])\n                    + self.social_constant * r2 * (global_best_position - positions[i])\n                )\n                \n                pareto_influence = self.pareto_front_influence(positions, personal_best_fitness)\n                self.velocities[i] += self.pareto_front_weight * r3 * pareto_influence\n\n                # Update positions and clip within bounds\n                positions[i] += self.velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n                \n                # Evaluate new positions\n                new_fitness = func(positions[i])\n                evaluations += 1\n\n                # Update personal bests\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = positions[i]\n\n                # Update global best\n                if new_fitness < personal_best_fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, personal_best_fitness[global_best_index]\n\n    def pareto_front_influence(self, positions, fitness):\n        norms = np.linalg.norm(positions - np.mean(positions, axis=0), axis=1)\n        max_norm = np.max(norms)\n        influence = norms / (max_norm + 1e-9)\n        return influence", "name": "AdaptiveSwarmIntelligence", "description": "Adaptive Swarm Intelligence with Pareto-front Exploration combining multi-agent systems dynamics for diversified search paths.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (2,) (30,) (2,) ').", "error": "ValueError('operands could not be broadcast together with shapes (2,) (30,) (2,) ')", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "ecdad86a-d470-45db-b337-976c61f13bab", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select multiple best parents for adaptive rotation\n                parents_indices = np.argsort(fitness)[:3]\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[parents_indices], fitness, i)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                # Update best position\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits_array, fitness, index):\n        # Multi-parent adaptive quantum rotation inspired update\n        delta_theta = sum(self.beta * (best_quantum_bits - quantum_bits) for best_quantum_bits in best_quantum_bits_array) / len(best_quantum_bits_array)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "EnhancedQuantumInspiredEvolutionaryAlgorithm", "description": "Enhanced Quantum-inspired Evolutionary Algorithm with multi-parent adaptive quantum rotation to improve diversity and convergence speed.", "configspace": "", "generation": 92, "fitness": 0.5049657445592546, "feedback": "The algorithm EnhancedQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.00.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.5009527342012591, 0.5089787549172502]}, "mutation_prompt": null}
{"id": "5a085268-54fc-4285-9043-1dc4889efb5a", "solution": "import numpy as np\n\nclass HybridSwarmQuantumAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.quantum_alpha = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particle_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        particle_velocity = np.zeros((self.population_size, self.dim))\n        particle_best_position = np.copy(particle_position)\n        fitness = np.array([func(ind) for ind in particle_position])\n        evaluations = self.population_size\n\n        best_index = np.argmin(fitness)\n        global_best_position = particle_position[best_index]\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(), np.random.rand()\n\n            for i in range(self.population_size):\n                # Update particle velocity and position using PSO formulae\n                particle_velocity[i] = (\n                    particle_velocity[i] +\n                    self.c1 * r1 * (particle_best_position[i] - particle_position[i]) +\n                    self.c2 * r2 * (global_best_position - particle_position[i])\n                )\n                particle_position[i] += particle_velocity[i]\n                particle_position[i] = np.clip(particle_position[i], lb, ub)\n\n                # Quantum-inspired update\n                quantum_bits = self.position_to_quantum(particle_position[i], lb, ub)\n                quantum_bits = self.quantum_update(quantum_bits, global_best_position, lb, ub)\n                particle_position[i] = self.quantum_to_position(quantum_bits, lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(particle_position[i])\n                evaluations += 1\n\n                # Update personal best\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    particle_best_position[i] = particle_position[i]\n\n                # Update global best\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    global_best_position = particle_position[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, fitness[best_index]\n\n    def position_to_quantum(self, position, lb, ub):\n        return (position - lb) / (ub - lb)\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        return lb + quantum_bits * (ub - lb)\n\n    def quantum_update(self, quantum_bits, global_best_position, lb, ub):\n        global_best_quantum = self.position_to_quantum(global_best_position, lb, ub)\n        delta = self.quantum_alpha * (global_best_quantum - quantum_bits)\n        new_quantum_bits = quantum_bits + delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "HybridSwarmQuantumAlgorithm", "description": "Hybrid Swarm-based Quantum Algorithm incorporating particle swarm and quantum optimization for enhanced convergence.", "configspace": "", "generation": 93, "fitness": 0.8124086416767338, "feedback": "The algorithm HybridSwarmQuantumAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.09.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.7263354191763736, 0.8984818641770941]}, "mutation_prompt": null}
{"id": "a7ca83c2-602f-4a0d-b69e-63603027be9e", "solution": "import numpy as np\n\nclass HybridQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.velocity_clamp = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        velocity_population = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n        personal_best_positions = position_population.copy()\n        personal_best_fitness = fitness.copy()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # PSO velocity update\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (personal_best_positions[i] - position_population[i])\n                social_velocity = self.social_coeff * r2 * (best_position - position_population[i])\n                velocity_population[i] = (self.inertia_weight * velocity_population[i] +\n                                          cognitive_velocity + social_velocity)\n                velocity_population[i] = np.clip(velocity_population[i], -self.velocity_clamp, self.velocity_clamp)\n\n                # PSO position update\n                position_population[i] += velocity_population[i]\n                position_population[i] = np.clip(position_population[i], lb, ub)\n\n                # Adaptive quantum rotation gate\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                # Convert quantum representation to classical position\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = position_population[i]\n\n                # Update global best\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return np.clip(position, lb, ub)\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        # Adaptive quantum rotation inspired update\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "HybridQuantumInspiredEvolutionaryAlgorithm", "description": "Hybrid Quantum-inspired Evolutionary Algorithm with Particle Swarm Optimization to enhance convergence speed and solution quality through cooperative search dynamics.", "configspace": "", "generation": 94, "fitness": 0.5980876087324434, "feedback": "The algorithm HybridQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.06.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.6570718266978806, 0.5391033907670062]}, "mutation_prompt": null}
{"id": "831f2fe9-0a70-46bc-8f7c-68924e28626c", "solution": "import numpy as np\n\nclass AdaptiveSwarmQuantumAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.weight = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution: Mutation and Crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = position_population[indices]\n                mutant = x1 + self.weight * (x2 - x3)\n                mutant = np.clip(mutant, lb, ub)\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, position_population[i])\n                \n                # Evaluate new trial\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                # Selection: keep the better solution\n                if trial_fitness < fitness[i]:\n                    position_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best position\n                if trial_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update quantum representation towards best\n            for i in range(self.population_size):\n                quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index])\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits):\n        # Simple attraction mechanism towards the best solution\n        attraction_strength = 0.1\n        updated_bits = quantum_bits + attraction_strength * (best_quantum_bits - quantum_bits)\n        updated_bits = np.clip(updated_bits, 0, 1)\n        return updated_bits", "name": "AdaptiveSwarmQuantumAlgorithm", "description": "Adaptive Swarm-Inspired Quantum Algorithm with Differential Evolution for fine-tuning solutions.", "configspace": "", "generation": 95, "fitness": 0.9391839219864211, "feedback": "The algorithm AdaptiveSwarmQuantumAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.02.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9231212193360447, 0.9552466246367974]}, "mutation_prompt": null}
{"id": "0ef6f229-7feb-4aae-b237-a5208e2883a5", "solution": "import numpy as np\n\nclass QuantumEntangledParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.entanglement_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_positions = np.random.rand(self.swarm_size, self.dim)\n        velocities = np.random.rand(self.swarm_size, self.dim) * 0.1\n        classical_positions = self.quantum_to_position(quantum_positions, lb, ub)\n        fitness = np.array([func(ind) for ind in classical_positions])\n        evaluations = self.swarm_size\n        personal_best_positions = np.copy(classical_positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = classical_positions[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                # Update velocities based on quantum entanglement and classical influences\n                cognitive_component = self.alpha * np.random.rand(self.dim) * (personal_best_positions[i] - classical_positions[i])\n                social_component = self.beta * np.random.rand(self.dim) * (global_best_position - classical_positions[i])\n                quantum_entanglement = self.entanglement_rate * np.random.normal(0, 1, self.dim)\n\n                velocities[i] = velocities[i] + cognitive_component + social_component + quantum_entanglement\n                classical_positions[i] += velocities[i]\n                classical_positions[i] = np.clip(classical_positions[i], lb, ub)\n\n                # Evaluate new position\n                new_fitness = func(classical_positions[i])\n                evaluations += 1\n\n                # Update personal and global bests\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = classical_positions[i]\n                if new_fitness < fitness[global_best_index]:\n                    global_best_index = i\n                    global_best_position = classical_positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_position, fitness[global_best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        # Convert quantum bits to classical positions in the search space\n        position = lb + quantum_bits * (ub - lb)\n        return position", "name": "QuantumEntangledParticleSwarmOptimization", "description": "Quantum-Entangled Particle Swarm Optimization integrates quantum superposition and entanglement principles to enhance solution diversity and convergence speed.", "configspace": "", "generation": 96, "fitness": 0.7216874194745977, "feedback": "The algorithm QuantumEntangledParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.01.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.7295150739273141, 0.7138597650218813]}, "mutation_prompt": null}
{"id": "c7013179-3e08-41d5-899f-ace08547ce48", "solution": "import numpy as np\n\nclass AdvancedQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha = 0.6\n        self.beta = 0.55\n        self.adaptive_factor = 0.15\n        self.dynamic_pop_reduction = True\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.initial_population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.initial_population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(len(quantum_population)):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.dynamic_pop_reduction and evaluations < self.budget:\n                # Dynamically reduce population size to accelerate convergence\n                improvement_threshold = 0.01\n                if np.mean(fitness) - np.min(fitness) < improvement_threshold:\n                    reduced_size = max(2, int(0.9 * len(quantum_population)))\n                    elite_indices = np.argsort(fitness)[:reduced_size]\n                    quantum_population = quantum_population[elite_indices]\n                    position_population = position_population[elite_indices]\n                    fitness = fitness[elite_indices]\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits", "name": "AdvancedQuantumInspiredEvolutionaryAlgorithm", "description": "Advanced Quantum-inspired Evolutionary Algorithm with dynamic population size adjustment to enhance convergence speed and quality.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 18').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 18')", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "d12d2166-fa93-4ce1-945e-5d66667d68c0", "solution": "import numpy as np\n\nclass QuantumInspiredEvolutionaryAlgorithmWithDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.dynamic_population_factor = 0.1  # New factor for dynamic population resizing\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        quantum_population = np.random.rand(population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(quantum_population[i], quantum_population[best_index], fitness, i)\n\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if np.random.rand() < self.dynamic_population_factor:  # Adjust population size dynamically\n                population_size = self.adjust_population_size(population_size, evaluations, self.budget)\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def adjust_population_size(self, current_size, evaluations, budget):\n        # Dynamically reduce or increase population size depending on the budget consumption\n        if evaluations < budget / 2:\n            return min(current_size + 1, 20 * self.dim)\n        else:\n            return max(current_size - 1, 5 * self.dim)", "name": "QuantumInspiredEvolutionaryAlgorithmWithDynamicPopulation", "description": "Quantum-inspired Evolutionary Algorithm with Dynamic Population Sizing and Adaptive Exploration-Exploitation Balance.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {}, "mutation_prompt": null}
{"id": "37ea2405-43ee-4c7b-8f60-ac41f20911d1", "solution": "import numpy as np\n\nclass HybridQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.adaptive_factor = 0.1\n        self.temperature = 1.0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        quantum_population = np.random.rand(self.population_size, self.dim)\n        position_population = self.quantum_to_position(quantum_population, lb, ub)\n        fitness = np.array([func(ind) for ind in position_population])\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = position_population[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    quantum_population[i] = self.update_quantum_bits(\n                        quantum_population[i], quantum_population[best_index], fitness, i\n                    )\n                position_population[i] = self.quantum_to_position(quantum_population[i], lb, ub)\n                new_fitness = func(position_population[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i] or self.accept_by_annealing(fitness[i], new_fitness):\n                    fitness[i] = new_fitness\n\n                if new_fitness < fitness[best_index]:\n                    best_index = i\n                    best_position = position_population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.temperature *= 0.95\n\n        return best_position, fitness[best_index]\n\n    def quantum_to_position(self, quantum_bits, lb, ub):\n        position = lb + quantum_bits * (ub - lb)\n        return position\n\n    def update_quantum_bits(self, quantum_bits, best_quantum_bits, fitness, index):\n        delta_theta = self.beta * (best_quantum_bits - quantum_bits)\n        improvement_ratio = (fitness[index] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-9)\n        adaptive_delta = delta_theta * (1 + self.adaptive_factor * (0.5 - improvement_ratio))\n        new_quantum_bits = quantum_bits + adaptive_delta\n        new_quantum_bits = np.clip(new_quantum_bits, 0, 1)\n        return new_quantum_bits\n\n    def accept_by_annealing(self, current_fitness, new_fitness):\n        if new_fitness < current_fitness:\n            return True\n        acceptance_probability = np.exp((current_fitness - new_fitness) / (self.temperature + 1e-9))\n        return np.random.rand() < acceptance_probability", "name": "HybridQuantumInspiredEvolutionaryAlgorithm", "description": "Hybrid Quantum-Inspired Evolutionary Algorithm with adaptive annealing-based strategy to enhance convergence speed and escape local optima.", "configspace": "", "generation": 99, "fitness": 0.7601665243434561, "feedback": "The algorithm HybridQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.76 with standard deviation 0.17.", "error": "", "parent_id": "f5a8e12a-0f10-4043-a575-09c0d29ead8f", "metadata": {"aucs": [0.9302856476760732, 0.5900474010108391]}, "mutation_prompt": null}
