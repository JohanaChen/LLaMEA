{"id": "fff681ef-3741-4ac6-934e-374f57fb2008", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25     # Discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5      # Social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "A novel algorithm combining Cuckoo Search and Particle Swarm Optimization concepts to balance exploration and exploitation in the search space.", "configspace": "", "generation": 0, "fitness": 0.15973234278541837, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": null, "metadata": {"aucs": [0.14877450889753174, 0.15006922766121444, 0.18035329179750892]}, "mutation_prompt": null}
{"id": "6870d87d-f902-4976-a689-6f07f5eef516", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25     # Discovery rate of alien eggs\n        n_particles = 30\n        w = 0.9       # Increased inertia weight for better exploration\n        c1 = 2.0      # Increased cognitive coefficient\n        c2 = 2.0      # Increased social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced HybridCuckooPSO with adaptive parameters and dynamic population management for improved convergence.", "configspace": "", "generation": 1, "fitness": 0.14884650087543028, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "fff681ef-3741-4ac6-934e-374f57fb2008", "metadata": {"aucs": [0.13580872284985213, 0.1538607716967919, 0.1568700080796468]}, "mutation_prompt": null}
{"id": "060a22cf-024d-4ebe-8659-54076c2ca672", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25     # Discovery rate of alien eggs\n        n_particles = 30\n        w = 0.9       # Increased inertia weight for better exploration\n        c1_initial = 2.5  # Increased initial cognitive coefficient\n        c2_initial = 0.5  # Decreased initial social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(), np.random.rand()\n            c1 = c1_initial - (c1_initial - 1.5) * eval_count / self.budget  # Adaptive cognitive coefficient\n            c2 = c2_initial + (2.5 - c2_initial) * eval_count / self.budget  # Adaptive social coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "An enhanced hybrid algorithm that incorporates dynamic parameters for improved exploration and exploitation balance in optimization.", "configspace": "", "generation": 2, "fitness": 0.158548904291384, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "fff681ef-3741-4ac6-934e-374f57fb2008", "metadata": {"aucs": [0.1477744172927964, 0.1638984650565285, 0.16397383052482706]}, "mutation_prompt": null}
{"id": "81252f42-085b-42e0-a42f-c27e6a16c1d8", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved balance between exploration and exploitation by introducing adaptive parameters and a dynamic population strategy.", "configspace": "", "generation": 3, "fitness": 0.1813737297656616, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "fff681ef-3741-4ac6-934e-374f57fb2008", "metadata": {"aucs": [0.19233345015431014, 0.17134169378865116, 0.18044604535402353]}, "mutation_prompt": null}
{"id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration capability by adjusting the inertia weight 'w' linearly over iterations.", "configspace": "", "generation": 4, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "81252f42-085b-42e0-a42f-c27e6a16c1d8", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "226c3141-9fa1-4582-a172-efaaf9186903", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration capability by adjusting the inertia weight 'w' linearly over iterations.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "9a177675-aff8-4616-b26f-b6ad40cfc69a", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.1 * step * (nests - best)  # Increased step size for better exploration\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced convergence by modifying the step size in Levy flights for better exploration.", "configspace": "", "generation": 6, "fitness": 0.17615714619630296, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1831409249846253, 0.17160801734731934, 0.17372249625696423]}, "mutation_prompt": null}
{"id": "ac8dbe7d-7763-44f5-a1d3-6412031e7e6b", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget) + 0.1 * np.sin(np.pi * eval_count / self.budget)  # Sinusoidal inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration by adding variability to the inertia weight using a sinusoidal function over iterations.", "configspace": "", "generation": 7, "fitness": 0.1659950459272009, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.15318845933779113, 0.16833830051692866, 0.1764583779268829]}, "mutation_prompt": null}
{"id": "1550ac78-0c3d-46f2-ae3b-847feb95a595", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            # Dynamic cognitive and social coefficients\n            c1 = 1.5 - 0.5 * (eval_count / self.budget)\n            c2 = 2.0 - 0.5 * (eval_count / self.budget)\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced dynamic adjustment for both cognitive and social coefficients during the PSO phase.", "configspace": "", "generation": 8, "fitness": 0.15675566989713952, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.15282178490361042, 0.16507355549120828, 0.15237166929659984]}, "mutation_prompt": null}
{"id": "25fca519-2eff-4127-bf97-d250df54c150", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            pa = 0.2 + 0.05 * (global_best_fitness / np.max(nest_fitness))  # Changed line: dynamic pa\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration by dynamically adapting the discovery rate pa based on the current best fitness.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Cannot apply_along_axis when any iteration dimensions are 0').", "error": "ValueError('Cannot apply_along_axis when any iteration dimensions are 0')", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {}, "mutation_prompt": null}
{"id": "d8fa494d-5f24-4139-81e0-048e0c4971aa", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            pa = 0.2 + 0.3 * (eval_count / self.budget)  # Time-varying adaptive discovery rate\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced a time-varying adaptive parameter for the discovery rate to enhance exploration.", "configspace": "", "generation": 10, "fitness": 0.16218787271767113, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.16421795762367752, 0.1537653910679695, 0.1685802694613664]}, "mutation_prompt": null}
{"id": "1381d52c-b9d9-487a-8658-3b1a9476bf78", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            pa = 0.2 + 0.3 * (eval_count / self.budget)  # Dynamically adjust 'pa'\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration by dynamically adjusting the discovery rate 'pa' over iterations.", "configspace": "", "generation": 11, "fitness": 0.1189411679478453, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.13893754275680748, 0.12229382016857637, 0.09559214091815205]}, "mutation_prompt": null}
{"id": "19f795c9-de41-488f-84d1-e6cc3dfe35e9", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Initial inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.7 * (eval_count / self.budget)  # Adaptive inertia weight with increased decay\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive inertia weight decay to enhance convergence speed and exploration balance.", "configspace": "", "generation": 12, "fitness": 0.10520836756787288, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.10309658516877351, 0.11261058202253127, 0.09991793551231387]}, "mutation_prompt": null}
{"id": "c55a162c-1f03-4ff0-854a-824d9b2c3d88", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            learning_rate = 0.1 + 0.9 * (eval_count / self.budget)  # Adaptive learning rate\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = (learning_rate * particles[better_fitness] +\n                                                       (1 - learning_rate) * personal_best_positions[better_fitness])\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive learning rate for personal best update to enhance convergence efficiency.", "configspace": "", "generation": 13, "fitness": 0.1287194980729198, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1260278327314689, 0.1328380981824001, 0.12729256330489036]}, "mutation_prompt": null}
{"id": "017042ea-4189-4df9-a4bc-7e4e9326d767", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 2.0 - 0.5 * np.random.rand()  # Dynamic cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduce dynamic cognitive coefficient `c1` to enhance adaptability and convergence speed.", "configspace": "", "generation": 14, "fitness": 0.15962658117089587, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1520609221767114, 0.14434635606391388, 0.1824724652720623]}, "mutation_prompt": null}
{"id": "650489b5-cc87-46b4-85a3-62085c7e0c05", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            \n            # Dynamic adjustment of c1 and c2 using a sigmoid function\n            c1 = 2.5 / (1 + np.exp(-10 * (eval_count / self.budget - 0.5)))\n            c2 = 2.5 - c1\n            \n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration-exploitation balance by dynamically adjusting cognitive and social coefficients based on a sigmoid function of evaluation count.", "configspace": "", "generation": 15, "fitness": 0.13673761305721624, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.15868969711523628, 0.10587076988270339, 0.14565237217370908]}, "mutation_prompt": null}
{"id": "11857cf4-e9f6-499d-9e86-257585d40d19", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            pa = 0.2 + 0.3 * np.exp(-global_best_fitness / (1e-9 + np.std(nest_fitness)))  # adapted line\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved global exploration by adapting the discovery rate of alien eggs based on current best fitness.", "configspace": "", "generation": 16, "fitness": 0.1610198732470768, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.16585000006601025, 0.1726245724443516, 0.14458504723086862]}, "mutation_prompt": null}
{"id": "96d1344f-2311-4c9e-aacf-e95f19ed2dbb", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            c1 = 2.5 - 2 * (eval_count / self.budget)  # Dynamic cognitive coefficient\n            c2 = 0.5 + 2 * (eval_count / self.budget)  # Dynamic social coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved convergence speed by dynamically adjusting both cognitive and social coefficients over iterations.", "configspace": "", "generation": 17, "fitness": 0.17829685529407613, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.15606776130709554, 0.17801439914079065, 0.2008084054343422]}, "mutation_prompt": null}
{"id": "0d634035-9371-4b1c-b9d5-b1c975cfc7f2", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            c2 = 1.5 + 0.5 * (1 - eval_count / self.budget)  # Dynamic social coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced dynamic adaptation to the particle's social coefficient to enhance convergence.", "configspace": "", "generation": 18, "fitness": 0.16887194591859458, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.16213423344995792, 0.187937789286172, 0.15654381501965386]}, "mutation_prompt": null}
{"id": "ae3bb998-8d2e-41c9-b368-f62234582d38", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            max_velocity = 0.1 * (bounds[1] - bounds[0])  # Adaptive velocity clamping\n            velocities = np.clip(velocities, -max_velocity, max_velocity)\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduce adaptive velocity clamping to enhance convergence by dynamically adjusting the velocity bounds based on the search space.", "configspace": "", "generation": 19, "fitness": 0.13093216808542263, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.14089764856238507, 0.10503158025132264, 0.14686727544256017]}, "mutation_prompt": null}
{"id": "378b6937-c4a8-4cf7-ac6b-99c6d65a589d", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration capability by adjusting the inertia weight 'w' linearly over iterations.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "bdcbc609-1953-4cac-a1be-c159a46fe029", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = lambda evals: 0.2 + 0.5 * (evals / self.budget)  # Dynamically adaptive discovery rate\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa(eval_count)\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration by dynamically adjusting the discovery rate 'pa' based on current evaluation progress.", "configspace": "", "generation": 21, "fitness": 0.15496848924719417, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.14429811321446628, 0.16542667807312617, 0.15518067645399003]}, "mutation_prompt": null}
{"id": "63a96f01-c99f-4e31-a80c-73e07e1c3281", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration capability by adjusting the inertia weight 'w' linearly over iterations.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "ba7a1a5a-7397-4438-b00e-d39259b73472", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, global_best_fitness)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, global_best_fitness):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        # Adaptive step size based on global best fitness\n        step_size = 0.01 * step * (nests - best) * (1 - global_best_fitness / (np.max(nest_fitness) + 1e-10))\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved convergence by introducing an adaptive step size in the Levy flights phase based on the current global best fitness.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'nest_fitness' is not defined\").", "error": "NameError(\"name 'nest_fitness' is not defined\")", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {}, "mutation_prompt": null}
{"id": "3e8765d3-ee19-4c74-9431-2b192a4c4ebf", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            pa = 0.2 + 0.05 * np.random.rand() * (1 - eval_count / self.budget) # Dynamic discovery rate\n\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduce dynamic adaptation of the discovery rate 'pa' for enhanced exploration.", "configspace": "", "generation": 24, "fitness": 0.15918733307468938, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.03.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.18570542320600802, 0.1758361396908249, 0.11602043632723524]}, "mutation_prompt": null}
{"id": "3f3ee0ac-d047-4cdb-9bb4-ca2dddedf101", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        n_nests = 25\n        beta = 3 / 2\n        pa = 0.2 + 0.05 * np.random.rand()\n        n_particles = 30\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n\n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n\n        while eval_count < self.budget:\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)\n            c1 = 1.5 + 0.5 * (eval_count / self.budget)  # Dynamic cognitive coefficient\n            c2 = 2.0 - 0.5 * (eval_count / self.budget)  # Dynamic social coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduce dynamic learning coefficients for exploration and exploitation to enhance convergence and diversity.", "configspace": "", "generation": 25, "fitness": 0.1298248051772136, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.03.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1777246589521092, 0.0957712351303136, 0.11597852144921794]}, "mutation_prompt": null}
{"id": "6b5cd387-0713-4c60-aa9b-405cf205aba6", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            \n            # Adaptive velocity clamping\n            max_velocity = 0.1 * (bounds[1] - bounds[0])\n            velocities = np.clip(velocities, -max_velocity, max_velocity)\n\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive velocity clamping in the PSO phase to maintain diverse exploration capabilities.", "configspace": "", "generation": 26, "fitness": 0.15739667635457458, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.14933102016994282, 0.1438060196838714, 0.17905298920990953]}, "mutation_prompt": null}
{"id": "1d509dff-6287-4ed5-ae52-9ccba20b6f93", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Adaptive inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced an adaptive inertia weight scaling factor for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "fbf06c3f-2642-4af3-bc04-75f640e01c56", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5 + 0.5 * np.random.rand() * (1 - eval_count / self.budget)  # Dynamic cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced a slight dynamic adjustment to the cognitive coefficient `c1` for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'eval_count' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'eval_count' referenced before assignment\")", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {}, "mutation_prompt": null}
{"id": "e19103df-738c-4d80-971f-0e5ceaac0064", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25 + 0.05 * np.random.rand()  # Slightly increased adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.6      # Slightly increased cognitive coefficient\n        c2 = 1.4 + 0.5 * np.random.rand()  # Slightly decreased adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Slightly adjusted coefficient parameters and adaptive discovery rate for improved exploration and convergence.", "configspace": "", "generation": 29, "fitness": 0.12095468414939843, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.12823648293704448, 0.11737550192941326, 0.11725206758173756]}, "mutation_prompt": null}
{"id": "d1a4a1b1-79e2-41c5-9867-ac009c1a4be5", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        adaptive_pa_factor = 0.05  # Factor for adaptive 'pa'\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        initial_global_best_fitness = global_best_fitness\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            improvement_factor = (initial_global_best_fitness - global_best_fitness) / abs(initial_global_best_fitness)\n            pa = 0.2 + adaptive_pa_factor * improvement_factor\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive adjustment of discovery rate 'pa' based on iteration progress and cumulative best improvement.", "configspace": "", "generation": 30, "fitness": 0.09801701735249409, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.05131856501421517, 0.10448297874257073, 0.13824950830069638]}, "mutation_prompt": null}
{"id": "ab96a982-d032-416f-9073-374590355372", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.6      # Increased cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved local search by increasing the personal learning coefficient slightly to enhance convergence.", "configspace": "", "generation": 31, "fitness": 0.08992652571029536, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.08050008136052822, 0.11505672815347179, 0.07422276761688607]}, "mutation_prompt": null}
{"id": "121bb293-5f48-4bbd-a449-32f708b6d124", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          (c1 * r1 + 0.1 * np.random.rand(*r1.shape)) * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improve exploration by increasing the random influence in the velocity update of particles.", "configspace": "", "generation": 32, "fitness": 0.15965372913902423, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1417916723330891, 0.15769387848297467, 0.17947563660100896]}, "mutation_prompt": null}
{"id": "81750db3-d1e7-4ded-89f2-9a2f40c207a4", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2\n        adaptive_pa = lambda e: 0.25 + 0.15 * (e / self.budget)  # Adaptive pa\n        n_particles = 30\n        w = 0.5\n        dynamic_c1 = lambda e: 1.0 + 1.0 * (1 - e / self.budget)  # Dynamic c1\n        dynamic_c2 = lambda e: 1.0 + 2.0 * (e / self.budget)  # Dynamic c2\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            pa = adaptive_pa(eval_count)\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)\n            c1 = dynamic_c1(eval_count)  # Apply dynamic c1\n            c2 = dynamic_c2(eval_count)  # Apply dynamic c2\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive learning coefficients and enhanced the nest abandonment strategy to improve exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.14500779229955826, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.134438478535847, 0.15236866133255167, 0.1482162370302761]}, "mutation_prompt": null}
{"id": "c44fc366-2ecb-429d-9267-d777a6cb4ccd", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            c2 = 1.5 + 0.5 * (1 - global_best_fitness / np.max(nest_fitness))  # Change applied here\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration by adjusting the social coefficient adaptively based on the current best fitness.", "configspace": "", "generation": 34, "fitness": 0.11153149455232947, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1033511652947714, 0.10581440679903353, 0.12542891156318348]}, "mutation_prompt": null}
{"id": "34e787fc-ce6d-4193-bee6-2478760db1a3", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Introduce mutation for diversity\n            if eval_count % (self.budget // 10) == 0:\n                mutation_scale = 0.1 * (bounds[1] - bounds[0])\n                particles += np.random.normal(0, mutation_scale, particles.shape)  # Mutation\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced convergence by introducing a mutation operator for diversity preservation.", "configspace": "", "generation": 35, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "029c0b2d-0f9c-49ae-a114-0d7ebc261bb6", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            pa = 0.1 + 0.3 * (eval_count / self.budget)  # Dynamically adapt pa based on iteration progress\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced dynamic discovery rate 'pa' adaptation based on iteration progress for improved exploration-exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Cannot apply_along_axis when any iteration dimensions are 0').", "error": "ValueError('Cannot apply_along_axis when any iteration dimensions are 0')", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {}, "mutation_prompt": null}
{"id": "727f5d94-8dda-4003-adaf-5b0f2f33c0cc", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count / self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, progress):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * (1 - progress) * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration using adaptive Levy flight step size based on current iteration.", "configspace": "", "generation": 37, "fitness": 0.15844126317511523, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.03.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.13275397445243897, 0.14839081373954033, 0.1941790013333664]}, "mutation_prompt": null}
{"id": "8ca9251d-63e9-48f0-879b-5b3261bedfb3", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.3 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by increasing the adaptive discovery rate of alien eggs.", "configspace": "", "generation": 38, "fitness": 0.15273468038005014, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.13863919803990965, 0.17305481762325248, 0.14651002547698833]}, "mutation_prompt": null}
{"id": "42f6a484-3c02-44b4-871d-268fe54d2f55", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w_max, w_min = 0.9, 0.4  # Changed inertia weight bounds\n        c1 = 1.5\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = w_max - ((w_max - w_min) * (eval_count / self.budget))  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive inertia weight bounds to enhance balance between exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.16889894936992558, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1467204823740108, 0.1867586327751274, 0.17321773296063858]}, "mutation_prompt": null}
{"id": "a808d68f-678e-4211-80e3-76cb67a926cd", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n            # Change `pa` dynamically\n            pa = 0.2 + 0.8 * (1 - eval_count / self.budget) * np.random.rand()\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by dynamically adjusting the discovery rate `pa` based on current evaluations.", "configspace": "", "generation": 40, "fitness": 0.16854582707945273, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.15988256690701652, 0.1661956957667694, 0.17955921856457224]}, "mutation_prompt": null}
{"id": "c212b3b3-7fd0-4f97-9e57-6b649a9858f0", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget) + 0.05 * np.random.rand()  # Dynamic inertia weight with slight variability\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by introducing slight variability in the inertia weight calculation to balance exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.1612703131003771, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1690854373944689, 0.1576039017878813, 0.15712160011878107]}, "mutation_prompt": null}
{"id": "ebc409a9-c6bb-4a55-a2aa-2d6ac4eaf1ed", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        n_nests = 25\n        beta = 3 / 2 \n        pa = 0.2 + 0.05 * np.random.rand()\n        n_particles = 30\n        w = 0.5\n        c1 = 1.5 \n        c2 = 1.5 + 0.5 * np.random.rand()\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n\n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n\n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            explore_factor = 1 - eval_count / self.budget\n            new_nests = self.hybrid_levy_flights(nests, global_best_position, bounds, beta, explore_factor)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)\n            c1_adaptive = c1 * explore_factor\n            c2_adaptive = c2 * (1 - explore_factor)\n            velocities = (w * velocities +\n                          c1_adaptive * r1 * (personal_best_positions - particles) +\n                          c2_adaptive * r2 * (global_best_position - particles))\n            particles += velocities\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def hybrid_levy_flights(self, nests, best, bounds, beta, explore_factor):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + explore_factor * step_size\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved convergence by introducing adaptive particle learning rates and hybrid exploitation strategies.", "configspace": "", "generation": 42, "fitness": 0.15143195222922534, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.02.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.15167610048360414, 0.1731654913599333, 0.12945426484413858]}, "mutation_prompt": null}
{"id": "91dadeb1-27f4-4a17-b623-4980aa022047", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            c1 = 2.5 - 1.5 * (eval_count / self.budget)  # Dynamic cognitive coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced particle exploration by introducing a dynamic cognitive coefficient `c1` that decreases over iterations to improve convergence.", "configspace": "", "generation": 43, "fitness": 0.15599236737928182, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.13838139019760376, 0.15643393902057323, 0.1731617729196685]}, "mutation_prompt": null}
{"id": "809a77e6-971d-49f4-bfd7-20d30a7829f4", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            c1 = 0.5 + 1.0 * (eval_count / self.budget)  # Dynamic cognitive coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration by dynamically adapting both inertia weight 'w' and cognitive coefficient 'c1'.", "configspace": "", "generation": 44, "fitness": 0.15632885939100263, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.14685628197618916, 0.15984539909765594, 0.16228489709916283]}, "mutation_prompt": null}
{"id": "dc312925-e777-4f21-a229-f52e5fbb2805", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration capability by adjusting the inertia weight 'w' linearly over iterations.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "283d2d67-7364-4989-bade-6815167f54b3", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.6      # Cognitive coefficient increased for improved local search\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved convergence by slightly increasing the cognitive coefficient 'c1' to enhance exploitation capability.", "configspace": "", "generation": 46, "fitness": 0.16809954745572386, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.00.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [0.16723062239061315, 0.1668776574853934, 0.17019036249116504]}, "mutation_prompt": null}
{"id": "337880c6-dfef-4850-88f8-38f45d5f42e2", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5 + 0.5 * (self.budget - eval_count) / self.budget  # Dynamic cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta):\n        # Levy flight step sizes\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        step_size = 0.01 * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced dynamic adaptation of the cognitive coefficient `c1` for enhanced convergence.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'eval_count' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'eval_count' referenced before assignment\")", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {}, "mutation_prompt": null}
{"id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive mutation in the Levy flight step to enhance exploration.", "configspace": "", "generation": 48, "fitness": 0.43445809306195377, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.40.", "error": "", "parent_id": "8a5d10e1-9ee9-4306-b7d4-a7e132183348", "metadata": {"aucs": [1.0, 0.1366903392315464, 0.16668393995431507]}, "mutation_prompt": null}
{"id": "068c7153-7376-4f81-8c0b-22f35a6a49c1", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = np.abs(np.cos(np.pi * eval_count / (2 * self.budget)))  # Nonlinear inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploitation by refining PSO velocity update with a nonlinear inertia weight.", "configspace": "", "generation": 49, "fitness": 0.1589586865788167, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.13646860243742442, 0.15634971720243263, 0.18405774009659304]}, "mutation_prompt": null}
{"id": "f7341f82-1dfa-44d9-ab0d-31e90900de79", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25 + 0.05 * np.random.rand()  # Slightly increased adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Adjusted the abandonment probability to increase exploration capability.", "configspace": "", "generation": 50, "fitness": 0.16001308790055138, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1396378653355148, 0.17248884008185783, 0.16791255828428153]}, "mutation_prompt": null}
{"id": "1fffc2e6-3bc1-4cf2-9cd5-87ccbd968e90", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25 + 0.05 * np.random.rand()  # Adjusted adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.05 + 0.1 * adapt_factor  # Enhanced adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced the adaptive mutation factor and modified exploration parameters for improved convergence.", "configspace": "", "generation": 51, "fitness": 0.0976747992402169, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.03.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.07745599298625327, 0.14379922020800695, 0.07176918452639047]}, "mutation_prompt": null}
{"id": "792df845-98b2-4112-84c5-1e93c3a4277a", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            if np.random.rand() < 0.5:  # Introduce probability-based global best selection\n                current_global_best_idx = np.argmin(nest_fitness)\n                if nest_fitness[current_global_best_idx] < global_best_fitness:\n                    global_best_position = nests[current_global_best_idx]\n                    global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced global best selection by introducing a probability-based mechanism to improve exploitation.", "configspace": "", "generation": 52, "fitness": 0.07832730639746148, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.053087637200697646, 0.1026155344268791, 0.07927874756480768]}, "mutation_prompt": null}
{"id": "d922251f-36e5-4264-9cf6-ec95889591a6", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        cr = 0.9 - 0.4 * np.random.rand()  # Adaptive crossover rate\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n\n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n\n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n\n        eval_count = 0\n\n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Crossover Phase (inspired by Differential Evolution)\n            indices = np.random.choice(n_particles, size=(n_particles, 2), replace=True)\n            for i in range(n_particles):\n                if np.random.rand() < cr:\n                    donor_vector = particles[indices[i, 0]] + 0.5 * (particles[indices[i, 1]] - particles[i])\n                    particles[i] = np.clip(donor_vector, bounds[0], bounds[1])\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced an adaptive crossover mechanism inspired by Differential Evolution to enhance diversity and convergence speed.", "configspace": "", "generation": 53, "fitness": 0.0950572868917902, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.10004265045526628, 0.08123606178709908, 0.10389314843300523]}, "mutation_prompt": null}
{"id": "2bafacdb-3128-4246-a25f-b697595d78ac", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.2 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved mutation factor adaptiveness by modifying the adaptive mutation formula.", "configspace": "", "generation": 54, "fitness": 0.1444161402186621, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1336833191314145, 0.15036140301476386, 0.14920369850980786]}, "mutation_prompt": null}
{"id": "ab2f339e-7ff9-4720-9559-fc23c577cf82", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.3 * (eval_count / self.budget)  # Slightly adjusted dynamic inertia weight for improvement\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced a small adaptive change in the inertia weight formula for enhanced convergence.", "configspace": "", "generation": 55, "fitness": 0.15740807713283878, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1356070320376651, 0.15785407617899305, 0.17876312318185816]}, "mutation_prompt": null}
{"id": "daae638b-3442-4c4f-a1c4-7a51dd834a63", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        n_nests = 25\n        beta = 3 / 2\n        pa = 0.2 + 0.05 * np.random.rand()\n        n_particles = 30\n        w = 0.5\n        c1 = 1.5\n        c2 = 1.5 + 0.5 * np.random.rand()\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Change: Dynamic beta adjustment for enhanced exploration\n            beta = 3 / 2 + (eval_count / self.budget) * 0.5\n            \n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced global exploration by adjusting the Levy flight exponent `beta` dynamically based on evaluation progress.", "configspace": "", "generation": 56, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "f14be833-f107-476c-a2ad-1c48a7077c67", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.6 * (eval_count / self.budget)  # Changed dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Adjusted the dynamic inertia weight formula to improve convergence speed.", "configspace": "", "generation": 57, "fitness": 0.17936570840237911, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.19267058395363956, 0.16207579884193413, 0.18335074241156368]}, "mutation_prompt": null}
{"id": "f2b080b3-4cb9-48a9-8456-8829bdbd07a0", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = lambda eval_fraction: 0.2 + 0.3 * eval_fraction  # Dynamic discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa(eval_count/self.budget)\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced dynamic adjustment of the discovery rate of alien eggs to improve balance between exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.1457741148814881, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1336578232407255, 0.1381902409868726, 0.16547428041686618]}, "mutation_prompt": null}
{"id": "ee0d43a4-82d7-4da9-8aef-6c4c487a7cd8", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa_base = 0.2  # Base probability of discovering alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        diversity_measure = lambda x: np.std(x)\n\n        # Main optimization loop\n        while eval_count < self.budget:\n            # Adaptive pa\n            pa = pa_base + 0.1 * diversity_measure(nests)\n\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            c1 = 1.5 - 0.5 * (eval_count / self.budget)  # Adaptive cognitive coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced global exploration by introducing a dynamic pa based on diversity and an adaptive c1 to balance exploration and exploitation.", "configspace": "", "generation": 59, "fitness": 0.14917584933258354, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.13459920358063593, 0.16361575496247893, 0.14931258945463577]}, "mutation_prompt": null}
{"id": "8a08314c-dc34-4b92-9831-1acc42523cbf", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.2 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by increasing the adaptive mutation factor's upper limit to 0.2.", "configspace": "", "generation": 60, "fitness": 0.10710524673571202, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.0946140068250173, 0.1214783493731274, 0.10522338400899134]}, "mutation_prompt": null}
{"id": "204b7501-d193-4838-a76f-8a35a11b54f3", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.05 + 0.15 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by adjusting the mutation factor's range for the Levy flight step.", "configspace": "", "generation": 61, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "483e4052-99d8-4307-955b-a2ba51a8d7af", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.2 * adapt_factor  # Enhanced adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced adaptive mutation factor by increasing its range for better exploration.", "configspace": "", "generation": 62, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "60e08857-f35b-4103-b9e7-ac713589dec8", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            pa = 0.2 + 0.05 * eval_count / self.budget  # Dynamically adjusted discovery rate\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by dynamically adjusting the discovery rate of alien eggs.", "configspace": "", "generation": 63, "fitness": 0.17754059918616924, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.18836888896419124, 0.17504496240210154, 0.1692079461922149]}, "mutation_prompt": null}
{"id": "3cf545ca-b220-4535-969a-4a3b8222dd20", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa_init = 0.1 + 0.05 * np.random.rand()  # Initial discovery rate of alien eggs\n        pa_final = 0.4  # Final discovery rate to increase exploration\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Dynamic discovery rate\n            pa = pa_init + (pa_final - pa_init) * (eval_count / self.budget)\n            \n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration and exploitation balance by introducing dynamic discovery rates and focused particle updates.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Cannot apply_along_axis when any iteration dimensions are 0').", "error": "ValueError('Cannot apply_along_axis when any iteration dimensions are 0')", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {}, "mutation_prompt": null}
{"id": "061630c5-22cc-42c2-8509-012079fbff71", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.4 * (eval_count / self.budget)  # More dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.02 + 0.15 * adapt_factor  # Enhanced adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved exploration by introducing dynamic inertia and enhancing the adaptive mutation factor.", "configspace": "", "generation": 65, "fitness": 0.17342473833842584, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.18056842036955978, 0.19626934992529566, 0.14343644472042205]}, "mutation_prompt": null}
{"id": "9b1a13ce-5358-4231-97e3-2975e245081e", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5 + 0.2 * np.random.rand()  # Adaptive cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced convergence by dynamically adjusting the cognitive coefficient of PSO.", "configspace": "", "generation": 66, "fitness": 0.1544438344732624, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.15241900676533537, 0.13974439648535142, 0.17116810016910045]}, "mutation_prompt": null}
{"id": "0ebc1aa1-7b8e-4e20-95cd-b7f397cc1df4", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2\n        pa = 0.2 + 0.1 * np.random.rand()  # Adjusted adaptive discovery rate\n        n_particles = 30\n        w = 0.6  # Adjusted initial inertia weight\n        c1 = 1.5\n        c2 = 1.5 + 0.7 * np.random.rand()  # Adjusted adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.85 - 0.4 * (eval_count / self.budget)  # Adjusted dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced HybridCuckooPSO by introducing a faster-converging dynamic discovery rate and improved inertia weight adjustment.", "configspace": "", "generation": 67, "fitness": 0.1426352705765588, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.03.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.13843251061177775, 0.1078212752068004, 0.1816520259110983]}, "mutation_prompt": null}
{"id": "23fc9b1f-1c27-48ca-9fcd-25877ba0853f", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.15 * adapt_factor  # Adaptive mutation factor increased\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Adjusted the mutation factor to increase adaptively over time to enhance exploration.", "configspace": "", "generation": 68, "fitness": 0.14419180326260325, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.13899220187004635, 0.14535367376890662, 0.14822953414885676]}, "mutation_prompt": null}
{"id": "8cd60e99-73fb-4bd1-bb19-6199169f922d", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.015 + 0.1 * adapt_factor  # Slightly adjusted adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Slightly adjusted the adaptive mutation factor to improve exploration and convergence stability.", "configspace": "", "generation": 69, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "5a7c6feb-3dd0-452d-8897-8f3204a87d67", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.7 - 0.3 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Adjusted the dynamic inertia weight range to improve convergence speed without compromising exploration.", "configspace": "", "generation": 70, "fitness": 0.1598268455468229, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.14971786025247547, 0.16478650497052483, 0.16497617141746834]}, "mutation_prompt": null}
{"id": "0d745b09-1af7-42ff-968b-47a283e44f90", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n            # Adjust particle count based on remaining budget\n            n_particles = max(5, int(30 * (self.budget - eval_count) / self.budget))\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced dynamic particle count adjustment based on remaining budget to enhance exploration.", "configspace": "", "generation": 71, "fitness": 0.1803523824637644, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1902151089252747, 0.16608610855337202, 0.18475592991264644]}, "mutation_prompt": null}
{"id": "0d6fd7e4-8685-4211-8ac5-27fbe04ade99", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            pa = 0.2 + 0.05 * (eval_count / self.budget)  # Time-adaptive discovery rate\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced time-adaptive discovery rate of alien eggs to enhance exploration.", "configspace": "", "generation": 72, "fitness": 0.17297525124251903, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.00.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.17483902905456383, 0.17504496240210154, 0.16904176227089174]}, "mutation_prompt": null}
{"id": "6b7d00f7-0a27-486b-a0c5-f514b07d5163", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        n_nests = 25\n        beta = 3 / 2\n        pa = 0.2 + 0.05 * np.random.rand()\n        n_particles = 30\n        w = 0.5\n        c1 = 1.5\n        c2 = 1.5 + 0.5 * np.random.rand()\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            elite_nests = np.argsort(nest_fitness)[:5]  # Elite Selection\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget, elite_nests)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)\n            c1 = 2.0 - 0.5 * (eval_count / self.budget)  # Adaptive cognitive coefficient\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor, elite_indices):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        elite_impact = 0.1 * (nests[elite_indices] - new_nests[elite_indices])  # Elite influence\n        new_nests[elite_indices] += elite_impact\n\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration and exploitation by integrating dynamic parameter tuning and elite selection strategies.", "configspace": "", "generation": 73, "fitness": 0.15466344210013158, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.14502800604439658, 0.1496991252251032, 0.16926319503089493]}, "mutation_prompt": null}
{"id": "003e681c-fa08-400d-bbc7-4d91f4c17d66", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.2 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Modified adaptive mutation factor to improve exploration capabilities.", "configspace": "", "generation": 74, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "db0f6573-ebeb-4362-a879-21f8240c7002", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Added an adaptive inertia weight decay to improve convergence speed by enhancing early exploration and later exploitation.", "configspace": "", "generation": 75, "fitness": 0.16105286869629076, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.14040814447561312, 0.1605221233712274, 0.18222833824203177]}, "mutation_prompt": null}
{"id": "80599845-7951-466a-8eb4-6309d5980375", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.85 - 0.5 * (eval_count / self.budget)  # Adjusted dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by adjusting the dynamic inertia weight's lower bound for better convergence.", "configspace": "", "generation": 76, "fitness": 0.15822065034289923, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.03.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.11952076407727741, 0.17297192645408221, 0.18216926049733806]}, "mutation_prompt": null}
{"id": "d7fe9172-6940-4912-8710-70191e72f91b", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            c1_dynamic = 1.5 + (1.5 * eval_count / self.budget)  # Time-varying cognitive coefficient\n            velocities = (w * velocities +\n                          c1_dynamic * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced the velocity update step by using a time-varying cognitive coefficient for improved convergence.", "configspace": "", "generation": 77, "fitness": 0.15915848054378298, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1341549181332199, 0.16581500689953355, 0.17750551659859548]}, "mutation_prompt": null}
{"id": "009af96c-941a-4765-b76c-eb3e68d2dfba", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.2      # Fine-tuned cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Fine-tuned cognitive coefficient for improved exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.16363382589226227, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1368876400954182, 0.17134288603685288, 0.18267095154451574]}, "mutation_prompt": null}
{"id": "3e5c59df-2110-46c0-af2d-154073fd5c61", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.7      # Fine-tuned cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Fine-tuned the cognitive coefficient for better particle exploration.", "configspace": "", "generation": 79, "fitness": 0.16839694055390853, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.15052052700582907, 0.16812709466422093, 0.18654319999167557]}, "mutation_prompt": null}
{"id": "5efddd7f-b1a4-4f71-bac2-c1e3e7981613", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.05 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced the adaptive mutation factor in the Levy flights for improved exploration.", "configspace": "", "generation": 80, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "2b249a26-5b81-4993-b4a3-a8d05a1f3ec0", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25 + 0.05 * np.random.rand()  # Adjusted adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Slightly increased the adaptive discovery rate of alien eggs to enhance exploration capabilities.", "configspace": "", "generation": 81, "fitness": 0.16001308790055138, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1396378653355148, 0.17248884008185783, 0.16791255828428153]}, "mutation_prompt": null}
{"id": "45d7821b-2724-4271-bd5b-ecfea22a6dc1", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best) * (1 + adapt_factor)  # Dynamic scaling\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved global exploration by introducing dynamic levy flight scaling based on the evaluation progress.", "configspace": "", "generation": 82, "fitness": 0.10870454823776839, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.03.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.06556464961489639, 0.14929874550263278, 0.11125024959577601]}, "mutation_prompt": null}
{"id": "6418993c-15eb-4046-a940-56752dbbeab7", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5 + 0.5 * np.random.rand()  # Adaptive cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced dynamic adjustment to the cognitive coefficient c1 to balance exploration and exploitation.", "configspace": "", "generation": 83, "fitness": 0.143566933725792, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.12589712894692406, 0.13354946982457572, 0.1712542024058762]}, "mutation_prompt": null}
{"id": "c5c6fb4a-50ce-45c4-b010-e7c6ac97c1cb", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Chaotic sequence for dynamic adaptation\n            chaos = 0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget)\n\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < (pa * chaos)\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = (0.9 - 0.5 * (eval_count / self.budget)) * chaos  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by introducing a chaotic sequence to dynamically adjust the discovery rate and inertia weight.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Cannot apply_along_axis when any iteration dimensions are 0').", "error": "ValueError('Cannot apply_along_axis when any iteration dimensions are 0')", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {}, "mutation_prompt": null}
{"id": "f22f3790-2fc8-4765-aa40-5b06e887e666", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.02 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced the exploration phase by modifying the adaptive mutation factor calculation.", "configspace": "", "generation": 85, "fitness": 0.15637440481661644, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.16554224140686302, 0.1387895547249609, 0.16479141831802535]}, "mutation_prompt": null}
{"id": "1fb40b13-fd3e-4e34-bc7f-afaa8ee7a383", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.02 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Adjusted the adaptive mutation factor to potentially enhance exploration in the Levy flight step.", "configspace": "", "generation": 86, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "ade56c50-98a7-486a-b3dd-d604189d1a94", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.6 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced an adaptive inertia weight decrease factor in PSO to improve convergence.", "configspace": "", "generation": 87, "fitness": 0.17936570840237911, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.19267058395363956, 0.16207579884193413, 0.18335074241156368]}, "mutation_prompt": null}
{"id": "86eadc2d-347e-4ddb-96f9-2d78231129d8", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5 - 0.5 * (0.5 * (self.budget / self.budget))  # Dynamic cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Adjusted the cognitive coefficient to dynamically decrease, improving convergence speed by balancing exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.16202640376394095, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.15678928792571922, 0.17153814695306357, 0.15775177641304006]}, "mutation_prompt": null}
{"id": "780c9691-e663-48ae-95af-bbdf1988f02f", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.6 * (eval_count / self.budget)  # Dynamic inertia weight (changed 0.5 to 0.6)\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Fine-tuned the dynamic inertia weight decay to balance exploration and exploitation more effectively.", "configspace": "", "generation": 89, "fitness": 0.17936570840237911, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.19267058395363956, 0.16207579884193413, 0.18335074241156368]}, "mutation_prompt": null}
{"id": "323e6b4f-886c-4de5-931f-de48c40df663", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.02 + 0.1 * adapt_factor  # Fine-tuned adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Fine-tuned the adaptive mutation factor to enhance convergence speed.", "configspace": "", "generation": 90, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "9375b20f-2887-4af2-8ad2-45f3683289f3", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.02 + 0.11 * adapt_factor  # Refined adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Refined adaptive mutation factor for Levy flight to enhance exploration balance.", "configspace": "", "generation": 91, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "4aa2b7f1-d57a-4d81-8440-3e4eedf5b335", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * np.exp(-adapt_factor)  # Exponential decay for adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced the adaptive mutation factor by introducing an exponential decay to improve convergence speed.", "configspace": "", "generation": 92, "fitness": 0.17713891984605057, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.1730320538176925]}, "mutation_prompt": null}
{"id": "3a7c7569-74c6-4738-aace-928cc01069c1", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Introduced adaptive inertia weight in PSO to balance exploration and exploitation efficiently.", "configspace": "", "generation": 93, "fitness": 0.16105286869629076, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.14040814447561312, 0.1605221233712274, 0.18222833824203177]}, "mutation_prompt": null}
{"id": "6fada22c-5b24-4ff3-8e06-16acd8aea95c", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa * (1 + eval_count/self.budget)  # Modified line\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Adjust the adaptive discovery rate to be dynamically more explorative as the budget progresses.", "configspace": "", "generation": 94, "fitness": 0.16219802258796823, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.02.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.14254173042702767, 0.15835633230962498, 0.18569600502725203]}, "mutation_prompt": null}
{"id": "cf57eea1-ca36-4f65-b00e-e0324cef3d8f", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.25  # Improved discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5      # Inertia weight\n        c1 = 1.5     # Cognitive coefficient\n        c2 = 2.0  # Enhanced adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.4 * (eval_count / self.budget)  # Adjusted dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.07 * adapt_factor  # Adjusted adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced HybridCuckooPSO by optimizing parameter adaptation and utilizing elite solutions for improved convergence.", "configspace": "", "generation": 95, "fitness": 0.12489886815570521, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.03.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.08533904822275373, 0.15234233630812044, 0.13701521993624144]}, "mutation_prompt": null}
{"id": "d2c9543f-9e8e-435b-9db4-a268223ddaa5", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.8 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Improved the adaptive component of the social coefficient to enhance convergence speed.", "configspace": "", "generation": 96, "fitness": 0.18113538472805354, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.19147262688208821, 0.17492539936438545, 0.17700812793768694]}, "mutation_prompt": null}
{"id": "e1b95e16-8b77-4367-8fa3-d3410b8979ef", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.015 + 0.1 * adapt_factor  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced global search capabilities by slightly adjusting the adaptive mutation factor.", "configspace": "", "generation": 97, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
{"id": "6e8186d7-8b96-419e-b903-8cc6f4fed384", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * adapt_factor * np.linalg.norm(best) / self.dim  # Adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by adjusting the mutation factor in levy flights based on the current global best position.", "configspace": "", "generation": 98, "fitness": 0.18155472733649725, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18627947628903252]}, "mutation_prompt": null}
{"id": "e916a942-9d82-42eb-b0da-d5c6ed55e2ca", "solution": "import numpy as np\n\nclass HybridCuckooPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Initialize parameters\n        n_nests = 25\n        beta = 3 / 2  # Levy flight exponent\n        pa = 0.2 + 0.05 * np.random.rand()  # Adaptive discovery rate of alien eggs\n        n_particles = 30\n        w = 0.5       # Inertia weight\n        c1 = 1.5      # Cognitive coefficient\n        c2 = 1.5 + 0.5 * np.random.rand()  # Adaptive social coefficient\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n\n        # Initialize nests and particles\n        nests = np.random.uniform(bounds[0], bounds[1], (n_nests, self.dim))\n        particles = np.random.uniform(bounds[0], bounds[1], (n_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (n_particles, self.dim))\n        \n        nest_fitness = np.apply_along_axis(func, 1, nests)\n        personal_best_positions = np.copy(particles)\n        personal_best_fitness = np.apply_along_axis(func, 1, particles)\n        \n        global_best_idx = np.argmin(nest_fitness)\n        global_best_position = nests[global_best_idx]\n        global_best_fitness = nest_fitness[global_best_idx]\n        \n        eval_count = 0\n        \n        # Main optimization loop\n        while eval_count < self.budget:\n            # Cuckoo Search Phase\n            new_nests = self.levy_flights(nests, global_best_position, bounds, beta, eval_count/self.budget)\n            new_fitness = np.apply_along_axis(func, 1, new_nests)\n            eval_count += n_nests\n\n            # Replace some nests\n            replace = new_fitness < nest_fitness\n            nests[replace] = new_nests[replace]\n            nest_fitness[replace] = new_fitness[replace]\n\n            # Abandon some nests\n            abandon_indices = np.random.rand(n_nests) < pa\n            nests[abandon_indices] = np.random.uniform(bounds[0], bounds[1], (np.sum(abandon_indices), self.dim))\n            nest_fitness[abandon_indices] = np.apply_along_axis(func, 1, nests[abandon_indices])\n            eval_count += np.sum(abandon_indices)\n\n            # Update global best\n            current_global_best_idx = np.argmin(nest_fitness)\n            if nest_fitness[current_global_best_idx] < global_best_fitness:\n                global_best_position = nests[current_global_best_idx]\n                global_best_fitness = nest_fitness[current_global_best_idx]\n\n            # Particle Swarm Optimization Phase\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - particles) +\n                          c2 * r2 * (global_best_position - particles))\n            particles += velocities\n\n            # Clamp particles within bounds\n            particles = np.clip(particles, bounds[0], bounds[1])\n\n            # Evaluate particles\n            particle_fitness = np.apply_along_axis(func, 1, particles)\n            eval_count += n_particles\n\n            # Update personal bests\n            better_fitness = particle_fitness < personal_best_fitness\n            personal_best_positions[better_fitness] = particles[better_fitness]\n            personal_best_fitness[better_fitness] = particle_fitness[better_fitness]\n\n            # Update global best from particles\n            current_particle_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_particle_best_idx] < global_best_fitness:\n                global_best_position = personal_best_positions[current_particle_best_idx]\n                global_best_fitness = personal_best_fitness[current_particle_best_idx]\n\n        return global_best_position\n\n    def levy_flights(self, nests, best, bounds, beta, adapt_factor):\n        # Levy flight step sizes with adaptive mutation\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        \n        u = np.random.normal(0, sigma, nests.shape)\n        v = np.random.normal(0, 1, nests.shape)\n        step = u / np.abs(v) ** (1 / beta)\n\n        mutation_factor = 0.01 + 0.1 * np.sin(np.pi * adapt_factor)  # Sine-based adaptive mutation factor\n        step_size = mutation_factor * step * (nests - best)\n        new_nests = nests + step_size\n\n        # Clip new nests to the bounds\n        new_nests = np.clip(new_nests, bounds[0], bounds[1])\n        return new_nests", "name": "HybridCuckooPSO", "description": "Enhanced exploration by adjusting the mutation factor in the Levy flight step using a sine-based adaptation.", "configspace": "", "generation": 99, "fitness": 0.18154425935145835, "feedback": "The algorithm HybridCuckooPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.01.", "error": "", "parent_id": "dda403ea-ec6a-4083-bb92-5860e9c9a2f5", "metadata": {"aucs": [0.1938625979955605, 0.16452210772489873, 0.18624807233391583]}, "mutation_prompt": null}
