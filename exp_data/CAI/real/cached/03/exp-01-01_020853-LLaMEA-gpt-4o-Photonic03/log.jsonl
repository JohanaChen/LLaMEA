{"id": "2e7f761f-dad2-4674-8470-8d27bef05328", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.1 * (best_individual - self.q_population[i])\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution\n\n# Example usage:\n# optimizer = AdaptiveQuantumEA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "name": "AdaptiveQuantumEA", "description": "Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) combining quantum-inspired representation with dynamic adaptive strategies for efficient global optimization.", "configspace": "", "generation": 0, "fitness": 0.24142813749330772, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.24142813749330772]}, "mutation_prompt": null}
{"id": "232222a4-79bf-4586-aca1-5b879dda0e88", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.1 * (best_individual - self.q_population[i])\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            # Adjust population size dynamically based on fitness variance\n            if np.var(fitness) > 0.1:  # New line for dynamic population adjustment\n                self.population_size = min(int(self.population_size * 1.1), 100)\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced AQEA by adjusting the population size dynamically based on fitness variance for better exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.24142813749330772, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "2e7f761f-dad2-4674-8470-8d27bef05328", "metadata": {"aucs": [0.24142813749330772]}, "mutation_prompt": null}
{"id": "c631f963-6de5-4ede-a7b0-5ac4778dc077", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.2 * (best_individual - self.q_population[i])  # Increased influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution\n\n# Example usage:\n# optimizer = AdaptiveQuantumEA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "name": "AdaptiveQuantumEA", "description": "Improved adaptive strategy by increasing the influence of best individuals for faster convergence.", "configspace": "", "generation": 2, "fitness": 0.2415074689905189, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "2e7f761f-dad2-4674-8470-8d27bef05328", "metadata": {"aucs": [0.2415074689905189]}, "mutation_prompt": null}
{"id": "0dea624d-4760-4705-aa4b-b6ede8487877", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.25 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Adjusted the quantum population update rule to enhance exploration.", "configspace": "", "generation": 3, "fitness": 0.24151136828952924, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "c631f963-6de5-4ede-a7b0-5ac4778dc077", "metadata": {"aucs": [0.24151136828952924]}, "mutation_prompt": null}
{"id": "c24a1bf2-9a60-43ce-b753-6e277980e483", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.3 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Increased the influence factor in the quantum update rule to boost exploration.", "configspace": "", "generation": 4, "fitness": 0.24153637346019452, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "0dea624d-4760-4705-aa4b-b6ede8487877", "metadata": {"aucs": [0.24153637346019452]}, "mutation_prompt": null}
{"id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.35 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Further enhanced exploration by slightly increasing the quantum update influence factor from 0.3 to 0.35 to balance exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.24153987057635418, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "c24a1bf2-9a60-43ce-b753-6e277980e483", "metadata": {"aucs": [0.24153987057635418]}, "mutation_prompt": null}
{"id": "2b6f7d7c-bb24-485a-aa44-ed03dfc36dd5", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly tweak the quantum update influence factor from 0.35 to 0.36 to enhance convergence speed while maintaining exploration balance.", "configspace": "", "generation": 6, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "2e1327ee-3a29-4bea-86ea-ffe2a9caa4cc", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced quantum update influence factor slightly to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "6c5dd517-5905-405b-adc9-d952fad2c267", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Fine-tune quantum update influence to 0.36 to enhance convergence speed.", "configspace": "", "generation": 8, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "8fa1cb7c-3267-461d-978c-1d984da8ba07", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.37 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase the quantum update influence factor from 0.35 to 0.37 to further improve exploration capabilities.", "configspace": "", "generation": 9, "fitness": 0.24152486014404817, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152486014404817]}, "mutation_prompt": null}
{"id": "6be0e941-dd30-477a-b1fd-b563225200e1", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.37 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase the quantum update influence factor to 0.37 to enhance exploration capabilities.", "configspace": "", "generation": 10, "fitness": 0.24152486014404817, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152486014404817]}, "mutation_prompt": null}
{"id": "8e57f60b-2f84-4131-bde1-3bf861a2b1ae", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.34 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly reduce the quantum update influence factor from 0.35 to 0.34 to balance exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.2415218734309036, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.2415218734309036]}, "mutation_prompt": null}
{"id": "01c53a1e-3308-4ee6-bd1e-814eab530c6e", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.37 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration by increasing the quantum update influence factor from 0.35 to 0.37 to further balance exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.24152486014404817, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152486014404817]}, "mutation_prompt": null}
{"id": "8c893812-8cfa-4cb0-98a5-6f1d57cd69bf", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase the quantum update influence factor from 0.35 to 0.36 to enhance convergence speed while maintaining a balance between exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "ba890f7b-30c0-4783-9ad9-88c45e815102", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase quantum update influence factor to 0.36 for better exploration.", "configspace": "", "generation": 14, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "22c56dec-931b-4033-92de-262e466d9451", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced adaptive strategy by further increasing the quantum update influence factor to 0.36 to promote a better balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "bfbb59cf-ba4b-41ac-b767-94c7c5d28777", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly enhance the quantum influence factor from 0.35 to 0.36 for better convergence balance.", "configspace": "", "generation": 16, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "ce8c8691-2c1b-47db-a448-709fb2e99a07", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase quantum update influence factor to 0.36 for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "8603cb85-5ba6-46f8-8156-1522ff775c35", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Further fine-tuned exploration by slightly adjusting the quantum update influence factor to 0.36 for a marginally different balance between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "59bf1367-c126-4a6c-8b46-f57d6e25d8f5", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Further enhance exploration by slightly increasing the quantum update influence factor from 0.35 to 0.36 for improved adaptation.", "configspace": "", "generation": 19, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "4afa7029-126c-4a00-ba3e-72d860eec5a0", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increased the quantum update influence factor from 0.35 to 0.36 to enhance exploration.", "configspace": "", "generation": 20, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "6079ced4-f895-48e9-8a1d-a918af54c64e", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.33 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhance exploitation by slightly reducing the quantum update influence factor from 0.35 to 0.33 for better convergence.", "configspace": "", "generation": 21, "fitness": 0.24153683573349616, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24153683573349616]}, "mutation_prompt": null}
{"id": "817ea518-1c92-41a8-a5f9-a38085cc5205", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.34 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Fine-tune the quantum update factor for an optimal balance between exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.2415218734309036, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.2415218734309036]}, "mutation_prompt": null}
{"id": "32550c75-9047-4548-8ff3-d5236868f449", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.37 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Fine-tuned exploration by modifying the quantum update influence factor to 0.37 for enhanced convergence.", "configspace": "", "generation": 23, "fitness": 0.24152486014404817, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152486014404817]}, "mutation_prompt": null}
{"id": "1501ad5b-4c5d-4fe9-8280-13e97467a968", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.37 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Further enhanced exploration by increasing the quantum update influence factor from 0.35 to 0.37 for better convergence.", "configspace": "", "generation": 24, "fitness": 0.24152486014404817, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152486014404817]}, "mutation_prompt": null}
{"id": "29c8b257-d3e1-4472-a1a0-fae879d98696", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.37 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly enhance the quantum update factor from 0.35 to 0.37 for improved exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.24152486014404817, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152486014404817]}, "mutation_prompt": null}
{"id": "8c5e6bc2-cda7-483f-a664-3783a9abdfd1", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Refining exploration balance by adjusting influence factor to 0.36.", "configspace": "", "generation": 26, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "23bdefa6-eb20-4186-ab3f-dbde907844c2", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced convergence by increasing the quantum update influence factor from 0.35 to 0.36 for improved balance of exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "c67ac550-cc9e-4caa-9850-8bdce0f7b6a7", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.36 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced the quantum update influence factor to 0.36 to improve exploitation and convergence.", "configspace": "", "generation": 28, "fitness": 0.24152677196252315, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24152677196252315]}, "mutation_prompt": null}
{"id": "eadcf3f9-cc54-4a0a-a989-1aeeeca8d894", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.38 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved balance between exploration and exploitation by adjusting the quantum update influence factor to 0.38.", "configspace": "", "generation": 29, "fitness": 0.2415389831167033, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.2415389831167033]}, "mutation_prompt": null}
{"id": "3f3f1d17-b100-4a64-b02d-b105649d0f00", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.35 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Increase population size to 60 to explore more solutions and potentially enhance algorithm performance.", "configspace": "", "generation": 30, "fitness": 0.24153651087662786, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24153651087662786]}, "mutation_prompt": null}
{"id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced balance of exploration and exploitation by optimizing quantum update influence and population strategy.", "configspace": "", "generation": 31, "fitness": 0.24155840938953677, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "6f2006fe-4ff1-4531-9279-17d1ecef44dd", "metadata": {"aucs": [0.24155840938953677]}, "mutation_prompt": null}
{"id": "2b0d8b3f-9287-4994-b21b-c946369ba2a3", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change: Increase exploration by randomizing a larger portion of the population\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration by increasing the randomization portion of the population.", "configspace": "", "generation": 32, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "5ef9ff8d-3514-4713-9ff1-82fb6b96d794", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 7, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Increase exploration by adjusting the randomization portion to 15% of the population to enhance global search capability.", "configspace": "", "generation": 33, "fitness": 0.2415348532283057, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.2415348532283057]}, "mutation_prompt": null}
{"id": "e4691c56-d799-4e91-886b-81bdb2016aed", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        fitness_diversity = np.std(fitness)  # Compute fitness diversity\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += (0.4 + 0.1 * fitness_diversity) * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduced adaptive dynamic scaling of quantum updates based on fitness diversity to improve convergence.", "configspace": "", "generation": 34, "fitness": 0.24155840938953677, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24155840938953677]}, "mutation_prompt": null}
{"id": "bbf58328-9a35-43e7-85af-7c6f2e59c5ec", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n        # Change: Increase randomization portion to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration by increasing the randomization portion of the population.", "configspace": "", "generation": 35, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "8490d33a-cd4a-4758-9a75-df2d7a8d8b65", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                variance = np.var(self.q_population)\n                update_coefficient = 0.4 + 0.1 * variance  # Adjusted influence dynamically\n                self.q_population[i] += update_coefficient * (best_individual - self.q_population[i])\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced population diversity by dynamically adjusting the quantum update coefficient based on population variance.", "configspace": "", "generation": 36, "fitness": 0.24153152935279454, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24153152935279454]}, "mutation_prompt": null}
{"id": "29422f05-0d53-4020-9a0a-e7e1ecbf4630", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced exploration by randomizing a larger portion of the population.", "configspace": "", "generation": 37, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "f558dcbe-c49a-4cd4-8817-c0622dbf1961", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n            # Change 1: Dynamic reduction of population size for focused exploration\n            self.population_size = max(10, self.population_size - 1)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduced dynamic population reduction to enhance convergence speed by focusing resources on promising areas.", "configspace": "", "generation": 38, "fitness": 0.24154757066504395, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154757066504395]}, "mutation_prompt": null}
{"id": "9a378e9f-c554-46ac-85e4-8228669dbd59", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.q_population = np.random.rand(self.population_size, dim)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.8  # Mutation factor for differential evolution\n        self.crossover_rate = 0.7  # Crossover rate for differential evolution\n\n    def measure(self, q_individual):\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def differential_evolution(self, index, classical_population):\n        indices = [i for i in range(self.population_size) if i != index]\n        a, b, c = classical_population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector = np.where(crossover, mutant_vector, classical_population[index])\n        return np.clip(trial_vector, 0, 1)\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]\n        for i in range(self.population_size):\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n                \n                # Differential evolution step\n                trial_vector = self.differential_evolution(i, classical_population)\n                trial_fitness = func(trial_vector)\n                if trial_fitness < fitness[i]:\n                    classical_population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "AdaptiveQuantumEA is enhanced by hybridizing with differential evolution strategies for improved search space exploration and exploitation balance.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {}, "mutation_prompt": null}
{"id": "0f5de70d-ac36-45c3-b60a-06a947bc73c7", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n        # Change 1: Introduce dynamic population resizing\n        fitness_variance = np.var(fitness)\n        if fitness_variance < 0.1:  # Threshold for variance\n            self.population_size = max(30, self.population_size // 2)\n        else:\n            self.population_size = min(100, self.population_size * 2)\n\n        # Change 2: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved balance of exploration and exploitation by introducing dynamic population resizing based on fitness variance.", "configspace": "", "generation": 40, "fitness": 0.24151558475120216, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24151558475120216]}, "mutation_prompt": null}
{"id": "7fdbf767-abcb-4738-9ce7-446386fad3a2", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved the exploration mechanism by introducing a slight modification in the randomization strategy to maintain diversity.", "configspace": "", "generation": 41, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "8c663378-3e48-46da-a03a-44197887c4b7", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.q_population = np.random.rand(self.population_size, dim)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]\n        for i in range(self.population_size):\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n                self.population_size = min(100, int(self.population_size * 1.1))  # Increase population size for more exploration\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduced a dynamic population size adjustment based on current best fitness improvement to enhance exploration-exploitation balance.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {}, "mutation_prompt": null}
{"id": "6d1ad259-d6c9-488e-9e42-85b29c672ab7", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:int(self.population_size * 0.6)]  # Top 60% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced quantum-inspired strategy by increasing population diversity and optimizing selection pressure.", "configspace": "", "generation": 43, "fitness": 0.24148611270618092, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24148611270618092]}, "mutation_prompt": null}
{"id": "5136465d-acc6-41dc-b70f-f3341bb2fd7a", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.q_population = np.random.rand(self.population_size, dim)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.diversity_threshold = 0.1\n\n    def measure(self, q_individual):\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n    \n    def calculate_diversity(self, classical_population):\n        return np.mean(np.std(classical_population, axis=0))\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]\n        diversity = self.calculate_diversity(classical_population)\n        \n        if diversity < self.diversity_threshold:\n            self.q_population = np.random.rand(self.population_size, self.dim)\n        else:\n            for i in range(self.population_size):\n                if i not in best_indices:\n                    best_individual = classical_population[np.random.choice(best_indices)]\n                    self.q_population[i] += 0.3 * (best_individual - self.q_population[i])\n                    self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n            \n            random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n            self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Quantum-inspired optimization with adaptive diversity control and dynamic population resizing.", "configspace": "", "generation": 44, "fitness": 0.24152126869360946, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24152126869360946]}, "mutation_prompt": null}
{"id": "9dc9adf0-9327-4c1e-9dcb-f4c9408d7042", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 52  # Increased population size from 50 to 52\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase the population size to enhance search diversity and solution refinement.", "configspace": "", "generation": 45, "fitness": 0.24151527715725596, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24151527715725596]}, "mutation_prompt": null}
{"id": "28c91ebf-abef-493e-8e09-a226d854587c", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.q_population = np.random.rand(self.population_size, dim)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]\n        for i in range(self.population_size):\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                influence = 0.4 + (0.2 * np.random.rand())  # Dynamic influence\n                self.q_population[i] += influence * (best_individual - self.q_population[i])\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n            self.population_size = self.initial_population_size + evaluations // (self.budget // 10)  # Adaptive size\n\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduce adaptive population size and dynamic quantum influence adjustments to improve convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {}, "mutation_prompt": null}
{"id": "89cacd13-33d1-4fe0-9e31-18db53aa1013", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.42 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced balance of exploration and exploitation by slightly increasing the quantum update influence factor for improved convergence.", "configspace": "", "generation": 47, "fitness": 0.24154294614259364, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154294614259364]}, "mutation_prompt": null}
{"id": "ab88df0f-d735-4f29-ae1a-a23e4ec5bd15", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        # Change 1: Adjust update influence based on fitness variance\n        learning_rate = 0.4 * (1 + np.std(fitness))\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += learning_rate * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved update influence by adjusting learning rate dynamically based on fitness variance.", "configspace": "", "generation": 48, "fitness": 0.24155840938953677, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24155840938953677]}, "mutation_prompt": null}
{"id": "b18d8fb6-38d2-490e-b34f-e1802f43abd3", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim) + np.random.normal(0, 0.05, (len(random_indices), self.dim))  # Added perturbation\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduce slight random perturbation to the quantum population to improve exploration.", "configspace": "", "generation": 49, "fitness": 0.2415348532283057, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.2415348532283057]}, "mutation_prompt": null}
{"id": "f6632a81-4d2d-4f09-bc97-e9ade8bce434", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Implement adaptive mutation scaling based on diversity\n        diversity = np.std(self.q_population, axis=0)\n        scaling_factor = 0.1 * (1 + np.mean(diversity))\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.clip(self.q_population[random_indices] + scaling_factor * np.random.randn(len(random_indices), self.dim), 0, 1)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration by introducing diversity in the quantum population using adaptive mutation scaling.", "configspace": "", "generation": 50, "fitness": 0.24152830720370033, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24152830720370033]}, "mutation_prompt": null}
{"id": "935a5024-fb96-4107-affa-342f65672eda", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)  # Increased randomization\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration by adjusting randomization of the population to enhance diversity.", "configspace": "", "generation": 51, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "1ef6d6bd-8a79-4a97-a4f6-6f9cf88ad530", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.45 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Adjusted quantum influence factor for improved balance between exploration and exploitation.", "configspace": "", "generation": 52, "fitness": 0.24153933323442933, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24153933323442933]}, "mutation_prompt": null}
{"id": "1357eb31-a908-4438-ab80-ae076668cc73", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Minor adjustment in quantum population update for enhanced exploration dynamics.", "configspace": "", "generation": 53, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "2f964ba8-4c30-4e43-b164-4e484a035986", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.45 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increased quantum population update influence for better convergence.", "configspace": "", "generation": 54, "fitness": 0.24153933323442933, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24153933323442933]}, "mutation_prompt": null}
{"id": "297578ef-36ff-4f8d-bf4a-8730c721bdf5", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 8, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improve exploration by adjusting randomization rate.", "configspace": "", "generation": 55, "fitness": 0.24151606610585397, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24151606610585397]}, "mutation_prompt": null}
{"id": "050c607a-a6c4-43a8-93d9-6ef0e02d7ddb", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = np.random.choice(sorted_indices[:self.population_size // 2], self.population_size // 2, replace=False)  # Stochastic selection\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introducing stochastic selection of best indices to enhance diversity without compromising convergence.", "configspace": "", "generation": 56, "fitness": 0.24153226396854532, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24153226396854532]}, "mutation_prompt": null}
{"id": "7dd1b67b-cca3-4a95-857b-c124779f00bb", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.6 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced exploration by integrating adaptive scaling with dynamic population size adjustment.", "configspace": "", "generation": 57, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "ad166c54-c7f4-4178-9a75-5e0f00d6f36e", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.45 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase the quantum update influence for improved exploration.", "configspace": "", "generation": 58, "fitness": 0.24153933323442933, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24153933323442933]}, "mutation_prompt": null}
{"id": "d3a1571c-cace-41b1-ad09-f6aad5a152b9", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Dynamic population size adjustment based on convergence progress\n            self.population_size = max(10, int(50 * (1 - evaluations / self.budget)))  # Modified line\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced exploration by dynamically adjusting population size based on convergence progress.", "configspace": "", "generation": 59, "fitness": 0.2415357048388057, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.2415357048388057]}, "mutation_prompt": null}
{"id": "564135c8-e267-4411-958d-0eb5756e05ef", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.35 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Fine-tuned quantum influence and population strategy for enhanced optimization performance.", "configspace": "", "generation": 60, "fitness": 0.24150745753202085, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24150745753202085]}, "mutation_prompt": null}
{"id": "47e1ed29-9aa2-4505-8fe7-9dd5cb31c4d7", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a slightly larger portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 8, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase the exploration factor by updating more individuals randomly in the quantum population.", "configspace": "", "generation": 61, "fitness": 0.24151606610585397, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24151606610585397]}, "mutation_prompt": null}
{"id": "901511c6-02b5-440c-b9a7-1e12ccd9e398", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.45 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved balance of exploration and exploitation by refining quantum population update parameter.", "configspace": "", "generation": 62, "fitness": 0.24153933323442933, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24153933323442933]}, "mutation_prompt": null}
{"id": "db974a5f-28f0-438d-b698-f07411acf94f", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved convergence through increased influence from the best individuals in quantum population updates.", "configspace": "", "generation": 63, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "1e7dbc8f-8f1e-47f2-932b-1f65ecab71a9", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced convergence by increasing the influence factor in the quantum population update process.", "configspace": "", "generation": 64, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "97f8327b-1396-4b41-a54c-e0d586438a21", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced balance of exploration and exploitation by optimizing quantum update influence and population strategy with slightly increased exploration through more randomized individuals.", "configspace": "", "generation": 65, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "70266022-d4c8-46cf-85ac-819024ffb985", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.6 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Minor enhancement by adjusting the update influence factor for improved convergence.", "configspace": "", "generation": 66, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "c4293c00-40b5-4946-88ab-2d1cf9e1ba64", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "AdaptiveQuantumEA with increased influence factor for rapid convergence.", "configspace": "", "generation": 67, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "b1bda29d-ede9-4ae3-9524-3622a67bba12", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)  # Increased randomization\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improve exploration by increasing the randomized portion of the population.", "configspace": "", "generation": 68, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "771cee43-94ac-4288-8dcf-8f8291cc3bd5", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 6, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Increase the exploration capability by adjusting the randomization portion to 15% of the population.", "configspace": "", "generation": 69, "fitness": 0.2415400558160623, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.2415400558160623]}, "mutation_prompt": null}
{"id": "de54588a-62f5-4d90-8239-d04838c26439", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        # Change 1: Initialize diversity control parameters\n        self.diversity_threshold = 0.1\n        self.q_population = np.random.rand(self.population_size, dim)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]\n        # Change 2: Introduce adaptive mutation strategy\n        mutation_strength = np.std(classical_population) * 0.1\n        for i in range(self.population_size):\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])\n                # Change 3: Apply mutation for exploration\n                self.q_population[i] += np.random.normal(0, mutation_strength, self.dim)\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 4: Enhanced exploration by adaptive randomization\n        if np.std(fitness) < self.diversity_threshold:\n            random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n            self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration and exploitation through adaptive mutation and crossover strategies within a quantum-inspired framework.", "configspace": "", "generation": 70, "fitness": 0.24151806988729596, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24151806988729596]}, "mutation_prompt": null}
{"id": "fa12ee71-0f11-4b8c-acd8-8d202382ad3d", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.35 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration and exploitation balance by adjusting quantum update influence.", "configspace": "", "generation": 71, "fitness": 0.24152542897618523, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24152542897618523]}, "mutation_prompt": null}
{"id": "26bf8759-2347-46e2-85b0-f39f0ebd5fdd", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, int(self.population_size * 0.2), replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced AdaptiveQuantumEA by increasing the random portion to 20% of the population for improved exploration and divergence.", "configspace": "", "generation": 72, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "7f1787cb-2f40-4f58-92e6-2de2a1b9d1a1", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        diversity_factor = np.std(fitness) / (np.mean(fitness) + 1e-8)  # Change 1: Dynamically vary influence factor\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * diversity_factor * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Further enhance exploration by dynamically varying the influence factor based on population diversity.", "configspace": "", "generation": 73, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "1ce5f798-f95f-499c-aace-0a8cb1ce24c5", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += np.random.uniform(0.3, 0.5) * (best_individual - self.q_population[i])  # Stochastic influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introducing stochastic influence adjustment to improve exploration-exploitation balance in quantum-inspired encoding.", "configspace": "", "generation": 74, "fitness": 0.2415389831167033, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.2415389831167033]}, "mutation_prompt": null}
{"id": "18599b41-970a-4e4d-86c8-19ae340451fe", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)  # Increased from 1/10\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increased randomization to encourage more exploration within the quantum-inspired population.", "configspace": "", "generation": 75, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "0b79d7e0-3c7b-4233-8e00-dbcf457cead5", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduce diversity by modifying the influence factor for quantum population update from 0.4 to 0.5.", "configspace": "", "generation": 76, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "61da8b9f-3d96-4fe2-8b0b-c3d5c638bea8", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)  # Changed from // 10 to // 5\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration by increasing the randomized portion of the quantum population.", "configspace": "", "generation": 77, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "d8e62c62-e28b-4fde-aa15-a860081575b3", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n        \n        # Additional randomization for exploration enhancement\n        another_random_indices = np.random.choice(self.population_size, self.population_size // 15, replace=False)\n        self.q_population[another_random_indices] = np.random.rand(len(another_random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Refined exploration through increased diversity by introducing an additional randomization step to expand the search space.", "configspace": "", "generation": 78, "fitness": 0.2415132058295153, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.2415132058295153]}, "mutation_prompt": null}
{"id": "b890503f-150b-47f0-9a63-02bb41576645", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                influence_factor = 0.3 + 0.1 * (self.budget - sum(fitness) / len(fitness)) / self.budget\n                self.q_population[i] += influence_factor * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improve convergence by dynamically adjusting quantum update influence and injection of uniformly distributed individuals.", "configspace": "", "generation": 79, "fitness": 0.24155840938953677, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24155840938953677]}, "mutation_prompt": null}
{"id": "5f883853-5767-4748-b381-a50db1f7e9f0", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                influence_factor = 0.2 + 0.2 * (self.budget - np.sum(fitness)) / self.budget  # Dynamic adjustment\n                self.q_population[i] += influence_factor * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n\n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduced a dynamic adjustment to quantum population update influence to improve convergence adaptability.", "configspace": "", "generation": 80, "fitness": 0.24155840938953677, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24155840938953677]}, "mutation_prompt": null}
{"id": "eb47ab09-7a75-4523-b420-e01546b86083", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.42 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Slightly increase the influence of the best individuals on the quantum population for improved convergence.", "configspace": "", "generation": 81, "fitness": 0.24154294614259364, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154294614259364]}, "mutation_prompt": null}
{"id": "23bf8a77-24e3-49bb-80ea-2f34094097c9", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n        \n        # Introduce adaptive population resizing for dynamic exploration-exploitation balance\n        self.population_size = max(10, int(self.population_size * 0.95 + 1))  # Adaptive resizing\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduced adaptive population resizing for improved exploration and exploitation balance in quantum-inspired evolutionary algorithm.", "configspace": "", "generation": 82, "fitness": 0.24154135646300146, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154135646300146]}, "mutation_prompt": null}
{"id": "46f9900d-93d9-4bb4-81ea-425d08ccf36a", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        elite_index = sorted_indices[0]  # Change 1: Identify elite individual\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] += 0.1 * (classical_population[elite_index] - self.q_population[i])  # Change 2: Elite influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 3: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n        # Change 4: Dynamic adjustment of population size for adaptability\n        if np.std(fitness) < 0.01:  # Low diversity threshold\n            self.population_size = min(self.population_size + 5, 100)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved adaptive quantum-inspired EA with enhanced exploration via elite individual influence and dynamic population size.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {}, "mutation_prompt": null}
{"id": "c23de4eb-1e2e-414b-bbb5-6871c42f3271", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)  # Change 1: Calculate fitness diversity\n        \n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                influence = 0.4 * (1 + fitness_diversity)  # Change 2: Adjust influence dynamically\n                self.q_population[i] += influence * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 3: Randomize a portion of the population based on diversity\n        random_indices = np.random.choice(self.population_size, int(self.population_size * 0.1 * (1 + fitness_diversity)), replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration and exploitation by dynamically adjusting quantum influence based on current fitness diversity.", "configspace": "", "generation": 84, "fitness": 0.24155840938953677, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24155840938953677]}, "mutation_prompt": null}
{"id": "7bbfcd7a-a9da-4213-9fe0-68a8350bc30a", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced balance of exploration and exploitation by optimizing quantum update influence and population strategy with increased randomness to improve exploration.", "configspace": "", "generation": 85, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "27d92b74-b006-4d9d-8e54-e3b8c1e5a0a6", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.3 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Fine-tune the exploration factor in the quantum update to enhance adaptability to problem landscapes.", "configspace": "", "generation": 86, "fitness": 0.24150204802217934, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24150204802217934]}, "mutation_prompt": null}
{"id": "ae030947-f8ba-4534-8cac-94412998b66d", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved adaptive quantum update by optimizing the influence factor for better exploration.", "configspace": "", "generation": 87, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "2669ae2c-18bb-4898-bd34-4c4574bd249e", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.42 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduce a slight increase in update influence to further improve convergence speed.", "configspace": "", "generation": 88, "fitness": 0.24154294614259364, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154294614259364]}, "mutation_prompt": null}
{"id": "55202020-db7b-48a4-8b3c-e0e5c0eb5abc", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduced a dynamic population size to balance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 89, "fitness": 0.24155840938953677, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24155840938953677]}, "mutation_prompt": null}
{"id": "45b199b4-5cea-440c-bf8f-24f7c12cebce", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)  # Changed from self.population_size // 10\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Augment the degree of randomization to enhance exploration in the quantum population.", "configspace": "", "generation": 90, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "123a0e53-a483-4599-babe-109de02e4711", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced quantum update to further refine the balance between exploration and exploitation.", "configspace": "", "generation": 91, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "5a3a2fd8-3248-4858-9829-a93bfe0ec2b7", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.5 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Minor adjustment to balance exploration and exploitation more effectively by modifying the update coefficient.", "configspace": "", "generation": 92, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "36c41b27-c675-4d08-87e2-4c9a3564a9d5", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1 (0.8%): Randomize a larger portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced quantum population diversity by increasing exploration through randomization.", "configspace": "", "generation": 93, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "845c7ede-47d8-4548-bf2a-447c486932c2", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a larger portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhance exploration by adjusting population randomization strategy.", "configspace": "", "generation": 94, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "d617d4e0-96c5-4e4a-b946-ef2435b306f2", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 8, replace=False)  # Increased portion size\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced exploratory capabilities by tweaking the randomized portion to boost diversity.", "configspace": "", "generation": 95, "fitness": 0.24151606610585397, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24151606610585397]}, "mutation_prompt": null}
{"id": "a81af6e4-e180-4138-9af5-d53873e20abf", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        influence_factor = 0.4 + 0.1 * np.random.rand()  # Dynamic adjustment\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += influence_factor * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Introduced dynamic adjustment of the quantum population influence factor to better balance exploration and exploitation.", "configspace": "", "generation": 96, "fitness": 0.2415329038722287, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.2415329038722287]}, "mutation_prompt": null}
{"id": "8bb3c9d0-9044-400b-91ab-c5778be3d23e", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.q_population = np.random.rand(self.population_size, dim)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_rate = 0.1  # New mutation rate parameter\n\n    def measure(self, q_individual):\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]\n        for i in range(self.population_size):\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                learning_rate = 0.5 * (1 - fitness[i] / np.max(fitness))  # Adaptive learning rate\n                self.q_population[i] += learning_rate * (best_individual - self.q_population[i])\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        random_indices = np.random.choice(self.population_size, self.population_size // 10, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n        \n        # Apply mutation to the population\n        mutation_mask = np.random.rand(*self.q_population.shape) < self.mutation_rate\n        self.q_population += mutation_mask * np.random.normal(0, 0.1, self.q_population.shape)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved dual-phase strategy enhances both exploration and exploitation by integrating adaptive mutation and dynamic learning rates.", "configspace": "", "generation": 97, "fitness": 0.24143369179970597, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24143369179970597]}, "mutation_prompt": null}
{"id": "505e004a-5563-4330-891b-a335795da748", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Improved exploration through diversified quantum population update strategy.", "configspace": "", "generation": 98, "fitness": 0.24154742614871738, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24154742614871738]}, "mutation_prompt": null}
{"id": "aa169a84-a623-453d-8583-6135b7a2aa33", "solution": "import numpy as np\n\nclass AdaptiveQuantumEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.q_population = np.random.rand(self.population_size, dim)  # Quantum-inspired encoding\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def measure(self, q_individual):\n        # Measure quantum individual to classical solution\n        return np.round(q_individual)\n\n    def evaluate_population(self, func):\n        classical_population = np.array([self.measure(q_ind) for q_ind in self.q_population])\n        fitness = np.array([func(ind) for ind in classical_population])\n        return fitness, classical_population\n\n    def update_quantum_population(self, fitness, classical_population):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:self.population_size // 2]  # Top 50% individuals\n        for i in range(self.population_size):\n            # Update rule inspired by best individuals\n            if i not in best_indices:\n                best_individual = classical_population[np.random.choice(best_indices)]\n                self.q_population[i] += 0.4 * (best_individual - self.q_population[i])  # Adjusted influence\n                self.q_population[i] = np.clip(self.q_population[i], 0, 1)\n        \n        # Change 1: Randomize a portion of the population to enhance exploration\n        random_indices = np.random.choice(self.population_size, self.population_size // 8, replace=False)\n        self.q_population[random_indices] = np.random.rand(len(random_indices), self.dim)\n\n    def __call__(self, func):\n        func_bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness, classical_population = self.evaluate_population(func)\n            evaluations += len(fitness)\n\n            # Update the best solution found\n            min_fitness_index = np.argmin(fitness)\n            if fitness[min_fitness_index] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_index]\n                self.best_solution = classical_population[min_fitness_index]\n\n            if evaluations >= self.budget:\n                break\n\n            self.update_quantum_population(fitness, classical_population)\n\n        # Convert solution to real-world scale within bounds\n        real_solution = self.best_solution * (func_bounds[:, 1] - func_bounds[:, 0]) + func_bounds[:, 0]\n        return real_solution", "name": "AdaptiveQuantumEA", "description": "Enhanced exploration by fine-tuning the randomization parameter to increase diversity in the population.", "configspace": "", "generation": 99, "fitness": 0.24151606610585397, "feedback": "The algorithm AdaptiveQuantumEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "35412ed2-3d4e-4df0-b01b-cae1fa83c193", "metadata": {"aucs": [0.24151606610585397]}, "mutation_prompt": null}
