{"id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + 0.8 * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "A Hybrid Quantum-Inspired Differential Evolution Algorithm with Adaptive Memory for efficient global optimization of photonic structures.", "configspace": "", "generation": 0, "fitness": 0.1324778414176858, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.13344068413343113, 0.13340999108329754, 0.13058284903632866]}, "mutation_prompt": null}
{"id": "0475d0bb-dae1-4377-b8b4-fab8ffee0f7a", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim)) * (self.budget / (self.population_size + 1))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + 0.8 * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhanced exploration by adjusting the quantum-inspired mutation amplitude based on budget usage.", "configspace": "", "generation": 1, "fitness": 0.12795229598039284, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "metadata": {"aucs": [0.1306425793701076, 0.12754356592260463, 0.12567074264846634]}, "mutation_prompt": null}
{"id": "79b77fc5-46d2-402c-bbdc-0eaa6f3df6ab", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + 0.8 * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                # Dynamically adjust crossover probability based on fitness variance\n                cr = 0.9 * (1 - (np.var(fitness) / (np.mean(fitness) + 1e-9)))\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhanced convergence by adjusting crossover probability dynamically based on fitness variance.", "configspace": "", "generation": 2, "fitness": 0.1324448583661034, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "metadata": {"aucs": [0.13334350789907756, 0.13340999108329754, 0.13058107611593506]}, "mutation_prompt": null}
{"id": "922089e7-cc31-4193-85de-5ab05cdedf64", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + 0.8 * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n            # Modified line for elitism\n            memory_best_fitness = min(self.memory, key=lambda mem: np.min(mem[1]))[1]\n            if np.min(fitness) > np.min(memory_best_fitness):\n                best_memory_index = np.argmin(memory_best_fitness)\n                population[best_index] = self.memory[-1][0][best_memory_index]\n                fitness[best_index] = np.min(memory_best_fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhanced selection strategy by incorporating a memory-based elitism to improve convergence speed.", "configspace": "", "generation": 3, "fitness": 0.1324778414176858, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "metadata": {"aucs": [0.13344068413343113, 0.13340999108329754, 0.13058284903632866]}, "mutation_prompt": null}
{"id": "2b21a660-8197-438c-897a-6797f8c026e7", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim)) * (self.budget / (self.budget + 1))  # Changed line\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + 0.8 * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhanced mutation strategy with dynamic amplitude scaling for improved exploration in global optimization.", "configspace": "", "generation": 4, "fitness": 0.13239234997464153, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "metadata": {"aucs": [0.13342864701067825, 0.13317548005833357, 0.13057292285491273]}, "mutation_prompt": null}
{"id": "32fbb142-80fd-439c-a4ee-d62096198334", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + 0.8 * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                diversity = np.std(population, axis=0).mean()  # Calculate diversity\n                cr = 0.5 + 0.4 * (1 - diversity)  # Adapt crossover rate\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on current population diversity to enhance search efficiency.", "configspace": "", "generation": 5, "fitness": 0.12732643397429852, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "metadata": {"aucs": [0.13002915566768058, 0.1274424380380501, 0.12450770821716484]}, "mutation_prompt": null}
{"id": "4d6a526a-ec5c-4b60-98b6-f1eb60ed6502", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + 0.8 * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                # Change: Use a dynamic crossover rate instead of a fixed one\n                dynamic_cr = 0.7 + 0.3 * (fitness[i] - fitness[best_index]) / (np.max(fitness) - fitness[best_index] + 1e-12)\n                trial = self.differential_crossover(population[i], donor, cr=dynamic_cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introducing a dynamic crossover rate in the differential crossover operator to enhance adaptability to the optimization landscape.", "configspace": "", "generation": 6, "fitness": 0.13236736673617713, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "metadata": {"aucs": [0.13315959617059436, 0.13264664390113823, 0.13129586013679884]}, "mutation_prompt": null}
{"id": "d84a7617-cae6-469c-b106-5addc50fd845", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhanced control over mutation scale factor by introducing adaptive scaling for improved convergence in complex landscapes.", "configspace": "", "generation": 7, "fitness": 0.13296536955328708, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7df86eb2-5807-453a-b6a7-1ac73844f159", "metadata": {"aucs": [0.13431354773537996, 0.13161492507958372, 0.13296763584489757]}, "mutation_prompt": null}
{"id": "68228de1-9bb6-4427-a4cb-590d56dfa9f7", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.random.choice(np.argsort(fitness)[:3])  # Changed line\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhanced exploitation through probabilistic selection of best solutions to guide evolution.", "configspace": "", "generation": 8, "fitness": 0.1314851015884798, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d84a7617-cae6-469c-b106-5addc50fd845", "metadata": {"aucs": [0.13250743358228478, 0.13185752982015686, 0.1300903413629978]}, "mutation_prompt": null}
{"id": "15af4fd3-cc44-4ce8-9928-196679134bed", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                adaptive_cr = 0.7 + 0.3 * np.random.rand()  # Changed line for adaptive crossover rate\n                trial = self.differential_crossover(population[i], donor, cr=adaptive_cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduced adaptive crossover rate to enhance exploration and exploitation balance for better convergence.", "configspace": "", "generation": 9, "fitness": 0.13190214852573437, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d84a7617-cae6-469c-b106-5addc50fd845", "metadata": {"aucs": [0.13389069505671558, 0.130309395686106, 0.13150635483438156]}, "mutation_prompt": null}
{"id": "38aad532-ec2c-4aaf-b055-b3b72f883417", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        generation = 0\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                cr = 0.5 + 0.4 * np.sin(np.pi * generation / 10)  # Changed line for dynamic crossover rate\n                trial = self.differential_crossover(population[i], donor, cr=cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n            generation += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Improved exploration by varying the crossover rate dynamically based on the generation.", "configspace": "", "generation": 10, "fitness": 0.1328050555117519, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d84a7617-cae6-469c-b106-5addc50fd845", "metadata": {"aucs": [0.1345791360453683, 0.13175420519229575, 0.1320818252975916]}, "mutation_prompt": null}
{"id": "1a15eed6-ed69-45e0-bea3-6eb511c4d69f", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                # Change: Dynamic crossover rate based on population diversity\n                diversity = np.std(population, axis=0).mean()\n                cr = min(0.9, max(0.1, 1.0 - diversity))\n\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a dynamic crossover rate that adjusts based on population diversity to improve convergence.", "configspace": "", "generation": 11, "fitness": 0.12822520589388656, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d84a7617-cae6-469c-b106-5addc50fd845", "metadata": {"aucs": [0.13004465441992064, 0.13012325504457423, 0.12450770821716484]}, "mutation_prompt": null}
{"id": "7613ccdd-0cd4-472d-90d5-175b1ca066c5", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                cr = 0.9 - 0.1 * (self.budget / (self.budget + self.population_size))  # Dynamic crossover probability\n                trial = self.differential_crossover(population[i], donor, cr=cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a dynamic crossover probability for enhanced exploration and exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.13263765842655137, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d84a7617-cae6-469c-b106-5addc50fd845", "metadata": {"aucs": [0.13414788178595582, 0.13143211889089745, 0.1323329746028008]}, "mutation_prompt": null}
{"id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce selection pressure by replacing one of the three randomly chosen individuals with the best solution to guide the search more effectively.", "configspace": "", "generation": 13, "fitness": 0.13311360873745837, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d84a7617-cae6-469c-b106-5addc50fd845", "metadata": {"aucs": [0.1343337124003955, 0.13161927756840786, 0.13338783624357176]}, "mutation_prompt": null}
{"id": "49eb0549-d6eb-4d5f-bb63-157ef5e9db04", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance information sharing by dynamically adjusting the mutation scaling factor based on fitness improvements.", "configspace": "", "generation": 14, "fitness": 0.13311360873745837, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.1343337124003955, 0.13161927756840786, 0.13338783624357176]}, "mutation_prompt": null}
{"id": "cc4a47f1-87cf-41a0-b15a-f943ea6a9763", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.7, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slight adjustment in differential scaling factor for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.1330653920703321, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.13432770624950607, 0.13147385446874527, 0.133394615492745]}, "mutation_prompt": null}
{"id": "f385972e-41b6-4980-a18b-9ba7ce934954", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        factor = np.random.rand()  # Changed line to introduce a dynamic factor\n        mutated = individual + factor * amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance mutation flexibility by allowing a variable amplitude influenced by a dynamic factor.", "configspace": "", "generation": 16, "fitness": 0.13212077014239013, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.1346613302444435, 0.13130337747919307, 0.13039760270353384]}, "mutation_prompt": null}
{"id": "d55d7ec1-f5aa-42ac-a809-eba9806fccbb", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                diversity = np.std(population, axis=0).mean()  # Added line to compute diversity\n                cr = np.clip(1 - diversity, 0.1, 0.9)  # Modified line for adaptive crossover rate\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce adaptive crossover rate based on population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.12761314497505072, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.1303704691370492, 0.1274424380380501, 0.12502652775005285]}, "mutation_prompt": null}
{"id": "79023664-2ced-4cab-848e-837881f0f94d", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                # Modified line for introducing randomness in operation choice\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploration by introducing randomness in the choice between adaptive scaling and quantum mutation.", "configspace": "", "generation": 18, "fitness": 0.13311360873745837, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.1343337124003955, 0.13161927756840786, 0.13338783624357176]}, "mutation_prompt": null}
{"id": "e436c926-45ab-43f7-b527-7f1a14fb0a7e", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.argsort(fitness)[:3]]  # Changed line for deterministic selection\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Replace stochastic choice with deterministic strategy by using the best two individuals in selection pressure.", "configspace": "", "generation": 19, "fitness": 0.13304171428637657, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.13392560460986636, 0.13207446758103725, 0.1331250706682261]}, "mutation_prompt": null}
{"id": "531f72a9-865c-468c-a208-bd94df372b00", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                cr = 0.9 * (np.std(fitness) / np.mean(fitness))  # Adjust crossover rate dynamically\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance crossover by dynamically adjusting crossover rate based on the population diversity to maintain exploration and exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.12923103846619102, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.13031188904094126, 0.12790270960284145, 0.12947851675479038]}, "mutation_prompt": null}
{"id": "f5eb93f3-9ebb-4c0f-868e-6940d40d94f0", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                if self.memory:  # New line added for donor selection\n                    b, c = np.random.choice(self.memory[-1][0], 2, replace=False)\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce memory effect by selecting donors using past best solutions stored in memory to enhance exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {}, "mutation_prompt": null}
{"id": "a52e08cc-a01a-4b1f-b37b-f2f103574c98", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def probabilistic_selection(self, fitness):\n        probabilities = np.exp(-fitness)\n        probabilities /= np.sum(probabilities)\n        return np.random.choice(self.population_size, p=probabilities)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a_idx, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = population[self.probabilistic_selection(fitness)] # Adaptive selection\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploration by introducing an adaptive memory mechanism and probabilistic selection to guide the mutation process.", "configspace": "", "generation": 22, "fitness": 0.13212244924424296, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.13296624013563474, 0.13277985228964762, 0.1306212553074465]}, "mutation_prompt": null}
{"id": "44201eb8-2014-425e-a988-516fed21ad96", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        amplitude = np.abs(np.random.normal(0, 1, self.dim)) * (self.budget / (self.budget + 1))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Refine the quantum mutation to incorporate a dynamic amplitude to enhance exploration and convergence.", "configspace": "", "generation": 23, "fitness": 0.13333576392201088, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2016713b-7c8c-46b2-913e-63b5d36cee9d", "metadata": {"aucs": [0.1343405524151532, 0.1322366053958749, 0.13343013395500458]}, "mutation_prompt": null}
{"id": "b4033154-b855-45ba-8bc2-5cb037dbb976", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 2)  # Changed line for adaptive scaling\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance the quantum mutation by introducing an adaptive amplitude scaling based on a dynamic factor to improve convergence.", "configspace": "", "generation": 24, "fitness": 0.13333815270788554, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "44201eb8-2014-425e-a988-516fed21ad96", "metadata": {"aucs": [0.13431328047122315, 0.1322411440344543, 0.1334600336179792]}, "mutation_prompt": null}
{"id": "7a5c9be8-0137-40de-b12e-2d3323e53585", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Improve exploration by adjusting the dynamic factor to balance between exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.1333463656717121, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "b4033154-b855-45ba-8bc2-5cb037dbb976", "metadata": {"aucs": [0.13434374439445584, 0.13224782826076908, 0.13344752435991136]}, "mutation_prompt": null}
{"id": "6daa7bbf-c26c-47fb-a0a3-ac525c18a145", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.5, 1.0) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                # Added line to switch crossover strategy\n                if np.random.rand() < 0.2:\n                    trial = self.differential_crossover(donor, population[i], cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a target-to-population crossover to improve diversity and exploration capability.", "configspace": "", "generation": 26, "fitness": 0.13099769110256673, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7a5c9be8-0137-40de-b12e-2d3323e53585", "metadata": {"aucs": [0.1319063132052607, 0.13172946758794335, 0.12935729251449612]}, "mutation_prompt": null}
{"id": "c9458ee2-0691-415c-8f2e-45967b97b557", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance adaptability by modifying mutation dynamics for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.13337260752106161, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7a5c9be8-0137-40de-b12e-2d3323e53585", "metadata": {"aucs": [0.13433640385133172, 0.1321037455265719, 0.13367767318528123]}, "mutation_prompt": null}
{"id": "6e94008e-aca7-44c9-a09f-462ae4b72d44", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                diversity = np.std(fitness) / np.mean(fitness)  # New line for diversity-based crossover\n                cr = min(0.9, max(0.1, 0.9 - diversity))  # Adjust crossover rate based on diversity\n                trial = self.differential_crossover(population[i], donor, cr=cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance convergence by adjusting the crossover probability dynamically based on population diversity.", "configspace": "", "generation": 28, "fitness": 0.13293671074093463, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.13420128015944466, 0.1315777812338058, 0.13303107082955345]}, "mutation_prompt": null}
{"id": "5f31eacd-0745-49fd-b0d2-d7ca39e875ae", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                cr = 0.9 - 0.5 * (self.budget / (self.budget + 1))  # Introduced line for adaptive crossover rate\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce adaptive crossover rate for better exploration and exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.12995267187811896, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.13109476085948357, 0.12916332975504896, 0.1295999250198243]}, "mutation_prompt": null}
{"id": "44c3b6f5-6b79-4497-8fc2-0cfa16d994c0", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n                \n                # Change: Use historical best solution for diversity\n                if np.random.rand() < 0.5:\n                    prev_best_solution = self.memory[-1][0][np.argmin(self.memory[-1][1])] if self.memory else best_solution\n                    donor = self.quantum_inspired_mutation(population[i], prev_best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Incorporate past best information to improve mutation diversity and convergence speed.", "configspace": "", "generation": 30, "fitness": 0.13337260752106161, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.13433640385133172, 0.1321037455265719, 0.13367767318528123]}, "mutation_prompt": null}
{"id": "581f83f4-5756-4ce7-b818-b04ba9cf0f73", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor * np.random.rand(), self.dim))  # Changed line for probabilistic amplification\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce probabilistic amplification in the mutation step to enhance exploration capabilities.", "configspace": "", "generation": 31, "fitness": 0.1317516734142016, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.13302083231365203, 0.13069722135199768, 0.13153696657695513]}, "mutation_prompt": null}
{"id": "f2b86fef-add2-4b7a-b08f-fb04da9ecfb3", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / self.population_size) / (self.budget / self.population_size + 5)  # Changed line\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduced adaptive mutation scaling by adjusting dynamic factor based on remaining budget to enhance convergence.", "configspace": "", "generation": 32, "fitness": 0.13317391707295548, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.13514383913108952, 0.13108808774964587, 0.13328982433813108]}, "mutation_prompt": null}
{"id": "db82db50-fa9c-4fe5-9595-964aaf0ebee8", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a feedback-driven adjustment to the mutation scale for improved responsiveness.", "configspace": "", "generation": 33, "fitness": 0.13337260752106161, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.13433640385133172, 0.1321037455265719, 0.13367767318528123]}, "mutation_prompt": null}
{"id": "6390a492-b72b-47f7-866b-3fdb84245a32", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.3, 0.9) * (b - c)  # Changed line for adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                # Change: Adjust crossover rate for better exploration\n                trial = self.differential_crossover(population[i], donor, cr=max(0.5, 1 - self.budget/self.population_size))\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Integrate adaptive mutation rate to improve exploration capabilities.", "configspace": "", "generation": 34, "fitness": 0.13147909873131872, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.13388730784656144, 0.12973946407254833, 0.1308105242748464]}, "mutation_prompt": null}
{"id": "57ff7059-8359-4fbc-8aff-16a31865df4f", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.4, 0.9) * (b - c)  # Adjusted line for better adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Improve convergence by refining the balance between exploration and exploitation.", "configspace": "", "generation": 35, "fitness": 0.1333949935982256, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9458ee2-0691-415c-8f2e-45967b97b557", "metadata": {"aucs": [0.1344095631068749, 0.13218330945019607, 0.1335921082376058]}, "mutation_prompt": null}
{"id": "28cdaf66-b812-4d17-ba59-0aea4d17389f", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                donor = a + np.random.uniform(0.4, 0.9) * (b - c)  # Adjusted line for better adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                cr = 0.9 - (0.5 * (self.budget / (self.budget + self.population_size)))  # Introduced dynamic crossover rate\n                trial = self.differential_crossover(population[i], donor, cr=cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introducing a dynamic crossover rate based on the current budget to enhance adaptability.", "configspace": "", "generation": 36, "fitness": 0.1314038277834472, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "57ff7059-8359-4fbc-8aff-16a31865df4f", "metadata": {"aucs": [0.1333512153484554, 0.13071527290847051, 0.1301449950934157]}, "mutation_prompt": null}
{"id": "c9f43d60-f818-479a-a24b-9432fca0e359", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = self.budget / (self.budget + 5)  # Changed line for improved balance\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution  # Introduced line to use best solution in mutation\n                # Modified line: Added 'dynamic_scaling' to improve adaptive scaling\n                dynamic_scaling = np.exp(-0.01 * i)  \n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)  # Adjusted line for better adaptive scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance the adaptive scaling factor to improve convergence by introducing a scale factor that dynamically adjusts based on the current best solution.", "configspace": "", "generation": 37, "fitness": 0.13354946494898154, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "57ff7059-8359-4fbc-8aff-16a31865df4f", "metadata": {"aucs": [0.1347398179799416, 0.1321785750014779, 0.13373000186552508]}, "mutation_prompt": null}
{"id": "fbaf7fcd-b364-45e3-9b66-96a23da867c5", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.01 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Adjust the mutation strategy to enhance exploration by increasing the dynamic factor's impact subtly.", "configspace": "", "generation": 38, "fitness": 0.13369603284840179, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "c9f43d60-f818-479a-a24b-9432fca0e359", "metadata": {"aucs": [0.1350779339250301, 0.13222725510734223, 0.133782909512833]}, "mutation_prompt": null}
{"id": "ee6bc56d-3a53-44f2-8f1a-8a541f6b9d7d", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.02  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.01 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance the mutation mechanism by slightly increasing the dynamic factor's range for improved exploration.", "configspace": "", "generation": 39, "fitness": 0.13364400433228998, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "fbaf7fcd-b364-45e3-9b66-96a23da867c5", "metadata": {"aucs": [0.13459678306849054, 0.13259545327721678, 0.13373977665116266]}, "mutation_prompt": null}
{"id": "56383bd8-0ca1-4551-8810-5835ac747d58", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance mutation dynamics by slightly increasing the dynamic scaling factor for improved exploration.", "configspace": "", "generation": 40, "fitness": 0.13371086998600276, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "fbaf7fcd-b364-45e3-9b66-96a23da867c5", "metadata": {"aucs": [0.13468793961639636, 0.13275002965269667, 0.13369464068891523]}, "mutation_prompt": null}
{"id": "6384a406-38e9-4193-a2d2-0c0a5a085fc0", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 6  # Increased memory size from 5 to 6\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly increase the memory size to enhance historical information usage for better convergence.", "configspace": "", "generation": 41, "fitness": 0.13371086998600276, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13468793961639636, 0.13275002965269667, 0.13369464068891523]}, "mutation_prompt": null}
{"id": "4680818a-0084-4cd2-af22-e4fb55a081fe", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.95)  # Adjusted crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance selection pressure by adjusting the crossover rate to dynamically increase with fewer fitness improvements.", "configspace": "", "generation": 42, "fitness": 0.13340994240268123, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.1347013009473047, 0.13238565783901224, 0.13314286842172673]}, "mutation_prompt": null}
{"id": "8a7ff4bc-29cd-452c-83f6-9c956e823b68", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.02  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Refine quantum mutation by using a slightly higher dynamic factor to improve exploration.", "configspace": "", "generation": 43, "fitness": 0.13370559892513265, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13456486245462718, 0.13281543679617247, 0.13373649752459826]}, "mutation_prompt": null}
{"id": "23f31774-d58c-470b-922e-f08b0d39f1e0", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.92)  # Changed line for increased crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly increase the crossover rate to enhance exploration capabilities.", "configspace": "", "generation": 44, "fitness": 0.13351914037237453, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13478694966885973, 0.13239579911446853, 0.1333746723337953]}, "mutation_prompt": null}
{"id": "70e94305-5446-46a7-9bb3-25d34c389c53", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.0085 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance mutation efficiency by slightly increasing the dynamic scaling factor during initial iterations for improved exploration.", "configspace": "", "generation": 45, "fitness": 0.13353364862122363, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13470302391947542, 0.1322032105605403, 0.13369471138365518]}, "mutation_prompt": null}
{"id": "28291f52-820d-4e40-a983-5901771788ad", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploration by slightly increasing the range of the dynamic scaling factor during mutation.", "configspace": "", "generation": 46, "fitness": 0.13352257742797746, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.1347026598331682, 0.13216918080170403, 0.13369589164906015]}, "mutation_prompt": null}
{"id": "bf2255bb-bf94-46f4-b3ec-1825eb0616dd", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.7:  # Increased probability for quantum-inspired mutation\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploration by increasing the probability of quantum-inspired mutation.", "configspace": "", "generation": 47, "fitness": 0.13290060628906228, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13375419282565149, 0.13112704068937642, 0.1338205853521589]}, "mutation_prompt": null}
{"id": "0c176994-13bc-4067-8512-1ffb43b3ef49", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.secondary_population_size = int(0.2 * self.population_size)  # New line\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        primary = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        secondary = lb + (ub - lb) * np.random.rand(self.secondary_population_size, self.dim)  # New line\n        return primary, secondary  # Modified line\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.02  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def adapt_learning_from_secondary(self, primary, secondary, cr=0.7):  # New function\n        for i in range(self.secondary_population_size):\n            if np.random.rand() < cr:\n                primary[i] = self.differential_crossover(primary[i], secondary[i % self.secondary_population_size], cr)\n        return primary\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        primary_population, secondary_population = self.initialize_population(lb, ub)  # Modified line\n        fitness = np.array([func(ind) for ind in primary_population])\n        self.budget -= self.population_size\n\n        secondary_fitness = np.array([func(ind) for ind in secondary_population])  # New line\n        self.budget -= self.secondary_population_size  # New line\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = primary_population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = primary_population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(primary_population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(primary_population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(primary_population[i])\n                    new_fitness.append(fitness[i])\n\n            primary_population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            primary_population = self.adapt_learning_from_secondary(primary_population, secondary_population)  # New line\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((primary_population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((primary_population, fitness))\n\n        best_index = np.argmin(fitness)\n        return primary_population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Implement a co-evolutionary strategy by integrating adaptive learning from a secondary population to enhance diversity and convergence.", "configspace": "", "generation": 48, "fitness": 0.1323369777132666, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13401070526350778, 0.13263296109690048, 0.1303672667793916]}, "mutation_prompt": null}
{"id": "12ba4c02-d848-4584-bad3-ed9fe65cbfdc", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.02  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.3, 0.8) * (b - c)  # Adjusted crossover scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.6:  # Adjusted probability for mutation\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.85)  # Adjusted crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce adaptive mutation and crossover strategies for better diversity control and convergence.", "configspace": "", "generation": 49, "fitness": 0.13340191090954423, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13492713353290398, 0.13228907705132542, 0.1329895221444033]}, "mutation_prompt": null}
{"id": "8694cb8a-cc1e-4361-936b-6fe8ac1c7acd", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            fitness_variance = np.var(fitness)  # New line to calculate fitness variance\n            scaling_factor = np.exp(-0.009 * fitness_variance)  # Modified scaling based on fitness variance\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                donor = a + scaling_factor * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Integrate adaptive scaling factor based on fitness variance to balance exploration and exploitation.", "configspace": "", "generation": 50, "fitness": 0.13334496440891122, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13447161710937583, 0.13189089406924814, 0.13367238204810972]}, "mutation_prompt": null}
{"id": "6732b713-ed40-4117-84b9-6b386ae2cdf4", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 0.99  # Reduced amplitude scaling factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Adjust the quantum-inspired mutation function by reducing the amplitude scaling factor to 0.99 for better convergence efficiency.", "configspace": "", "generation": 51, "fitness": 0.13354676345212868, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13475835952311432, 0.13216529850608671, 0.133716632327185]}, "mutation_prompt": null}
{"id": "2a7b227c-d8b6-4afc-8540-bf4e84b790de", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.01  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                diversity = np.mean(np.std(population, axis=0))  # New line: calculating population diversity\n                trial = self.differential_crossover(population[i], donor, cr=min(1.0, 0.9 + diversity))  # Adjusted line for dynamic crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a dynamic crossover rate adjustment based on population diversity to improve exploration and exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.13345909518499446, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.13500821529147378, 0.13201343914586516, 0.13335563111764448]}, "mutation_prompt": null}
{"id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Further enhance exploratory capability by fine-tuning the mutation scaling factor adjustment.", "configspace": "", "generation": 53, "fitness": 0.1337130252503117, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "56383bd8-0ca1-4551-8810-5835ac747d58", "metadata": {"aucs": [0.1346923045966688, 0.132757181579089, 0.1336895895751773]}, "mutation_prompt": null}
{"id": "a7aca318-52db-4f19-b777-b6c54da24166", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Slightly adjusted for more adaptive search\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploratory capability by modifying the dynamic scaling factor formula for more adaptive search.", "configspace": "", "generation": 54, "fitness": 0.13352616779669835, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468800284240012, 0.1321996596830557, 0.13369084086463923]}, "mutation_prompt": null}
{"id": "755b2076-6654-499c-897c-d7a5500d2d89", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim)) * 0.95  # Adjusted line for altered amplitude distribution\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Refine convergence by modifying the mutation amplitude distribution.", "configspace": "", "generation": 55, "fitness": 0.13347119126932014, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1349174984254432, 0.13211954123255532, 0.13337653414996187]}, "mutation_prompt": null}
{"id": "a268ecb4-aea9-4c30-88b5-87a7fda38c11", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.02  # Enhanced mutation amplitude\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly increase the mutation amplitude in the quantum-inspired mutation for enhanced exploration.", "configspace": "", "generation": 56, "fitness": 0.13370559892513265, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13456486245462718, 0.13281543679617247, 0.13373649752459826]}, "mutation_prompt": null}
{"id": "fe39ef3e-a5c2-4382-8e55-d2332f4e0656", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.85)  # Changed line\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Fine-tune crossover probability for improved exploration-exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.13298478600313413, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13447914690193707, 0.13168203761446606, 0.13279317349299924]}, "mutation_prompt": null}
{"id": "91b1ba95-99d0-4bde-8128-25e366c54ce4", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Adjust mutation scaling to improve convergence precision.", "configspace": "", "generation": 58, "fitness": 0.13352616779669835, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468800284240012, 0.1321996596830557, 0.13369084086463923]}, "mutation_prompt": null}
{"id": "60823dfc-b786-4dde-8a41-aca1d22ecbcc", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.0085 * i)  # Slightly adjusted line for improved dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Fine-tune dynamic scaling exponential decay for improved exploration.", "configspace": "", "generation": 59, "fitness": 0.1335311225944732, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13469962522737644, 0.13220415350178505, 0.1336895890542581]}, "mutation_prompt": null}
{"id": "e3424184-5d42-4682-b03d-cd966171cabf", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                # Changed line: introducing adaptive crossover rate\n                trial = self.differential_crossover(population[i], donor, cr=0.5 + np.random.rand() * 0.5)\n                \n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce an adaptive crossover rate to better balance exploration and exploitation.", "configspace": "", "generation": 60, "fitness": 0.13195312571981632, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13239862411792558, 0.13184280524887626, 0.13161794779264713]}, "mutation_prompt": null}
{"id": "08f8d51d-c190-485b-9717-e9138e2dc3e2", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.020  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly enhance the dynamic factor for better exploratory power in quantum-inspired mutation.", "configspace": "", "generation": 61, "fitness": 0.13370559892513265, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13456486245462718, 0.13281543679617247, 0.13373649752459826]}, "mutation_prompt": null}
{"id": "65728c58-91ad-4025-b832-ac68a2585f6f", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.95)  # Fine-tuned crossover probability\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Optimize exploration and exploitation balance by fine-tuning the crossover probability.", "configspace": "", "generation": 62, "fitness": 0.13340906995118526, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1346996812085477, 0.13238749613058076, 0.1331400325144273]}, "mutation_prompt": null}
{"id": "99a76deb-14bb-46d1-ae9e-b37bb9e918dc", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.012  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Fine-tune the mutation scaling factor for improved convergence speed and precision.", "configspace": "", "generation": 63, "fitness": 0.13371174612212922, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468899277250201, 0.13276174705438315, 0.13368449853950248]}, "mutation_prompt": null}
{"id": "5e7b331a-baae-41f9-9ed7-f29b14f3f82a", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.85)  # Fine-tuned crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Fine-tune crossover rate to enhance exploitation in solution space.", "configspace": "", "generation": 64, "fitness": 0.13298478600313413, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13447914690193707, 0.13168203761446606, 0.13279317349299924]}, "mutation_prompt": null}
{"id": "f7cd0872-e3a9-4064-9594-fe75ef6c26ca", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                cr = 0.9 * (self.budget / self.budget + self.population_size)  # Adjusted line for dynamic crossover probability\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploration by introducing a dynamic crossover probability based on iteration progress.", "configspace": "", "generation": 65, "fitness": 0.13346081078694239, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13501942890724516, 0.13201121112565506, 0.13335179232792693]}, "mutation_prompt": null}
{"id": "9fa424df-ce2c-41ef-9a97-5145b0ac7dcb", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  \n                donor = a + dynamic_scaling * np.random.uniform(0.45, 0.9) * (b - c)  # Adjusted line for refined scaling range\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly refine exploration by adjusting donor vector scaling range for better adaptability.", "configspace": "", "generation": 66, "fitness": 0.13345220821630618, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1347275402727831, 0.1319221631539722, 0.1337069212221632]}, "mutation_prompt": null}
{"id": "25f7ecf9-1a76-4ba6-bab6-26e1ed909a8e", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.015  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploration by slightly increasing mutation amplitude for broader search.", "configspace": "", "generation": 67, "fitness": 0.1337076869842269, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468182068808976, 0.1327731217759458, 0.13366811848864513]}, "mutation_prompt": null}
{"id": "0f8872a2-cc5e-47f0-949a-8b3100c693e5", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.6:  # Changed line for increased mutation probability\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly improve convergence by adjusting the probability of applying quantum-inspired mutation.", "configspace": "", "generation": 68, "fitness": 0.13345409958576884, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13464675189047415, 0.13279178476213327, 0.13292376210469914]}, "mutation_prompt": null}
{"id": "51f12998-c8bf-429e-959b-72999b9ff0d8", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9 - (0.5 * self.budget/self.population_size))  # Changed line for adaptive crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))  # Adjusted line to improve memory update mechanism\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Improve convergence speed by enhancing exploration using adaptive crossover rate and memory usage.", "configspace": "", "generation": 69, "fitness": 0.12760671903241416, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1301247114827756, 0.1274424380380501, 0.12525300757641677]}, "mutation_prompt": null}
{"id": "b8696586-4b13-437a-87f1-3db2e8f8e783", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.92)  # Slight adjustment to crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly enhance the crossover probability to improve exploration.", "configspace": "", "generation": 70, "fitness": 0.1335157676589697, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13478458508416324, 0.13239735629115346, 0.1333653616015924]}, "mutation_prompt": null}
{"id": "892a4822-f9a8-4f83-afee-9058ffcfd51a", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.85)  # Adjusted crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Incrementally adjust crossover probability to enhance exploration-exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.13298478600313413, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13447914690193707, 0.13168203761446606, 0.13279317349299924]}, "mutation_prompt": null}
{"id": "e5788685-e96a-4b5d-97fb-da4e55bbe51a", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.95)  # Increased crossover probability\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Increase the crossover probability to enhance exploration and diversity.", "configspace": "", "generation": 72, "fitness": 0.13340906995118526, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1346996812085477, 0.13238749613058076, 0.1331400325144273]}, "mutation_prompt": null}
{"id": "4e372dd5-5987-4d3d-90dc-c49ff13a39c0", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.92)  # Slightly increased crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a minor adjustment to enhance convergence by slightly increasing the crossover rate during differential crossover.", "configspace": "", "generation": 73, "fitness": 0.1335157676589697, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13478458508416324, 0.13239735629115346, 0.1333653616015924]}, "mutation_prompt": null}
{"id": "17f971cc-a689-497d-bbf4-b8877873a67d", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.015  # Slightly increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce slight enhancement by tweaking the dynamic factor for quantum mutation to improve exploration.", "configspace": "", "generation": 74, "fitness": 0.1337076869842269, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468182068808976, 0.1327731217759458, 0.13366811848864513]}, "mutation_prompt": null}
{"id": "58dbabd9-e936-429d-9dc9-796076001361", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Improved convergence through adaptive mutation scaling based on dynamic feedback from the population's diversity.", "configspace": "", "generation": 75, "fitness": 0.1337130252503117, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1346923045966688, 0.132757181579089, 0.1336895895751773]}, "mutation_prompt": null}
{"id": "7652d465-0d2b-436f-b77d-be7630de1a34", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011\n        amplitude = np.abs(np.random.normal(0, dynamic_factor + 0.001, self.dim))  # Slight increase in randomness\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Refine the mutation amplitude by slightly increasing its randomness to balance exploration and exploitation effectively.", "configspace": "", "generation": 76, "fitness": 0.13371173331553665, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1346889598275719, 0.13276179128208976, 0.1336844488369483]}, "mutation_prompt": null}
{"id": "825fbe97-cde2-4b80-8ade-b90d107c4ac1", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = ((self.budget + 100) / (self.budget + 5)) * 1.011  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Adjust mutation scaling factor for better convergence in early stages.", "configspace": "", "generation": 77, "fitness": 0.13314404573384683, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13416190938055006, 0.13346930411074331, 0.1318009237102471]}, "mutation_prompt": null}
{"id": "c0898e05-9180-4db0-9079-31717fa1888e", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Slightly increase dynamic scaling factor\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a slight increase to the dynamic scaling factor to enhance exploration.", "configspace": "", "generation": 78, "fitness": 0.13352616779669835, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468800284240012, 0.1321996596830557, 0.13369084086463923]}, "mutation_prompt": null}
{"id": "0ec30489-d276-4f66-9b47-fe0183749e3a", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 6)) * 1.011  # Changed line for improved dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance adaptive mutation control by modifying the dynamic factor calculation for better balance.", "configspace": "", "generation": 79, "fitness": 0.13353895946026473, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.134690842924428, 0.13222786749239068, 0.1336981679639755]}, "mutation_prompt": null}
{"id": "a68470ea-33ba-4ef7-99e9-4aafdb924675", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Refined dynamic scaling factor for enhanced convergence speed.", "configspace": "", "generation": 80, "fitness": 0.13352616779669835, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468800284240012, 0.1321996596830557, 0.13369084086463923]}, "mutation_prompt": null}
{"id": "dfa9cf13-5dcb-4b38-9205-a10e34f51efc", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.0085 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance convergence by fine-tuning the dynamic scaling factor for increased efficiency.", "configspace": "", "generation": 81, "fitness": 0.1335311225944732, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13469962522737644, 0.13220415350178505, 0.1336895890542581]}, "mutation_prompt": null}
{"id": "692804e9-9943-4e44-adc0-c0762efb05ea", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.015  # Slightly adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly enhance mutation exploration by adjusting the dynamic factor.", "configspace": "", "generation": 82, "fitness": 0.1337076869842269, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468182068808976, 0.1327731217759458, 0.13366811848864513]}, "mutation_prompt": null}
{"id": "2fe5a216-53dd-4fe9-9be3-c2539074fdab", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.015  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly increase the mutation amplitude adjustment using a dynamic factor to enhance exploration.", "configspace": "", "generation": 83, "fitness": 0.1337076869842269, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468182068808976, 0.1327731217759458, 0.13366811848864513]}, "mutation_prompt": null}
{"id": "3928ac1d-f9ce-44a7-a4c6-455ca7c97715", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.015  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly modify the mutation strategy to enhance the algorithm's exploration ability.", "configspace": "", "generation": 84, "fitness": 0.1337076869842269, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468182068808976, 0.1327731217759458, 0.13366811848864513]}, "mutation_prompt": null}
{"id": "312513c8-5d02-4d4a-a8b5-f9c55b7eec11", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011\n        amplitude = np.abs(np.random.normal(0, dynamic_factor * np.random.uniform(0.8, 1.2), self.dim))  # Adjusted line for increased amplitude variability\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Increase mutation amplitude variability to enhance exploration.", "configspace": "", "generation": 85, "fitness": 0.13213514137337914, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13344643442873383, 0.13127108238663676, 0.13168790730476687]}, "mutation_prompt": null}
{"id": "3c46739d-2a8d-4c2f-9a20-695c48b17871", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.0085 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Minor adjustment to dynamic scaling rate for improved convergence efficiency.", "configspace": "", "generation": 86, "fitness": 0.1335311225944732, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13469962522737644, 0.13220415350178505, 0.1336895890542581]}, "mutation_prompt": null}
{"id": "a880e8fe-008e-44fe-ad65-59003ca7774b", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.85)  # Adjusted crossover rate\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Fine-tune the crossover rate in differential crossover for enhanced exploration-exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.13298478600313413, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13447914690193707, 0.13168203761446606, 0.13279317349299924]}, "mutation_prompt": null}
{"id": "b376862b-7bc4-472b-a671-08f564154c48", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.45, 0.9) * (b - c)  # Modified line for tuning donor scaling\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a minor adjustment in donor vector scaling to balance exploration and exploitation effectively.", "configspace": "", "generation": 88, "fitness": 0.13345220821630618, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1347275402727831, 0.1319221631539722, 0.1337069212221632]}, "mutation_prompt": null}
{"id": "a9a7cc66-000e-428c-9251-3ae62d185622", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.012  # Adjusted line for further enhanced dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance adaptability by slightly refining the mutation factor calculation.", "configspace": "", "generation": 89, "fitness": 0.13371174612212922, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468899277250201, 0.13276174705438315, 0.13368449853950248]}, "mutation_prompt": null}
{"id": "42cfd60d-1d68-49f0-8092-df8bd2c0b734", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i) + 0.01 * np.random.rand()  # Adjusted line for enhanced randomness\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a small probabilistic factor in the mutation scaling to enhance randomness and maintain a balance between exploration and exploitation.", "configspace": "", "generation": 90, "fitness": 0.13259712774101787, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13434873598385366, 0.13147086112866968, 0.1319717861105303]}, "mutation_prompt": null}
{"id": "3cea2e53-586f-4fc0-a59a-2293d89415e8", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.008 * i)  # Adjusted line for slightly modified decay rate\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce a minor adjustment in the dynamic scaling factor's decay rate to balance exploration and exploitation better.", "configspace": "", "generation": 91, "fitness": 0.13352616779669835, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468800284240012, 0.1321996596830557, 0.13369084086463923]}, "mutation_prompt": null}
{"id": "b40be8f8-3164-4148-a06b-0c0360e3d66b", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.015  # Slightly adjusted quantum factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance mutation dynamics by marginally adjusting the quantum factor for improved exploration.", "configspace": "", "generation": 92, "fitness": 0.1337076869842269, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468182068808976, 0.1327731217759458, 0.13366811848864513]}, "mutation_prompt": null}
{"id": "9c5d5844-810a-428b-ba3d-32b2d0143702", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.016  # Slightly increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Fine-tune exploration by slightly increasing the mutation scaling through dynamic factor adjustment.", "configspace": "", "generation": 93, "fitness": 0.1336769232770132, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.1345928350928115, 0.13277578307367777, 0.1336621516645503]}, "mutation_prompt": null}
{"id": "fae18957-efac-448f-91fc-aadfd64cb58a", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.015  # Adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly increase mutation amplitude for better exploration.", "configspace": "", "generation": 94, "fitness": 0.1337076869842269, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13468182068808976, 0.1327731217759458, 0.13366811848864513]}, "mutation_prompt": null}
{"id": "c4ef855f-aeb0-4520-bfbe-1af8fc1c1b82", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.91)  # Changed crossover probability from 0.9 to 0.91\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly increase the crossover probability to improve exploration and diversity.", "configspace": "", "generation": 95, "fitness": 0.13348798790578056, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13472540906279662, 0.13204164736738033, 0.13369690728716477]}, "mutation_prompt": null}
{"id": "5a1c611c-8d3c-474c-a9f0-ea9cdf195005", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.0085 * i)  # Slightly adjusted for increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly adjust the dynamic scaling factor to further enhance exploration and exploitation balance.", "configspace": "", "generation": 96, "fitness": 0.1335311225944732, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13469962522737644, 0.13220415350178505, 0.1336895890542581]}, "mutation_prompt": null}
{"id": "95b10f2c-0d4a-4084-965d-db498ae6ec91", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted line: Increased population size multiplier from 10 to 12\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Enhance exploration by increasing the population size multiplier to better cover the search space.", "configspace": "", "generation": 97, "fitness": 0.13270731518999226, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13389261752903714, 0.13253713290250968, 0.13169219513843]}, "mutation_prompt": null}
{"id": "fbbf0025-e6a5-43d4-bd77-446ec19b3075", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.0085 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                trial = self.differential_crossover(population[i], donor, cr=0.9)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Slightly increase dynamic scaling for quantum-inspired mutation to boost exploratory capability.", "configspace": "", "generation": 98, "fitness": 0.1335311225944732, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13469962522737644, 0.13220415350178505, 0.1336895890542581]}, "mutation_prompt": null}
{"id": "f52f2cb4-b021-469a-b2f0-65f3a99a7d5b", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.memory = []\n\n    def initialize_population(self, lb, ub):\n        return lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def quantum_inspired_mutation(self, individual, best_solution, lb, ub):\n        dynamic_factor = (self.budget / (self.budget + 5)) * 1.011  # Further adjusted line for increased dynamic factor\n        amplitude = np.abs(np.random.normal(0, dynamic_factor, self.dim))\n        mutated = individual + amplitude * (best_solution - individual)\n        return np.clip(mutated, lb, ub)\n\n    def differential_crossover(self, target, donor, cr):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = list(range(self.population_size))\n                idxs.remove(i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                a = best_solution\n                dynamic_scaling = np.exp(-0.009 * i)  # Adjusted line for slightly increased dynamic scaling\n                donor = a + dynamic_scaling * np.random.uniform(0.4, 0.9) * (b - c)\n                donor = np.clip(donor, lb, ub)\n\n                if np.random.rand() < 0.5:\n                    donor = self.quantum_inspired_mutation(population[i], best_solution, lb, ub)\n\n                cr = 0.9 - (0.5 * (self.budget / (self.budget + 1)))  # Introduced adaptive crossover rate adjustment\n                trial = self.differential_crossover(population[i], donor, cr)\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if len(self.memory) < self.memory_size:\n                self.memory.append((population, fitness))\n            else:\n                self.memory.pop(0)\n                self.memory.append((population, fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridQuantumDifferentialEvolution", "description": "Introduce adaptive crossover rate adjustment to enhance solution refinement.", "configspace": "", "generation": 99, "fitness": 0.13011054476119824, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d13414b0-d9f4-4b14-8857-33dcb681a86d", "metadata": {"aucs": [0.13123804420762875, 0.1297140390407262, 0.1293795510352398]}, "mutation_prompt": null}
