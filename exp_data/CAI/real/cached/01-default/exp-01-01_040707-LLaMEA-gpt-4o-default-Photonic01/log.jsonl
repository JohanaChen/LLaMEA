{"id": "28eab971-1423-4e7d-a0b3-c441e53aaa4f", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.729  # Inertia weight\n        self.f = 0.8  # Differential evolution scale factor\n        self.cr = 0.9  # Crossover rate\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = self.w * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position()\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n        return self.gbest, self.gbest_score", "name": "HybridSwarmOptimizer", "description": "A hybrid swarm-based optimization algorithm that combines particle swarm optimization with adaptive differential evolution for global optimization of photonic structures.", "configspace": "", "generation": 0, "fitness": 0.2576317603682151, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2584459013122987, 0.26055951414589074, 0.2538898656464559]}, "mutation_prompt": null}
{"id": "63d2236b-0a26-4c31-a9bd-41365be51945", "solution": "import numpy as np\n\nclass QuantumBatOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.A = 0.5  # Loudness\n        self.r = 0.5  # Pulse rate\n        self.freq_min = 0.0\n        self.freq_max = 2.0\n        self.position = None\n        self.velocity = None\n        self.fitness = None\n        self.best = None\n        self.best_fitness = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.fitness[i]:\n                self.fitness[i] = scores[i]\n            if scores[i] < self.best_fitness:\n                self.best_fitness = scores[i]\n                self.best = self.position[i]\n        return scores\n\n    def update_velocity_position(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        for i in range(self.population_size):\n            freq = self.freq_min + (self.freq_max - self.freq_min) * np.random.rand()\n            self.velocity[i] += (self.position[i] - self.best) * freq\n            self.position[i] += self.velocity[i]\n            self.position[i] = np.clip(self.position[i], lb, ub)\n            if np.random.rand() > self.r:\n                self.position[i] = self.best + 0.001 * np.random.randn(self.dim)\n\n    def quantum_tunneling(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        for i in range(self.population_size):\n            if np.random.rand() < self.r:\n                q_position = (1 - self.A) * self.position[i] + self.A * self.best\n                q_position = np.clip(q_position + np.random.uniform(-0.5, 0.5, self.dim), lb, ub)\n                if func(q_position) < self.fitness[i]:\n                    self.position[i] = q_position\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(func.bounds)\n            self.quantum_tunneling(func.bounds)\n        return self.best, self.best_fitness", "name": "QuantumBatOptimizer", "description": "Quantum-inspired Bat Algorithm that integrates quantum superposition principles with bat-inspired echolocation for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "28eab971-1423-4e7d-a0b3-c441e53aaa4f", "metadata": {}, "mutation_prompt": null}
{"id": "3ac5ca05-fafd-4dbb-986e-653c5fd57a09", "solution": "import numpy as np\n\nclass AdvancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.f = 0.9  # DE scale factor\n        self.cr = 0.9  # Crossover rate\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        inertia_weight = self.w_max - ((self.w_max - self.w_min) * (self.iteration / self.max_iterations))\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position()\n            new_population = self.differential_evolution_mutation(func.bounds)\n            new_scores = np.array([func(p) for p in new_population])\n            self.position = np.where(scores[:, np.newaxis] <= new_scores[:, np.newaxis],\n                                     self.position, new_population)\n            scores = np.minimum(scores, new_scores)\n            func_calls += self.population_size\n            self.iteration += 1\n        return self.gbest, self.gbest_score", "name": "AdvancedSwarmOptimizer", "description": "An advanced swarm optimizer that leverages adaptive inertia and multiple best memories to enhance convergence in photonic structure optimization.", "configspace": "", "generation": 2, "fitness": 0.25735677035648025, "feedback": "The algorithm AdvancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "28eab971-1423-4e7d-a0b3-c441e53aaa4f", "metadata": {"aucs": [0.2551373584191867, 0.2593156981115301, 0.25761725453872397]}, "mutation_prompt": null}
{"id": "7cddaed0-d2c3-4143-a13c-63f9d8aa68c9", "solution": "import numpy as np\n\nclass QuantumInspiredEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.1  # Quantum-inspired parameter\n        self.mutation_rate = 0.1\n        self.position = None\n        self.best_position = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.best_position = np.copy(self.position)\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best_position = self.position[i]\n        return scores\n\n    def quantum_update(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            if np.random.rand() < self.alpha:\n                quantum_factor = np.random.uniform(-0.5, 0.5, self.dim)\n                new_population[i] = self.best_position + quantum_factor * (ub - lb)\n            else:\n                new_population[i] = self.position[i]\n            new_population[i] = np.clip(new_population[i], lb, ub)\n        return new_population\n\n    def mutation(self, population, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        for i in range(self.population_size):\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.normal(0, 0.1, self.dim)\n                population[i] = np.clip(population[i] + mutation_vector, lb, ub)\n        return population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            quantum_population = self.quantum_update(func.bounds)\n            self.position = self.mutation(quantum_population, func.bounds)\n        return self.best_position, self.best_score", "name": "QuantumInspiredEvolutionaryOptimizer", "description": "Quantum-Inspired Evolutionary Optimizer (QIEO) integrating quantum-inspired probabilistic distribution with evolutionary operators for enhanced exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 3, "fitness": 0.2494773366882959, "feedback": "The algorithm QuantumInspiredEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "28eab971-1423-4e7d-a0b3-c441e53aaa4f", "metadata": {"aucs": [0.2487982590543084, 0.24674161902036063, 0.25289213199021865]}, "mutation_prompt": null}
{"id": "280ad311-c3c3-429d-8126-0f9a823171d8", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.729  # Inertia weight\n        self.f = 0.8  # Differential evolution scale factor\n        self.cr = 0.9  # Crossover rate\n        self.mutation_prob = 0.1  # Probability for adaptive mutation\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = self.w * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def adaptive_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        for i in range(self.population_size):\n            if np.random.rand() < self.mutation_prob:\n                mutation_vector = np.random.normal(0, 0.1, self.dim)\n                self.position[i] = np.clip(self.position[i] + mutation_vector, lb, ub)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position()\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            self.adaptive_mutation(func.bounds)\n        return self.gbest, self.gbest_score", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid algorithm combining Particle Swarm Optimization, Differential Evolution, and Adaptive Mutation strategies for robust global optimization of photonic structures.", "configspace": "", "generation": 4, "fitness": 0.2546177576930605, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "28eab971-1423-4e7d-a0b3-c441e53aaa4f", "metadata": {"aucs": [0.25366246594811137, 0.25444511105584966, 0.25574569607522046]}, "mutation_prompt": null}
{"id": "be1bfcbf-2552-4f9c-8fc3-fd61da617747", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.729  # Inertia weight\n        self.f = 0.8  # Differential evolution scale factor\n        self.cr = 0.9  # Crossover rate\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_chaotic_sequence()\n\n    def generate_chaotic_sequence(self, length=10000):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n    \n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n    \n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_position(self, iteration):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = self.w * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "EnhancedHybridSwarmOptimizer", "description": "An enhanced hybrid swarm optimizer integrating chaotic maps for adaptive parameter tuning to improve exploration and exploitation in the global optimization of photonic structures.", "configspace": "", "generation": 5, "fitness": 0.2599667268316794, "feedback": "The algorithm EnhancedHybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "28eab971-1423-4e7d-a0b3-c441e53aaa4f", "metadata": {"aucs": [0.2597259929671263, 0.2613594116820497, 0.2588147758458622]}, "mutation_prompt": null}
{"id": "857604e5-5a41-4a8e-998b-f9e44aeeb2ae", "solution": "import numpy as np\n\nclass EnhancedDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w_max = 0.9  # Maximum inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.f = 0.8  # Differential evolution scale factor\n        self.cr = 0.9  # Crossover rate\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_chaotic_sequence()\n        self.iteration = 0\n        self.func_calls = 0\n\n    def generate_chaotic_sequence(self, length=10000):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return np.array(sequence)\n    \n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n    \n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.initial_population_size, self.dim)\n        self.velocity = np.random.rand(self.initial_population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.initial_population_size, float('inf'))\n        self.population_size = self.initial_population_size\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def adaptive_inertia_weight(self):\n        return self.w_max - ((self.w_max - self.w_min) * self.iteration / (self.budget // self.initial_population_size))\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(self.iteration)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        w = self.adaptive_inertia_weight()\n        self.velocity = w * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def adapt_population_size(self):\n        if self.iteration % 10 == 0 and self.population_size > self.min_population_size:\n            self.population_size = max(self.min_population_size, self.population_size - 5)\n            self.position = self.position[:self.population_size]\n            self.velocity = self.velocity[:self.population_size]\n            self.pbest = self.pbest[:self.population_size]\n            self.pbest_scores = self.pbest_scores[:self.population_size]\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        while self.func_calls < self.budget:\n            scores = self.evaluate(func)\n            self.func_calls += self.population_size\n            self.update_velocity_position()\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            self.func_calls += self.population_size\n            self.adapt_population_size()\n            self.iteration += 1\n        return self.gbest, self.gbest_score", "name": "EnhancedDynamicSwarmOptimizer", "description": "Introduce adaptive inertia weights and dynamic population resizing based on convergence metrics to enhance exploration and exploitation balance in photonic structure optimization.", "configspace": "", "generation": 6, "fitness": 0.2581457677034475, "feedback": "The algorithm EnhancedDynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "be1bfcbf-2552-4f9c-8fc3-fd61da617747", "metadata": {"aucs": [0.2553169028532627, 0.26019556432599733, 0.2589248359310824]}, "mutation_prompt": null}
{"id": "1f15e108-3991-459b-b9a5-a06660e48f38", "solution": "import numpy as np\n\nclass QuantumInspiredGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.q_states = None\n        self.population = None\n        self.best_solution = None\n        self.best_score = float('inf')\n        self.alpha = 0.3  # Rotation angle for Q-gates\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.q_states = np.pi * np.random.rand(self.population_size, self.dim)  # Quantum superposition states\n        self.population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.best_solution = None\n        self.best_score = float('inf')\n\n    def collapse_q_state(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        binary_values = np.cos(self.q_states) ** 2 > np.random.rand(self.population_size, self.dim)\n        return lb + (ub - lb) * binary_values.astype(float)\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.population])\n        best_idx = np.argmin(scores)\n        if scores[best_idx] < self.best_score:\n            self.best_score = scores[best_idx]\n            self.best_solution = self.population[best_idx]\n        return scores\n\n    def quantum_rotation_gate(self, scores):\n        for i in range(self.population_size):\n            if scores[i] < self.best_score:\n                self.q_states[i] = self.q_states[i] + self.alpha\n            else:\n                self.q_states[i] = self.q_states[i] - self.alpha\n\n    def genetic_operations(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.population)\n        for i in range(0, self.population_size, 2):\n            if i + 1 >= self.population_size:\n                break\n            parent1, parent2 = self.population[i], self.population[i+1]\n            crossover_point = np.random.randint(1, self.dim - 1)\n            child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n            child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n            new_population[i], new_population[i+1] = child1, child2\n\n        mutation_prob = 1.0 / self.dim\n        for i in range(self.population_size):\n            if np.random.rand() < mutation_prob:\n                mutation_index = np.random.randint(self.dim)\n                new_population[i, mutation_index] = lb[mutation_index] + (ub[mutation_index] - lb[mutation_index]) * np.random.rand()\n        \n        self.population = np.clip(new_population, lb, ub)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            self.population = self.collapse_q_state(func.bounds)\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.quantum_rotation_gate(scores)\n            self.genetic_operations(func.bounds)\n        return self.best_solution, self.best_score", "name": "QuantumInspiredGeneticAlgorithm", "description": "A Quantum-inspired Genetic Algorithm (QIGA) using quantum superposition states for enhanced exploration and genetic operations for exploitation in optimizing photonic structures.", "configspace": "", "generation": 7, "fitness": 0.2037381717072334, "feedback": "The algorithm QuantumInspiredGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.00.", "error": "", "parent_id": "be1bfcbf-2552-4f9c-8fc3-fd61da617747", "metadata": {"aucs": [0.2037381717072334, 0.2037381717072334, 0.2037381717072334]}, "mutation_prompt": null}
{"id": "eaedd1ba-ce6b-4058-bc17-becf35d78e62", "solution": "import numpy as np\n\nclass DynamicAdaptiveHybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.f = 0.8\n        self.cr = 0.9\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.7\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i-1] * (1 - sequence[i-1]) ** 2\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n    \n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n    \n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "DynamicAdaptiveHybridSwarmOptimizer", "description": "A dynamic adaptive hybrid swarm optimizer utilizing a stochastic inertia weight and enhanced chaotic map for improved balance between exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 8, "fitness": 0.2655424330416956, "feedback": "The algorithm DynamicAdaptiveHybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "be1bfcbf-2552-4f9c-8fc3-fd61da617747", "metadata": {"aucs": [0.2657257052182799, 0.2707876702991874, 0.26011392360761953]}, "mutation_prompt": null}
{"id": "3bd37163-2ced-461d-a583-5d67982fc62c", "solution": "import numpy as np\n\nclass AdaptiveMultiPhasedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.f = 0.5\n        self.cr = 0.7\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n        self.global_best_improvement = 0.01\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.6\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i-1] * (1 - sequence[i-1]) ** 2\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        last_best_score = float('inf')\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            score_improvement = np.abs(self.gbest_score - last_best_score)\n            if score_improvement < self.global_best_improvement:\n                self.w_max *= 0.9  # Adaptive strategy based on improvement\n            \n            self.update_velocity_position(iteration, max_iterations)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            last_best_score = self.gbest_score\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "AdaptiveMultiPhasedSwarmOptimizer", "description": "An adaptive multi-phased swarm optimizer using chaotic parameter tuning and multi-population strategies for enhanced exploration-exploitation balance and convergence in photonic structure optimization.", "configspace": "", "generation": 9, "fitness": 0.2759174894488505, "feedback": "The algorithm AdaptiveMultiPhasedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eaedd1ba-ce6b-4058-bc17-becf35d78e62", "metadata": {"aucs": [0.276928190297131, 0.2736320116124292, 0.27719226643699124]}, "mutation_prompt": null}
{"id": "bbb5ea99-cb78-4231-a217-a35a787f645b", "solution": "import numpy as np\n\nclass HierarchicalCoEvolutionaryParticleOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sub_population_size = 10\n        self.c1 = 1.5\n        self.c2 = 2.0\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def dynamic_leader_selection(self):\n        leaders = []\n        for i in range(0, self.population_size, self.sub_population_size):\n            sub_positions = self.position[i:i+self.sub_population_size]\n            sub_scores = self.pbest_scores[i:i+self.sub_population_size]\n            leader_idx = np.argmin(sub_scores)\n            leaders.append(sub_positions[leader_idx])\n        return np.array(leaders)\n\n    def neighborhood_learning(self, leaders):\n        for i in range(self.population_size):\n            neighbor_idx = np.random.choice(range(leaders.shape[0]))\n            self.position[i] = self.position[i] + np.random.rand() * (leaders[neighbor_idx] - self.position[i])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            leaders = self.dynamic_leader_selection()\n            self.neighborhood_learning(leaders)\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "HierarchicalCoEvolutionaryParticleOptimizer", "description": "A hierarchical co-evolutionary particle optimization algorithm utilizing dynamic leader selection and neighborhood learning to enhance adaptability and convergence in highly complex search spaces.", "configspace": "", "generation": 10, "fitness": 0.2633293401692506, "feedback": "The algorithm HierarchicalCoEvolutionaryParticleOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.2614880011961678, 0.26386398244018994, 0.26463603687139403]}, "mutation_prompt": null}
{"id": "4da6f073-0477-463d-bc9c-24dd74a01965", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.9\n        self.beta = 0.5\n        self.gamma = 0.2\n        self.position = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.best_position = np.copy(self.position)\n        self.best_scores = np.full(self.population_size, float('inf')) \n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i]\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.global_best = self.position[i]\n        return scores\n\n    def quantum_superposition(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        q_population = (self.alpha * self.best_position +\n                        self.beta * self.global_best +\n                        self.gamma * np.random.rand(self.population_size, self.dim))\n        return np.clip(q_population, lb, ub)\n\n    def update_position(self, q_population, scores, new_scores):\n        for i in range(self.population_size):\n            if new_scores[i] < scores[i]:\n                self.position[i] = q_population[i]\n                scores[i] = new_scores[i]\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            q_population = self.quantum_superposition(func.bounds)\n            new_scores = np.array([func(p) for p in q_population])\n            func_calls += self.population_size\n            self.update_position(q_population, scores, new_scores)\n        return self.global_best, self.best_score", "name": "QuantumInspiredPSO", "description": "Quantum-Inspired Particle Swarm Optimization employing quantum superposition states and adaptive hybridization for enhanced exploration and convergence in photonic structure optimization.", "configspace": "", "generation": 11, "fitness": 0.23994134079892693, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.24341540882856016, 0.23834480608611286, 0.23806380748210776]}, "mutation_prompt": null}
{"id": "dd810248-3114-4631-952f-987a6ab7e3a1", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.f = 0.5\n        self.cr = 0.7\n        self.w_min = 0.2\n        self.w_max = 0.9\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n        self.convergence_threshold = 0.01\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.6\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i-1] * (1 - sequence[i-1]) ** 2\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations, improvement_factor):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration + improvement_factor) / max_iterations)\n\n    def update_velocity_position(self, iteration, max_iterations, improvement_factor):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations, improvement_factor)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        last_best_score = float('inf')\n        improvement_factor = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            score_improvement = np.abs(self.gbest_score - last_best_score)\n            if score_improvement < self.convergence_threshold:\n                improvement_factor += 1\n            else:\n                improvement_factor = 0\n            \n            self.update_velocity_position(iteration, max_iterations, improvement_factor)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            last_best_score = self.gbest_score\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "RefinedAdaptiveSwarmOptimizer", "description": "A dynamic multi-phased optimizer leveraging adaptive chaotic parameter tuning, inertia weight scheduling, and hybrid crossover for robust exploration-exploitation in photonic structure optimization.", "configspace": "", "generation": 12, "fitness": 0.2720387694954675, "feedback": "The algorithm RefinedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.2739069043128489, 0.2660232941131696, 0.27618611006038407]}, "mutation_prompt": null}
{"id": "ab7c445e-0115-4673-872a-c8d854d57c06", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n        self.global_best_improvement = 0.005\n        self.dynamic_leadership_threshold = 5\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.7\n        for i in range(1, length):\n            sequence[i] = 3.9 * sequence[i-1] * (1 - sequence[i-1])\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def dynamic_leadership_adjustment(self, scores, iteration):\n        if iteration % self.dynamic_leadership_threshold == 0:\n            elite_indices = np.argsort(scores)[:self.population_size // 5]\n            self.gbest = np.mean(self.position[elite_indices], axis=0)\n            self.gbest_score = np.mean(scores[elite_indices])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        last_best_score = float('inf')\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            score_improvement = np.abs(self.gbest_score - last_best_score)\n            if score_improvement < self.global_best_improvement:\n                self.w_max *= 0.95  # Adaptive strategy based on improvement\n\n            self.update_velocity_position(iteration, max_iterations)\n            self.dynamic_leadership_adjustment(scores, iteration)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            last_best_score = self.gbest_score\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "An enhanced multi-phased swarm optimizer integrating adaptive chaotic sequences and dynamic leadership adjustments for improved convergence and solution diversity in photonic structure optimization.", "configspace": "", "generation": 13, "fitness": 0.27178771672307894, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.27038493651878415, 0.2700144002864313, 0.2749638133640214]}, "mutation_prompt": null}
{"id": "2b4acc9c-7e98-4f5f-a300-85040f247661", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.5\n        self.beta = 0.5\n        self.q_probability = 0.1\n        self.topology_update_freq = 10\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.topology = np.random.choice(self.population_size, (self.population_size, 3), replace=False)\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_position(self, iteration, max_iterations, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            quantum_jumps = np.random.rand(self.dim) < self.q_probability\n            if quantum_jumps.any():\n                self.position[i][quantum_jumps] = lb[quantum_jumps] + (ub[quantum_jumps] - lb[quantum_jumps]) * np.random.rand(np.sum(quantum_jumps))\n            else:\n                local_best = self.pbest[self.topology[i]].min(axis=0)\n                cognitive = self.alpha * r1[i] * (self.pbest[i] - self.position[i])\n                social = self.beta * r2[i] * (local_best - self.position[i])\n                self.velocity[i] = cognitive + social\n                self.position[i] += self.velocity[i]\n                self.position[i] = np.clip(self.position[i], lb, ub)\n\n    def update_topology(self):\n        self.topology = np.random.choice(self.population_size, (self.population_size, 3), replace=False)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations, func.bounds)\n            if iteration % self.topology_update_freq == 0:\n                self.update_topology()\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "QuantumInspiredDynamicSwarmOptimizer", "description": "Quantum-Inspired Dynamic Swarm Optimizer utilizing quantum superposition for diverse exploration and dynamic topology adaptation for efficient global convergence in photonic structures.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {}, "mutation_prompt": null}
{"id": "697be362-eb0b-435b-b1a4-698f9f4379b4", "solution": "import numpy as np\n\nclass QuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 50\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bandwidth = 0.01\n        self.position = None\n        self.scores = None\n        self.best_position = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.harmony_memory_size, self.dim)\n        self.scores = np.array([np.inf] * self.harmony_memory_size)\n        \n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.harmony_memory_size):\n            if scores[i] < self.scores[i]:\n                self.scores[i] = scores[i]\n                \n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best_position = self.position[i]\n        return scores\n\n    def quantum_walk(self, lb, ub):\n        step_size = np.random.rand(self.dim) * (ub - lb) * self.bandwidth\n        return step_size * (np.random.randint(2, size=self.dim) * 2 - 1)\n\n    def generate_new_harmony(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_harmony = np.zeros(self.dim)\n        \n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_harmony[i] = self.position[np.random.randint(self.harmony_memory_size), i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth * (ub[i] - lb[i])\n            else:\n                new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n        \n        new_harmony += self.quantum_walk(lb, ub)\n        new_harmony = np.clip(new_harmony, lb, ub)\n        return new_harmony\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        \n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.harmony_memory_size\n            \n            new_harmony = self.generate_new_harmony(func.bounds)\n            new_score = func(new_harmony)\n            func_calls += 1\n            \n            worst_idx = np.argmax(self.scores)\n            if new_score < self.scores[worst_idx]:\n                self.position[worst_idx] = new_harmony\n                self.scores[worst_idx] = new_score\n                \n                if new_score < self.best_score:\n                    self.best_score = new_score\n                    self.best_position = new_harmony\n        \n        return self.best_position, self.best_score", "name": "QuantumInspiredHarmonySearch", "description": "Quantum-inspired Harmony Search with Dynamic Memory Consideration integrates quantum walks and adaptive memory updating to enhance exploration and convergence for photonic structure optimization.", "configspace": "", "generation": 15, "fitness": 0.2500319845790218, "feedback": "The algorithm QuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.2500118293153697, 0.24813867765439168, 0.2519454467673041]}, "mutation_prompt": null}
{"id": "bdafc8e5-c9c6-4de6-a40d-0bf1e1da3597", "solution": "import numpy as np\n\nclass QuantumHybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.f = 0.5\n        self.cr = 0.7\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.alpha = 0.9  # Quantum step size\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n        self.global_best_improvement = 0.01\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.6\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i-1] * (1 - sequence[i-1]) ** 2\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def quantum_behavior_update(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        quantum_move = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        quantum_step = self.alpha * quantum_move * (self.gbest - self.position)\n        quantum_position = self.position + quantum_step\n        quantum_position = np.clip(quantum_position, lb, ub)\n        return quantum_position\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        last_best_score = float('inf')\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            score_improvement = np.abs(self.gbest_score - last_best_score)\n            if score_improvement < self.global_best_improvement:\n                self.w_max *= 0.9  # Adaptive strategy based on improvement\n            \n            self.update_velocity_position(iteration, max_iterations)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            quantum_population = self.quantum_behavior_update(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in quantum_population])[:, np.newaxis],\n                self.position, quantum_population\n            )\n            func_calls += self.population_size * 2\n            last_best_score = self.gbest_score\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "QuantumHybridSwarmOptimizer", "description": "A hybrid swarm optimizer that introduces quantum-behavior inspired exploration and local search intensification, aiming to enhance convergence speed and precision for photonic structure optimization.", "configspace": "", "generation": 16, "fitness": 0.27547263869350785, "feedback": "The algorithm QuantumHybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.2762865767111413, 0.2756262875261255, 0.2745050518432567]}, "mutation_prompt": null}
{"id": "80ac57ce-1e3d-4871-8c81-631a7e48507f", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicWavefront:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavefront_size = 10\n        self.alpha = 0.1\n        self.beta = 0.9\n        self.position = None\n        self.best_position = None\n        self.best_score = float('inf')\n        self.q_registers = None\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.q_registers = np.random.rand(self.population_size, self.dim)\n        self.best_position = np.copy(self.position)\n\n    def quantum_superposition(self):\n        angle = np.arccos(1 - 2 * self.q_registers)\n        wavefront = np.sin(angle) * self.position + np.cos(angle) * self.best_position\n        return wavefront\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best_position = self.position[i]\n        return scores\n\n    def dynamic_wavefront_update(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        superposition = self.quantum_superposition()\n        wavefront = np.zeros(superposition.shape)\n\n        for i in range(self.wavefront_size):\n            perturbation = self.alpha * (ub - lb) * np.random.rand(self.population_size, self.dim)\n            wavefront = superposition + perturbation * np.sin(2 * np.pi * np.random.rand(*perturbation.shape))\n            wavefront = np.clip(wavefront, lb, ub)\n\n        self.position = wavefront\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n\n            self.dynamic_wavefront_update(func.bounds)\n            self.q_registers = self.beta * self.q_registers + (1 - self.beta) * np.random.rand(self.population_size, self.dim)\n\n        return self.best_position, self.best_score", "name": "QuantumInspiredDynamicWavefront", "description": "Quantum-Inspired Dynamic Wavefront Algorithm combines quantum superposition principles with dynamic wavefront propagation for enhanced exploration and convergence in optimizing photonic structures.", "configspace": "", "generation": 17, "fitness": 0.2404726982870349, "feedback": "The algorithm QuantumInspiredDynamicWavefront got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.24079028241753464, 0.24209312127368465, 0.23853469116988546]}, "mutation_prompt": null}
{"id": "402d3b70-4499-417f-983f-adf6b1e29571", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiPhasedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.f = 0.5\n        self.cr = 0.7\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n        self.global_best_improvement = 0.01\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.6\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i-1] * (1 - sequence[i-1]) ** 2\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        adaptive_c1 = self.c1 + chaotic_factor * 0.1  # Adaptive cognitive parameter\n        adaptive_c2 = self.c2 + chaotic_factor * 0.1  # Adaptive social parameter\n        cognitive = chaotic_factor * adaptive_c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * adaptive_c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.initial_population_size\n        iteration = 0\n        last_best_score = float('inf')\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n\n            score_improvement = np.abs(self.gbest_score - last_best_score)\n            if score_improvement < self.global_best_improvement:\n                self.w_max *= 0.9  # Adaptive strategy based on improvement\n                self.population_size = max(10, int(self.population_size * 0.95))  # Dynamically adjust population size\n                self.initialize(func.bounds)  # Re-initialize with new population size\n            \n            self.update_velocity_position(iteration, max_iterations)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            last_best_score = self.gbest_score\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "EnhancedAdaptiveMultiPhasedSwarmOptimizer", "description": "Enhanced Adaptive Multi-Phased Swarm Optimizer with adaptive learning rates and dynamic population size for improved convergence in photonic structure optimization.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,1) (47,1) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,1) (47,1) ')", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {}, "mutation_prompt": null}
{"id": "eec4623d-61f4-405f-9347-f08c4d117f35", "solution": "import numpy as np\nfrom scipy.special import gamma\n\nclass EnhancedAdaptiveMultiPhasedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.f = 0.5\n        self.cr = 0.7\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n        self.global_best_improvement = 0.01\n        self.alpha = 1.5  # Lévy flight parameter\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.6\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i-1] * (1 - sequence[i-1]) ** 2\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def levy_flight(self):\n        sigma = (gamma(1 + self.alpha) * np.sin(np.pi * self.alpha / 2) / (gamma((1 + self.alpha) / 2) * self.alpha * 2 ** ((self.alpha - 1) / 2))) ** (1 / self.alpha)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / abs(v) ** (1 / self.alpha)\n        return step\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social + self.levy_flight()\n        self.position += self.velocity\n\n    def adaptive_mutation_rate(self, iteration, max_iterations):\n        return self.cr * (1 - (iteration / max_iterations))\n\n    def differential_evolution_mutation(self, bounds, iteration, max_iterations):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.adaptive_mutation_rate(iteration, max_iterations)\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        last_best_score = float('inf')\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            score_improvement = np.abs(self.gbest_score - last_best_score)\n            if score_improvement < self.global_best_improvement:\n                self.w_max *= 0.9  # Adaptive strategy based on improvement\n            \n            self.update_velocity_position(iteration, max_iterations)\n            new_population = self.differential_evolution_mutation(func.bounds, iteration, max_iterations)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            last_best_score = self.gbest_score\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "EnhancedAdaptiveMultiPhasedSwarmOptimizer", "description": "Enhanced Adaptive Multi-Phased Swarm Optimizer with Lévy flight for global exploration and adaptive mutation rate for convergence improvement in photonic structure optimization.", "configspace": "", "generation": 19, "fitness": 0.27545091149664597, "feedback": "The algorithm EnhancedAdaptiveMultiPhasedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.2765332011338839, 0.27568783800764307, 0.27413169534841086]}, "mutation_prompt": null}
{"id": "e6b609cc-940e-4bb9-b7b6-e5c376522352", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveMultiPopAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.position = None\n        self.best_global_position = None\n        self.best_global_score = float('inf')\n        self.quantum_probability = 0.5\n        self.tournament_size = 5\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.best_local_positions = np.copy(self.position)\n        self.best_local_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.best_local_scores[i]:\n                self.best_local_scores[i] = scores[i]\n                self.best_local_positions[i] = self.position[i]\n            if scores[i] < self.best_global_score:\n                self.best_global_score = scores[i]\n                self.best_global_position = self.position[i]\n        return scores\n\n    def quantum_superposition(self, position, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        mask = np.random.rand(self.population_size, self.dim) < self.quantum_probability\n        new_positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        return np.where(mask, new_positions, position)\n\n    def tournament_selection(self, scores):\n        selected_indices = []\n        for _ in range(self.population_size):\n            candidates = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best_candidate = candidates[np.argmin(scores[candidates])]\n            selected_indices.append(best_candidate)\n        return selected_indices\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        func_calls = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            selected_indices = self.tournament_selection(scores)\n            selected_positions = self.position[selected_indices]\n            self.position = self.quantum_superposition(selected_positions, func.bounds)\n        return self.best_global_position, self.best_global_score", "name": "QuantumInspiredAdaptiveMultiPopAlgorithm", "description": "Quantum-Inspired Adaptive Multi-Population Algorithm: Leverages quantum-inspired superposition states and tournament selection for adaptive global exploration and refined local exploitation in photonic structure optimization.", "configspace": "", "generation": 20, "fitness": 0.2628485055296058, "feedback": "The algorithm QuantumInspiredAdaptiveMultiPopAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.2611517935183154, 0.26163751491937837, 0.26575620815112366]}, "mutation_prompt": null}
{"id": "d6979208-b018-47d3-a9ef-44ac1951f6f1", "solution": "import numpy as np\n\nclass QuantumParticleSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.alpha = 0.5  # Quantum adaptation parameter\n        self.beta = 0.5   # Quantum crossover probability\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = self.w * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def quantum_superposition(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            qbit = np.random.rand(self.dim) < self.beta\n            q_position = lb + (ub - lb) * np.random.rand(self.dim)\n            new_position = np.where(qbit, q_position, self.position[i])\n            new_population[i] = new_position\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        \n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            \n            self.update_velocity_position()\n            quantum_population = self.quantum_superposition(func.bounds)\n            scores_quantum = np.array([func(p) for p in quantum_population])\n            func_calls += self.population_size\n            \n            self.position = np.where(\n                scores[:, np.newaxis] <= scores_quantum[:, np.newaxis],\n                self.position, quantum_population\n            )\n            \n            # Adaptive parameter control\n            if iteration % 10 == 0:\n                self.w = max(0.4, self.w * 0.95)\n                self.alpha = min(0.9, self.alpha + 0.05)\n                self.beta = min(0.9, self.beta + 0.02)\n                \n            iteration += 1\n        \n        return self.gbest, self.gbest_score", "name": "QuantumParticleSwarmOptimizer", "description": "A Bio-inspired Quantum Particle Swarm Optimizer leveraging quantum superposition with adaptive parameter control for enhanced exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 21, "fitness": 0.2658761928212889, "feedback": "The algorithm QuantumParticleSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.269712614454539, 0.2656059801651136, 0.2623099838442141]}, "mutation_prompt": null}
{"id": "52230dbb-8916-48f8-a33b-78c57db6409a", "solution": "import numpy as np\nfrom scipy.stats import levy\n\nclass EnhancedAdaptiveMultiPhasedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.f = 0.5\n        self.cr = 0.7\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.chaotic_sequence = self.generate_advanced_chaotic_sequence()\n        self.global_best_improvement = 0.01\n        self.subpop_size = 10  # Dynamic subpopulation size\n\n    def generate_advanced_chaotic_sequence(self, length=10000):\n        sequence = np.zeros(length)\n        sequence[0] = 0.6\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i - 1] * (1 - sequence[i - 1]) ** 2\n        return sequence\n\n    def chaotic_parameter(self, index):\n        return self.chaotic_sequence[index % len(self.chaotic_sequence)]\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        chaotic_factor = self.chaotic_parameter(iteration)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = chaotic_factor * self.c1 * r1 * (self.pbest - self.position)\n        social = chaotic_factor * self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = inertia_weight * self.velocity + cognitive + social + self.levy_perturbation()\n        self.position += self.velocity\n\n    def differential_evolution_mutation(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.pbest[a] + self.f * (self.pbest[b] - self.pbest[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_population[i] = np.where(crossover, mutant, self.position[i])\n        return new_population\n\n    def levy_perturbation(self):\n        return levy.rvs(size=(self.population_size, self.dim)) * (self.gbest - self.position)\n\n    def subpopulation_interaction(self, scores):\n        interacting_indices = np.argsort(scores)[:self.subpop_size]\n        interacting_pos = self.position[interacting_indices]\n        means = np.mean(interacting_pos, axis=0)\n        self.position[interacting_indices] += self.f * (means - self.position[interacting_indices])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        last_best_score = float('inf')\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            score_improvement = np.abs(self.gbest_score - last_best_score)\n            if score_improvement < self.global_best_improvement:\n                self.w_max *= 0.9  # Adaptive strategy based on improvement\n            \n            self.update_velocity_position(iteration, max_iterations)\n            new_population = self.differential_evolution_mutation(func.bounds)\n            self.position = np.where(\n                scores[:, np.newaxis] <= np.array([func(p) for p in new_population])[:, np.newaxis],\n                self.position, new_population\n            )\n            func_calls += self.population_size\n            self.subpopulation_interaction(scores)\n            last_best_score = self.gbest_score\n            iteration += 1\n        return self.gbest, self.gbest_score", "name": "EnhancedAdaptiveMultiPhasedSwarmOptimizer", "description": "Enhanced Adaptive Multi-Phased Swarm Optimizer with dynamic subpopulation interactions and Lévy flight perturbations for improved global exploration and convergence in photonic structure optimization.", "configspace": "", "generation": 22, "fitness": 0.25855567589422557, "feedback": "The algorithm EnhancedAdaptiveMultiPhasedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.2621038561593164, 0.25913619097112106, 0.2544269805522392]}, "mutation_prompt": null}
{"id": "69302e64-6959-4c66-ba37-b130f36dc232", "solution": "import numpy as np\n\nclass QuantumPSOWithAdaptiveQRG:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumPSOWithAdaptiveQRG", "description": "Quantum-inspired Particle Swarm Optimization with Adaptive Quantum Rotation Gates for Exploration-Exploitation Balance.", "configspace": "", "generation": 23, "fitness": 0.27706942418803604, "feedback": "The algorithm QuantumPSOWithAdaptiveQRG got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "3bd37163-2ced-461d-a583-5d67982fc62c", "metadata": {"aucs": [0.27706198692015205, 0.27696948529818577, 0.2771768003457703]}, "mutation_prompt": null}
{"id": "43afd9e6-8c21-4ace-86e8-c419720c6bff", "solution": "import numpy as np\n\nclass EnhancedQuantumPSOWithAdaptiveQRG:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def dynamic_population_resizing(self, iteration, max_iterations):\n        if iteration < max_iterations // 3:\n            self.population_size = max(10, int(self.population_size * 0.9))\n        elif iteration > 2 * max_iterations // 3:\n            self.population_size = min(100, int(self.population_size * 1.1))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        self.dynamic_population_resizing(iteration, max_iterations)\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls + self.population_size <= self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "EnhancedQuantumPSOWithAdaptiveQRG", "description": "Enhanced Quantum-inspired Particle Swarm Optimization with Adaptive Quantum Rotation Gates and Dynamic Population Resizing to Improve Convergence Speed and Solution Quality.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (45,10) (50,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (45,10) (50,10) ')", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {}, "mutation_prompt": null}
{"id": "f87e2b68-de73-4e6d-aa08-5a36fd0a6791", "solution": "import numpy as np\n\nclass EnhancedQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.neighborhood_size = max(2, self.population_size // 5)\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def dynamic_neighborhood_best(self, index):\n        start = max(0, index - self.neighborhood_size // 2)\n        end = min(self.population_size, index + self.neighborhood_size // 2)\n        neighborhood = self.position[start:end]\n        neighborhood_scores = self.pbest_scores[start:end]\n        local_best_index = np.argmin(neighborhood_scores)\n        return neighborhood[local_best_index]\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        for i in range(self.population_size):\n            cognitive = self.c1 * r1[i] * (self.pbest[i] - self.position[i])\n            local_best = self.dynamic_neighborhood_best(i)\n            social = self.c2 * r2[i] * (local_best - self.position[i])\n            quantum_velocity = self.quantum_rotation_gate(self.velocity[i])\n            self.velocity[i] = inertia_weight * quantum_velocity + cognitive + social\n            self.position[i] += self.velocity[i]\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "EnhancedQuantumPSO", "description": "Enhanced Quantum PSO with Dynamic Neighborhoods and Adaptive Rotation for Improved Convergence in High-Dimensional Spaces.", "configspace": "", "generation": 25, "fitness": 0.27608763535641007, "feedback": "The algorithm EnhancedQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {"aucs": [0.2751692896690424, 0.27596352347950814, 0.2771300929206796]}, "mutation_prompt": null}
{"id": "253fd8e3-d90a-4fac-a3d3-45b6b7c2507b", "solution": "import numpy as np\n\nclass ImprovedQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.1\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        phase = 2 * (iteration / max_iterations)\n        return self.w_min + 0.5 * (self.w_max - self.w_min) * (1 + np.cos(np.pi * phase))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) - np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "ImprovedQuantumPSO", "description": "Quantum-inspired Particle Swarm Optimization with Dynamic Multi-phase Inertia and Adaptive Quantum Rotation Gates for Enhanced Convergence.", "configspace": "", "generation": 26, "fitness": 0.2754001968464341, "feedback": "The algorithm ImprovedQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {"aucs": [0.2749906209013361, 0.27610278739441474, 0.27510718224355135]}, "mutation_prompt": null}
{"id": "033432a9-71a3-47f7-b3ab-b182ae5bf9e3", "solution": "import numpy as np\n\nclass MemeticQuantumSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_velocity_update(self, velocity):\n        theta = np.random.rand(*velocity.shape) * (np.pi / 4)\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def local_search(self, func):\n        if np.random.rand() < self.mutation_rate:\n            index = np.random.randint(0, self.population_size)\n            perturb = np.random.normal(0, 0.1, self.dim)\n            candidate_solution = self.position[index] + perturb\n            candidate_score = func(candidate_solution)\n            if candidate_score < self.pbest_scores[index]:\n                self.pbest_scores[index] = candidate_score\n                self.pbest[index] = candidate_solution\n            if candidate_score < self.gbest_score:\n                self.gbest_score = candidate_score\n                self.gbest = candidate_solution\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_velocity_update(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.local_search(func)\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "MemeticQuantumSwarmOptimization", "description": "Memetic Quantum Swarm Optimization with Dynamic Local Search to Enhance Convergence Speed and Solution Quality in High-Dimensional Spaces.", "configspace": "", "generation": 27, "fitness": 0.27701005133451106, "feedback": "The algorithm MemeticQuantumSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {"aucs": [0.2773526421345446, 0.276656409132525, 0.27702110273646363]}, "mutation_prompt": null}
{"id": "77a6bfb6-3ab9-4276-b542-40c6c845d59d", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.1\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.subpopulations = 2\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def dynamic_subpopulation_update(self, iteration, max_iterations):\n        if iteration % (max_iterations // 5) == 0:\n            self.subpopulations = 2 if self.subpopulations == 3 else 3\n\n    def update_velocity_position(self, iteration, max_iterations):\n        self.dynamic_subpopulation_update(iteration, max_iterations)\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n\n        for i in range(self.subpopulations):\n            subpop_size = self.population_size // self.subpopulations\n            subpop_start = i * subpop_size\n            subpop_end = subpop_start + subpop_size\n            self.position[subpop_start:subpop_end] += self.velocity[subpop_start:subpop_end]\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumPSO", "description": "Adaptive Quantum-Inspired PSO with Dynamic Subpopulation Strategies for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 28, "fitness": 0.2748330987767664, "feedback": "The algorithm AdaptiveQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {"aucs": [0.27564261823053493, 0.275704756373104, 0.27315192172666036]}, "mutation_prompt": null}
{"id": "09b9463a-43d8-480b-a883-27c919b705f8", "solution": "import numpy as np\n\nclass LevyFlightEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.5\n        self.beta = 1.5\n        self.scaling_factor_min = 0.5\n        self.scaling_factor_max = 1.0\n        self.crossover_probability = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.best_individual = np.copy(self.population[0])\n\n    def evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        best_idx = np.argmin(scores)\n        if scores[best_idx] < self.best_score:\n            self.best_score = scores[best_idx]\n            self.best_individual = np.copy(self.population[best_idx])\n        return scores\n\n    def levy_flight(self):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1/self.beta)\n        return self.alpha * step\n\n    def mutate(self, target_idx, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        idxs = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(idxs, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.dynamic_scaling_factor() * (self.population[b] - self.population[c]), lb, ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def dynamic_scaling_factor(self):\n        return self.scaling_factor_min + (self.scaling_factor_max - self.scaling_factor_min) * np.random.rand()\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            for i in range(self.population_size):\n                mutant = self.mutate(i, func.bounds)\n                trial = self.crossover(self.population[i], mutant)\n                \n                # Perform Lévy flight\n                trial += self.levy_flight()\n                \n                trial_score = func(trial)\n                func_calls += 1\n                if trial_score < scores[i]:\n                    self.population[i] = trial\n                    scores[i] = trial_score\n                if trial_score < self.best_score:\n                    self.best_score = trial_score\n                    self.best_individual = trial\n                if func_calls >= self.budget:\n                    break\n\n        return self.best_individual, self.best_score", "name": "LevyFlightEnhancedDE", "description": "Lévy Flight Enhanced Differential Evolution with Dynamic Scaling Factors for Superior Exploration and Exploitation.", "configspace": "", "generation": 29, "fitness": 0.25949967938411417, "feedback": "The algorithm LevyFlightEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {"aucs": [0.2585379242178577, 0.25908807052121197, 0.2608730434132729]}, "mutation_prompt": null}
{"id": "3ffe0192-6885-4a24-aa4b-4fe660e801b0", "solution": "import numpy as np\n\nclass AdaptiveGeneticAlgorithmWithNiching:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.7\n        self.elite_archive_size = 10\n        self.elite_archive = []\n        self.niche_radius = None\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.elite_archive = []\n\n    def evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.population])\n        return scores\n\n    def niche_count(self, candidate):\n        return sum(np.linalg.norm(candidate - e) < self.niche_radius for e in self.elite_archive)\n\n    def select_parents(self):\n        niche_counts = np.array([self.niche_count(ind) for ind in self.population])\n        fitness = 1 / (1 + self.scores + niche_counts)\n        selected_indices = np.random.choice(self.population_size, size=self.population_size // 2, p=fitness/fitness.sum())\n        return self.population[selected_indices]\n\n    def crossover(self, parents):\n        offspring = []\n        for _ in range(len(parents) // 2):\n            if np.random.rand() < self.crossover_rate:\n                p1, p2 = np.random.choice(len(parents), 2, replace=False)\n                crossover_point = np.random.randint(1, self.dim)\n                child1 = np.hstack((parents[p1][:crossover_point], parents[p2][crossover_point:]))\n                child2 = np.hstack((parents[p2][:crossover_point], parents[p1][crossover_point:]))\n                offspring.extend([child1, child2])\n            else:\n                offspring.extend(parents[np.random.choice(len(parents), 2, replace=False)])\n        return np.array(offspring)\n\n    def mutate(self, offspring):\n        mutation_matrix = np.random.rand(*offspring.shape) < self.mutation_rate\n        mutation_values = (np.random.rand(*offspring.shape) - 0.5) * 0.1\n        offspring[mutation_matrix] += mutation_values[mutation_matrix]\n        return offspring\n\n    def update_elite_archive(self, scores):\n        elite_candidates = list(zip(self.population, scores))\n        elite_candidates.sort(key=lambda x: x[1])\n        self.elite_archive.extend(elite_candidates[:self.elite_archive_size])\n        self.elite_archive = sorted(self.elite_archive, key=lambda x: x[1])[:self.elite_archive_size]\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        self.niche_radius = 0.1 * (func.bounds.ub - func.bounds.lb).mean()\n\n        while func_calls < self.budget:\n            self.scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_elite_archive(self.scores)\n            parents = self.select_parents()\n            offspring = self.crossover(parents)\n            self.population = self.mutate(offspring)\n            iteration += 1\n\n        best_individual = min(self.elite_archive, key=lambda x: x[1])\n        return best_individual[0], best_individual[1]", "name": "AdaptiveGeneticAlgorithmWithNiching", "description": "Adaptive Genetic Algorithm with Dynamic Niching and Elite Archiving for Global Exploration and Local Exploitation.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (2,) + inhomogeneous part.').", "error": "ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (2,) + inhomogeneous part.')", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {}, "mutation_prompt": null}
{"id": "c4ab9f4a-77b6-4051-b471-27a838441f88", "solution": "import numpy as np\n\nclass MemeticDEWithDynamicLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.position = None\n        self.scores = None\n        self.best_index = None\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        for i in range(self.population_size):\n            self.scores[i] = func(self.position[i])\n        self.best_index = np.argmin(self.scores)\n\n    def differential_mutation(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        mutant = self.position[r1] + self.F * (self.position[r2] - self.position[r3])\n        return np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        perturbation = (np.random.rand(self.dim) - 0.5) * 0.1 * (func.bounds.ub - func.bounds.lb)\n        local_candidate = np.clip(candidate + perturbation, func.bounds.lb, func.bounds.ub)\n        return local_candidate if func(local_candidate) < func(candidate) else candidate\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            self.evaluate(func)\n            func_calls += self.population_size\n            new_population = np.copy(self.position)\n            for i in range(self.population_size):\n                mutant = self.differential_mutation(i)\n                trial = self.crossover(self.position[i], mutant)\n                trial = self.local_search(trial, func)\n                trial_score = func(trial)\n                func_calls += 1\n                if trial_score < self.scores[i]:\n                    new_population[i] = trial\n                    self.scores[i] = trial_score\n            self.position = new_population\n\n        best_index = np.argmin(self.scores)\n        return self.position[best_index], self.scores[best_index]", "name": "MemeticDEWithDynamicLocalSearch", "description": "Memetic Differential Evolution with Dynamic Local Search for Improved Convergence and Solution Refinement.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {}, "mutation_prompt": null}
{"id": "590d3f84-2006-4347-952f-b6b483c22bb3", "solution": "import numpy as np\n\nclass AdaptiveDEWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F = 0.5  # Scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.position = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def levy_flight(self, step_size=0.1):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step_size * step\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def mutate(self):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.position[indices[0]], self.position[indices[1]], self.position[indices[2]]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        jrand = np.random.randint(self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == jrand else target[j] for j in range(self.dim)])\n        return trial\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate() + self.levy_flight()\n                trial = self.crossover(self.position[i], mutant)\n                trial_score = func(trial)\n                func_calls += 1\n                \n                if trial_score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = trial_score\n                    self.pbest[i] = trial\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest = trial\n\n                if func_calls >= self.budget:\n                    break\n        \n        return self.gbest, self.gbest_score", "name": "AdaptiveDEWithLevyFlight", "description": "Adaptive Differential Evolution with Lévy Flight for Efficient Global Exploration and Exploitation.", "configspace": "", "generation": 32, "fitness": 0.2597674192494032, "feedback": "The algorithm AdaptiveDEWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {"aucs": [0.26049291903603566, 0.25627205143129284, 0.2625372872808811]}, "mutation_prompt": null}
{"id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "solution": "import numpy as np\n\nclass QuantumEnhancedPSODynamicInertiaGaussianMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.gaussian_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSODynamicInertiaGaussianMutation", "description": "Quantum-Enhanced PSO with Dynamic Inertia and Gaussian Mutation for Improved Exploration-Exploitation Tradeoff.", "configspace": "", "generation": 33, "fitness": 0.27760543519159614, "feedback": "The algorithm QuantumEnhancedPSODynamicInertiaGaussianMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "69302e64-6959-4c66-ba37-b130f36dc232", "metadata": {"aucs": [0.27754659788798786, 0.27765728754526364, 0.27761242014153686]}, "mutation_prompt": null}
{"id": "f3b3adfb-531d-4b8a-8aa4-e2a03e07f1d9", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmLevySelfAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.alpha = 0.1  # Initial mutation step size\n        self.scaling_factor = 0.99  # Scaling factor for mutation step adaptation\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * iteration / max_iterations)\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / abs(v)**(1 / beta)\n        return position + step\n\n    def self_adaptive_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.alpha\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.levy_flight(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.self_adaptive_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n            self.alpha *= self.scaling_factor  # Adapt mutation step size\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumSwarmLevySelfAdaptive", "description": "Adaptive Quantum Swarm Optimization with Levy Flight-Inspired Exploration and Self-Adaptive Mutation for Enhanced Global Search Efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "5b5c803e-fdec-4b62-9c8a-8a1fa12bc114", "solution": "import numpy as np\n\nclass ImprovedQuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 3\n        self.mutation_rate = 0.05\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def adaptive_quantum_rotation(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def enhanced_mutation(self, position):\n        mutation_strength = np.random.uniform(0, self.mutation_rate, position.shape)\n        mutation = np.random.randn(*position.shape) * mutation_strength\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.adaptive_quantum_rotation(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.enhanced_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "ImprovedQuantumEnhancedPSO", "description": "Quantum-Enhanced PSO with Adaptive Quantum Rotation, Enhanced Mutation, and Local Optima Avoidance for Superior Convergence.", "configspace": "", "generation": 35, "fitness": 0.2686001673452608, "feedback": "The algorithm ImprovedQuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2682615525195692, 0.27168414021757914, 0.26585480929863414]}, "mutation_prompt": null}
{"id": "25472cbe-20b5-4ef5-9a33-2cca90f6c7a3", "solution": "import numpy as np\n\nclass HybridQuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_min = 0.2\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.elites = 5\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def adaptive_mutation(self, position, best_position):\n        mutation_strength = np.random.rand() * self.mutation_rate\n        mutation = np.random.randn(*position.shape) * mutation_strength * np.abs(best_position - position)\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        elite_indices = np.argsort(self.pbest_scores)[:self.elites]\n        for i in elite_indices:\n            self.position[i] = self.adaptive_mutation(self.position[i], self.gbest)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "HybridQuantumEnhancedPSO", "description": "Hybrid Quantum-Enhanced PSO with Adaptive Mutation and Elite Learning for Enhanced Convergence in High-Dimensional Spaces.", "configspace": "", "generation": 36, "fitness": 0.26874381851741713, "feedback": "The algorithm HybridQuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.270945705642766, 0.2670215453232716, 0.2682642045862138]}, "mutation_prompt": null}
{"id": "ad6e90d6-39c1-46bb-bd4b-a27e4485565b", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSO_DEMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def de_mutation(self, population):\n        mutant_population = np.copy(population)\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = population[indices[0]], population[indices[1]], population[indices[2]]\n            mutant_vector = x1 + self.mutation_factor * (x2 - x3)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            mutant_population[i] = np.where(crossover, mutant_vector, population[i])\n        return mutant_population\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.de_mutation(self.position)\n        \n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumEnhancedPSO_DEMutation", "description": "Adaptive Quantum-Enhanced PSO with Differential Evolution-Inspired Mutation for Enhanced Diversity and Convergence.", "configspace": "", "generation": 37, "fitness": 0.2623876217235304, "feedback": "The algorithm AdaptiveQuantumEnhancedPSO_DEMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2589696855705139, 0.26393934211194214, 0.26425383748813525]}, "mutation_prompt": null}
{"id": "7110fd66-cb46-4e2f-b75e-649b27c45c5a", "solution": "import numpy as np\nfrom scipy.stats import levy\n\nclass AdaptiveDifferentialEvolutionLevyChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.position = None\n        self.scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.scores[i]:\n                self.scores[i] = scores[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def levy_flight(self, step_size=0.01):\n        return levy.rvs(size=self.dim) * step_size\n\n    def chaotic_perturbation(self, iteration, max_iterations, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        chaos_factor = np.sin(2 * np.pi * iteration / max_iterations)\n        perturbation = (ub - lb) * chaos_factor * np.random.rand(self.dim)\n        return perturbation\n\n    def mutate_and_recombine(self, bounds, iteration, max_iterations):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        new_position = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = self.position[np.random.choice(indices, 3, replace=False)]\n            mutant = a + self.F * (b - c) + self.levy_flight()\n            mutant = np.clip(mutant, lb, ub)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.position[i])\n            trial += self.chaotic_perturbation(iteration, max_iterations, bounds)\n            new_position[i] = np.clip(trial, lb, ub)\n        return new_position\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.position = self.mutate_and_recombine(func.bounds, iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveDifferentialEvolutionLevyChaos", "description": "Adaptive Differential Evolution with Lévy Flight and Chaos-Inspired Perturbations for Enhanced Global Search.", "configspace": "", "generation": 38, "fitness": 0.24906208792218557, "feedback": "The algorithm AdaptiveDifferentialEvolutionLevyChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.24946748605281777, 0.24960337154026546, 0.2481154061734735]}, "mutation_prompt": null}
{"id": "eb0b57dc-b6f5-42e6-acc3-a92b9a6ad612", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR_max = 0.9\n        self.CR_min = 0.1\n        self.quantum_amplification_prob = 0.05\n        self.population = None\n        self.scores = None\n        self.best_idx = None\n        self.best_score = float('inf')\n        self.best_solution = None\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        for i in range(self.population_size):\n            score = func(self.population[i])\n            if score < self.scores[i]:\n                self.scores[i] = score\n            if score < self.best_score:\n                self.best_score = score\n                self.best_solution = self.population[i]\n        return self.scores\n\n    def adaptive_crossover_rate(self, iteration, max_iterations):\n        return self.CR_max - ((self.CR_max - self.CR_min) * iteration / max_iterations)\n\n    def mutate(self, target_idx):\n        idxs = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(idxs, 3, replace=False)\n        mutation_vector = self.population[a] + self.F * (self.population[b] - self.population[c])\n        return mutation_vector\n\n    def crossover(self, target, mutant, cr):\n        trial = np.copy(target)\n        for i in range(self.dim):\n            if np.random.rand() < cr:\n                trial[i] = mutant[i]\n        return trial\n\n    def quantum_amplitude_amplification(self, candidate):\n        probability = np.random.rand()\n        if probability < self.quantum_amplification_prob:\n            phase_flip = np.exp(1j * np.pi)\n            candidate = np.real(candidate * phase_flip)\n        return candidate\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            cr = self.adaptive_crossover_rate(iteration, max_iterations)\n            new_population = np.copy(self.population)\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant, cr)\n                trial = self.quantum_amplitude_amplification(trial)\n                trial_score = func(trial)\n                func_calls += 1\n                if trial_score < self.scores[i]:\n                    new_population[i] = trial\n                    self.scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n                if func_calls >= self.budget:\n                    break\n            self.population = new_population\n            iteration += 1\n        \n        return self.best_solution, self.best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Crossover and Quantum Amplitude Amplification for Enhanced Global Search Efficiency.", "configspace": "", "generation": 39, "fitness": 0.26758651334606026, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.26666294774421506, 0.2699033904820374, 0.2661932018119284]}, "mutation_prompt": null}
{"id": "3962d297-7009-416c-a990-efabc3a1cdc4", "solution": "import numpy as np\n\nclass LevyFlightEnhancedPSOSGD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.01  # Learning rate for SGD\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def levy_flight(self, step_size=0.1):\n        u = np.random.randn(*self.position.shape) * step_size\n        v = np.random.randn(*self.position.shape)\n        step = u / (np.abs(v) ** (1 / 3))\n        return self.position + step\n\n    def sgd_update(self, func):\n        gradients = np.array([self.gradient_approx(func, p) for p in self.position])\n        self.position -= self.alpha * gradients\n\n    def gradient_approx(self, func, x, epsilon=1e-8):\n        grad = np.zeros_like(x)\n        for i in range(len(x)):\n            x1 = np.copy(x)\n            x2 = np.copy(x)\n            x1[i] += epsilon\n            x2[i] -= epsilon\n            grad[i] = (func(x1) - func(x2)) / (2 * epsilon)\n        return grad\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = self.w * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            if iteration % 2 == 0:\n                self.position = self.levy_flight()\n            self.update_velocity_position()\n            self.sgd_update(func)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "LevyFlightEnhancedPSOSGD", "description": "Adaptive Lévy Flight Enhanced PSO with Stochastic Gradient Descent for Fine-Tuning Global and Local Searches.", "configspace": "", "generation": 40, "fitness": 0.2690740774734512, "feedback": "The algorithm LevyFlightEnhancedPSOSGD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.26495417412368627, 0.2716548778966551, 0.27061318040001225]}, "mutation_prompt": null}
{"id": "4db0d09f-5bb8-4af9-be97-906beaaa4c9a", "solution": "import numpy as np\n\nclass AdaptiveMemeticHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.harmony_memory_size = 10\n        self.harmony_consideration_rate = 0.9\n        self.pitch_adjustment_rate = 0.1\n        self.local_search_rate = 0.2\n        self.position = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.harmony_memory = np.copy(self.position[:self.harmony_memory_size])\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def harmony_search(self):\n        new_position = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for d in range(self.dim):\n                if np.random.rand() < self.harmony_consideration_rate:\n                    new_position[i, d] = self.harmony_memory[np.random.randint(self.harmony_memory_size), d]\n                    if np.random.rand() < self.pitch_adjustment_rate:\n                        new_position[i, d] += 0.1 * np.random.randn()\n                else:\n                    new_position[i, d] = np.random.rand() * (self.harmony_memory[:, d].max() - self.harmony_memory[:, d].min()) + self.harmony_memory[:, d].min()\n        self.position = new_position\n\n    def local_search(self, position):\n        return position + np.random.randn(*position.shape) * 0.01\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n\n            if np.random.rand() < self.local_search_rate:\n                for i in range(self.population_size):\n                    self.position[i] = self.local_search(self.position[i])\n\n            self.harmony_search()\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveMemeticHarmonySearch", "description": "Adaptive Memetic Algorithm with Harmony Search for Enhanced Global and Local Search Balance.", "configspace": "", "generation": 41, "fitness": 0.2601668193899163, "feedback": "The algorithm AdaptiveMemeticHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2581332376778802, 0.2585740538977823, 0.26379316659408647]}, "mutation_prompt": null}
{"id": "a0b10964-afa6-401d-a51f-29dd33dab7b4", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveDiversityLevyMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.diversity_threshold = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v) ** (1 / beta)\n        return position + 0.01 * step\n\n    def update_diversity(self):\n        position_mean = np.mean(self.position, axis=0)\n        diversity = np.mean(np.linalg.norm(self.position - position_mean, axis=1))\n        return diversity < self.diversity_threshold\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n        if self.update_diversity():\n            self.position = self.levy_flight(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveDiversityLevyMutation", "description": "Quantum-Enhanced PSO with Adaptive Diversity Maintenance and Lévy Flight Mutation for Enhanced Global Search and Local Refinement.", "configspace": "", "generation": 42, "fitness": 0.2773121638518703, "feedback": "The algorithm QuantumEnhancedPSOAdaptiveDiversityLevyMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.27728177163555623, 0.2775936988291392, 0.27706102109091546]}, "mutation_prompt": null}
{"id": "568ddb40-87c0-4944-aef0-faae7bd8c14a", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSODynamicTopologyLevyMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_scale = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.neighborhood_size = 10\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight_mutation(self, position):\n        levy = np.random.standard_cauchy(size=position.shape) * self.mutation_scale\n        return position + levy\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n\n        for i in range(self.population_size):\n            neighbors = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n            local_best = min(neighbors, key=lambda idx: self.pbest_scores[idx])\n            cognitive = self.c1 * r1[i] * (self.pbest[i] - self.position[i])\n            social = self.c2 * r2[i] * (self.pbest[local_best] - self.position[i])\n\n            quantum_velocity = self.quantum_rotation_gate(self.velocity[i])\n            self.velocity[i] = inertia_weight * quantum_velocity + cognitive + social\n            self.position[i] += self.velocity[i]\n            self.position[i] = self.levy_flight_mutation(self.position[i])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumPSODynamicTopologyLevyMutation", "description": "Adaptive Quantum PSO with Dynamic Topology and Lévy Flight Mutation to Enhance Global and Local Search Capabilities.", "configspace": "", "generation": 43, "fitness": 0.27278090942219485, "feedback": "The algorithm AdaptiveQuantumPSODynamicTopologyLevyMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.27066644407025464, 0.27299142705620716, 0.2746848571401228]}, "mutation_prompt": null}
{"id": "64b5e0ce-49a4-4d1d-8cad-7e1772aff0ae", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSODiversityPreservation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.diversity_threshold = 0.1\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def calculate_diversity(self):\n        centroid = np.mean(self.position, axis=0)\n        diversity = np.mean(np.linalg.norm(self.position - centroid, axis=1))\n        return diversity\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.gaussian_mutation(self.position)\n\n        diversity = self.calculate_diversity()\n        if diversity < self.diversity_threshold:\n            self.position += np.random.randn(*self.position.shape) * 0.1\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumEnhancedPSODiversityPreservation", "description": "Adaptive Quantum-Enhanced PSO with Dynamic Inertia, Gaussian Mutation, and Diversity Preservation to Enhance Global Search Efficacy.", "configspace": "", "generation": 44, "fitness": 0.27760543519159614, "feedback": "The algorithm AdaptiveQuantumEnhancedPSODiversityPreservation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.27754659788798786, 0.27765728754526364, 0.27761242014153686]}, "mutation_prompt": null}
{"id": "18ef44ba-200f-4dc2-84ab-3d316d47e8e6", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.5\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def levy_flight(self, beta=1.5):\n        sigma_u = np.power((np.gamma(1 + beta) * np.sin(np.pi * beta / 2)) /\n                           (np.gamma((1 + beta) / 2) * beta * np.power(2, (beta - 1) / 2)), 1 / beta)\n        u = np.random.randn(*self.position.shape) * sigma_u\n        v = np.random.randn(*self.position.shape)\n        step = u / np.power(np.abs(v), 1 / beta)\n        return 0.01 * step\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        self.velocity = self.w * self.velocity + cognitive + social\n        self.position += self.velocity + self.levy_flight()\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position()\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumSwarmLevyFlight", "description": "Adaptive Quantum-Swarm with Lévy Flights for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "adcfbf45-f10f-45ad-a273-c967cce67ee8", "solution": "import numpy as np\n\nclass EnhancedHybridQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.mutation_rate_min = 0.05\n        self.mutation_rate_max = 0.3\n        self.rotation_angle_max = np.pi / 4\n        self.rotation_angle_min = np.pi / 8\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * iteration / max_iterations)\n\n    def adaptive_quantum_rotation(self, velocity, iteration, max_iterations):\n        rotation_angle = self.rotation_angle_max - ((self.rotation_angle_max - self.rotation_angle_min) * iteration / max_iterations)\n        theta = np.random.rand(*velocity.shape) * rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def adaptive_gaussian_mutation(self, position, iteration, max_iterations):\n        mutation_rate = self.mutation_rate_min + ((self.mutation_rate_max - self.mutation_rate_min) * iteration / max_iterations)\n        mutation = np.random.randn(*position.shape) * mutation_rate\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.adaptive_quantum_rotation(self.velocity, iteration, max_iterations)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.adaptive_gaussian_mutation(self.position, iteration, max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "EnhancedHybridQuantumPSO", "description": "Enhanced Hybrid Quantum PSO with Adaptive Quantum Rotation and Adaptive Gaussian Mutation for Dynamic Search Space Exploration.", "configspace": "", "generation": 46, "fitness": 0.27404086502227215, "feedback": "The algorithm EnhancedHybridQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2717435879885052, 0.27613778960385316, 0.2742412174744582]}, "mutation_prompt": null}
{"id": "4c597035-e0d9-4898-aa04-c73dfd3a3afe", "solution": "import numpy as np\n\nclass HybridGADifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.5\n        self.adaptive_scale = 0.1\n        self.position = None\n        self.scores = None\n        self.best_solution = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        for i in range(self.population_size):\n            score = func(self.position[i])\n            if score < self.scores[i]:\n                self.scores[i] = score\n            if score < self.best_score:\n                self.best_score = score\n                self.best_solution = self.position[i]\n        return self.scores\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vec = self.position[a] + self.mutation_factor * (self.position[b] - self.position[c])\n        return np.clip(mutant_vec, 0, 1)\n\n    def crossover(self, parent, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, parent)\n        return trial\n\n    def adapt_parameters(self, iteration, max_iterations):\n        self.crossover_rate = 0.7 + (0.9 - 0.7) * (iteration / max_iterations)\n        self.mutation_factor = 0.5 + (0.9 - 0.5) * (1 - (iteration / max_iterations))\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        \n        while func_calls < self.budget:\n            self.adapt_parameters(iteration, max_iterations)\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n\n            new_population = []\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.position[i], mutant)\n                trial_score = func(trial)\n                func_calls += 1\n\n                if trial_score < self.scores[i]:\n                    new_population.append(trial)\n                    self.scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n                else:\n                    new_population.append(self.position[i])\n\n            self.position = np.array(new_population)\n            iteration += 1\n\n        return self.best_solution, self.best_score", "name": "HybridGADifferentialEvolution", "description": "Hybrid Genetic Algorithm and Differential Evolution with Adaptive Crossover and Mutation for Enhanced Diversity and Convergence.", "configspace": "", "generation": 47, "fitness": 0.2363375317587462, "feedback": "The algorithm HybridGADifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.232603981708018, 0.23834480608611286, 0.23806380748210776]}, "mutation_prompt": null}
{"id": "30e68388-ceab-471b-97e7-3e8aa0ec52ec", "solution": "import numpy as np\n\nclass DifferentiatedQuantumCoherencePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 6\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_coherence(self, velocity):\n        coherence_shift = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(coherence_shift) + np.random.rand(*velocity.shape) * np.sin(coherence_shift)\n        return q_velocity\n\n    def adaptive_exploration(self, position, iteration, max_iterations):\n        exploration_factor = np.exp(-iteration / (0.5 * max_iterations))\n        perturbation = exploration_factor * np.random.randn(*position.shape)\n        return position + perturbation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        q_velocity = self.quantum_coherence(self.velocity)\n        self.velocity = inertia_weight * q_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.adaptive_exploration(self.position, iteration, max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "DifferentiatedQuantumCoherencePSO", "description": "Differentiated Population-based Quantum Coherence PSO with Adaptive Exploration for Enhanced Global Search.", "configspace": "", "generation": 48, "fitness": 0.26257136007672993, "feedback": "The algorithm DifferentiatedQuantumCoherencePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.26523254666392726, 0.2600225442245595, 0.262458989341703]}, "mutation_prompt": null}
{"id": "4f9b36e8-a238-4832-8282-459c9ffb2995", "solution": "import numpy as np\n\nclass AdaptiveMemoryMultiPhaseOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.memory_size = 15  # Memory size for storing best solutions\n        self.noise_amplitude = 0.05\n        self.adaptive_phase_switch = 0.5  # Ratio to switch between exploration and exploitation\n        self.exploration_factor = 0.9\n        self.exploitation_factor = 0.1\n        self.memory = None\n        self.best_solution = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.memory = []\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.population])\n        for i in range(self.population_size):\n            if scores[i] < self.scores[i]:\n                self.scores[i] = scores[i]\n                if scores[i] < self.best_score:\n                    self.best_score = scores[i]\n                    self.best_solution = self.population[i]\n        return scores\n\n    def update_memory(self):\n        sorted_indices = np.argsort(self.scores)\n        for idx in sorted_indices[:self.memory_size]:\n            if len(self.memory) < self.memory_size:\n                self.memory.append(self.population[idx])\n            else:\n                worst_idx = np.argmax([func(p) for p in self.memory])\n                if func(self.memory[worst_idx]) > self.scores[idx]:\n                    self.memory[worst_idx] = self.population[idx]\n\n    def adaptive_neighborhood_search(self, func):\n        exploration = np.random.randn(self.population_size, self.dim) * self.exploration_factor\n        exploitation = np.zeros((self.population_size, self.dim))\n        for i, member in enumerate(self.memory):\n            exploitation += (member - self.population) * self.exploitation_factor / len(self.memory)\n        self.population += exploration + exploitation + np.random.randn(self.population_size, self.dim) * self.noise_amplitude\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_memory()\n            self.adaptive_neighborhood_search(func)\n            iteration += 1\n\n        return self.best_solution, self.best_score", "name": "AdaptiveMemoryMultiPhaseOptimization", "description": "Adaptive Memory-Based Multi-Phase Optimization with Dynamic Neighborhood and Noise Resilience for Enhanced Exploration and Convergence.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "54978168-789a-4c02-9b00-67e11e5246b8", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.mutation_prob = 0.1  # Mutation probability\n        self.position = None\n        self.lb = None\n        self.ub = None\n\n    def initialize(self, bounds):\n        self.lb, self.ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def evaluate(self, func):\n        scores = np.array([func(ind) for ind in self.position])\n        return scores\n\n    def mutate(self, idx, best_idx):\n        indices = np.random.permutation(self.population_size)\n        indices = indices[indices != idx][:3]\n        a, b, c = self.position[indices]\n        best = self.position[best_idx]\n        mutant = best + self.F * (a - b + c - self.position[idx])\n        mutant = np.clip(mutant, self.lb, self.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def quantum_mutation(self, position):\n        theta = np.random.rand(*position.shape) * np.pi / 4\n        mutation = np.random.randn(*position.shape) * self.mutation_prob\n        return position * np.cos(theta) + mutation * np.sin(theta)\n\n    def select(self, target, trial, target_score, trial_score):\n        if trial_score < target_score:\n            return trial, trial_score\n        return target, target_score\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        scores = self.evaluate(func)\n        func_calls += self.population_size\n\n        best_idx = np.argmin(scores)\n        best_score = scores[best_idx]\n        \n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i, best_idx)\n                trial = self.crossover(self.position[i], mutant)\n                trial_score = func(trial)\n                func_calls += 1\n\n                self.position[i], scores[i] = self.select(self.position[i], trial, scores[i], trial_score)\n                self.position[i] = self.quantum_mutation(self.position[i])\n\n                if scores[i] < best_score:\n                    best_score = scores[i]\n                    best_idx = i\n\n                if func_calls >= self.budget:\n                    break\n\n        return self.position[best_idx], best_score", "name": "QuantumInspiredDifferentialEvolutionAdaptiveMutation", "description": "Quantum-Inspired Differential Evolution with Adaptive Cross-Mutation for Enhanced Global Search and Local Refinement.", "configspace": "", "generation": 50, "fitness": 0.25164530661415024, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.01.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.245646991620464, 0.25831094850605896, 0.2509779797159277]}, "mutation_prompt": null}
{"id": "ba72c467-3115-4850-acb6-6d0f1f086732", "solution": "import numpy as np\n\nclass HybridQuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.elite_archive_size = 5\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.elite_archive = []\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.elite_archive = []\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n            self.update_elite_archive(self.position[i], scores[i])\n        return scores\n\n    def update_elite_archive(self, position, score):\n        if len(self.elite_archive) < self.elite_archive_size:\n            self.elite_archive.append((position, score))\n        else:\n            worst_idx = max(range(len(self.elite_archive)), key=lambda i: self.elite_archive[i][1])\n            if score < self.elite_archive[worst_idx][1]:\n                self.elite_archive[worst_idx] = (position, score)\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def adaptive_feature_selection(self, position):\n        selected_features = np.random.choice(self.dim, size=int(self.dim * 0.8), replace=False)\n        new_position = np.copy(position)\n        new_position[selected_features] += np.random.randn(len(selected_features)) * 0.05\n        return new_position\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.gaussian_mutation(self.position)\n\n        for i in range(self.population_size):\n            if np.random.rand() < 0.1:\n                self.position[i] = self.adaptive_feature_selection(self.position[i])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "HybridQuantumEnhancedPSO", "description": "Hybrid Quantum-Enhanced PSO with Adaptive Feature Selection and Elite Archive for Improved Convergence and Diversity.", "configspace": "", "generation": 51, "fitness": 0.2774803148271417, "feedback": "The algorithm HybridQuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2778094726712096, 0.2772103294423628, 0.27742114236785265]}, "mutation_prompt": null}
{"id": "149c4023-09df-4f96-ab19-d5b5aeb417d4", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveLearningDynamicNeighborhood:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def adaptive_learning_rates(self, iteration, max_iterations):\n        decay = iteration / max_iterations\n        c1 = self.c1_initial * (1 - decay)\n        c2 = self.c2_initial * decay\n        return c1, c2\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def determine_neighbors(self):\n        num_neighbors = 5\n        indices = np.arange(self.population_size)\n        np.random.shuffle(indices)\n        neighbors = []\n        for i in range(self.population_size):\n            neighbors.append(indices[np.random.choice(indices, num_neighbors, replace=False)])\n        return neighbors\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        c1, c2 = self.adaptive_learning_rates(iteration, max_iterations)\n\n        cognitive = c1 * r1 * (self.pbest - self.position)\n        neighbors = self.determine_neighbors()\n        social = np.zeros_like(self.velocity)\n        for i in range(self.population_size):\n            neighborhood_best = min(self.pbest_scores[neighbors[i]])\n            social[i] = c2 * r2[i] * (neighborhood_best - self.position[i])\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.gaussian_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveLearningDynamicNeighborhood", "description": "Quantum-Enhanced PSO with Adaptive Learning Rate and Dynamic Neighborhood for Enhanced Performance and Convergence.", "configspace": "", "generation": 52, "fitness": 0.2521315092902771, "feedback": "The algorithm QuantumEnhancedPSOAdaptiveLearningDynamicNeighborhood got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.01.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2551720381728374, 0.24413590093313497, 0.257086588764859]}, "mutation_prompt": null}
{"id": "c088788f-b089-4bf6-9ee0-6135f69b20bb", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearchDifferentialMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.hmcr = 0.9  # Harmony Memory Consideration Rate\n        self.par_min = 0.2  # Initial Pitch Adjustment Rate\n        self.par_max = 0.8  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.1  # Minimum differential mutation factor\n        self.f_max = 0.9  # Maximum differential mutation factor\n        self.position = None\n        self.harmony_memory = None\n        self.hm_scores = None\n        self.best_harmony = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.harmony_memory = np.copy(self.position)\n        self.hm_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(h) for h in self.harmony_memory])\n        for i in range(self.population_size):\n            if scores[i] < self.hm_scores[i]:\n                self.hm_scores[i] = scores[i]\n                self.harmony_memory[i] = self.position[i]\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best_harmony = self.position[i]\n        return scores\n\n    def adapt_par(self, iteration, max_iterations):\n        return self.par_min + (self.par_max - self.par_min) * (iteration / max_iterations)\n\n    def adapt_f(self, iteration, max_iterations):\n        return self.f_min + (self.f_max - self.f_min) * (1 - iteration / max_iterations)\n\n    def differential_mutation(self, harmony, f):\n        indexes = np.random.choice(self.population_size, 3, replace=False)\n        mutant = self.harmony_memory[indexes[0]] + f * (self.harmony_memory[indexes[1]] - self.harmony_memory[indexes[2]])\n        return np.clip(mutant, 0, 1)\n\n    def generate_new_harmony(self, iteration, max_iterations):\n        new_harmony = np.zeros(self.dim)\n        par = self.adapt_par(iteration, max_iterations)\n        f = self.adapt_f(iteration, max_iterations)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                indx = np.random.randint(self.population_size)\n                new_harmony[i] = self.harmony_memory[indx][i]\n                if np.random.rand() < par:\n                    new_harmony[i] += np.random.uniform(-1, 1) * f\n            else:\n                mutant = self.differential_mutation(new_harmony, f)\n                new_harmony[i] = mutant[i]\n        return new_harmony\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                self.position[i] = self.generate_new_harmony(iteration, max_iterations)\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            iteration += 1\n        \n        return self.best_harmony, self.best_score", "name": "AdaptiveHarmonySearchDifferentialMutation", "description": "Adaptive Harmony Search with Differential Mutation for Enhanced Global and Local Exploration.", "configspace": "", "generation": 53, "fitness": 0.24042559337578995, "feedback": "The algorithm AdaptiveHarmonySearchDifferentialMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.01.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.232603981708018, 0.23834480608611286, 0.250327992333239]}, "mutation_prompt": null}
{"id": "48adb2e1-5840-497f-9d96-db859534d854", "solution": "import numpy as np\n\nclass AdaptiveQuantumEvolutionary:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.elite_fraction = 0.2\n        self.mutation_rate = 0.05\n        self.crossover_rate = 0.7\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.best_solutions = None\n        self.best_scores = None\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.best_solutions = np.copy(self.position)\n        self.best_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_solutions[i] = self.position[i]\n        return scores\n\n    def quantum_rotation_gate(self, position):\n        theta = np.random.rand(*position.shape) * self.rotation_angle\n        q_position = position * np.cos(theta) + np.random.rand(*position.shape) * np.sin(theta)\n        return q_position\n\n    def mutate(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            crossover_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            child = parent1\n        return child\n\n    def select_parents(self, scores):\n        probabilities = 1 / (scores + 1e-9)\n        probabilities /= probabilities.sum()\n        parents_indices = np.random.choice(self.population_size, size=2, p=probabilities)\n        return self.position[parents_indices[0]], self.position[parents_indices[1]]\n\n    def adaptive_elitism(self, scores):\n        elite_size = int(self.elite_fraction * self.population_size)\n        elite_indices = np.argsort(scores)[:elite_size]\n        return self.position[elite_indices]\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        generation = 0\n        max_generations = self.budget // self.population_size\n\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n\n            elite_individuals = self.adaptive_elitism(scores)\n            next_generation = []\n\n            while len(next_generation) < self.population_size:\n                parent1, parent2 = self.select_parents(scores)\n                child = self.crossover(parent1, parent2)\n                child = self.mutate(child)\n                next_generation.append(child)\n\n            self.position = np.array(next_generation)\n            self.position[:len(elite_individuals)] = elite_individuals  # Preserve elites\n            self.position = self.quantum_rotation_gate(self.position)\n            generation += 1\n\n        best_index = np.argmin(self.best_scores)\n        return self.best_solutions[best_index], self.best_scores[best_index]", "name": "AdaptiveQuantumEvolutionary", "description": "Adaptive Quantum Evolutionary Algorithm with Multi-Objective Guidance for Enhanced Exploration and Convergence.", "configspace": "", "generation": 54, "fitness": 0.25337914161990766, "feedback": "The algorithm AdaptiveQuantumEvolutionary got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.01.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2474552713854712, 0.24624445049502863, 0.2664377029792231]}, "mutation_prompt": null}
{"id": "392dd7ad-1742-4756-b98f-b4a14d605df4", "solution": "import numpy as np\n\nclass SelfAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.position = None\n        self.bounds = None\n        self.fitness = None\n\n    def initialize(self, bounds):\n        self.bounds = np.array([bounds.lb, bounds.ub])\n        self.position = np.random.rand(self.population_size, self.dim)\n        self.position = self.bounds[0] + self.position * (self.bounds[1] - self.bounds[0])\n        self.fitness = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.fitness[i]:\n                self.fitness[i] = scores[i]\n        return scores\n\n    def mutate(self, target_idx):\n        candidates = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.position[np.random.choice(candidates, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        return np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, target)\n        return crossover_vector\n\n    def adapt_parameters(self, iteration, max_iterations):\n        self.mutation_factor = 0.5 + 0.3 * np.sin(np.pi * iteration / max_iterations)\n        self.crossover_rate = 0.9 - 0.4 * np.sin(np.pi * iteration / max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        best_score = float('inf')\n        best_solution = None\n\n        for iteration in range(max_iterations):\n            self.adapt_parameters(iteration, max_iterations)\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.position[i], mutant)\n                trial_score = func(trial)\n                func_calls += 1\n\n                if trial_score < self.fitness[i]:\n                    self.position[i] = trial\n                    self.fitness[i] = trial_score\n\n                if trial_score < best_score:\n                    best_score = trial_score\n                    best_solution = trial\n\n                if func_calls >= self.budget:\n                    break\n\n            if func_calls >= self.budget:\n                break\n\n        return best_solution, best_score", "name": "SelfAdaptiveDE", "description": "Differential Evolution with Self-Adaptive Mutation and Crossover Rates for Dynamic Solution Search and Enhanced Convergence.", "configspace": "", "generation": 55, "fitness": 0.26662189994286706, "feedback": "The algorithm SelfAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2651771837542446, 0.26746641058525733, 0.2672221054890993]}, "mutation_prompt": null}
{"id": "bb169f3d-1dd3-4a8e-81bf-1a9510340b64", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.rotation_angle = np.pi / 4\n        self.adapt_factor = 0.1\n        self.position = None\n        self.best_position = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.best_position = np.copy(self.position[0])\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best_position = self.position[i]\n        return scores\n\n    def quantum_rotation(self, vector):\n        theta = np.random.rand(*vector.shape) * self.rotation_angle\n        q_vector = vector * np.cos(theta) + np.random.rand(*vector.shape) * np.sin(theta)\n        return q_vector\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            indices = list(range(0, i)) + list(range(i + 1, self.population_size))\n            a, b, c = self.position[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = self.quantum_rotation(a + self.mutation_factor * (b - c))\n            cross_points = np.random.rand(self.dim) < self.crossover_prob\n            trial_vector = np.where(cross_points, mutant_vector, self.position[i])\n            trial_score = func(trial_vector)\n            if trial_score < func(self.position[i]):\n                self.position[i] = trial_vector\n\n    def update_parameters(self, iteration, max_iterations):\n        self.mutation_factor = 0.5 + (0.5 - 0.1) * (1 - iteration / max_iterations) ** 2\n        self.crossover_prob = 0.9 - 0.4 * np.sin(np.pi * iteration / max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            self.evaluate(func)\n            func_calls += self.population_size\n            self.differential_evolution(func)\n            self.update_parameters(iteration, max_iterations)\n            iteration += 1\n\n        return self.best_position, self.best_score", "name": "AdaptiveQuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution (AQIDE) utilizing Quantum Rotation and Adaptive Parameter Control for Enhanced Global Search Capabilities.", "configspace": "", "generation": 56, "fitness": 0.26058301727314676, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.25842498042452466, 0.26272675154484815, 0.2605973198500675]}, "mutation_prompt": null}
{"id": "2a1f8e48-cecc-4960-87f1-bb975b31fa6f", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSOLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.1\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations)**2)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / abs(v) ** (1 / beta)\n        return position + 0.01 * step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.levy_flight(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumPSOLevyFlight", "description": "Adaptive Quantum-enhanced PSO with Nonlinear Inertia and Lévy Flight for Enhanced Global Search and Convergence Speed.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "ce5bec8c-d92c-4ee9-ab9f-dca0b75a76df", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.f = 0.8  # Scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n    \n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n    \n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        \n        self.velocity = self.w * self.velocity + cognitive + social\n        self.position += self.velocity\n\n    def differential_evolution_crossover(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        for i in range(self.population_size):\n            idxs = np.random.choice(self.population_size, 3, replace=False)\n            a, b, c = self.position[idxs[0]], self.position[idxs[1]], self.position[idxs[2]]\n            mutant = np.clip(a + self.f * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.cr\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            self.position[i] = np.where(cross_points, mutant, self.position[i])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position()\n            self.differential_evolution_crossover(func.bounds)\n\n        return self.gbest, self.gbest_score", "name": "HybridPSODE", "description": "Hybrid Particle Swarm Optimization with Differential Evolution and Adaptive Crossover to enhance solution diversity and convergence efficiency.", "configspace": "", "generation": 58, "fitness": 0.2461715537881641, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.01.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.23866327120712116, 0.254168942487079, 0.24568244767029213]}, "mutation_prompt": null}
{"id": "ad9fc5ee-4024-4d5e-b3e0-fbd146d28623", "solution": "import numpy as np\n\nclass EnhancedQuantumPSOAdaptiveNeighborhood:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.neighborhood_size = 5  # Adaptive neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def adaptive_gaussian_mutation(self, position, iteration, max_iterations):\n        adaptive_rate = self.mutation_rate * (1 - (iteration / max_iterations))\n        mutation = np.random.randn(*position.shape) * adaptive_rate\n        return position + mutation\n\n    def select_gbest_within_neighborhood(self):\n        for i in range(self.population_size):\n            neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n            local_best_score = float('inf')\n            local_best_position = self.position[i]\n            for index in neighbors_indices:\n                if self.pbest_scores[index] < local_best_score:\n                    local_best_score = self.pbest_scores[index]\n                    local_best_position = self.position[index]\n            if local_best_score < self.gbest_score:\n                self.gbest_score = local_best_score\n                self.gbest = local_best_position\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.adaptive_gaussian_mutation(self.position, iteration, max_iterations)\n        \n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            self.evaluate(func)\n            self.select_gbest_within_neighborhood()\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "EnhancedQuantumPSOAdaptiveNeighborhood", "description": "Enhanced Quantum-Enhanced PSO with Adaptive Neighborhood and Adaptive Gaussian Mutation for Superior Convergence.", "configspace": "", "generation": 59, "fitness": 0.2703579722877807, "feedback": "The algorithm EnhancedQuantumPSOAdaptiveNeighborhood got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.01.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.27746681463337186, 0.2566831152250404, 0.2769239870049298]}, "mutation_prompt": null}
{"id": "a2c9ffff-db5a-4002-9ebc-09d036ae359e", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSODiversityControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def calculate_diversity(self):\n        centroid = np.mean(self.position, axis=0)\n        distances = np.linalg.norm(self.position - centroid, axis=1)\n        return np.mean(distances)\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n        diversity = self.calculate_diversity()\n        if diversity < self.diversity_threshold:\n            self.position = self.gaussian_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumEnhancedPSODiversityControl", "description": "Adaptive Quantum-Enhanced PSO with Dynamic Inertia and Gaussian Mutation incorporating Diversity Control for Enhanced Exploration.", "configspace": "", "generation": 60, "fitness": 0.2773121638518703, "feedback": "The algorithm AdaptiveQuantumEnhancedPSODiversityControl got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.27728177163555623, 0.2775936988291392, 0.27706102109091546]}, "mutation_prompt": null}
{"id": "157e0da8-ae71-4ab1-a4b4-16b811bc5671", "solution": "import numpy as np\n\nclass AdaptiveNichingGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.niche_radius = None\n        self.population = None\n        self.fitness = None\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.niche_radius = np.linalg.norm(ub - lb) / 10\n\n    def evaluate(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n\n    def select_parents(self):\n        probabilities = 1 / (1 + self.fitness)\n        probabilities /= probabilities.sum()\n        indices = np.random.choice(self.population_size, size=self.population_size, p=probabilities)\n        return self.population[indices]\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            point = np.random.randint(1, self.dim)\n            child1 = np.concatenate((parent1[:point], parent2[point:]))\n            child2 = np.concatenate((parent2[:point], parent1[point:]))\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual):\n        if np.random.rand() < self.mutation_rate:\n            mutation = np.random.randn(self.dim) * self.niche_radius\n            individual += mutation\n        return individual\n\n    def reduce_niche_radius(self, iteration, max_iterations):\n        self.niche_radius *= 0.9 ** (iteration / max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n\n        while func_calls < self.budget:\n            self.evaluate(func)\n            func_calls += self.population_size\n\n            parents = self.select_parents()\n            next_generation = []\n\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = parents[i], parents[i + 1]\n                child1, child2 = self.crossover(parent1, parent2)\n                next_generation.append(self.mutate(child1))\n                next_generation.append(self.mutate(child2))\n\n            self.population = np.array(next_generation)\n            self.reduce_niche_radius(iteration, max_iterations)\n            iteration += 1\n\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index], self.fitness[best_index]", "name": "AdaptiveNichingGeneticAlgorithm", "description": "Adaptive Niching Genetic Algorithm (ANGA) with Dynamic Niche Radius to Enhance Diversity and Prevent Premature Convergence.", "configspace": "", "generation": 61, "fitness": 0.2683210070551973, "feedback": "The algorithm AdaptiveNichingGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2740392663461909, 0.2679221755116772, 0.2630015793077237]}, "mutation_prompt": null}
{"id": "bcf25d7a-93de-4bc3-8eb5-cb6da22130c8", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveMutationConstriction:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * iteration / max_iterations)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def adaptive_gaussian_mutation(self, position, iteration, max_iterations):\n        adaptive_rate = self.mutation_rate * (1 - iteration / max_iterations)\n        mutation = np.random.randn(*position.shape) * adaptive_rate\n        return position + mutation\n\n    def constriction_coefficient(self):\n        phi = self.c1 + self.c2\n        if phi <= 4:\n            return 1.0\n        return 2 / abs(2 - phi - np.sqrt(phi**2 - 4 * phi))\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        constriction = self.constriction_coefficient()\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = constriction * (inertia_weight * quantum_velocity + cognitive + social)\n        self.position += self.velocity\n        self.position = self.adaptive_gaussian_mutation(self.position, iteration, max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveMutationConstriction", "description": "Quantum-Enhanced PSO with Adaptive Mutation and Constriction for Enhanced Convergence Control and Global Search Efficiency.", "configspace": "", "generation": 62, "fitness": 0.2755057564320241, "feedback": "The algorithm QuantumEnhancedPSOAdaptiveMutationConstriction got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2747442085804158, 0.27594732120735266, 0.2758257395083037]}, "mutation_prompt": null}
{"id": "f77d0c3f-ccfe-43db-87d7-c66cb2917217", "solution": "import numpy as np\n\nclass SelfAdaptiveDEQuantumInspired:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.position = None\n        self.scores = None\n        self.best_solution = None\n        self.best_score = float('inf')\n        self.adaptive_rate = 0.1\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i, score in enumerate(scores):\n            if score < self.scores[i]:\n                self.scores[i] = score\n                if score < self.best_score:\n                    self.best_score = score\n                    self.best_solution = self.position[i]\n        return scores\n\n    def mutation(self, target_idx):\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = self.position[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.F * (b - c)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        offspring = np.where(crossover_mask, mutant, target)\n        return offspring\n\n    def quantum_adaptive(self, iteration, max_iterations):\n        adaptive_factor = self.adaptive_rate * ((max_iterations - iteration) / max_iterations)\n        self.F = 0.5 + adaptive_factor * (np.random.rand() - 0.5)\n        self.CR = 0.9 + adaptive_factor * (np.random.rand() - 0.5)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutation(i)\n                trial = self.crossover(self.position[i], mutant)\n                trial_score = func(trial)\n                func_calls += 1\n                if trial_score < self.scores[i]:\n                    self.position[i] = trial\n                    self.scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_solution = trial\n                if func_calls >= self.budget:\n                    break\n            self.quantum_adaptive(iteration, max_iterations)\n            iteration += 1\n\n        return self.best_solution, self.best_score", "name": "SelfAdaptiveDEQuantumInspired", "description": "Self-Adaptive Differential Evolution with Quantum-Inspired Adaptive Mechanism for Efficient Exploration and Exploitation in High-Dimensional Spaces.", "configspace": "", "generation": 63, "fitness": 0.26426830618139835, "feedback": "The algorithm SelfAdaptiveDEQuantumInspired got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2642651194542831, 0.2658871136647404, 0.2626526854251716]}, "mutation_prompt": null}
{"id": "a1d1af7c-1e36-404f-9393-c0fc82add0aa", "solution": "import numpy as np\n\nclass HybridQuantumEnhancedPSOLevyAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v)**(1 / beta)\n        return position + step\n\n    def adaptive_mutation(self, position, iteration, max_iterations):\n        decay = (max_iterations - iteration) / max_iterations\n        mutation_strength = self.mutation_rate * decay\n        mutation = np.random.randn(*position.shape) * mutation_strength\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n        if iteration % 5 == 0:\n            self.position = self.levy_flight(self.position)\n        else:\n            self.position = self.adaptive_mutation(self.position, iteration, max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "HybridQuantumEnhancedPSOLevyAdaptiveMutation", "description": "Hybrid Quantum-Enhanced PSO with Lévy Flight for Enhanced Global Search and Adaptive Mutation for Fine-Tuning.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "1a40740b-000f-44b2-b806-0864306b3fe2", "solution": "import numpy as np\n\nclass AdaptiveFractionalQuantumPSOLevyChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.alpha = 0.9\n        self.gamma = 0.5\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v) ** (1 / beta)\n        return position + step\n\n    def chaotic_map(self, value):\n        return (4.0 * value * (1 - value)) % 1\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n        if iteration % 2 == 0:\n            self.position = self.levy_flight(self.position)\n        else:\n            self.position = self.gaussian_mutation(self.position)\n\n        for i in range(self.population_size):\n            self.position[i] = np.clip(self.position[i], func.bounds.lb, func.bounds.ub)\n            self.velocity[i] = self.chaotic_map(self.velocity[i])\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveFractionalQuantumPSOLevyChaos", "description": "Adaptive Fractional Quantum PSO with Levy Flight and Chaotic Mapping for Enhanced Global Search and Convergence.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "0c2cf02e-093c-49d4-a8a4-e7ef66835794", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveVelocityLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.velocity_clamp_factor = 0.5\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        u = np.random.randn(*position.shape) * self.mutation_rate\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v) ** (1/3)\n        return position + step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n\n        velocity_max = self.velocity_clamp_factor * (np.array(func.bounds.ub) - np.array(func.bounds.lb))\n        self.velocity = np.clip(self.velocity, -velocity_max, velocity_max)\n\n        self.position += self.velocity\n        self.position = self.levy_flight(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveVelocityLevyFlight", "description": "Quantum-Enhanced PSO with Adaptive Velocity Clamping and Lévy Flight for Improved Convergence and Exploration Balance.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "bcca1f79-cc6a-4558-b2b9-c02242e8c505", "solution": "import numpy as np\n\nclass TimeAdaptedQuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def time_adaptive_mutation(self, position, iteration, max_iterations):\n        current_mutation_rate = self.initial_mutation_rate - (self.initial_mutation_rate - self.final_mutation_rate) * (iteration / max_iterations)\n        mutation = np.random.randn(*position.shape) * current_mutation_rate\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.time_adaptive_mutation(self.position, iteration, max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "TimeAdaptedQuantumEnhancedPSO", "description": "Time-Adapted Quantum-Enhanced PSO with Hybrid Mutation Strategy for Enhanced Convergence and Robust Exploration.", "configspace": "", "generation": 67, "fitness": 0.2776048328912905, "feedback": "The algorithm TimeAdaptedQuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2775450836098463, 0.2776570301469392, 0.27761238491708595]}, "mutation_prompt": null}
{"id": "8153d73f-7869-40f7-82da-5003d298e2ba", "solution": "import numpy as np\nfrom scipy.stats import levy\n\nclass EnhancedQuantumPSOAdaptiveClampingLevyMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive parameter\n        self.c2 = 2.0  # Increased social parameter\n        self.w_min = 0.2\n        self.w_max = 0.9  # Increased max inertia\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * iteration / max_iterations)\n\n    def adaptive_velocity_clamping(self, velocity, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        return np.clip(velocity, lb - self.position, ub - self.position)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight_mutation(self, position):\n        steps = levy.rvs(size=position.shape) * self.mutation_rate\n        return position + steps\n\n    def update_velocity_position(self, iteration, max_iterations, bounds):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.velocity = self.adaptive_velocity_clamping(self.velocity, bounds)\n        self.position += self.velocity\n        self.position = self.levy_flight_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations, func.bounds)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "EnhancedQuantumPSOAdaptiveClampingLevyMutation", "description": "Enhanced Quantum PSO with Adaptive Velocity Clamping and Levy Flight Mutation for Superior Search Efficiency.", "configspace": "", "generation": 68, "fitness": 0.2565845121666564, "feedback": "The algorithm EnhancedQuantumPSOAdaptiveClampingLevyMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.25897407591629507, 0.2609991595064707, 0.2497803010772035]}, "mutation_prompt": null}
{"id": "1fccef79-49f4-46ca-8e7a-a98030cb46ee", "solution": "import numpy as np\n\nclass AdaptiveLevyPSODynamicNeighborhood:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.alpha = 1.5  # Lévy distribution exponent\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * iteration / max_iterations)\n\n    def levy_flight(self, position):\n        step = np.random.standard_cauchy(position.shape) * 0.01\n        return position + step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        neighbors = np.random.randint(self.population_size, size=(self.population_size, 2))\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        \n        for i in range(self.population_size):\n            local_best = min(self.pbest_scores[neighbors[i]], default=self.gbest_score)\n            cognitive = self.c1 * r1[i] * (self.pbest[i] - self.position[i])\n            social = self.c2 * r2[i] * (self.gbest - self.position[i])\n            self.velocity[i] = inertia_weight * self.velocity[i] + cognitive + social\n\n        self.position += self.velocity\n        self.position = self.levy_flight(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveLevyPSODynamicNeighborhood", "description": "Adaptive Lévy Flight Enhanced Particle Swarm Optimization (ALFPSO) using Dynamic Neighborhood for improved global search capabilities.", "configspace": "", "generation": 69, "fitness": 0.2659946015848987, "feedback": "The algorithm AdaptiveLevyPSODynamicNeighborhood got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2645549171561322, 0.26609802740463473, 0.26733086019392904]}, "mutation_prompt": null}
{"id": "61bdde97-ac73-48e1-93da-6941ea572638", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSOLévyPolynomial:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.5  # Fixed inertia weight to simplify tuning\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def lévy_flight(self, position):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, position.shape)\n        v = np.random.normal(0, 1, position.shape)\n        step = u / np.abs(v)**(1 / beta)\n        return position + step\n\n    def polynomial_mutation(self, position):\n        eta_m = 20.0\n        delta = np.random.rand(*position.shape)\n        for i in range(position.shape[0]):\n            for j in range(position.shape[1]):\n                if delta[i, j] < 0.5:\n                    delta[i, j] = (2.0 * delta[i, j])**(1.0 / (eta_m + 1.0)) - 1.0\n                else:\n                    delta[i, j] = 1.0 - (2.0 * (1.0 - delta[i, j]))**(1.0 / (eta_m + 1.0))\n        return position + delta\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = self.w * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.lévy_flight(self.position)\n        self.position = self.polynomial_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position()\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumPSOLévyPolynomial", "description": "Adaptive Quantum Particle Swarm Optimization with Lévy Flight and Polynomial Mutation for Enhanced Diversity and Convergence.", "configspace": "", "generation": 70, "fitness": 0.2722753032465039, "feedback": "The algorithm AdaptiveQuantumPSOLévyPolynomial got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2669626690775786, 0.2742875821938513, 0.27557565846808185]}, "mutation_prompt": null}
{"id": "a03cd8d4-f521-4cfc-96d3-81d0df7a78f8", "solution": "import numpy as np\n\nclass QuantumInspiredBeeSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.employee_bees = self.population_size // 2\n        self.onlooker_bees = self.population_size // 2\n        self.scout_bees = 1\n        self.adaptive_radius = 0.1\n        self.food_sources = None\n        self.food_source_fitness = None\n        self.best_food_source = None\n        self.best_fitness = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.food_sources = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.food_source_fitness = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.food_sources])\n        for i, score in enumerate(scores):\n            if score < self.food_source_fitness[i]:\n                self.food_source_fitness[i] = score\n            if score < self.best_fitness:\n                self.best_fitness = score\n                self.best_food_source = self.food_sources[i]\n        return scores\n\n    def adaptive_exploration(self, position):\n        offset = self.adaptive_radius * (np.random.rand(self.dim) - 0.5)\n        return position + offset\n\n    def employee_phase(self, func):\n        for i in range(self.employee_bees):\n            k = np.random.randint(0, self.employee_bees)\n            while k == i:\n                k = np.random.randint(0, self.employee_bees)\n            candidate_solution = self.adaptive_exploration(self.food_sources[i])\n            candidate_score = func(candidate_solution)\n            if candidate_score < self.food_source_fitness[i]:\n                self.food_sources[i] = candidate_solution\n                self.food_source_fitness[i] = candidate_score\n\n    def onlooker_phase(self, func):\n        fitness_probabilities = self.food_source_fitness / np.sum(self.food_source_fitness)\n        for _ in range(self.onlooker_bees):\n            selected_index = np.random.choice(range(self.employee_bees), p=fitness_probabilities)\n            candidate_solution = self.adaptive_exploration(self.food_sources[selected_index])\n            candidate_score = func(candidate_solution)\n            if candidate_score < self.food_source_fitness[selected_index]:\n                self.food_sources[selected_index] = candidate_solution\n                self.food_source_fitness[selected_index] = candidate_score\n\n    def scout_phase(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        for i in range(self.scout_bees):\n            self.food_sources[-(i + 1)] = lb + (ub - lb) * np.random.rand(self.dim)\n            self.food_source_fitness[-(i + 1)] = float('inf')\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            self.evaluate(func)\n            self.employee_phase(func)\n            self.onlooker_phase(func)\n            self.scout_phase(func.bounds)\n            func_calls += self.population_size\n\n        return self.best_food_source, self.best_fitness", "name": "QuantumInspiredBeeSwarmOptimization", "description": "Quantum-Inspired Bee Swarm Optimization with Adaptive Neighborhood Exploration for Enhanced Global Search.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "e969ed76-4d65-4ccf-a5fa-3214f9aae118", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveElite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.elite_rate = 0.1\n        self.elite_size = max(1, int(self.population_size * self.elite_rate))\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def elite_strategy(self, scores):\n        elite_indices = np.argsort(scores)[:self.elite_size]\n        for i in elite_indices:\n            self.position[i] = self.gbest + np.random.randn(self.dim) * 0.1\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.gaussian_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            self.elite_strategy(scores)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveElite", "description": "Quantum-Enhanced PSO with Adaptive Dynamic Inertia, Gaussian Mutation, and Elite Strategy to Balance Global and Local Search.", "configspace": "", "generation": 72, "fitness": 0.271298157554475, "feedback": "The algorithm QuantumEnhancedPSOAdaptiveElite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.01.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.263966349868372, 0.27606107449054273, 0.27386704830451036]}, "mutation_prompt": null}
{"id": "cb251ec3-9374-4621-95a9-06165ffc2174", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSOEntropicMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_min = 0.1\n        self.w_max = 0.9\n        self.entropy_scale = 0.5\n        self.mutation_scale = 0.5\n        self.rotation_angle_range = (np.pi / 6, np.pi / 4)\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        entropy = -np.sum(self.pbest_scores * np.log(self.pbest_scores + 1e-9))\n        normalized_entropy = (entropy - np.min(self.pbest_scores)) / (np.max(self.pbest_scores) - np.min(self.pbest_scores) + 1e-9)\n        return self.w_max - ((self.w_max - self.w_min) * (1 - normalized_entropy) * self.entropy_scale)\n\n    def quantum_rotation_gate(self, velocity, iteration, max_iterations):\n        rotation_angle = self.rotation_angle_range[0] + (self.rotation_angle_range[1] - self.rotation_angle_range[0]) * (iteration / max_iterations)\n        theta = np.random.rand(*velocity.shape) * rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def diversity_based_mutation(self, position):\n        diversity = np.std(position, axis=0)\n        mutation = np.random.randn(*position.shape) * (self.mutation_scale * diversity)\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity, iteration, max_iterations)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.diversity_based_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumEnhancedPSOEntropicMutation", "description": "Adaptive Quantum-Enhanced PSO with Entropic Inertia and Diversity-Based Mutation to Enhance Convergence and Avoid Premature Stagnation.", "configspace": "", "generation": 73, "fitness": 0.25800814849142906, "feedback": "The algorithm AdaptiveQuantumEnhancedPSOEntropicMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.25672471907620853, 0.26179257071415263, 0.255507155683926]}, "mutation_prompt": null}
{"id": "72b7c495-1c30-453a-bfc6-d3935d16c31e", "solution": "import numpy as np\n\nclass HybridQuantumPSOAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1_initial = 2.5\n        self.c2_initial = 0.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate_initial = 0.1\n        self.mutation_rate_min = 0.01\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def adaptive_gaussian_mutation(self, position, iteration, max_iterations):\n        mutation_rate = self.mutation_rate_initial - ((self.mutation_rate_initial - self.mutation_rate_min) * (iteration / max_iterations))\n        mutation = np.random.randn(*position.shape) * mutation_rate\n        return position + mutation\n\n    def update_acceleration_coeffs(self, iteration, max_iterations):\n        c1 = self.c1_initial - (self.c1_initial - 1.5) * (iteration / max_iterations)\n        c2 = self.c2_initial + (2.0 - self.c2_initial) * (iteration / max_iterations)\n        return c1, c2\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        c1, c2 = self.update_acceleration_coeffs(iteration, max_iterations)\n        cognitive = c1 * r1 * (self.pbest - self.position)\n        social = c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.adaptive_gaussian_mutation(self.position, iteration, max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "HybridQuantumPSOAdaptiveMutation", "description": "Hybrid Quantum-Enhanced PSO with Adaptive Gaussian Mutation and Time-Varying Acceleration Coefficients for Enhanced Dynamic Adaptation.", "configspace": "", "generation": 74, "fitness": 0.2774937221434149, "feedback": "The algorithm HybridQuantumPSOAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2776896906494871, 0.27688717248642747, 0.27790430329433014]}, "mutation_prompt": null}
{"id": "cf8a2e59-6539-45ba-bbcd-4e908e0e3f68", "solution": "import numpy as np\n\nclass AdaptiveQuantumGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_base_rate = 0.05\n        self.rotation_angle_base = np.pi / 6\n        self.crossover_rate = 0.7\n        self.adaptation_factor = 0.1\n        self.position = None\n        self.fitness = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.fitness[i]:\n                self.fitness[i] = scores[i]\n            if scores[i] < self.best_fitness:\n                self.best_fitness = scores[i]\n                self.best_solution = self.position[i]\n        return scores\n\n    def adaptive_mutation(self, position, current_iteration, max_iterations):\n        mutation_rate = self.mutation_base_rate * (1 + self.adaptation_factor * current_iteration / max_iterations)\n        mutation = np.random.randn(*position.shape) * mutation_rate\n        return position + mutation\n\n    def quantum_rotation(self, position):\n        theta = self.rotation_angle_base * np.random.rand(*position.shape)\n        rotated_position = position * np.cos(theta) + np.random.rand(*position.shape) * np.sin(theta)\n        return rotated_position\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            mask = np.random.rand(self.dim) < 0.5\n            offspring = np.where(mask, parent1, parent2)\n        else:\n            offspring = parent1\n        return offspring\n\n    def evolve(self, max_iterations):\n        for iteration in range(max_iterations):\n            new_population = []\n            for i in range(self.population_size):\n                parent1_idx = np.random.randint(0, self.population_size)\n                parent2_idx = np.random.randint(0, self.population_size)\n                parent1 = self.position[parent1_idx]\n                parent2 = self.position[parent2_idx]\n\n                child = self.crossover(parent1, parent2)\n                child = self.adaptive_mutation(child, iteration, max_iterations)\n                child = self.quantum_rotation(child)\n\n                new_population.append(child)\n\n            self.position = np.array(new_population)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.evolve(max_iterations)\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumGeneticAlgorithm", "description": "Adaptive Quantum Genetic Algorithm (AQGA) blending quantum-inspired rotations and adaptive mutation rates for efficient global exploration and convergence.", "configspace": "", "generation": 75, "fitness": 0.2363375317587462, "feedback": "The algorithm AdaptiveQuantumGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.232603981708018, 0.23834480608611286, 0.23806380748210776]}, "mutation_prompt": null}
{"id": "8ca2cd0d-aa90-4895-a999-ff59a4c186f6", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSOLevyAsynchronous:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.func_calls = 0\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        self.func_calls += self.population_size\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        rotation_angle = np.pi / 4\n        theta = np.random.rand(*velocity.shape) * rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / abs(v) ** (1 / beta)\n        return position + 0.01 * step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        for i in range(self.population_size):\n            if self.func_calls >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n            cognitive = self.c1 * r1 * (self.pbest[i] - self.position[i])\n            social = self.c2 * r2 * (self.gbest - self.position[i])\n\n            quantum_velocity = self.quantum_rotation_gate(self.velocity[i])\n            self.velocity[i] = inertia_weight * quantum_velocity + cognitive + social\n            self.position[i] += self.velocity[i]\n            self.position[i] = self.levy_flight(self.position[i])\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while self.func_calls < self.budget:\n            self.evaluate(func)\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumPSOLevyAsynchronous", "description": "Adaptive Quantum-Enhanced PSO with Lévy Flight and Asynchronous Updates for Enhanced Global Search and Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "a4029e25-495c-45b9-8858-23e5255fcd8e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.position = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        chaotic_sequence = np.random.rand(self.population_size, self.dim)\n        self.position = lb + (ub - lb) * chaotic_sequence\n        self.pbest = np.copy(self.position)\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=position.shape)\n        v = np.random.normal(0, 1, size=position.shape)\n        step = u / np.abs(v) ** (1 / beta)\n        return position + 0.01 * step\n\n    def mutate(self, idx):\n        idxs = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(idxs, 3, replace=False)\n        return self.pbest[a] + self.F * (self.pbest[b] - self.pbest[c])\n\n    def crossover(self, idx, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, self.position[idx])\n        return trial\n\n    def select(self, idx, trial, score):\n        if score < self.gbest_score:\n            self.gbest_score = score\n            self.gbest = trial\n        return trial if score < self.evaluate(self.position[idx]) else self.position[idx]\n\n    def evaluate(self, position):\n        return self.func(position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.func = func\n        self.initialize(func.bounds)\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(i, mutant)\n                trial = self.levy_flight(trial)\n                score = self.evaluate(trial)\n                self.position[i] = self.select(i, trial, score)\n                func_calls += 1\n                if func_calls >= self.budget:\n                    break\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveDifferentialEvolutionLevyFlight", "description": "Adaptive Differential Evolution with Lévy Flight Mutation and Chaotic Sequence Initialization for Enhanced Global Search.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "583b1be1-76ce-4b35-9d6a-8f7e98069994", "solution": "import numpy as np\n\nclass HybridQuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.alpha = 0.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max * ((max_iterations - iteration) / max_iterations) + self.w_min * (iteration / max_iterations)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight_mutation(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v) ** (1 / beta)\n        return position + self.alpha * step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.levy_flight_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "HybridQuantumEnhancedPSO", "description": "Hybridized Quantum-Enhanced PSO with Adaptive Learning and Lévy-Flight Mutation for Enhanced Convergence in High-Dimensional Spaces.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "64d73a6a-c45f-48cb-874c-c10ab3149f26", "solution": "import numpy as np\n\nclass AdaptiveLevyFlightPSODynamicNeighborhood:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.alpha = 0.1\n        self.beta = 1.5  # Lévy flight parameter\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def levy_flight(self, position):\n        step = np.random.normal(size=position.shape) * (1 / (np.abs(np.random.normal(scale=1, size=position.shape)) ** (1 / self.beta)))\n        return position + self.alpha * step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n\n        # Dynamic neighborhood selection\n        neighborhood_size = min(5, self.population_size // 5)\n        neighbors = np.random.choice(self.population_size, size=(self.population_size, neighborhood_size), replace=False)\n        neighborhood_best = np.array([self.pbest[neigh].min(axis=0) for neigh in neighbors])\n\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (neighborhood_best - self.position)\n\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n\n        # Apply Lévy flight for enhanced exploration\n        self.position = self.levy_flight(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveLevyFlightPSODynamicNeighborhood", "description": "Adaptive Lévy Flight Enhanced PSO with Dynamic Neighborhoods for Enhanced Explorative Capability and Capture of Global Optima.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "66ee2494-5639-47e4-884c-c71e881cc89a", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDEScalingRotation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.F = 0.5\n        self.CR = 0.9\n        self.rotation_angle = np.pi / 6\n        self.position = None\n        self.best = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best = self.position[i]\n        return scores\n\n    def quantum_mutation(self, target, a, b, c):\n        diff = (b - c) * np.cos(self.rotation_angle) + np.random.rand(self.dim) * np.sin(self.rotation_angle)\n        return target + self.F * diff\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def update_scaling_factor(self, iteration, max_iterations):\n        return self.F * (1 - iteration / max_iterations)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            new_population = np.copy(self.position)\n            scores = self.evaluate(func)\n            for i in range(self.population_size):\n                a, b, c = self.position[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = self.quantum_mutation(self.position[i], a, b, c)\n                child = self.crossover(self.position[i], mutant)\n                new_population[i] = child if func(child) < func(self.position[i]) else self.position[i]\n                func_calls += 1\n                if func_calls >= self.budget:\n                    break\n            self.position = new_population\n            iteration += 1\n            self.F = self.update_scaling_factor(iteration, max_iterations)\n\n        return self.best, self.best_score", "name": "AdaptiveQuantumInspiredDEScalingRotation", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Scaling and Rotation for Enhanced Exploration.", "configspace": "", "generation": 80, "fitness": 0.2662070275831025, "feedback": "The algorithm AdaptiveQuantumInspiredDEScalingRotation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.26218178169194617, 0.26563179169450846, 0.2708075093628529]}, "mutation_prompt": null}
{"id": "4b13a285-107c-42e7-a03d-1698e1afb4a3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionLevyDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 20\n        self.population_size = self.base_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.alpha = 1.5  # Lévy flight exponent\n        self.position = None\n        self.scores = None\n        self.best_position = None\n        self.best_score = float('inf')\n    \n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n    \n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.scores[i]:\n                self.scores[i] = scores[i]\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best_position = self.position[i]\n        return scores\n    \n    def levy_flight(self):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v) ** (1 / self.alpha)\n        return step\n    \n    def mutate_and_crossover(self, idx):\n        a, b, c = np.random.choice(self.population_size, 3, replace=False)\n        mutant = self.position[a] + self.F * (self.position[b] - self.position[c])\n        trial = np.copy(self.position[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def adjust_population(self, iteration, max_iterations):\n        self.population_size = self.base_population_size + int((self.budget // self.base_population_size) * (iteration / max_iterations))\n        self.position = np.resize(self.position, (self.population_size, self.dim))\n        self.scores = np.resize(self.scores, self.population_size)\n    \n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.base_population_size\n        iteration = 0\n        \n        while func_calls < self.budget:\n            new_position = np.copy(self.position)\n            for i in range(self.population_size):\n                trial = self.mutate_and_crossover(i)\n                trial += self.levy_flight()\n                trial_score = func(trial)\n                func_calls += 1\n                if trial_score < self.scores[i]:\n                    new_position[i] = trial\n                    self.scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_position = trial\n            self.position = new_position\n            self.adjust_population(iteration, max_iterations)\n            iteration += 1\n        \n        return self.best_position, self.best_score", "name": "AdaptiveDifferentialEvolutionLevyDynamicPopulation", "description": "Adaptive Differential Evolution with Lévy Flights and Dynamic Population Sizing for Efficient Global Search.", "configspace": "", "generation": 81, "fitness": 0.2716766070216623, "feedback": "The algorithm AdaptiveDifferentialEvolutionLevyDynamicPopulation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2760124882288727, 0.26916154623332533, 0.26985578660278886]}, "mutation_prompt": null}
{"id": "ec0489c9-42b2-4dae-83c7-2d1e045247fc", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSOAnisotropicMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_min = 0.1\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 6\n        self.base_mutation_rate = 0.05\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        phase = iteration / max_iterations\n        return self.w_max - (self.w_max - self.w_min) * (phase ** 2)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def anisotropic_gaussian_mutation(self, position, scores):\n        normalized_scores = (scores - np.min(scores)) / (np.ptp(scores) + 1e-6)\n        mutation_strength = self.base_mutation_rate * (1 - normalized_scores[:, np.newaxis])\n        mutation = np.random.randn(*position.shape) * mutation_strength\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.position = self.anisotropic_gaussian_mutation(self.position, scores)\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumEnhancedPSOAnisotropicMutation", "description": "Adaptive Quantum-Enhanced PSO with Anisotropic Gaussian Mutation and Nonlinear Inertia for Enhanced Convergence and Diversity in Complex Search Spaces.", "configspace": "", "generation": 82, "fitness": 0.26251595633774377, "feedback": "The algorithm AdaptiveQuantumEnhancedPSOAnisotropicMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.26338231025452996, 0.2627664855402305, 0.2613990732184708]}, "mutation_prompt": null}
{"id": "ca8c28d9-26c9-454c-a3a1-fc534b36e61c", "solution": "import numpy as np\n\nclass HybridQuantumEnhancedPSOAdaptiveLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v)**(1/beta)\n        return position + step * self.mutation_rate\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        \n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.levy_flight(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "HybridQuantumEnhancedPSOAdaptiveLevyFlight", "description": "Hybrid Quantum-Enhanced PSO with Adaptive Neighborhood and Lévy Flight for Enhanced Global Exploration and Local Refinement.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "17818b3a-9cdb-43da-8040-70132d830485", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSOLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.initial_mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight_mutation(self, position, beta=1.5):\n        u = np.random.randn(*position.shape) * (0.01 ** (1 / beta))\n        v = np.random.randn(*position.shape)\n        step = u / (np.abs(v) ** (1 / beta))\n        return position + step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.levy_flight_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumEnhancedPSOLevyFlight", "description": "Adaptive Quantum-Enhanced PSO with Lévy Flight Mutation for Enhanced Exploration and Balanced Convergence.", "configspace": "", "generation": 84, "fitness": 0.2760925497037488, "feedback": "The algorithm AdaptiveQuantumEnhancedPSOLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2743982355632729, 0.2766932666552059, 0.27718614689276755]}, "mutation_prompt": null}
{"id": "64368b0c-3b54-4bd3-b1de-e9d5cd66e953", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveRatesHybridMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.hybrid_mutation_rate = 0.05\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def adaptive_learning_rates(self, iteration, max_iterations):\n        factor = (iteration / max_iterations)\n        return self.c1 * (1 + factor), self.c2 * (1 - factor)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def gaussian_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation\n\n    def hybrid_mutation(self, position):\n        mutation = np.random.uniform(-1, 1, position.shape) * self.hybrid_mutation_rate\n        return position + mutation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        c1_adapt, c2_adapt = self.adaptive_learning_rates(iteration, max_iterations)\n        cognitive = c1_adapt * r1 * (self.pbest - self.position)\n        social = c2_adapt * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.gaussian_mutation(self.position)\n        self.position = self.hybrid_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveRatesHybridMutation", "description": "Quantum-Enhanced PSO with Adaptive Learning Rates and Hybrid Mutation for Enhanced Convergence and Diversity Maintenance.", "configspace": "", "generation": 85, "fitness": 0.2758306576123123, "feedback": "The algorithm QuantumEnhancedPSOAdaptiveRatesHybridMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2772959899601204, 0.2728369737446795, 0.27735900913213696]}, "mutation_prompt": null}
{"id": "e2ed162a-5092-4561-aa7d-ba4a9e974039", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveInertiaLevyMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight_mutation(self, position):\n        # Levy flight step size\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v) ** (1 / beta)\n        return position + step * self.mutation_rate\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.levy_flight_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveInertiaLevyMutation", "description": "Quantum-Enhanced PSO with Adaptive Dynamic Inertia and Levy Flight-based Mutation for Enhanced Exploration and Faster Convergence.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "ab510e62-89fb-4493-8ab6-086d14ad448f", "solution": "import numpy as np\n\nclass AdaptiveDEQuantumAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.F_min = 0.5\n        self.F_max = 1.0\n        self.CR = 0.9\n        self.mutation_rate = 0.1\n        self.potential_solutions = None\n        self.best_solution = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.potential_solutions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def evaluate(self, func):\n        scores = np.array([func(sol) for sol in self.potential_solutions])\n        for i in range(self.population_size):\n            if scores[i] < self.best_score:\n                self.best_score = scores[i]\n                self.best_solution = self.potential_solutions[i]\n        return scores\n\n    def adaptive_mutation(self, iteration, max_iterations):\n        scale_factor = self.F_min + (self.F_max - self.F_min) * (1 - (iteration / max_iterations))\n        return scale_factor * (np.random.randn(self.dim) * self.mutation_rate)\n\n    def evolve(self, func, iteration, max_iterations):\n        new_solutions = np.copy(self.potential_solutions)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(idxs, 3, replace=False)\n            mutant_vector = self.potential_solutions[a] + self.adaptive_mutation(iteration, max_iterations) * (self.potential_solutions[b] - self.potential_solutions[c])\n            cross_points = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(cross_points, mutant_vector, self.potential_solutions[i])\n            trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n            trial_score = func(trial_vector)\n            if trial_score < func(self.potential_solutions[i]):\n                new_solutions[i] = trial_vector\n        self.potential_solutions = new_solutions\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            self.evaluate(func)\n            func_calls += self.population_size\n            self.evolve(func, iteration, max_iterations)\n            iteration += 1\n\n        return self.best_solution, self.best_score", "name": "AdaptiveDEQuantumAdaptiveMutation", "description": "Adaptive Differential Evolution with Quantum-Inspired Adaptive Mutation and Dynamic Scaling for Enhanced Convergence.", "configspace": "", "generation": 87, "fitness": 0.26994628992121766, "feedback": "The algorithm AdaptiveDEQuantumAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.264954016412531, 0.2730594014292633, 0.2718254519218586]}, "mutation_prompt": null}
{"id": "262a1b5e-444f-4da6-8f5c-a32c5774b17d", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSONonlinearDiversity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 6\n        self.diversity_threshold = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_cognitive_social_parameters(self, iteration, max_iterations):\n        ratio = iteration / max_iterations\n        self.c1 = self.c1_initial * (1 - ratio) + self.c1_final * ratio\n        self.c2 = self.c2_initial * (1 - ratio) + self.c2_final * ratio\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations) ** 2)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def preserve_diversity(self):\n        distances = np.linalg.norm(self.position - self.gbest, axis=1)\n        diversity_factor = np.mean(distances)\n        if diversity_factor < self.diversity_threshold:\n            perturbation = np.random.randn(self.population_size, self.dim) * 0.05\n            self.position += perturbation\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        self.update_cognitive_social_parameters(iteration, max_iterations)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.preserve_diversity()\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumPSONonlinearDiversity", "description": "Adaptive Quantum PSO with Nonlinear Dynamics and Diversity Preservation to Enhance Global and Local Search Capabilities.", "configspace": "", "generation": 88, "fitness": 0.26564485667088317, "feedback": "The algorithm AdaptiveQuantumPSONonlinearDiversity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2707502860588886, 0.26168259520874704, 0.2645016887450138]}, "mutation_prompt": null}
{"id": "75fc443b-2fc5-4ce7-aad3-2b4b9b1aec3a", "solution": "import numpy as np\n\nclass AdaptiveQE_PSODynamicInertiaLevyMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.alpha = 0.9 # Nonlinear inertia control parameter\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_min + (self.w_max - self.w_min) * ((max_iterations - iteration) / max_iterations) ** self.alpha\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * np.pi / 4\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight_mutation(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v) ** (1 / beta)\n        return position + 0.01 * step\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.levy_flight_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQE_PSODynamicInertiaLevyMutation", "description": "Adaptive Quantum-Enhanced PSO with Nonlinear Dynamic Inertia and Lévy Flight Mutation for Robust Exploration.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "6802d56e-190d-46d0-b942-c5d90110068f", "solution": "import numpy as np\n\nclass EnhancedQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * np.log(iteration + 1) / np.log(max_iterations + 1))\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def adaptive_gaussian_mutation(self, position, iteration, max_iterations):\n        mutation_strength = self.mutation_rate * (1 - (iteration / max_iterations))\n        mutation = np.random.randn(*position.shape) * mutation_strength\n        return position + mutation\n\n    def local_search(self, position, func):\n        perturbation = np.random.randn(*position.shape) * 0.01\n        new_position = position + perturbation\n        new_score = func(new_position)\n        return new_position if new_score < func(position) else position\n\n    def update_velocity_position(self, iteration, max_iterations, func):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.adaptive_gaussian_mutation(self.position, iteration, max_iterations)\n        self.position = np.array([self.local_search(p, func) for p in self.position])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations, func)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "EnhancedQuantumPSO", "description": "Enhanced Quantum PSO with Adaptive Gaussian Mutation and Local Search for Optimized Performance.", "configspace": "", "generation": 90, "fitness": 0.27589466505735133, "feedback": "The algorithm EnhancedQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2753886041980873, 0.2758721362797568, 0.2764232546942099]}, "mutation_prompt": null}
{"id": "af62da19-d326-4f04-9cc6-7c61e2b49e2c", "solution": "import numpy as np\n\nclass GradientHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.learning_rate = 0.01\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * (iteration / max_iterations))\n\n    def gradient_local_search(self, func, position):\n        grad = np.zeros_like(position)\n        epsilon = 1e-5\n        for i in range(self.dim):\n            perturbed_position = np.copy(position)\n            perturbed_position[i] += epsilon\n            grad[i] = (func(perturbed_position) - func(position)) / epsilon\n        return position - self.learning_rate * grad\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n        \n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.position += self.velocity\n        \n        for i in range(self.population_size):\n            if np.random.rand() < 0.2:  # Apply local search with certain probability\n                self.position[i] = self.gradient_local_search(lambda x: func(x), self.position[i])\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "GradientHybridPSO", "description": "Gradient Hybrid Particle Swarm Optimization (GHPSO) combines traditional PSO with gradient-based local search for enhanced convergence in photonic structure optimization.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "6829bd22-93bd-4f4e-a679-3c094218b93a", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSOLévyEnhancedMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / abs(v) ** (1 / beta)\n        return position + 0.01 * step\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_inertia_weight(self, iteration, max_iterations):\n        return self.w_max - ((self.w_max - self.w_min) * iteration / max_iterations)\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def enhanced_mutation(self, position):\n        mutation = np.random.randn(*position.shape) * self.mutation_rate\n        return position + mutation + self.levy_flight(position)\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_inertia_weight(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.enhanced_mutation(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveQuantumPSOLévyEnhancedMutation", "description": "Adaptive Quantum PSO with Lévy Flight and Enhanced Mutation for Robust Global Search.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {}, "mutation_prompt": null}
{"id": "4ad7a586-1de6-40d8-8c39-72db0b23db29", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOAdaptiveLevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_min = 0.2\n        self.w_max = 0.9\n        self.rotation_angle = np.pi / 4\n        self.mutation_rate = 0.1\n        self.alpha = 0.9\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_parameters(self, iteration, max_iterations):\n        inertia_weight = self.w_max - ((self.w_max - self.w_min) * iteration / max_iterations)\n        self.c1 = 2.0 * (1 - iteration / max_iterations) + 1.5\n        self.c2 = 2.0 * iteration / max_iterations\n        return inertia_weight\n\n    def quantum_rotation_gate(self, velocity):\n        theta = np.random.rand(*velocity.shape) * self.rotation_angle\n        q_velocity = velocity * np.cos(theta) + np.random.rand(*velocity.shape) * np.sin(theta)\n        return q_velocity\n\n    def levy_flight(self, position):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(*position.shape) * sigma\n        v = np.random.randn(*position.shape)\n        step = u / np.abs(v)**(1 / beta)\n        return position + step * self.mutation_rate\n\n    def update_velocity_position(self, iteration, max_iterations):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.update_parameters(iteration, max_iterations)\n        cognitive = self.c1 * r1 * (self.pbest - self.position)\n        social = self.c2 * r2 * (self.gbest - self.position)\n\n        quantum_velocity = self.quantum_rotation_gate(self.velocity)\n        self.velocity = inertia_weight * quantum_velocity + cognitive + social\n        self.position += self.velocity\n        self.position = self.levy_flight(self.position)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity_position(iteration, max_iterations)\n            iteration += 1\n\n        return self.gbest, self.gbest_score", "name": "QuantumEnhancedPSOAdaptiveLevy", "description": "Quantum-Enhanced PSO with Adaptive Parameter Control and Levy Flight for Enhanced Global Search and Convergence.", "configspace": "", "generation": 93, "fitness": 0.2758196103485134, "feedback": "The algorithm QuantumEnhancedPSOAdaptiveLevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.27565345170511657, 0.2757589015490778, 0.2760464777913457]}, "mutation_prompt": null}
{"id": "972184a0-75ce-4666-8ae3-49a9d58bc817", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.min_population_size = 10\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.position = None\n        self.best_solution = None\n        self.best_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i, score in enumerate(scores):\n            if score < self.best_score:\n                self.best_score = score\n                self.best_solution = self.position[i]\n        return scores\n\n    def mutate(self, idx, scores):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        return self.position[a] + self.F * (self.position[b] - self.position[c])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == np.random.randint(self.dim):\n                trial[j] = mutant[j]\n        return trial\n\n    def adaptive_resize(self, iteration, max_iterations):\n        if iteration % (max_iterations // 4) == 0 and iteration > 0:\n            self.population_size = max(self.min_population_size, self.population_size // 2)\n            self.position = self.position[:self.population_size]\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            \n            new_population = np.copy(self.position)\n            for i in range(self.population_size):\n                mutant = self.mutate(i, scores)\n                trial = self.crossover(self.position[i], mutant)\n                trial_score = func(trial)\n                func_calls += 1\n\n                if trial_score < scores[i]:\n                    new_population[i] = trial\n\n            self.position = new_population\n            self.adaptive_resize(iteration, max_iterations)\n            iteration += 1\n\n        return self.best_solution, self.best_score", "name": "AdaptiveDifferentialEvolution", "description": "Differential Evolution with Adaptive Population Size and Diversity Preservation for Efficient Global Search.", "configspace": "", "generation": 94, "fitness": 0.2598121132412696, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2584169395115762, 0.25711125822468184, 0.26390814198755086]}, "mutation_prompt": null}
{"id": "094c8bee-cc93-4112-927f-c121e60cd4f0", "solution": "import numpy as np\n\nclass AdaptiveLevyFlightDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.position = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(self.population_size, self.dim) * sigma\n        v = np.random.randn(self.population_size, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def quantum_inspired_position_update(self, current_position, best_position):\n        phi = np.random.rand(*current_position.shape)\n        return current_position + phi * (best_position - current_position)\n\n    def update_population(self):\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.position[a] + self.mutation_factor * (self.position[b] - self.position[c])\n            cross_points = np.random.rand(self.dim) < self.crossover_rate\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, self.position[i])\n            new_population[i] = self.quantum_inspired_position_update(trial, self.gbest)\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.position = self.update_population()\n            self.position += self.levy_flight()\n\n        return self.gbest, self.gbest_score", "name": "AdaptiveLevyFlightDifferentialEvolution", "description": "Adaptive Levy Flight Differential Evolution with Quantum-Inspired Position Update for Enhanced Global Exploration and Exploitation.", "configspace": "", "generation": 95, "fitness": 0.27763666410913185, "feedback": "The algorithm AdaptiveLevyFlightDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "516b4b10-b074-4ca5-adb7-b2d7dfbfb804", "metadata": {"aucs": [0.2775640493608382, 0.2776424868589433, 0.27770345610761404]}, "mutation_prompt": null}
{"id": "9a50449b-3bc7-4746-b024-3cf14024bdf1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveLevyFlightDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.position = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.shrink_factor = 0.95  # Factor to reduce population size\n        self.local_search_rate = 0.3  # Proportion of iterations dedicated to local search\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(self.population_size, self.dim) * sigma\n        v = np.random.randn(self.population_size, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def quantum_inspired_position_update(self, current_position, best_position):\n        phi = np.random.rand(*current_position.shape)\n        return current_position + phi * (best_position - current_position)\n\n    def dynamic_population_update(self):\n        new_size = max(5, int(self.population_size * self.shrink_factor))\n        if new_size < self.population_size:\n            sorted_indices = np.argsort(self.pbest_scores)\n            self.position = self.position[sorted_indices[:new_size]]\n            self.pbest = self.pbest[sorted_indices[:new_size]]\n            self.pbest_scores = self.pbest_scores[sorted_indices[:new_size]]\n            self.population_size = new_size\n\n    def local_search_acceleration(self):\n        for i in range(self.population_size):\n            local_best = self.position[i] + np.random.uniform(-0.1, 0.1, self.dim)\n            local_score = func(local_best)\n            if local_score < self.pbest_scores[i]:\n                self.pbest_scores[i] = local_score\n                self.pbest[i] = local_best\n                if local_score < self.gbest_score:\n                    self.gbest_score = local_score\n                    self.gbest = local_best\n\n    def update_population(self):\n        new_population = np.copy(self.position)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.position[a] + self.mutation_factor * (self.position[b] - self.position[c])\n            cross_points = np.random.rand(self.dim) < self.crossover_rate\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, self.position[i])\n            new_population[i] = self.quantum_inspired_position_update(trial, self.gbest)\n        return new_population\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.position = self.update_population()\n            self.position += self.levy_flight()\n            if func_calls / self.budget > self.local_search_rate:\n                self.local_search_acceleration()\n            self.dynamic_population_update()\n\n        return self.gbest, self.gbest_score", "name": "EnhancedAdaptiveLevyFlightDifferentialEvolution", "description": "Enhanced Adaptive Levy Flight Differential Evolution with Dynamic Population Size and Local Search Acceleration for Improved Convergence.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "094c8bee-cc93-4112-927f-c121e60cd4f0", "metadata": {}, "mutation_prompt": null}
{"id": "55ca34ce-3e7c-435b-86b4-d0a05a141b2b", "solution": "import numpy as np\n\nclass CoevolutionaryGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.niche_radius = 0.1 * (budget / (dim * self.population_size)) ** 0.5\n        self.mutation_prob = 0.05\n        self.crossover_rate = 0.8\n        self.position = None\n        self.scores = None\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.scores[i]:\n                self.scores[i] = scores[i]\n        return scores\n\n    def select_parents(self):\n        total_score = np.sum(1 / (1 + self.scores))\n        probabilities = (1 / (1 + self.scores)) / total_score\n        indices = np.random.choice(range(self.population_size), size=self.population_size, p=probabilities)\n        return self.position[indices]\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            point = np.random.randint(1, self.dim)\n            return np.concatenate((parent1[:point], parent2[point:]))\n        else:\n            return parent1 if np.random.rand() > 0.5 else parent2\n\n    def mutate(self, individual):\n        for j in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                individual[j] += np.random.normal(0, 0.1)\n        return individual\n\n    def dynamic_niche_partitioning(self, niche_radius):\n        niches = []\n        for i in range(self.population_size):\n            new_niche = True\n            for niche in niches:\n                if np.linalg.norm(self.position[i] - niche) < niche_radius:\n                    new_niche = False\n                    break\n            if new_niche:\n                niches.append(self.position[i])\n        return niches\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            parents = self.select_parents()\n            new_population = []\n            for i in range(0, self.population_size, 2):\n                offspring1 = self.crossover(parents[i], parents[i + 1])\n                offspring2 = self.crossover(parents[i + 1], parents[i])\n                new_population.extend([self.mutate(offspring1), self.mutate(offspring2)])\n            self.position = np.array(new_population)\n            niches = self.dynamic_niche_partitioning(self.niche_radius)\n            if len(niches) < self.population_size:\n                self.position[:len(niches)] = niches\n\n        best_index = np.argmin(self.scores)\n        return self.position[best_index], self.scores[best_index]", "name": "CoevolutionaryGeneticAlgorithm", "description": "Coevolutionary Genetic Algorithm with Dynamic Niche Partitioning for Enhanced Diversity and Convergence in High-Dimensional Spaces.", "configspace": "", "generation": 97, "fitness": 0.2487001738574535, "feedback": "The algorithm CoevolutionaryGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "094c8bee-cc93-4112-927f-c121e60cd4f0", "metadata": {"aucs": [0.24977332777398165, 0.2455820364461242, 0.25074515735225467]}, "mutation_prompt": null}
{"id": "efddf330-28b5-4c0d-9524-baae5e69eb66", "solution": "import numpy as np\n\nclass HierarchicalSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.alpha = 0.5  # weight for global and local influence\n        self.beta = 0.8   # inertia weight\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.scale_factors = np.logspace(-2, 0, num=3)  # multi-scale exploration factors\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def update_velocity_and_position(self, scale_factor):\n        r1, r2 = np.random.rand(2)\n        for i in range(self.population_size):\n            local_influence = r1 * (self.pbest[i] - self.position[i])\n            global_influence = r2 * (self.gbest - self.position[i])\n            self.velocity[i] = (self.beta * self.velocity[i] +\n                                self.alpha * (local_influence + global_influence) * scale_factor)\n            self.position[i] += self.velocity[i]\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            for scale_factor in self.scale_factors:\n                self.update_velocity_and_position(scale_factor)\n                self.position = np.clip(self.position, func.bounds.lb, func.bounds.ub)\n\n        return self.gbest, self.gbest_score", "name": "HierarchicalSwarmOptimization", "description": "Hierarchical Swarm Optimization (HSO) with Multi-Scale Exploration for Efficient Global and Local Search.", "configspace": "", "generation": 98, "fitness": 0.27283286027589915, "feedback": "The algorithm HierarchicalSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "094c8bee-cc93-4112-927f-c121e60cd4f0", "metadata": {"aucs": [0.27665949919499877, 0.26884597412152567, 0.272993107511173]}, "mutation_prompt": null}
{"id": "aac4c892-8878-464d-9ceb-79ecd8701f1e", "solution": "import numpy as np\n\nclass QuantumCooperativeParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_rate = 0.1\n        self.position = None\n        self.velocity = None\n        self.pbest = None\n        self.pbest_scores = None\n        self.gbest = None\n        self.gbest_score = float('inf')\n\n    def initialize(self, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        self.velocity = np.random.rand(self.population_size, self.dim) - 0.5\n        self.pbest = np.copy(self.position)\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n\n    def evaluate(self, func):\n        scores = np.array([func(p) for p in self.position])\n        for i in range(self.population_size):\n            if scores[i] < self.pbest_scores[i]:\n                self.pbest_scores[i] = scores[i]\n                self.pbest[i] = self.position[i]\n            if scores[i] < self.gbest_score:\n                self.gbest_score = scores[i]\n                self.gbest = self.position[i]\n        return scores\n\n    def quantum_position_update(self, current_position, best_position):\n        phi = np.random.rand(*current_position.shape)\n        return current_position + phi * (best_position - current_position)\n\n    def mutate(self, position, bounds):\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        mutation = np.where(np.random.rand(self.dim) < self.mutation_rate,\n                            lb + (ub - lb) * np.random.rand(self.dim), position)\n        return mutation\n\n    def update_velocity(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            cognitive_velocity = self.cognitive_coefficient * r1 * (self.pbest[i] - self.position[i])\n            social_velocity = self.social_coefficient * r2 * (self.gbest - self.position[i])\n            self.velocity[i] = (self.inertia_weight * self.velocity[i] +\n                                cognitive_velocity +\n                                social_velocity)\n\n    def update_position(self, bounds):\n        self.position += self.velocity\n        lb, ub = np.array(bounds.lb), np.array(bounds.ub)\n        self.position = np.clip(self.position, lb, ub)\n        for i in range(self.population_size):\n            self.position[i] = self.mutate(self.position[i], bounds)\n\n    def __call__(self, func):\n        func_calls = 0\n        self.initialize(func.bounds)\n        while func_calls < self.budget:\n            scores = self.evaluate(func)\n            func_calls += self.population_size\n            self.update_velocity()\n            self.update_position(func.bounds)\n            self.position = self.quantum_position_update(self.position, self.gbest)\n\n        return self.gbest, self.gbest_score", "name": "QuantumCooperativeParticleSwarmOptimization", "description": "Quantum Cooperative Particle Swarm Optimization with Adaptive Mutation for Diverse Exploration and Robust Convergence.", "configspace": "", "generation": 99, "fitness": 0.266802559243175, "feedback": "The algorithm QuantumCooperativeParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "094c8bee-cc93-4112-927f-c121e60cd4f0", "metadata": {"aucs": [0.2694520212919852, 0.26005253834613473, 0.270903118091405]}, "mutation_prompt": null}
