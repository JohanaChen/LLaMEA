{"id": "1999659a-76d1-4dcb-940e-d430fa0152fe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate particle fitness\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n                    \n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            # Update particles and apply Differential Evolution\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # PSO update\n                inertia_weight = 0.5 + np.random.rand() / 2\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                # DE mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n                F = 0.8\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                # Selection\n                if trial_fitness < fitness:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n        \n        return self.global_best", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm and Differential Evolution algorithm combining exploration and exploitation for efficient optimization.", "configspace": "", "generation": 0, "fitness": 0.2708921367261752, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2708921367261752]}, "mutation_prompt": null}
{"id": "df0c0334-618d-4b85-a831-c0d00facf466", "solution": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.elite_size = max(1, self.population_size // 10)\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate particle fitness\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal and global bests\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            # Update particles using PSO and DE\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # PSO update with adaptive parameters\n                inertia_weight = 0.4 + 0.5 * (1 - self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5 + 0.5 * np.random.rand()\n                social_coeff = 1.5 + 0.5 * np.random.rand()\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                # DE mutation and crossover with elite selection\n                best_indices = np.argsort(self.personal_best_fitness)[:self.elite_size]\n                indices = np.random.choice(best_indices, 3, replace=False)\n                a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                # Selection\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "ImprovedHybridPSO_DE", "description": "Improved Hybrid PSO-DE with Adaptive Parameters and Elite Selection for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 1, "fitness": 0.27148311494196853, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "1999659a-76d1-4dcb-940e-d430fa0152fe", "metadata": {"aucs": [0.27148311494196853]}, "mutation_prompt": null}
{"id": "ce36e026-f777-4ef1-a957-76c63e76dd77", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.dynamic_elite_factor = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        while self.fitness_evaluations < self.budget:\n            # Dynamic elite size based on progress\n            self.elite_size = max(1, int(self.population_size * self.dynamic_elite_factor))\n            self.dynamic_elite_factor = 0.1 + 0.9 * (1 - self.fitness_evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate particle fitness\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal and global bests\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            # Update particles using PSO and DE\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # PSO update with stochastic parameter adaptation\n                inertia_weight = 0.5 + 0.3 * np.random.rand()\n                cognitive_coeff = 1.5 + 0.5 * np.random.rand()\n                social_coeff = 1.5 + 0.5 * np.random.rand()\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                # DE mutation and crossover with dynamic elite selection\n                best_indices = np.argsort(self.personal_best_fitness)[:self.elite_size]\n                indices = np.random.choice(best_indices, 3, replace=False)\n                a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                # Selection\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE using Dynamic Elite Selection and Stochastic Parameter Adaptation for Improved Convergence.", "configspace": "", "generation": 2, "fitness": 0.27165676416927453, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "df0c0334-618d-4b85-a831-c0d00facf466", "metadata": {"aucs": [0.27165676416927453]}, "mutation_prompt": null}
{"id": "99751289-ba72-4ce3-82d3-adbd8a60c8f9", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.quantum_delta = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        while self.fitness_evaluations < self.budget:\n            # Non-linear decrease of inertia over time\n            inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (self.fitness_evaluations / self.budget)**2\n            \n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate particle fitness\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal and global bests\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            # Update particles using Quantum-Inspired PSO\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                quantum_potential = (self.global_best - self.particles[i]) * self.quantum_delta * np.random.standard_normal(self.dim)\n                cognitive_coeff = 1.5 + 0.5 * np.random.rand()\n                social_coeff = 1.5 + 0.5 * np.random.rand()\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                \n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + quantum_potential\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "QuantumAdaptivePSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization with Non-linear Decreasing Inertia and Quantum Delta Potential for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 3, "fitness": 0.2691349626158035, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "ce36e026-f777-4ef1-a957-76c63e76dd77", "metadata": {"aucs": [0.2691349626158035]}, "mutation_prompt": null}
{"id": "df50d08b-ac8f-4293-b017-47918ba7a071", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.dynamic_elite_factor = 0.1\n        self.diversity_threshold = 0.2\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        while self.fitness_evaluations < self.budget:\n            # Dynamic elite size and diversity control\n            self.elite_size = max(1, int(self.population_size * self.dynamic_elite_factor))\n            self.dynamic_elite_factor = 0.1 + 0.9 * (1 - self.fitness_evaluations / self.budget)\n            self.control_diversity(lower_bound, upper_bound)\n            \n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate particle fitness\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal and global bests\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            # Update particles using PSO and DE\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # PSO update with stochastic parameter adaptation\n                inertia_weight = 0.5 + 0.3 * np.random.rand()\n                cognitive_coeff = 1.5 + 0.5 * np.random.rand()\n                social_coeff = 1.5 + 0.5 * np.random.rand()\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                # DE mutation and crossover with dynamic elite selection\n                best_indices = np.argsort(self.personal_best_fitness)[:self.elite_size]\n                indices = np.random.choice(best_indices, 3, replace=False)\n                a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                # Selection\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best\n\n    def control_diversity(self, lower_bound, upper_bound):\n        diversity = np.mean(np.std(self.particles, axis=0))\n        if diversity < self.diversity_threshold:\n            self.particles += np.random.uniform(-0.1, 0.1, size=self.particles.shape)\n            self.particles = np.clip(self.particles, lower_bound, upper_bound)", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Feature Selection and Diversity Control for Robust Global Optimization.", "configspace": "", "generation": 4, "fitness": 0.27165676416927453, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "ce36e026-f777-4ef1-a957-76c63e76dd77", "metadata": {"aucs": [0.27165676416927453]}, "mutation_prompt": null}
{"id": "7fdc8fe7-c972-4ebe-9ed2-b05a05551d43", "solution": "import numpy as np\n\nclass AdvancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.dynamic_elite_factor = 0.1\n        self.archive = []  # Adaptive memory archive\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        \n        # Multi-swarm division\n        num_swarms = 3\n        sub_pop_size = self.population_size // num_swarms\n        swarms = [self.particles[i*sub_pop_size:(i+1)*sub_pop_size] for i in range(num_swarms)]\n        \n        while self.fitness_evaluations < self.budget:\n            # Dynamic elite size based on progress\n            self.elite_size = max(1, int(self.population_size * self.dynamic_elite_factor))\n            self.dynamic_elite_factor = 0.1 + 0.9 * (1 - self.fitness_evaluations / self.budget)\n\n            for swarm in swarms:\n                for i in range(sub_pop_size):\n                    if self.fitness_evaluations >= self.budget:\n                        break\n\n                    # Evaluate particle fitness\n                    fitness = func(swarm[i])\n                    self.fitness_evaluations += 1\n\n                    # Update personal and global bests\n                    if fitness < self.personal_best_fitness[i]:\n                        self.personal_best_fitness[i] = fitness\n                        self.personal_best[i] = swarm[i].copy()\n\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best = swarm[i].copy()\n\n                    # Update archive with some probability\n                    if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                        self.archive.append(swarm[i].copy())\n\n            # Update particles using PSO and DE\n            for swarm in swarms:\n                for i in range(sub_pop_size):\n                    if self.fitness_evaluations >= self.budget:\n                        break\n\n                    # PSO update with stochastic parameter adaptation\n                    inertia_weight = 0.5 + 0.3 * np.random.rand()\n                    cognitive_coeff = 1.5 + 0.5 * np.random.rand()\n                    social_coeff = 1.5 + 0.5 * np.random.rand()\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - swarm[i])\n                    social_velocity = social_coeff * r2 * (self.global_best - swarm[i])\n                    self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                    swarm[i] += self.velocities[i]\n                    swarm[i] = np.clip(swarm[i], lower_bound, upper_bound)\n\n                    # DE mutation and crossover with dynamic elite selection\n                    best_indices = np.argsort(self.personal_best_fitness)[:self.elite_size]\n                    if len(self.archive) > 3:\n                        archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                        a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                    else:\n                        indices = np.random.choice(best_indices, 3, replace=False)\n                        a, b, c = swarm[indices[0]], swarm[indices[1]], swarm[indices[2]]\n                    F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                    mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                    crossover_rate = 0.9\n                    crossover_indices = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_indices, mutant, swarm[i])\n\n                    # Evaluate trial vector\n                    trial_fitness = func(trial)\n                    self.fitness_evaluations += 1\n\n                    # Selection\n                    if trial_fitness < self.personal_best_fitness[i]:\n                        swarm[i] = trial.copy()\n                        self.personal_best[i] = trial.copy()\n                        self.personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < self.global_best_fitness:\n                            self.global_best_fitness = trial_fitness\n                            self.global_best = trial.copy()\n\n        return self.global_best", "name": "AdvancedHybridPSO_DE", "description": "Advanced Hybrid PSO-DE using Adaptive Memory Archive and Multi-Swarm Strategy for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 5, "fitness": 0.2753407546742098, "feedback": "The algorithm AdvancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "ce36e026-f777-4ef1-a957-76c63e76dd77", "metadata": {"aucs": [0.2753407546742098]}, "mutation_prompt": null}
{"id": "d6f93cdc-bbc8-4448-930d-ebdbd65a90fd", "solution": "import numpy as np\n\nclass QuantumInspiredHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate fitness of the current particle\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                # Update global best\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                # Quantum-inspired superposition: alternate approach for particle position\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                if np.random.rand() < 0.2:  # Probability of quantum jump\n                    self.particles[i] = quantum_exploration\n\n                # Update archive with probability\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n\n            # Update particles using PSO principles\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            # Differential Evolution with Memory-Enhanced Strategies\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.5 + 0.5 * np.random.rand()  # More adaptive mutation factor\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.8\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumInspiredHybridPSO_DE", "description": "Quantum-Inspired Hybrid PSO-DE combining quantum superposition for enhanced exploration and memory-improved DE for robust exploitation.", "configspace": "", "generation": 6, "fitness": 0.2788281759650414, "feedback": "The algorithm QuantumInspiredHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "7fdc8fe7-c972-4ebe-9ed2-b05a05551d43", "metadata": {"aucs": [0.2788281759650414]}, "mutation_prompt": null}
{"id": "a8286db8-06c6-4fc1-86e5-37513d5bd5d7", "solution": "import numpy as np\n\nclass AdaptiveSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 50\n        self.hmcr = 0.9  # Harmony Memory Consideration Rate\n        self.par = 0.3   # Pitch Adjustment Rate\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, dim)\n        self.best_harmony = None\n        self.best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        \n        # Evaluate initial harmonies\n        for i in range(self.harmony_memory_size):\n            if self.fitness_evaluations >= self.budget:\n                break\n            fitness = func(self.harmony_memory[i])\n            self.fitness_evaluations += 1\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_harmony = self.harmony_memory[i].copy()\n        \n        while self.fitness_evaluations < self.budget:\n            new_harmony = np.zeros(self.dim)\n\n            # Generate new harmony by considering harmony memory\n            for j in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[j] = self.harmony_memory[idx, j]\n                    if np.random.rand() < self.par:\n                        new_harmony[j] += np.random.normal(0, 0.01)  # Small random adjustment\n                else:\n                    new_harmony[j] = lower_bound[j] + np.random.rand() * (upper_bound[j] - lower_bound[j])\n            \n            new_harmony = np.clip(new_harmony, lower_bound, upper_bound)\n            new_fitness = func(new_harmony)\n            self.fitness_evaluations += 1\n\n            # Update harmony memory if the new harmony is better\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if new_fitness < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n            if new_fitness < self.best_fitness:\n                self.best_fitness = new_fitness\n                self.best_harmony = new_harmony.copy()\n        \n        return self.best_harmony", "name": "AdaptiveSwarmHarmonySearch", "description": "Adaptive Swarm Harmony Search combines adaptive parameter control of Harmony Search with swarm intelligence-inspired exploration to efficiently navigate complex landscapes.", "configspace": "", "generation": 7, "fitness": 0.26733254052155697, "feedback": "The algorithm AdaptiveSwarmHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "d6f93cdc-bbc8-4448-930d-ebdbd65a90fd", "metadata": {"aucs": [0.26733254052155697]}, "mutation_prompt": null}
{"id": "de73eae4-f08c-4f1c-9967-1ea84e9fe44d", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate fitness of the current particle\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                # Update global best\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                # Quantum-inspired superposition with adaptive probability\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    self.particles[i] = quantum_exploration\n\n                # Dynamic archive management\n                if np.random.rand() < 0.15:\n                    if len(self.archive) < self.population_size:\n                        self.archive.append(self.particles[i].copy())\n                    else:\n                        worst_index = np.argmax([func(indiv) for indiv in self.archive])\n                        if fitness < func(self.archive[worst_index]):\n                            self.archive[worst_index] = self.particles[i].copy()\n\n            # Update particles using PSO principles with adaptive inertia\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.9 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff, social_coeff = 1.5, 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            # Differential Evolution with adaptive strategies\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.5 + 0.5 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9 - 0.3 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumInspiredPSO_DE", "description": "Enhanced Quantum-Inspired PSO-DE with Adaptive Control Parameters and Dynamic Archive Management for better exploration-exploitation balance and memory utilization.", "configspace": "", "generation": 8, "fitness": 0.279500865091453, "feedback": "The algorithm EnhancedQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "d6f93cdc-bbc8-4448-930d-ebdbd65a90fd", "metadata": {"aucs": [0.279500865091453]}, "mutation_prompt": null}
{"id": "4aa6d85a-b1d8-4e52-a50f-7293ebaca347", "solution": "import numpy as np\n\nclass RefinedQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate fitness of the current particle\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                # Update global best\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n                    \n                # Stochastic exploration with dynamic adjustment\n                exploration_factor = 0.1 + 0.4 * (1 - self.fitness_evaluations / self.budget)\n                stochastic_jump = np.random.rand(self.dim) < exploration_factor\n                exploration_vector = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                self.particles[i] = np.where(stochastic_jump, exploration_vector, self.particles[i])\n\n                # Enhanced archive management\n                if np.random.rand() < 0.1:\n                    if len(self.archive) < self.population_size:\n                        self.archive.append(self.particles[i].copy())\n                    else:\n                        worst_index = np.argmax([func(indiv) for indiv in self.archive])\n                        if fitness < func(self.archive[worst_index]):\n                            self.archive[worst_index] = self.particles[i].copy()\n\n            # Update particles using PSO principles with adaptive learning rates\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 + 0.3 * np.sin(np.pi * self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5 + 0.5 * np.cos(2 * np.pi * self.fitness_evaluations / self.budget)\n                social_coeff = 1.5 - 0.5 * np.sin(2 * np.pi * self.fitness_evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            # Differential Evolution with adaptive crossover and mutation\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.5 + 0.5 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9 - 0.2 * np.cos(np.pi * self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "RefinedQuantumInspiredPSO_DE", "description": "Quantum-Inspired PSO-DE with Stochastic Exploration and Adaptive Learning Components for Enhanced Global Search and Convergence.", "configspace": "", "generation": 9, "fitness": 0.27735046322591894, "feedback": "The algorithm RefinedQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "de73eae4-f08c-4f1c-9967-1ea84e9fe44d", "metadata": {"aucs": [0.27735046322591894]}, "mutation_prompt": null}
{"id": "530a8a1a-0bee-4bbf-aa5d-0d276ad025c0", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate fitness of the current particle\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                # Update global best\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                # Quantum-inspired superposition with enhanced adaptive probability\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                quantum_jump_prob = 0.3 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    self.particles[i] = quantum_exploration\n\n                # Dynamic archive management with fitness-based replacement\n                archive_prob = 0.2\n                if np.random.rand() < archive_prob:\n                    if len(self.archive) < self.population_size:\n                        self.archive.append(self.particles[i].copy())\n                    else:\n                        worst_index = np.argmax([func(indiv) for indiv in self.archive])\n                        if fitness < func(self.archive[worst_index]):\n                            self.archive[worst_index] = self.particles[i].copy()\n\n            # Update particles using PSO principles with adaptive cognitive and social factors\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.9 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5 + 0.5 * (1 - self.fitness_evaluations / self.budget)\n                social_coeff = 1.5 + 0.5 * (self.fitness_evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            # Differential Evolution with adaptive crossover and mutation\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.8 - 0.4 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumInspiredPSO_DE", "description": "Enhanced Quantum-Inspired PSO-DE with Adaptive Strategies and Dynamic Memory Integration to improve global convergence and solution refinement.", "configspace": "", "generation": 10, "fitness": 0.27944644020848475, "feedback": "The algorithm EnhancedQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "de73eae4-f08c-4f1c-9967-1ea84e9fe44d", "metadata": {"aucs": [0.27944644020848475]}, "mutation_prompt": null}
{"id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "solution": "import numpy as np\n\nclass ImprovedQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                quantum_jump_prob = 0.25 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                niches = self._niche_strategy(self.particles, i)\n                if niches:\n                    social_coeff = 2.0\n                else:\n                    social_coeff = 1.5\n                inertia_weight = 0.95 - 0.6 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.85 - 0.35 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best\n\n    def _niche_strategy(self, particles, index):\n        niche_radius = np.linalg.norm(np.ptp(particles, axis=0)) / 10\n        distances = np.linalg.norm(particles - particles[index], axis=1)\n        return np.sum(distances < niche_radius) > 3", "name": "ImprovedQuantumInspiredPSO_DE", "description": "Adaptive Quantum-Inspired PSO-DE with Dynamic Niching and Archive Prioritization for enhanced convergence and diversity preservation.", "configspace": "", "generation": 11, "fitness": 0.28524125607501805, "feedback": "The algorithm ImprovedQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "de73eae4-f08c-4f1c-9967-1ea84e9fe44d", "metadata": {"aucs": [0.28524125607501805]}, "mutation_prompt": null}
{"id": "cc4f716e-e84f-4820-8e1a-df6c2037fd8c", "solution": "import numpy as np\n\nclass HybridQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n        self.learning_rates = np.full((self.population_size, dim), 0.1)\n        self.historical_memory = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n                    self.historical_memory[i] = self.particles[i] - self.historical_memory[i]\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    self.particles[i] = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.9 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5 + 0.5 * np.random.rand()\n                social_coeff = 1.5 + 0.5 * np.random.rand()\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + self.learning_rates[i] * self.historical_memory[i]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.5 + 0.5 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.8 - 0.3 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridQuantumInspiredPSO_DE", "description": "Hybrid Quantum-Inspired PSO-DE with Adaptive Learning Factors and Historical Memory for improved exploration-exploitation balance and convergence speed.", "configspace": "", "generation": 12, "fitness": 0.2782826020089363, "feedback": "The algorithm HybridQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {"aucs": [0.2782826020089363]}, "mutation_prompt": null}
{"id": "d5a3a7bd-a3f8-428d-a721-b2159acf00ed", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                quantum_jump_prob = 0.20 - 0.10 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.10 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size and fitness < max(self.personal_best_fitness):\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                niches = self._niche_strategy(self.particles, i)\n                social_coeff = 2.5 if niches else 1.5\n                inertia_weight = 0.90 - 0.55 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.80 - 0.30 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best\n\n    def _niche_strategy(self, particles, index):\n        niche_radius = np.linalg.norm(np.ptp(particles, axis=0)) / 15\n        distances = np.linalg.norm(particles - particles[index], axis=1)\n        return np.sum(distances < niche_radius) > 3", "name": "EnhancedQuantumInspiredPSO_DE", "description": "Enhanced Quantum-Inspired PSO-DE with Adaptive Learning Rates and Dynamic Archive Management for improved exploration-exploitation balance and convergence.", "configspace": "", "generation": 13, "fitness": 0.2791777432995566, "feedback": "The algorithm EnhancedQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {"aucs": [0.2791777432995566]}, "mutation_prompt": null}
{"id": "d26355ce-d981-41e5-9dab-7272b539b084", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                quantum_jump_prob = 0.25 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                niches = self._niche_strategy(self.particles, i)\n                if niches:\n                    social_coeff = 2.0\n                else:\n                    social_coeff = 1.5\n                inertia_weight = 0.95 - 0.6 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5 + 0.5 * np.random.rand()  # Adaptive learning rate\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.85 - 0.35 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best\n\n    def _niche_strategy(self, particles, index):\n        niche_radius = np.linalg.norm(np.ptp(particles, axis=0)) / 10\n        distances = np.linalg.norm(particles - particles[index], axis=1)\n        return np.sum(distances < niche_radius) > 3", "name": "EnhancedQuantumInspiredPSO_DE", "description": "Enhanced Quantum-Inspired PSO-DE with Adaptive Learning Rates and Memory-Based Diversity Control for faster convergence and robustness.", "configspace": "", "generation": 14, "fitness": 0.27673587374346886, "feedback": "The algorithm EnhancedQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {"aucs": [0.27673587374346886]}, "mutation_prompt": null}
{"id": "85a70692-bb18-4624-b1fc-dc53d8ccc8a1", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                quantum_jump_prob = 0.3 - 0.2 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    self.particles[i] = quantum_exploration\n\n                self._adaptive_archive_update(fitness, self.particles[i])\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                niches = self._niche_strategy(self.particles, i)\n                social_coeff = 2.0 if niches else 1.5\n                inertia_weight = 0.9 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.7\n                learning_rate = 0.1 + 0.9 * (1 - self.fitness_evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + learning_rate * (cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                a, b, c = self._select_from_archive()\n                F = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.8 - 0.3 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best\n\n    def _niche_strategy(self, particles, index):\n        niche_radius = np.linalg.norm(np.ptp(particles, axis=0)) / 10\n        distances = np.linalg.norm(particles - particles[index], axis=1)\n        return np.sum(distances < niche_radius) > 3\n\n    def _adaptive_archive_update(self, fitness, particle):\n        if np.random.rand() < 0.2 and len(self.archive) < self.population_size:\n            self.archive.append(particle.copy())\n        elif len(self.archive) == self.population_size:\n            worst_idx = np.argmax([func(p) for p in self.archive])\n            if fitness < func(self.archive[worst_idx]):\n                self.archive[worst_idx] = particle.copy()\n\n    def _select_from_archive(self):\n        if len(self.archive) > 3:\n            archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n            return (self.archive[archive_indices[0]], \n                    self.archive[archive_indices[1]], \n                    self.archive[archive_indices[2]])\n        else:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            return (self.particles[indices[0]], \n                    self.particles[indices[1]], \n                    self.particles[indices[2]])", "name": "EnhancedQuantumInspiredPSO_DE", "description": "Enhanced Quantum-Inspired PSO-DE with Adaptive Learning Rates and Adaptive Archiving for improved exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {}, "mutation_prompt": null}
{"id": "71a5b688-c295-4249-9c14-d578c5737f0c", "solution": "import numpy as np\nfrom scipy.stats import norm\n\nclass HybridDE_BayesianOpt:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            self._evaluate_population(func)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                a, b, c = self._select_parents(i)\n                F = 0.5 + 0.2 * np.random.rand()\n                mutation = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9 - 0.4 * (self.fitness_evaluations / self.budget)\n                trial = self._crossover(self.population[i], mutation, crossover_rate, lower_bound, upper_bound)\n\n                new_fitness = func(trial)\n                self.fitness_evaluations += 1\n                if new_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = new_fitness\n                    if new_fitness < self.best_fitness:\n                        self.best_fitness = new_fitness\n                        self.best_solution = trial\n\n            self._bayesian_refinement(func, lower_bound, upper_bound)\n\n        return self.best_solution\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness_evaluations >= self.budget:\n                break\n\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.fitness_evaluations += 1\n\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_solution = self.population[i]\n\n    def _select_parents(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def _crossover(self, target, mutant, cr, lb, ub):\n        mask = np.random.rand(self.dim) < cr\n        trial = np.where(mask, mutant, target)\n        return np.clip(trial, lb, ub)\n\n    def _bayesian_refinement(self, func, lb, ub):\n        if self.fitness_evaluations >= self.budget:\n            return\n\n        t = np.arange(self.fitness_evaluations) / self.budget\n        mean = np.mean(self.fitness)\n        std = np.std(self.fitness) + 1e-6  # Avoid division by zero\n        acquisition_values = (self.fitness - mean) / std\n        probability_improvement = norm.cdf(acquisition_values)\n\n        selected = np.argmax(probability_improvement)\n        refinement_candidate = self.population[selected] + np.random.normal(0, 0.1, self.dim)\n        refinement_candidate = np.clip(refinement_candidate, lb, ub)\n\n        candidate_fitness = func(refinement_candidate)\n        self.fitness_evaluations += 1\n\n        if candidate_fitness < self.fitness[selected]:\n            self.population[selected] = refinement_candidate\n            self.fitness[selected] = candidate_fitness\n            if candidate_fitness < self.best_fitness:\n                self.best_fitness = candidate_fitness\n                self.best_solution = refinement_candidate", "name": "HybridDE_BayesianOpt", "description": "Hybrid Differential Evolution and Bayesian Optimization with Adaptive Mutation for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 16, "fitness": 0.271436015140755, "feedback": "The algorithm HybridDE_BayesianOpt got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {"aucs": [0.271436015140755]}, "mutation_prompt": null}
{"id": "f85fe5c9-de1c-4204-ab2c-267eb616161b", "solution": "import numpy as np\n\nclass HybridSwarmGuidedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.swarm = np.random.uniform(0, 1, (self.population_size, dim))\n        self.velocities = np.random.uniform(0, 1, (self.population_size, dim)) * 0.1\n        self.best_positions = self.swarm.copy()\n        self.global_best = None\n        self.best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.swarm[i])\n                self.evaluations += 1\n\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = self.swarm[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.swarm[i].copy()\n\n                inertia_weight = 0.9 - 0.7 * (self.evaluations / self.budget)\n                cognitive_coeff = 2.0 * np.random.rand()\n                social_coeff = 2.0 * np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * (self.best_positions[i] - self.swarm[i])\n                social_velocity = social_coeff * (self.global_best - self.swarm[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.swarm[i] += self.velocities[i]\n                self.swarm[i] = np.clip(self.swarm[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.swarm[indices[0]], self.swarm[indices[1]], self.swarm[indices[2]]\n\n                F = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9 - 0.4 * (self.evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.swarm[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.best_fitness[i]:\n                    self.swarm[i] = trial.copy()\n                    self.best_positions[i] = trial.copy()\n                    self.best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridSwarmGuidedDE", "description": "Hybrid Swarm-Guided Differential Evolution (HS-DE) integrating Adaptive Swarm Behavior and Differential Mutation Strategies for enhanced exploration-exploitation balance in high-dimensional black-box optimization.", "configspace": "", "generation": 17, "fitness": 0.26889678813923445, "feedback": "The algorithm HybridSwarmGuidedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {"aucs": [0.26889678813923445]}, "mutation_prompt": null}
{"id": "479ecd63-f74b-4165-b3e6-5a5031c4b484", "solution": "import numpy as np\n\nclass DynamicMemeticDE_AOBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        self._initialize_population(lower_bound, upper_bound)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                mutant = self._mutate(i, lower_bound, upper_bound)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial.copy()\n\n                self._local_search(func, i, lower_bound, upper_bound)\n\n            self._opposition_based_learning(lower_bound, upper_bound, func)\n\n        return self.best_solution\n\n    def _initialize_population(self, lb, ub):\n        scale = ub - lb\n        self.population = lb + np.random.rand(self.population_size, self.dim) * scale\n        for i in range(self.population_size):\n            self.fitness[i] = np.inf\n\n    def _mutate(self, index, lb, ub):\n        a, b, c = self._select_three_random_indices_excluding(index)\n        F = 0.5 + 0.3 * np.random.rand()\n        mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), lb, ub)\n        return mutant\n\n    def _select_three_random_indices_excluding(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        return np.random.choice(indices, 3, replace=False)\n\n    def _crossover(self, target, mutant):\n        crossover_rate = 0.9 - 0.5 * (self.fitness_evaluations / self.budget)\n        crossover_indices = np.random.rand(self.dim) < crossover_rate\n        trial = np.where(crossover_indices, mutant, target)\n        return trial\n\n    def _local_search(self, func, index, lb, ub):\n        if np.random.rand() < 0.1:\n            neighbors = lb + np.random.rand(3, self.dim) * (ub - lb)\n            best_neighbor = self.population[index]\n            best_fitness = self.fitness[index]\n            for neighbor in neighbors:\n                neighbor_fitness = func(neighbor)\n                self.fitness_evaluations += 1\n                if neighbor_fitness < best_fitness:\n                    best_neighbor = neighbor\n                    best_fitness = neighbor_fitness\n            if best_fitness < self.fitness[index]:\n                self.population[index] = best_neighbor\n                self.fitness[index] = best_fitness\n\n    def _opposition_based_learning(self, lb, ub, func):\n        if np.random.rand() < 0.2:\n            opposition_population = lb + ub - self.population\n            for i, opposition in enumerate(opposition_population):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                opposition_fitness = func(opposition)\n                self.fitness_evaluations += 1\n                if opposition_fitness < self.fitness[i]:\n                    self.population[i] = opposition\n                    self.fitness[i] = opposition_fitness\n", "name": "DynamicMemeticDE_AOBL", "description": "Dynamic Memetic Differential Evolution with Adaptive Opposition-Based Learning for efficient exploration-exploitation balance and diversity enhancement.", "configspace": "", "generation": 18, "fitness": 0.2808215760269068, "feedback": "The algorithm DynamicMemeticDE_AOBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {"aucs": [0.2808215760269068]}, "mutation_prompt": null}
{"id": "97b7f869-1683-4999-bcad-6895c4a0d592", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE_SI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE_SI", "description": "Quantum-Enhanced Adaptive Differential Evolution with Swarm Intelligence and Adaptive Archive Management for Improved Global Search in Photonic Structures.", "configspace": "", "generation": 19, "fitness": 0.2862426982392956, "feedback": "The algorithm QuantumEnhancedAdaptiveDE_SI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "76f3d558-6d9a-442c-8cc0-72dc73124ebf", "metadata": {"aucs": [0.2862426982392956]}, "mutation_prompt": null}
{"id": "9d097ddf-8994-41c3-ae43-8f955109f8df", "solution": "import numpy as np\n\nclass HybridQuantumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.fireflies = np.random.uniform(size=(self.population_size, dim))\n        self.intensities = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_intensity = np.inf\n        self.fitness_evaluations = 0\n        self.alpha = 0.5\n        self.beta_min = 0.2\n        self.gamma = 1.0\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        \n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                \n                intensity = func(self.fireflies[i])\n                self.fitness_evaluations += 1\n                \n                if intensity < self.intensities[i]:\n                    self.intensities[i] = intensity\n                    \n                if intensity < self.global_best_intensity:\n                    self.global_best_intensity = intensity\n                    self.global_best = self.fireflies[i].copy()\n            \n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if self.intensities[i] > self.intensities[j]:\n                        r = np.linalg.norm(self.fireflies[i] - self.fireflies[j])\n                        beta = self.beta_min + (1 - self.beta_min) * np.exp(-self.gamma * r ** 2)\n                        self.fireflies[i] += beta * (self.fireflies[j] - self.fireflies[i]) + \\\n                                             self.alpha * (np.random.rand(self.dim) - 0.5)\n                        self.fireflies[i] = np.clip(self.fireflies[i], lower_bound, upper_bound)\n\n            self.alpha = self.chaotic_map(self.alpha)\n            adaptive_mutation_prob = 0.1 + 0.4 * np.sin(2 * np.pi * self.fitness_evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < adaptive_mutation_prob:\n                    mutation_vector = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.fireflies[i] = mutation_vector\n\n        return self.global_best", "name": "HybridQuantumFirefly", "description": "Hybrid Quantum-Inspired Firefly Algorithm with Adaptive Mutation and Chaos Theory for Enhanced Exploration-Exploitation Balance in Photonic Structure Optimization.", "configspace": "", "generation": 20, "fitness": 0.2751055956929521, "feedback": "The algorithm HybridQuantumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2751055956929521]}, "mutation_prompt": null}
{"id": "2c8ada70-1a60-42dc-b02d-a9ab687bcb7b", "solution": "import numpy as np\n\nclass QuantumSwarmSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.temperature = 1.0  # Initial temperature for simulated annealing\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        \n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Update personal and global bests\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            # Simulated annealing acceptance criterion\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.9 - 0.7 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Velocity update\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                # Quantum-inspired perturbation\n                if np.random.rand() < np.exp(-self.fitness_evaluations / self.budget):\n                    q_jump = np.random.uniform(-0.1, 0.1, self.dim)\n                    self.particles[i] += q_jump\n                    self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                # Evaluate new position\n                trial_fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                # Accept trial solution based on simulated annealing criterion\n                if trial_fitness < self.personal_best_fitness[i] or \\\n                   np.random.rand() < np.exp((self.personal_best_fitness[i] - trial_fitness) / self.temperature):\n                    self.personal_best[i] = self.particles[i].copy()\n                    self.personal_best_fitness[i] = trial_fitness\n\n                    # Update global best if necessary\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = self.particles[i].copy()\n            \n            # Decrease temperature\n            self.temperature *= 0.99\n\n        return self.global_best", "name": "QuantumSwarmSimulatedAnnealing", "description": "Quantum-Swarm Simulated Annealing (QSSA) combines quantum-inspired particle dynamics with simulated annealing for adaptive exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 21, "fitness": 0.2673163505113857, "feedback": "The algorithm QuantumSwarmSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2673163505113857]}, "mutation_prompt": null}
{"id": "8671c4cc-0b66-4b16-bace-8b48ab224f91", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.cos(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.4 - 0.2 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.2 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumInspiredAdaptivePSO_DE", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Differential Mutation and Elite Archive for Enhanced Exploration and Exploitation in Photonic Structures.", "configspace": "", "generation": 22, "fitness": 0.2814053792349791, "feedback": "The algorithm QuantumInspiredAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2814053792349791]}, "mutation_prompt": null}
{"id": "7d074987-98cf-4b94-85bf-34200e0c110c", "solution": "import numpy as np\n\nclass HarmonyAdaptiveQuantumSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.harmony_memory = np.random.uniform(size=(self.population_size, dim))\n        self.fitness_scores = np.full(self.population_size, np.inf)\n        self.best_harmony = None\n        self.best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        harmony_memory_consideration_rate = 0.95\n        pitch_adjustment_rate = 0.3\n        bandwidth = 0.1\n\n        while self.fitness_evaluations < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < harmony_memory_consideration_rate:\n                    idx = np.random.choice(self.population_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < pitch_adjustment_rate:\n                        new_harmony[i] += bandwidth * np.random.uniform(-1.0, 1.0)\n                else:\n                    new_harmony[i] = lower_bound[i] + np.random.rand() * (upper_bound[i] - lower_bound[i])\n            \n            new_harmony = np.clip(new_harmony, lower_bound, upper_bound)\n            new_fitness = func(new_harmony)\n            self.fitness_evaluations += 1\n\n            max_fitness_idx = np.argmax(self.fitness_scores)\n            if new_fitness < self.fitness_scores[max_fitness_idx]:\n                self.harmony_memory[max_fitness_idx] = new_harmony\n                self.fitness_scores[max_fitness_idx] = new_fitness\n\n            if new_fitness < self.best_fitness:\n                self.best_fitness = new_fitness\n                self.best_harmony = new_harmony\n\n        return self.best_harmony", "name": "HarmonyAdaptiveQuantumSwarm", "description": "Harmony-Inspired Adaptive Quantum Swarm Optimization integrates harmony search concepts with adaptive quantum swarm dynamics for effective exploration and exploitation in complex optimization landscapes.", "configspace": "", "generation": 23, "fitness": 0.2798177263929912, "feedback": "The algorithm HarmonyAdaptiveQuantumSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2798177263929912]}, "mutation_prompt": null}
{"id": "69d9125b-877f-4355-a98f-919f90ee090f", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE_SI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.7 + 0.2 * np.cos(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.3 * np.sin(evals / self.budget * np.pi)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.05 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.2 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5 + 0.1 * np.sin(self.fitness_evaluations / self.budget * np.pi)\n                social_coeff = 1.4 + 0.1 * np.cos(self.fitness_evaluations / self.budget * np.pi)\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE_SI", "description": "Quantum-Enhanced Particle Swarm Optimization with Adaptive Differential Evolution and Dynamic Quantum Jumps for Enhanced Exploration and Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 24, "fitness": 0.2801495648146525, "feedback": "The algorithm QuantumEnhancedAdaptiveDE_SI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2801495648146525]}, "mutation_prompt": null}
{"id": "823a6efc-7a0d-4638-b7c8-f6f6cef1efca", "solution": "import numpy as np\n\nclass AdaptiveQuantumGA_CLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(size=(self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.mutation_rate = 0.1\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def crossover(self, parent1, parent2):\n        alpha = np.random.rand()\n        return alpha * parent1 + (1 - alpha) * parent2\n\n    def mutate(self, individual, bounds):\n        mutation_vector = self.mutation_rate * np.random.normal(size=self.dim)\n        return np.clip(individual + mutation_vector, bounds[0], bounds[1])\n\n    def select_parents(self, fitness):\n        probabilities = 1.0 / (1.0 + fitness)\n        probabilities /= probabilities.sum()\n        return np.random.choice(self.population_size, 2, p=probabilities)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        fitness = np.array([func(ind) for ind in self.population])\n        self.fitness_evaluations += self.population_size\n\n        while self.fitness_evaluations < self.budget:\n            new_population = []\n            for _ in range(self.population_size):\n                p1_idx, p2_idx = self.select_parents(fitness)\n                parent1, parent2 = self.population[p1_idx], self.population[p2_idx]\n                offspring = self.crossover(parent1, parent2)\n\n                chaotic_factor = self.chaotic_map(np.random.rand())\n                if np.random.rand() < chaotic_factor:\n                    offspring = self.mutate(offspring, [lower_bound, upper_bound])\n\n                new_population.append(offspring)\n\n            self.population = np.array(new_population)\n            fitness = np.array([func(ind) for ind in self.population])\n            self.fitness_evaluations += self.population_size\n\n            min_fitness_idx = np.argmin(fitness)\n            if fitness[min_fitness_idx] < self.best_fitness:\n                self.best_fitness = fitness[min_fitness_idx]\n                self.best_solution = self.population[min_fitness_idx].copy()\n\n            # Feedback-driven mutation rate adjustment\n            diversity = np.std(self.population, axis=0).mean()\n            self.mutation_rate = max(0.01, min(0.5, 1.0 / (1.0 + diversity)))\n\n        return self.best_solution", "name": "AdaptiveQuantumGA_CLS", "description": "Adaptive Quantum-Inspired Genetic Algorithm with Chaotic Local Search and Feedback-Driven Mutation for Enhanced Exploration-Exploitation Balance in Photonic Structure Optimization.", "configspace": "", "generation": 25, "fitness": 0.28573111503327786, "feedback": "The algorithm AdaptiveQuantumGA_CLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.28573111503327786]}, "mutation_prompt": null}
{"id": "bc8eab99-fda6-4ee7-956a-4a85751c703c", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptivePSO_EP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.energy_pool = np.random.uniform(size=self.population_size)\n        self.energy_threshold = 0.5\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        inertia_weight_decay = 0.95\n        cognitive_coeff = lambda evals: 2.0 - 1.5 * (evals / self.budget)\n        social_coeff = lambda evals: 1.5 + 1.0 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                if self.energy_pool[i] < self.energy_threshold:\n                    quantum_jump = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_jump\n                    self.energy_pool[i] = 1.0\n\n                self.energy_pool[i] *= inertia_weight_decay\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.9 * (1 - self.fitness_evaluations / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                cog_velocity = cognitive_coeff(self.fitness_evaluations) * r1 * (self.personal_best[i] - self.particles[i])\n                soc_velocity = social_coeff(self.fitness_evaluations) * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cog_velocity + soc_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            if np.random.rand() < 0.2:\n                energy_transfer_indices = np.random.choice(self.population_size, 2, replace=False)\n                i, j = energy_transfer_indices\n                if self.personal_best_fitness[i] < self.personal_best_fitness[j]:\n                    energy_transfer = 0.1 * (self.personal_best_fitness[j] - self.personal_best_fitness[i])\n                    self.energy_pool[i] += energy_transfer\n                    self.energy_pool[j] -= energy_transfer\n                else:\n                    energy_transfer = 0.1 * (self.personal_best_fitness[i] - self.personal_best_fitness[j])\n                    self.energy_pool[j] += energy_transfer\n                    self.energy_pool[i] -= energy_transfer\n\n        return self.global_best", "name": "QuantumInspiredAdaptivePSO_EP", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Energy Pooling for Enhanced Search Efficiency in Photonic Structure Optimization.", "configspace": "", "generation": 26, "fitness": 0.2832128869279703, "feedback": "The algorithm QuantumInspiredAdaptivePSO_EP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2832128869279703]}, "mutation_prompt": null}
{"id": "e4a4126f-59fd-4b90-b2eb-c687a89399ba", "solution": "import numpy as np\n\nclass HybridQuantumAdaptiveDE_LR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.4 * (evals / self.budget)\n        learning_rate = lambda evals: 0.1 + 0.5 * (1 - evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.25 - 0.05 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += learning_rate(self.fitness_evaluations) * self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridQuantumAdaptiveDE_LR", "description": "Hybrid Quantum-Inspired Adaptive DE with Dynamic Archive and Learning Rate Modulation for Enhanced Exploration-Exploitation Balance in Photonic Structures.", "configspace": "", "generation": 27, "fitness": 0.2773042214985958, "feedback": "The algorithm HybridQuantumAdaptiveDE_LR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2773042214985958]}, "mutation_prompt": null}
{"id": "4f801b9f-f1da-4bc6-85a4-f81b67dfb6e0", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE_DSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            # Evaluate fitness and update personal and global bests\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                # Quantum exploration with dynamic probability\n                quantum_jump_prob = 0.3 * (1 - self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                # Update archive for diversity preservation\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    avg_fitness = np.mean(self.personal_best_fitness)\n                    if fitness < avg_fitness:\n                        worst_idx = np.argmax(self.personal_best_fitness)\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            # Update velocities and positions with adaptive coefficients\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.5 + 0.3 * np.cos(2 * np.pi * self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            # Differential evolution mutation and crossover\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE_DSA", "description": "Quantum-Enhanced Adaptive Differential Evolution with Dynamic Swarm Adaptation and Diversity Preservation for Improved Exploration in Photonic Structures.", "configspace": "", "generation": 28, "fitness": 0.28591414355261113, "feedback": "The algorithm QuantumEnhancedAdaptiveDE_DSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.28591414355261113]}, "mutation_prompt": null}
{"id": "c78ae95a-b3fe-4b2f-a5fc-34999086232e", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE_SI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.05 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.6\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE_SI", "description": "Quantum-Enhanced Adaptive Differential Evolution with Dynamic Archive Management and Adaptive Parameter Control for Enhanced Exploration-Exploitation Balance in Photonic Structure Optimization.", "configspace": "", "generation": 29, "fitness": 0.2804500139673506, "feedback": "The algorithm QuantumEnhancedAdaptiveDE_SI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2804500139673506]}, "mutation_prompt": null}
{"id": "6e894fe3-8ffa-44eb-868a-d9b203239cf7", "solution": "import numpy as np\n\nclass HybridQuantumLevyEnhancedDE_SI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v)**(1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    levy_step = self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(quantum_exploration + levy_step, lower_bound, upper_bound)\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridQuantumLevyEnhancedDE_SI", "description": "Hybrid Quantum-Levy Enhanced Adaptive Differential Evolution with Swarm Intelligence and Archive Management for Robust Global Search in Photonic Structures.", "configspace": "", "generation": 30, "fitness": 0.27891809652150645, "feedback": "The algorithm HybridQuantumLevyEnhancedDE_SI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.27891809652150645]}, "mutation_prompt": null}
{"id": "aed5dc48-ea92-4ad1-bcd7-469fe80104e9", "solution": "import numpy as np\n\nclass BioInspiredQuantumLeapBat:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bats = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.zeros((self.population_size, dim))\n        self.frequencies = np.random.uniform(0, 1, self.population_size)\n        self.loudness = np.ones(self.population_size)\n        self.pulse_rate = np.random.rand(self.population_size)\n        self.current_best = self.bats[0].copy()\n        self.current_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Update frequency, velocity, and position\n                self.frequencies[i] = np.random.uniform(0, 1)\n                self.velocities[i] += (self.bats[i] - self.current_best) * self.frequencies[i]\n                self.bats[i] += self.velocities[i]\n                self.bats[i] = np.clip(self.bats[i], lower_bound, upper_bound)\n\n                # Generate new solution by flying around current best\n                if np.random.rand() > self.pulse_rate[i]:\n                    self.bats[i] = self.current_best + 0.001 * np.random.randn(self.dim)\n\n                # Evaluate new solutions\n                fitness = func(self.bats[i])\n                self.fitness_evaluations += 1\n\n                # Update if the solution improves\n                if fitness < self.current_best_fitness and np.random.rand() < self.loudness[i]:\n                    self.current_best = self.bats[i].copy()\n                    self.current_best_fitness = fitness\n                    self.loudness[i] = max(0.1, self.loudness[i] * 0.9)\n                    self.pulse_rate[i] = min(1, self.pulse_rate[i] * 1.1)\n\n                # Quantum leap strategy for exploration\n                quantum_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_prob:\n                    quantum_jump = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    trial_fitness = func(quantum_jump)\n                    self.fitness_evaluations += 1\n                    if trial_fitness < self.current_best_fitness:\n                        self.current_best = quantum_jump.copy()\n                        self.current_best_fitness = trial_fitness\n\n        return self.current_best", "name": "BioInspiredQuantumLeapBat", "description": "Bio-Inspired Quantum Leap Strategy integrating Bat Algorithm with Adaptive Mutation for Optimized Exploration in High-Dimensional Photonic Structure Optimization.", "configspace": "", "generation": 31, "fitness": 0.28049036884705214, "feedback": "The algorithm BioInspiredQuantumLeapBat got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.28049036884705214]}, "mutation_prompt": null}
{"id": "86ace099-5ae0-4fab-90e1-2e7a410021c2", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE_SI_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n        self.dynamic_population_size = self.population_size\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            # Dynamic Population Adjustment\n            if self.fitness_evaluations < 0.5 * self.budget:\n                self.dynamic_population_size = int(self.population_size * (1 + 0.5 * self.fitness_evaluations / self.budget))\n            else:\n                self.dynamic_population_size = int(self.population_size * (1.5 - 0.5 * self.fitness_evaluations / self.budget))\n            self.dynamic_population_size = min(self.dynamic_population_size, self.budget - self.fitness_evaluations)\n\n            for i in range(self.dynamic_population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                \n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.dynamic_population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.dynamic_population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE_SI_V2", "description": "Quantum-Enhanced Differential Evolution with Dynamic Population Management and Adaptive Mutation for Superior Global Search in Photonic Structures.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {}, "mutation_prompt": null}
{"id": "cf18d478-91b7-4b00-bcdd-72c6a3b88463", "solution": "import numpy as np\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\n\nclass SurrogateEnhancedQuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n        self.kernel = RBF()\n        self.gp = GaussianProcessRegressor(kernel=self.kernel, alpha=1e-6)\n        self.surrogate_update_interval = 10\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n                if self.fitness_evaluations % self.surrogate_update_interval == 0 and len(self.archive) > 5:\n                    X_train = np.array(self.archive)\n                    y_train = np.array([func(x) for x in self.archive])\n                    self.gp.fit(X_train, y_train)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                if self.fitness_evaluations % self.surrogate_update_interval == 0:\n                    trial_fitness = self.gp.predict(trial.reshape(1, -1))[0]\n                else:\n                    trial_fitness = func(trial)\n                    self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "SurrogateEnhancedQuantumAdaptiveDE", "description": "Surrogate-Assisted Quantum-Enhanced Adaptive DE with Local Search Intensification and Archiving for Improved Photonic Structure Optimization.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('too many indices for array: array is 0-dimensional, but 1 were indexed').", "error": "IndexError('too many indices for array: array is 0-dimensional, but 1 were indexed')", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {}, "mutation_prompt": null}
{"id": "d1f7e835-6365-4eea-aa2b-66b1177bba3c", "solution": "import numpy as np\n\nclass BioInspiredHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.drift = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                if np.random.rand() < 0.1:\n                    theta = 2 * np.pi * np.random.rand(self.dim)\n                    self.drift[i] += 0.01 * np.sin(theta)\n                else:\n                    self.drift[i] *= 0.9\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.9 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 2.0\n                social_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                bacterial_drift = self.drift[i]\n\n                self.velocities[i] = (inertia_weight * self.velocities[i] + cognitive_velocity \n                                      + social_velocity + bacterial_drift)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "BioInspiredHybridSwarm", "description": "Bio-inspired Hybrid Swarm Algorithm integrating Particle Swarm Optimization with Bacterial Foraging for Enhanced Diversity and Convergence in Photonic Structure Optimization. ", "configspace": "", "generation": 34, "fitness": 0.26886037350912484, "feedback": "The algorithm BioInspiredHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.26886037350912484]}, "mutation_prompt": null}
{"id": "61727345-4853-4f31-8e02-add7b593891f", "solution": "import numpy as np\n\nclass QuantumDrivenHybridSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        def adaptive_parameters(evals):\n            scale_factor = 0.4 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n            crossover_rate = 0.8 - 0.4 * (evals / self.budget)\n            return scale_factor, crossover_rate\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.25 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.05 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            inertia_weight = 0.5 + 0.2 * np.random.rand()\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) >= 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F, crossover_rate = adaptive_parameters(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumDrivenHybridSwarmOptimization", "description": "Quantum-Driven Hybrid Swarm Optimization (QDHSO) with Dynamic Learning and Archive-Assisted Exploration for Enhanced Convergence in Photonic Structures.", "configspace": "", "generation": 35, "fitness": 0.28012794505576133, "feedback": "The algorithm QuantumDrivenHybridSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.28012794505576133]}, "mutation_prompt": null}
{"id": "5961f472-0a32-4da3-a28a-97dd522a71dc", "solution": "import numpy as np\n\nclass QuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        def adaptive_parameters(evals):\n            scale_factor = 0.5 + 0.2 * np.cos(2 * np.pi * evals / self.budget)\n            crossover_rate = 0.8 - 0.4 * (evals / self.budget)\n            inertia_weight = 0.6 + 0.3 * np.cos(np.pi * evals / self.budget)\n            return scale_factor, crossover_rate, inertia_weight\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.35 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                scale_factor, crossover_rate, inertia_weight = adaptive_parameters(self.fitness_evaluations)\n                cognitive_coeff, social_coeff = 1.5, 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                mutant = np.clip(a + scale_factor * (b - c), lower_bound, upper_bound)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumInspiredPSO_DE", "description": "Quantum-Inspired Particle Swarm with Differential Mutation and Dynamic Archive for Enhanced Exploration-Exploitation Balance in Photonic Optimization.", "configspace": "", "generation": 36, "fitness": 0.28046846715141116, "feedback": "The algorithm QuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.28046846715141116]}, "mutation_prompt": null}
{"id": "e1e0b337-60f5-41f6-8985-c5389dab7a63", "solution": "import numpy as np\n\nclass DynamicQuantumSwarm_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.cos(2 * np.pi * evals / self.budget)\n        mutation_probability = lambda evals: 0.1 + 0.4 * np.sin(np.pi * evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                mutation_prob = mutation_probability(self.fitness_evaluations)\n                if np.random.rand() < mutation_prob:\n                    self.particles[i] = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.725 - 0.425 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "DynamicQuantumSwarm_DE", "description": "Dynamic Quantum Swarm-based Differential Evolution with Adaptive Mutation and Memorization Strategy for Efficient Search in Photonic Structures.", "configspace": "", "generation": 37, "fitness": 0.2672461298566008, "feedback": "The algorithm DynamicQuantumSwarm_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2672461298566008]}, "mutation_prompt": null}
{"id": "30acafd9-b27c-47c9-8cbb-3860f99c1e36", "solution": "import numpy as np\n\nclass QuantumInspiredSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.4 + 0.5 * np.sin(3 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.85 - 0.55 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.25 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.2 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumInspiredSwarmOptimizer", "description": "Quantum-Inspired Swarm Intelligence with Adaptive Archive and Dynamic Mutation Strategies for Efficient Global Search in Complex Photonic Landscapes.", "configspace": "", "generation": 38, "fitness": 0.2796885280478856, "feedback": "The algorithm QuantumInspiredSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2796885280478856]}, "mutation_prompt": null}
{"id": "f0a27297-1ab4-4a07-96b7-e58f9227ae9e", "solution": "import numpy as np\n\nclass QuantumEnhancedEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.island_count = 5\n        self.island_size = self.population_size // self.island_count\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.cos(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.5 * np.cos(evals / self.budget)\n        \n        def island_model_exchange(island_particles):\n            np.random.shuffle(island_particles)\n            return island_particles\n\n        while self.fitness_evaluations < self.budget:\n            for island_idx in range(self.island_count):\n                start = island_idx * self.island_size\n                end = start + self.island_size\n                island_particles = self.particles[start:end]\n                island_particles = island_model_exchange(island_particles)\n                self.particles[start:end] = island_particles\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedEvolutionarySwarmOptimization", "description": "Quantum-Enhanced Evolutionary Swarm Optimization with Dynamic Island Model and Adaptive Learning for Enhanced Global Exploration in Photonic Structures.", "configspace": "", "generation": 39, "fitness": 0.2727585290020482, "feedback": "The algorithm QuantumEnhancedEvolutionarySwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2727585290020482]}, "mutation_prompt": null}
{"id": "db0505bd-ab84-4ae3-b2d0-a38f2205a4db", "solution": "import numpy as np\n\nclass MultiTribeQuantumSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_tribes = 5\n        self.tribe_size = self.population_size // self.num_tribes\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.tribal_best = self.particles[:self.num_tribes].copy()\n        self.global_best = None\n        self.tribal_best_fitness = np.full(self.num_tribes, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        quantum_jump_prob = lambda evals: 0.3 - 0.1 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for tribe in range(self.num_tribes):\n                for i in range(tribe * self.tribe_size, (tribe + 1) * self.tribe_size):\n                    if self.fitness_evaluations >= self.budget:\n                        break\n\n                    fitness = func(self.particles[i])\n                    self.fitness_evaluations += 1\n\n                    if fitness < self.tribal_best_fitness[tribe]:\n                        self.tribal_best_fitness[tribe] = fitness\n                        self.tribal_best[tribe] = self.particles[i].copy()\n\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best = self.particles[i].copy()\n\n            for tribe in range(self.num_tribes):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                for i in range(tribe * self.tribe_size, (tribe + 1) * self.tribe_size):\n                    inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                    cognitive_coeff = 1.4\n                    social_coeff = 1.7\n                    r1, r2 = np.random.rand(), np.random.rand()\n\n                    cognitive_velocity = cognitive_coeff * r1 * (self.tribal_best[tribe] - self.particles[i])\n                    social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                    self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                    if np.random.rand() < quantum_jump_prob(self.fitness_evaluations):\n                        quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                        self.particles[i] = quantum_exploration\n\n            if self.fitness_evaluations % (self.budget // 10) == 0:\n                best_tribe_idx = np.argmin(self.tribal_best_fitness)\n                self.particles = self.reinitialize_tribes(best_tribe_idx, lower_bound, upper_bound)\n\n        return self.global_best\n\n    def reinitialize_tribes(self, best_tribe_idx, lower_bound, upper_bound):\n        new_particles = np.random.uniform(size=(self.population_size, self.dim))\n        new_particles[best_tribe_idx * self.tribe_size:(best_tribe_idx + 1) * self.tribe_size] = self.particles[best_tribe_idx * self.tribe_size:(best_tribe_idx + 1) * self.tribe_size]\n        return new_particles", "name": "MultiTribeQuantumSwarm", "description": "Multi-Tribe Quantum Swarm Optimization combines multiple dynamic sub-populations with quantum-inspired random walks and competitive cooperation to enhance exploration and exploitation in global optimization.", "configspace": "", "generation": 40, "fitness": 0.28270715544567926, "feedback": "The algorithm MultiTribeQuantumSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.28270715544567926]}, "mutation_prompt": null}
{"id": "10cbe72d-2275-4617-b698-71cdc5d509a1", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE_SI_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.8 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 2.0\n                social_coeff = 2.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE_SI_Improved", "description": "Quantum-Enhanced Adaptive Differential Evolution with Dynamic Neighborhoods and Self-Adaptive Mechanisms for Improved Global Search in Photonic Structures.", "configspace": "", "generation": 41, "fitness": 0.27639646146573893, "feedback": "The algorithm QuantumEnhancedAdaptiveDE_SI_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.27639646146573893]}, "mutation_prompt": null}
{"id": "7ae75a59-80f8-43a1-9665-5494d148afbf", "solution": "import numpy as np\n\nclass QuantumAnnealedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.5 + 0.3 * np.cos(2 * np.pi * self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.5 + 0.5 * np.tanh(2 * np.pi * self.fitness_evaluations / self.budget)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.7 + 0.2 * np.exp(-3 * self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumAnnealedSwarmOptimization", "description": "Quantum-Annealed Swarm Optimization with Dynamic Archive and Reinforced Mutation for Enhanced Exploration in Photonic Structures.", "configspace": "", "generation": 42, "fitness": 0.2790507319039286, "feedback": "The algorithm QuantumAnnealedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2790507319039286]}, "mutation_prompt": null}
{"id": "f7c714cb-8316-41b6-b687-7e4fadbb19db", "solution": "import numpy as np\n\nclass ImprovedQuantumEnhancedAdaptiveDE_SI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = max(0.2, 0.5 * np.std(self.personal_best_fitness) / (np.mean(self.personal_best_fitness) + 1e-10))\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "ImprovedQuantumEnhancedAdaptiveDE_SI", "description": "Improved Quantum-Enhanced Adaptive DE with Particle Diversity Preservation and Dynamic Quantum Probability for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 43, "fitness": 0.2805177817732838, "feedback": "The algorithm ImprovedQuantumEnhancedAdaptiveDE_SI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2805177817732838]}, "mutation_prompt": null}
{"id": "356aba8f-f393-4d36-9957-168683669905", "solution": "import numpy as np\n\nclass HybridQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.4 * np.random.rand()\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.4 * np.random.rand()\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            if self.fitness_evaluations > self.budget * 0.6:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridQuantumDE", "description": "Hybrid Quantum-Inspired Differential Evolution with Adaptive Learning Rates and Dynamic Population Resizing for Enhanced Global Optimization in Photonic Structures.", "configspace": "", "generation": 44, "fitness": 0.2769226467497913, "feedback": "The algorithm HybridQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2769226467497913]}, "mutation_prompt": null}
{"id": "98a98928-18a4-45cf-9485-5295de1bcad8", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def levy_flight(self, L, dim):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, dim)\n        v = np.random.normal(0, 1, dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return L * step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + self.levy_flight(0.01, self.dim)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridQuantumDifferentialEvolution", "description": "Hybrid Quantum Differential Evolution with Reinforced Particle Swarm and Dynamic Levy Flights for Enhanced Global Optimization of Photonic Structures.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {}, "mutation_prompt": null}
{"id": "2accb72f-9e90-487f-9bbf-ac321115a858", "solution": "import numpy as np\n\nclass EnhancedQuantumDE_SI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        dynamic_scale_factor = lambda evals: 0.6 + 0.3 * np.cos(np.pi * evals / self.budget)\n        dynamic_crossover_rate = lambda evals: 0.8 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.35 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.8 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = dynamic_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = dynamic_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumDE_SI", "description": "Enhanced Quantum Differential Evolution with Dynamic Swarm Intelligence and Adaptive Memory for Superior Global Search in Photonic Structures.", "configspace": "", "generation": 46, "fitness": 0.2790883874410558, "feedback": "The algorithm EnhancedQuantumDE_SI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2790883874410558]}, "mutation_prompt": null}
{"id": "dfcfdfba-ad68-49ce-b55e-8f79a3cbdf5b", "solution": "import numpy as np\n\nclass QuantumDrivenCoevolutionaryHS_AF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 50\n        self.harmony_memory = np.random.uniform(size=(self.harmony_memory_size, dim))\n        self.fitness_evaluations = 0\n        self.best_harmony = None\n        self.best_fitness = np.inf\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:  # Harmony memory consideration rate\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                else:\n                    new_harmony[i] = lower_bound[i] + np.random.rand() * (upper_bound[i] - lower_bound[i])\n                \n                if np.random.rand() < 0.3:  # Pitch adjustment rate\n                    new_harmony[i] += np.random.uniform(-0.05, 0.05) * (upper_bound[i] - lower_bound[i])\n                    new_harmony[i] = np.clip(new_harmony[i], lower_bound[i], upper_bound[i])\n\n            fitness = func(new_harmony)\n            self.fitness_evaluations += 1\n\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_harmony = new_harmony.copy()\n\n            if len(self.archive) < self.harmony_memory_size:\n                self.archive.append(new_harmony.copy())\n            else:\n                worst_idx = np.argmax([func(h) for h in self.archive])\n                if fitness < func(self.archive[worst_idx]):\n                    self.archive[worst_idx] = new_harmony.copy()\n\n            quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n            if np.random.rand() < quantum_jump_prob:\n                quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                self.harmony_memory[np.random.randint(self.harmony_memory_size)] = quantum_exploration\n\n            self.harmony_memory = np.array(sorted(self.harmony_memory, key=lambda x: func(x)))\n            self.harmony_memory[-1] = new_harmony\n\n        return self.best_harmony", "name": "QuantumDrivenCoevolutionaryHS_AF", "description": "Quantum-Driven Coevolutionary Harmony Search with Adaptive Feedback for Efficient Exploration and Exploitation in Photonic Structure Optimization.", "configspace": "", "generation": 47, "fitness": 0.26769823385852176, "feedback": "The algorithm QuantumDrivenCoevolutionaryHS_AF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.26769823385852176]}, "mutation_prompt": null}
{"id": "037177ff-77bb-4baa-bb3e-8cbf1b01bd37", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE_DQT:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n        adaptive_tunneling_rate = lambda evals: max(0.1, 0.5 - 0.4 * (evals / self.budget))\n        \n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = adaptive_tunneling_rate(self.fitness_evaluations)\n                if np.random.rand() < quantum_jump_prob:\n                    tunneling_vector = np.random.normal(loc=0.0, scale=0.1, size=self.dim)\n                    quantum_exploration = self.particles[i] + tunneling_vector * (upper_bound - lower_bound)\n                    self.particles[i] = np.clip(quantum_exploration, lower_bound, upper_bound)\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE_DQT", "description": "Quantum-Enhanced Adaptive Differential Evolution with Dynamic Quantum Tunneling for Enhanced Exploration in Photonic Structure Optimization.", "configspace": "", "generation": 48, "fitness": 0.27063969486611916, "feedback": "The algorithm QuantumEnhancedAdaptiveDE_DQT got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.27063969486611916]}, "mutation_prompt": null}
{"id": "5a43f6ff-fbef-4085-8f5c-fe14dce2868c", "solution": "import numpy as np\n\nclass EnhancedQuantumDE_SI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.35 - 0.15 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.8 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumDE_SI", "description": "Enhanced Quantum-Driven Differential Evolution with Dynamic Swarm Intelligence and Adaptive Memory Utilization for Superior Exploration and Exploitation in Photonic Structure Optimization.", "configspace": "", "generation": 49, "fitness": 0.28167690772523357, "feedback": "The algorithm EnhancedQuantumDE_SI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.28167690772523357]}, "mutation_prompt": null}
{"id": "af077099-4709-4b2f-92ea-bf69f219d0e6", "solution": "import numpy as np\n\nclass QuantumInspiredFuzzyLogicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def fuzzy_logic_params(self, evals):\n        # Fuzzy logic to adjust parameters dynamically\n        progress = evals / self.budget\n        inertia_weight = 0.9 - 0.5 * progress\n        social_component = 1.5 + 0.5 * (1 - progress)\n        cognitive_component = 1.5 + 0.5 * progress\n        return inertia_weight, cognitive_component, social_component\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight, cognitive_coeff, social_coeff = self.fuzzy_logic_params(self.fitness_evaluations)\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                # Quantum-inspired exploration mechanism\n                if np.random.rand() < 0.1:\n                    quantum_jump = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_jump\n\n        return self.global_best", "name": "QuantumInspiredFuzzyLogicPSO", "description": "Quantum-Inspired Fuzzy Logic Particle Swarm Optimization (QIFL-PSO) leverages fuzzy logic for dynamic parameter adjustment and quantum-inspired exploration to enhance global search efficiency in photonic structure optimization.", "configspace": "", "generation": 50, "fitness": 0.27661321215587453, "feedback": "The algorithm QuantumInspiredFuzzyLogicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.27661321215587453]}, "mutation_prompt": null}
{"id": "e8776d46-b4fe-4d30-8887-19ba0ccc5ee3", "solution": "import numpy as np\n\nclass HybridQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.max_population_size = 100\n        self.min_population_size = 20\n        self.particles = np.random.uniform(size=(self.initial_population_size, dim))\n        self.velocities = np.random.uniform(size=(self.initial_population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.initial_population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - self.fitness_evaluations / self.budget))\n            self.particles = self.particles[:population_size]\n            self.velocities = self.velocities[:population_size]\n            self.personal_best = self.personal_best[:population_size]\n            self.personal_best_fitness = self.personal_best_fitness[:population_size]\n\n            for i in range(population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridQuantumDE", "description": "Hybrid Quantum-Inspired Differential Evolution with Dynamic Population Resizing and Archive-Based Mutation for Enhanced Exploration and Exploitation in Photonic Structure Optimization.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {}, "mutation_prompt": null}
{"id": "e0efe942-f913-4310-b712-a7f9a6b3e3cc", "solution": "import numpy as np\n\nclass QuantumInspiredMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        def local_search(particle):\n            step_size = (upper_bound - lower_bound) * 0.01\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            perturbed_particle = np.clip(particle + perturbation, lower_bound, upper_bound)\n            if func(perturbed_particle) < func(particle):\n                return perturbed_particle\n            return particle\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = local_search(trial.copy())\n                    self.personal_best[i] = self.particles[i]\n                    self.personal_best_fitness[i] = func(self.particles[i])\n                    if self.personal_best_fitness[i] < self.global_best_fitness:\n                        self.global_best_fitness = self.personal_best_fitness[i]\n                        self.global_best = self.personal_best[i].copy()\n\n        return self.global_best", "name": "QuantumInspiredMemeticDE", "description": "Quantum-Inspired Memetic Differential Evolution with Adaptive Perturbation and Diversity Preservation for Enhanced Search in Photonic Structures.", "configspace": "", "generation": 52, "fitness": 0.277487292095848, "feedback": "The algorithm QuantumInspiredMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.277487292095848]}, "mutation_prompt": null}
{"id": "e8fe38fb-0772-4111-8222-aefca36a536b", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE_QT_AN:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        quantum_tunneling_prob = 0.2\n        \n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                if np.random.rand() < quantum_tunneling_prob:\n                    tunnel_vector = np.random.standard_normal(self.dim)\n                    self.particles[i] += tunnel_vector * (upper_bound - lower_bound) * 0.03\n                    self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.7\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumAdaptiveDE_QT_AN", "description": "Incorporates Quantum Tunneling and Adaptive Neighborhood Search into Quantum-Enhanced Adaptive DE for enhanced exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 53, "fitness": 0.26950454246959454, "feedback": "The algorithm QuantumAdaptiveDE_QT_AN got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.26950454246959454]}, "mutation_prompt": null}
{"id": "39ba44df-7540-4e66-9a9f-f2c90a2b6404", "solution": "import numpy as np\n\nclass EnhancedStochasticQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                if np.random.rand() < 0.25:\n                    quantum_jump = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_jump\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            inertia_weight = 0.5 + 0.4 * np.cos(2 * np.pi * self.fitness_evaluations / self.budget)\n            cognitive_coeff = 1.5\n            social_coeff = 1.8\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.6 + 0.4 * np.sin(2 * np.pi * self.fitness_evaluations / self.budget)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.8 - 0.5 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedStochasticQuantumPSO", "description": "Enhanced Stochastic Quantum Particle Swarm Optimization with Dynamic Archive and Adaptive Mutation for Robust Global Optimization in Photonic Structures.", "configspace": "", "generation": 54, "fitness": 0.2850939590867919, "feedback": "The algorithm EnhancedStochasticQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2850939590867919]}, "mutation_prompt": null}
{"id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "solution": "import numpy as np\n\nclass HybridQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "HybridQuantumCollaborativeDE", "description": "Hybrid Quantum-Collaborative Differential Evolution with Adaptive Archive and Dynamic Inertia for Enhanced Photonic Structure Optimization.", "configspace": "", "generation": 55, "fitness": 0.2862567030977391, "feedback": "The algorithm HybridQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "97b7f869-1683-4999-bcad-6895c4a0d592", "metadata": {"aucs": [0.2862567030977391]}, "mutation_prompt": null}
{"id": "ac9cd1aa-01d4-4657-b896-e7328d767465", "solution": "import numpy as np\n\nclass QuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 50\n        self.harmony_memory = np.random.uniform(size=(self.harmony_memory_size, dim))\n        self.harmony_fitness = np.full(self.harmony_memory_size, np.inf)\n        self.best_harmony = None\n        self.best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        memory_consideration_rate = 0.95\n        pitch_adjustment_rate = lambda evals: 0.4 + 0.5 * (1 - evals / self.budget)\n        bandwidth = lambda evals: (upper_bound - lower_bound) * (1 - evals / self.budget)\n\n        for i in range(self.harmony_memory_size):\n            self.harmony_fitness[i] = func(self.harmony_memory[i])\n            self.fitness_evaluations += 1\n            if self.harmony_fitness[i] < self.best_fitness:\n                self.best_fitness = self.harmony_fitness[i]\n                self.best_harmony = self.harmony_memory[i]\n\n        while self.fitness_evaluations < self.budget:\n            new_harmony = np.empty(self.dim)\n            for j in range(self.dim):\n                if np.random.rand() < memory_consideration_rate:\n                    new_harmony[j] = self.harmony_memory[np.random.randint(self.harmony_memory_size)][j]\n                    if np.random.rand() < pitch_adjustment_rate(self.fitness_evaluations):\n                        new_harmony[j] += np.random.uniform(-1, 1) * bandwidth(self.fitness_evaluations)[j]\n                else:\n                    new_harmony[j] = lower_bound[j] + np.random.rand() * (upper_bound[j] - lower_bound[j])\n\n            new_harmony = np.clip(new_harmony, lower_bound, upper_bound)\n            new_fitness = func(new_harmony)\n            self.fitness_evaluations += 1\n\n            if new_fitness < self.best_fitness:\n                self.best_fitness = new_fitness\n                self.best_harmony = new_harmony.copy()\n\n            worst_idx = np.argmax(self.harmony_fitness)\n            if new_fitness < self.harmony_fitness[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                self.harmony_fitness[worst_idx] = new_fitness\n\n        return self.best_harmony", "name": "QuantumInspiredHarmonySearch", "description": "Quantum-Inspired Harmony Search with Adaptive Pitch Adjustment and Dynamic Bandwidth Reduction for Efficient Photonic Structure Optimization.", "configspace": "", "generation": 56, "fitness": 0.2796614795309691, "feedback": "The algorithm QuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2796614795309691]}, "mutation_prompt": null}
{"id": "3a83bf2f-9ea7-4c5f-ac7f-3dd6acfe7f83", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(3 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            # Dynamic Quantum Probability and Archive Management\n            quantum_jump_prob = 0.4 - 0.3 * (self.fitness_evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            # Multi-Phase Velocity Update\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 2.0\n                social_coeff = 2.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            # Enhanced Differential Evolution Mutation\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedAdaptiveQuantumCollaborativeDE", "description": "Enhanced Adaptive Quantum-Collaborative Differential Evolution with Dynamic Convergence and Multi-Phase Strategy for Improved Photonic Structure Optimization.", "configspace": "", "generation": 57, "fitness": 0.276785702091888, "feedback": "The algorithm EnhancedAdaptiveQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.276785702091888]}, "mutation_prompt": null}
{"id": "4105370f-a05b-45ca-89ba-87d5eafb82ff", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n        \n        def dynamic_population_update():\n            self.population_size = self.initial_population_size + int((self.budget - self.fitness_evaluations) / self.budget * 20)\n            if self.population_size > self.initial_population_size:\n                new_particles = np.random.uniform(size=(self.population_size - len(self.particles), self.dim))\n                new_velocities = np.random.uniform(size=(self.population_size - len(self.velocities), self.dim)) * 0.1\n                self.particles = np.vstack((self.particles, new_particles))\n                self.velocities = np.vstack((self.velocities, new_velocities))\n                self.personal_best = np.vstack((self.personal_best, new_particles))\n                self.personal_best_fitness = np.append(self.personal_best_fitness, np.full(new_particles.shape[0], np.inf))\n\n        while self.fitness_evaluations < self.budget:\n            dynamic_population_update()\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative DE with Dynamic Population Strategy and Adaptive Learning using Historical Archives for Photonic Optimization.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('negative dimensions are not allowed').", "error": "ValueError('negative dimensions are not allowed')", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {}, "mutation_prompt": null}
{"id": "91414956-4514-4f8b-a183-39b5a81a7273", "solution": "import numpy as np\n\nclass QuantumEntanglementEvolutionarySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.memory_archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_mutation_factor = lambda evals: 0.5 + 0.3 * np.cos(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                entanglement_prob = 0.4 - 0.2 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < entanglement_prob:\n                    entangled_state = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = entangled_state\n\n                if np.random.rand() < 0.15 and len(self.memory_archive) < self.population_size:\n                    self.memory_archive.append(self.particles[i].copy())\n                elif len(self.memory_archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.memory_archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.memory_archive) > 3:\n                    archive_indices = np.random.choice(len(self.memory_archive), 3, replace=False)\n                    a, b, c = (self.memory_archive[idx] for idx in archive_indices)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = (self.particles[idx] for idx in indices)\n\n                F = adaptive_mutation_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumEntanglementEvolutionarySwarm", "description": "Quantum-Entanglement Assisted Evolutionary Swarm Optimization with Adaptive Memory and Dynamic Strategy Pivoting for Robust Photonic Structure Optimization.", "configspace": "", "generation": 59, "fitness": 0.2806586774730915, "feedback": "The algorithm QuantumEntanglementEvolutionarySwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2806586774730915]}, "mutation_prompt": null}
{"id": "524ea1e9-7ae2-4f7a-9f12-7e18690ddb54", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n        adaptive_inertia_weight = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        def update_velocity(particle_index):\n            inertia_weight = adaptive_inertia_weight(self.fitness_evaluations)\n            cognitive_coeff = 1.5 + 0.5 * np.random.rand()\n            social_coeff = 1.8 + 0.5 * np.random.rand()\n            r1, r2 = np.random.rand(), np.random.rand()\n\n            cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[particle_index] - self.particles[particle_index])\n            social_velocity = social_coeff * r2 * (self.global_best - self.particles[particle_index])\n            self.velocities[particle_index] = inertia_weight * self.velocities[particle_index] + cognitive_velocity + social_velocity\n            self.particles[particle_index] += self.velocities[particle_index]\n            self.particles[particle_index] = np.clip(self.particles[particle_index], lower_bound, upper_bound)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                update_velocity(i)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative Differential Evolution with Adaptive Swarm Intelligence and Diversity Preservation for Superior Photonic Structure Optimization.", "configspace": "", "generation": 60, "fitness": 0.2819136143618526, "feedback": "The algorithm EnhancedQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2819136143618526]}, "mutation_prompt": null}
{"id": "d7ce67dc-2924-4665-8e46-d90edf0c8610", "solution": "import numpy as np\n\nclass QuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 50\n        self.harmonies = np.random.uniform(size=(self.harmony_memory_size, dim))\n        self.harmony_memory_fitness = np.full(self.harmony_memory_size, np.inf)\n        self.best_harmony = None\n        self.best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        def adaptive_pitch_adjustment(evals):\n            return 0.1 + 0.9 * np.cos(np.pi * evals / (2 * self.budget))\n\n        def harmony_consideration_rate(evals):\n            return 0.5 + 0.4 * np.sin(np.pi * evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < harmony_consideration_rate(self.fitness_evaluations):\n                    new_harmony[i] = self.harmonies[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < adaptive_pitch_adjustment(self.fitness_evaluations):\n                        new_harmony[i] += np.random.uniform(-1, 1) * (upper_bound[i] - lower_bound[i]) * 0.05\n                else:\n                    new_harmony[i] = lower_bound[i] + np.random.rand() * (upper_bound[i] - lower_bound[i])\n\n            new_harmony = np.clip(new_harmony, lower_bound, upper_bound)\n            new_fitness = func(new_harmony)\n            self.fitness_evaluations += 1\n\n            if new_fitness < self.best_fitness:\n                self.best_fitness = new_fitness\n                self.best_harmony = new_harmony.copy()\n\n            if new_fitness < np.max(self.harmony_memory_fitness):\n                worst_idx = np.argmax(self.harmony_memory_fitness)\n                self.harmonies[worst_idx] = new_harmony\n                self.harmony_memory_fitness[worst_idx] = new_fitness\n\n        return self.best_harmony", "name": "QuantumInspiredHarmonySearch", "description": "Quantum-Inspired Harmony Search with Adaptive Dynamic Pitch Adjustment for Optimizing Photonic Structures.", "configspace": "", "generation": 61, "fitness": 0.28355688360786613, "feedback": "The algorithm QuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.28355688360786613]}, "mutation_prompt": null}
{"id": "22a20ab8-652e-4fd5-b398-169f96d3b38e", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n        self.diversity_threshold = 0.1  # Diversity-preserving threshold\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        def calculate_diversity(population):\n            mean_pos = np.mean(population, axis=0)\n            diversity = np.mean(np.linalg.norm(population - mean_pos, axis=1))\n            return diversity\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    diversity = calculate_diversity(self.particles)\n                    if diversity < self.diversity_threshold:\n                        quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                        self.particles[i] = quantum_exploration + 0.1 * np.random.randn(self.dim)  # Adding noise for exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative Differential Evolution integrates a progressive diversity-preserving mechanism and adaptive stochastic quantum walks to improve convergence in photonic structure optimization.", "configspace": "", "generation": 62, "fitness": 0.2664551727303197, "feedback": "The algorithm EnhancedQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2664551727303197]}, "mutation_prompt": null}
{"id": "a04e0ec0-93ba-420b-a568-6f31053886d2", "solution": "import numpy as np\n\nclass QuantumSwarmAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        \n        def adaptive_scale_factor(evals):\n            return 0.4 + 0.3 * np.cos(2 * np.pi * evals / self.budget)\n        \n        def adaptive_crossover_rate(evals):\n            return 0.8 - 0.4 * (evals / self.budget)\n\n        def transition_prob(evals):\n            return 0.4 - 0.3 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                if np.random.rand() < transition_prob(self.fitness_evaluations):\n                    self.particles[i] = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                \n                if np.random.rand() < 0.05 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.7\n                social_coeff = 1.5\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumSwarmAdaptiveDE", "description": "Quantum-Swarm Adaptive DE with Multi-phase Transition Search for Efficient Photonic Optimization.", "configspace": "", "generation": 63, "fitness": 0.2819996005375738, "feedback": "The algorithm QuantumSwarmAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2819996005375738]}, "mutation_prompt": null}
{"id": "6ff98cf7-ef57-4d7b-a242-731fc96fbba6", "solution": "import numpy as np\n\nclass QuantumAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.diversity_threshold = 0.2\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                local_neighborhood = self._select_neighborhood(i)\n                neighborhood_best = min(local_neighborhood, key=lambda x: func(self.particles[x]))\n\n                inertia_weight = 0.5 + 0.3 * np.random.rand()\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.particles[neighborhood_best] - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            quantum_exploration_prob = self._calculate_diversity() * 0.1\n            for i in range(self.population_size):\n                if np.random.rand() < quantum_exploration_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n        return self.global_best\n\n    def _select_neighborhood(self, index):\n        neighborhood_size = max(3, self.population_size // 10)\n        return np.random.choice(self.population_size, neighborhood_size, replace=False)\n\n    def _calculate_diversity(self):\n        mean_particle = np.mean(self.particles, axis=0)\n        diversity = np.mean(np.linalg.norm(self.particles - mean_particle, axis=1))\n        return diversity / (np.linalg.norm(self.particles[0]) + 1e-12)", "name": "QuantumAdaptiveSwarmOptimizer", "description": "Quantum-Inspired Adaptive Swarm Optimization with Dynamic Niching for Diverse Exploration in Photonic Design Space.", "configspace": "", "generation": 64, "fitness": 0.26525957998147276, "feedback": "The algorithm QuantumAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.26525957998147276]}, "mutation_prompt": null}
{"id": "2634332f-689e-4343-a1de-fa0593145620", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveGSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                # Evaluate fitness & update personal and global bests\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            # Quantum potential wells exploration\n            quantum_well_width = 0.1 * (upper_bound - lower_bound)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Quantum jump probability\n                    quantum_jump = lower_bound + np.random.rand(self.dim) * quantum_well_width\n                    self.particles[i] = quantum_jump\n\n            # Adaptive velocity update (Quantum-inspired)\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                inertia_weight = 0.5 + 0.4 * np.sin(2 * np.pi * self.fitness_evaluations / self.budget)\n                cognitive_coeff = 2.0\n                social_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            # Genetic-like crossover for diversity enhancement\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                partner_idx = np.random.randint(0, self.population_size)\n                crossover_prob = 0.6\n                mask = np.random.rand(self.dim) < crossover_prob\n                offspring = np.where(mask, self.particles[i], self.particles[partner_idx])\n                \n                offspring_fitness = func(offspring)\n                self.fitness_evaluations += 1\n\n                if offspring_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = offspring.copy()\n                    self.personal_best[i] = offspring.copy()\n                    self.personal_best_fitness[i] = offspring_fitness\n                    if offspring_fitness < self.global_best_fitness:\n                        self.global_best_fitness = offspring_fitness\n                        self.global_best = offspring.copy()\n\n        return self.global_best", "name": "QuantumInspiredAdaptiveGSO", "description": "Quantum-Inspired Adaptive Genetic Swarm Optimization that leverages quantum potential wells and adaptive learning to enhance search efficiency and accuracy in photonic structure optimization.", "configspace": "", "generation": 65, "fitness": 0.26776047653638113, "feedback": "The algorithm QuantumInspiredAdaptiveGSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.26776047653638113]}, "mutation_prompt": null}
{"id": "c7c0f3a8-2dc7-4dd0-af6f-bd186704f1b2", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def crowding_distance(self, particle, neighbors):\n        if len(neighbors) == 0:\n            return float('inf')\n        distances = np.linalg.norm(neighbors - particle, axis=1)\n        return np.min(distances)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n                if trial_fitness >= self.personal_best_fitness[i]:\n                    neighbors = np.array([self.particles[j] for j in range(self.population_size) if j != i])\n                    distance = self.crowding_distance(self.particles[i], neighbors)\n                    if distance > 0.2:  # Arbitrary threshold to maintain diversity\n                        self.particles[i] = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative Differential Evolution with Adaptive Archive, Dynamic Inertia, and Crowding Distance for Improved Diversity and Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 66, "fitness": 0.2862426982392956, "feedback": "The algorithm EnhancedQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2862426982392956]}, "mutation_prompt": null}
{"id": "4b768d2f-2e22-49aa-908f-cb5a573fc0a6", "solution": "import numpy as np\n\nclass QuantumChaosPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        def chaos_sequence(size):\n            x = 0.7  # initial value for logistic map\n            chaos = np.empty(size)\n            for i in range(size):\n                x = 4 * x * (1 - x)\n                chaos[i] = x\n            return chaos\n\n        chaos = chaos_sequence(self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 * chaos[self.fitness_evaluations % len(chaos)]\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = 0.5 + 0.3 * np.sin(2 * np.pi * self.fitness_evaluations / self.budget)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9 - 0.5 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumChaosPSO", "description": "Quantum-Inspired Particle Swarm with Adaptive Archive and Chaos-Driven Exploration for Robust Photonic Optimization.", "configspace": "", "generation": 67, "fitness": 0.2751996117540605, "feedback": "The algorithm QuantumChaosPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2751996117540605]}, "mutation_prompt": null}
{"id": "ed443b57-10ea-4f97-af6e-6c484c9e7375", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.05 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.2 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            elite_indices = np.argsort(self.personal_best_fitness)[:5]\n            elite_particles = self.personal_best[elite_indices]\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.7\n                social_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                elite_influence = np.mean(elite_particles, axis=0) - self.particles[i]\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + 0.1 * elite_influence\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-Collaborative Differential Evolution with Dynamic Quantum Tunneling and Elite Archival Strategy for Robust Photonic Structure Optimization.", "configspace": "", "generation": 68, "fitness": 0.2842592724091123, "feedback": "The algorithm EnhancedAdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2842592724091123]}, "mutation_prompt": null}
{"id": "307e1659-2cac-43f7-8251-e28009753dcd", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveMemoryEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.memory = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        def adaptive_scale_factor(evals):\n            return 0.5 + 0.4 * (1 - np.cos(2 * np.pi * evals / self.budget))\n\n        def adaptive_crossover_rate(evals):\n            return 0.8 - 0.4 * np.exp(-5 * evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.4 - 0.2 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.memory) < self.population_size:\n                    self.memory.append(self.particles[i].copy())\n                elif len(self.memory) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.memory[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.8 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.9\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.memory) > 3:\n                    memory_indices = np.random.choice(len(self.memory), 3, replace=False)\n                    a, b, c = self.memory[memory_indices[0]], self.memory[memory_indices[1]], self.memory[memory_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumInspiredAdaptiveMemoryEvolution", "description": "Quantum-Inspired Adaptive Memory Evolution (QAME) integrates quantum-inspired initialization with adaptive memory-based mutation and recombination, tailored for photonic structure optimization.", "configspace": "", "generation": 69, "fitness": 0.2803941782165714, "feedback": "The algorithm QuantumInspiredAdaptiveMemoryEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2803941782165714]}, "mutation_prompt": null}
{"id": "8d13cb53-0094-4dd8-83a5-8bbe27484553", "solution": "import numpy as np\n\nclass QuantumDynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        def adaptive_quantum_prob(evals):\n            return 0.4 - 0.2 * (evals / self.budget)\n\n        def adaptive_inertia_weight(evals):\n            return 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                if np.random.rand() < adaptive_quantum_prob(self.fitness_evaluations):\n                    neighborhood = np.random.choice(self.population_size, size=3, replace=False)\n                    quantum_jump = np.mean(self.particles[neighborhood], axis=0)\n                    self.particles[i] = lower_bound + np.random.rand(self.dim) * (quantum_jump - lower_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = adaptive_inertia_weight(self.fitness_evaluations)\n                cognitive_coeff = 1.5\n                social_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "QuantumDynamicSwarmOptimization", "description": "Quantum-Assisted Dynamic Swarm Optimization with Adaptive Neighborhoods for Efficient Photonic Design.", "configspace": "", "generation": 70, "fitness": 0.2673030884667371, "feedback": "The algorithm QuantumDynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2673030884667371]}, "mutation_prompt": null}
{"id": "db963764-771e-4720-ba84-3fe77c69c46c", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.4 - 0.2 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.7\n                social_coeff = 1.9\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative Differential Evolution with Dynamic Quantum Jumps, Adaptive Memetic Search, and Stochastic Fitness Selection for Optimized Photonic Structures.", "configspace": "", "generation": 71, "fitness": 0.28017320328696693, "feedback": "The algorithm EnhancedQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.28017320328696693]}, "mutation_prompt": null}
{"id": "434a37d6-a893-4593-adde-25db22310653", "solution": "import numpy as np\n\nclass QuantumMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.swarms = 3\n        self.particles_per_swarm = self.population_size // self.swarms\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archives = [[] for _ in range(self.swarms)]\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.cos(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for swarm in range(self.swarms):\n                for i in range(swarm * self.particles_per_swarm, (swarm + 1) * self.particles_per_swarm):\n                    if self.fitness_evaluations >= self.budget:\n                        break\n\n                    fitness = func(self.particles[i])\n                    self.fitness_evaluations += 1\n\n                    if fitness < self.personal_best_fitness[i]:\n                        self.personal_best_fitness[i] = fitness\n                        self.personal_best[i] = self.particles[i].copy()\n\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best = self.particles[i].copy()\n\n                    quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                    if np.random.rand() < quantum_jump_prob:\n                        quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                        self.particles[i] = quantum_exploration\n\n                    if np.random.rand() < 0.05 and len(self.archives[swarm]) < self.particles_per_swarm:\n                        self.archives[swarm].append(self.particles[i].copy())\n                    elif len(self.archives[swarm]) == self.particles_per_swarm:\n                        worst_idx = np.argmax(self.personal_best_fitness[swarm * self.particles_per_swarm:(swarm + 1) * self.particles_per_swarm])\n                        global_idx = swarm * self.particles_per_swarm + worst_idx\n                        if fitness < self.personal_best_fitness[global_idx]:\n                            self.archives[swarm][worst_idx] = self.particles[i].copy()\n\n            for swarm in range(self.swarms):\n                for i in range(swarm * self.particles_per_swarm, (swarm + 1) * self.particles_per_swarm):\n                    if self.fitness_evaluations >= self.budget:\n                        break\n\n                    inertia_weight = 0.6 - 0.3 * (self.fitness_evaluations / self.budget)\n                    cognitive_coeff = 1.7\n                    social_coeff = 2.0\n                    r1, r2 = np.random.rand(), np.random.rand()\n\n                    cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                    social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                    self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for swarm in range(self.swarms):\n                for i in range(swarm * self.particles_per_swarm, (swarm + 1) * self.particles_per_swarm):\n                    if self.fitness_evaluations >= self.budget:\n                        break\n\n                    if len(self.archives[swarm]) > 3:\n                        archive_indices = np.random.choice(len(self.archives[swarm]), 3, replace=False)\n                        a, b, c = self.archives[swarm][archive_indices[0]], self.archives[swarm][archive_indices[1]], self.archives[swarm][archive_indices[2]]\n                    else:\n                        indices = np.random.choice(self.particles_per_swarm, 3, replace=False)\n                        a, b, c = self.particles[swarm * self.particles_per_swarm + indices[0]], self.particles[swarm * self.particles_per_swarm + indices[1]], self.particles[swarm * self.particles_per_swarm + indices[2]]\n\n                    F = adaptive_scale_factor(self.fitness_evaluations)\n                    mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                    crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                    crossover_indices = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                    trial_fitness = func(trial)\n                    self.fitness_evaluations += 1\n\n                    if trial_fitness < self.personal_best_fitness[i]:\n                        self.particles[i] = trial.copy()\n                        self.personal_best[i] = trial.copy()\n                        self.personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < self.global_best_fitness:\n                            self.global_best_fitness = trial_fitness\n                            self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumMultiSwarmOptimizer", "description": "Quantum-Inspired Multi-Swarm Optimization with Adaptive Learning and Dynamic Niching for Enhanced Photonic Structure Optimization.", "configspace": "", "generation": 72, "fitness": 0.2725209065758728, "feedback": "The algorithm QuantumMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2725209065758728]}, "mutation_prompt": null}
{"id": "9b6c2eb4-b52e-4d2d-be46-aaa5692b3199", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n        max_archive_size = int(self.population_size / 2) # Dynamic archive size\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.1 and len(self.archive) < max_archive_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == max_archive_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-Collaborative DE with Dynamic Archive Size and Multi-strategy Exploration to Optimize Photonic Structures.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list assignment index out of range').", "error": "IndexError('list assignment index out of range')", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {}, "mutation_prompt": null}
{"id": "1e672479-23d1-4924-9661-a1009aeea2d3", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.4 * (evals / self.budget)\n        stochastic_memory_weight = lambda: 0.5 + 0.5 * np.random.rand()\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.3 - 0.2 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.2:\n                    if len(self.archive) < self.population_size:\n                        self.archive.append(self.particles[i].copy())\n                    else:\n                        worst_idx = np.argmax(self.personal_best_fitness)\n                        if fitness < self.personal_best_fitness[worst_idx]:\n                            self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.6 - 0.2 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.7\n                social_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations) * stochastic_memory_weight()\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative Differential Evolution with Variable Quantum Exploration, Stochastic Memory Archive, and Adaptive Parameter Tuning.", "configspace": "", "generation": 74, "fitness": 0.2821498915319529, "feedback": "The algorithm EnhancedQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2821498915319529]}, "mutation_prompt": null}
{"id": "ae3763df-10d3-4a1e-9bb3-839493e3d931", "solution": "import numpy as np\n\nclass QuantumInspiredMemetic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def chaotic_local_search(self, position, func, lower_bound, upper_bound):\n        beta = 0.1\n        steps = int(np.sqrt(self.dim))\n        best_position = position.copy()\n        best_fitness = func(best_position)\n\n        for _ in range(steps):\n            perturbation = (np.random.rand(self.dim) - 0.5) * 2 * beta * (upper_bound - lower_bound)\n            candidate = np.clip(position + perturbation, lower_bound, upper_bound)\n            candidate_fitness = func(candidate)\n            self.fitness_evaluations += 1\n            if candidate_fitness < best_fitness:\n                best_fitness = candidate_fitness\n                best_position = candidate.copy()\n            beta *= 0.9  # Chaotic decay\n            if self.fitness_evaluations >= self.budget:\n                break\n\n        return best_position, best_fitness\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.5 + (0.9 - 0.5) * (1 - self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.4\n                social_coeff = 1.6\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.2:  # Probability for local search\n                    local_position, local_fitness = self.chaotic_local_search(self.particles[i], func, lower_bound, upper_bound)\n                    if local_fitness < self.personal_best_fitness[i]:\n                        self.particles[i] = local_position.copy()\n                        self.personal_best[i] = local_position.copy()\n                        self.personal_best_fitness[i] = local_fitness\n                        if local_fitness < self.global_best_fitness:\n                            self.global_best_fitness = local_fitness\n                            self.global_best = local_position.copy()\n\n        return self.global_best", "name": "QuantumInspiredMemetic", "description": "Quantum-Inspired Memetic Algorithm with Chaotic Local Search for Efficient Photonic Structure Optimization.", "configspace": "", "generation": 75, "fitness": 0.27082882486874427, "feedback": "The algorithm QuantumInspiredMemetic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.27082882486874427]}, "mutation_prompt": null}
{"id": "75622b30-3f48-40e7-8720-cc8f8407c65e", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n        self.local_search_prob = 0.2\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.7 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.2 - 0.1 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < self.local_search_prob:\n                    local_exploration = self.particles[i] + 0.05 * np.random.normal(size=self.dim)\n                    self.particles[i] = np.clip(local_exploration, lower_bound, upper_bound)\n\n                if np.random.rand() < 0.1 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.8 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative Differential Evolution with Adaptive Inertia and Dynamic Mutation for Robust Photonic Structure Optimization.", "configspace": "", "generation": 76, "fitness": 0.28162268721623296, "feedback": "The algorithm EnhancedQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.28162268721623296]}, "mutation_prompt": null}
{"id": "56068ce2-005f-4530-af2f-bd179aa57360", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.positions = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.positions.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.positions[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.positions[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                \n                inertia_weight = 0.5 + 0.4 * np.random.rand()\n                cognitive_coeff = 1.5\n                social_coeff = 1.8\n                quantum_coeff = 0.1 * np.sin(2 * np.pi * self.fitness_evaluations / self.budget)\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.positions[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.positions[i])\n                quantum_velocity = quantum_coeff * (np.random.uniform(lower_bound, upper_bound, self.dim) - self.positions[i])\n                \n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + quantum_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                neighborhood_size = max(1, int(self.population_size * (1 - self.fitness_evaluations / self.budget)))\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                \n                best_neighbor = min(neighbors, key=lambda idx: func(self.positions[idx]))\n                if func(self.positions[best_neighbor]) < fitness:\n                    self.positions[i] = self.positions[best_neighbor]\n\n        return self.global_best", "name": "QuantumInspiredAdaptiveSwarm", "description": "Quantum-Inspired Adaptive Swarm Optimization with Dynamic Neighborhood Search for Enhanced Photonic Structure Optimization.", "configspace": "", "generation": 77, "fitness": 0.26522489959063134, "feedback": "The algorithm QuantumInspiredAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.26522489959063134]}, "mutation_prompt": null}
{"id": "233ea35e-bb8a-49dc-b64a-75e8f7d5b914", "solution": "import numpy as np\n\nclass EnhancedQuantumCollaborativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.particles.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.archive = []\n        self.convergence_threshold = 0.001\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.cos(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i] - self.convergence_threshold:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness - self.convergence_threshold:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.particles[i].copy()\n\n                quantum_jump_prob = 0.4 - 0.2 * (self.fitness_evaluations / self.budget)\n                if np.random.rand() < quantum_jump_prob:\n                    quantum_exploration = lower_bound + np.random.rand(self.dim) * (upper_bound - lower_bound)\n                    self.particles[i] = quantum_exploration\n\n                if np.random.rand() < 0.15 and len(self.archive) < self.population_size:\n                    self.archive.append(self.particles[i].copy())\n                elif len(self.archive) == self.population_size:\n                    worst_idx = np.argmax(self.personal_best_fitness)\n                    if fitness < self.personal_best_fitness[worst_idx]:\n                        self.archive[worst_idx] = self.particles[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                inertia_weight = 0.8 - 0.5 * (self.fitness_evaluations / self.budget)\n                cognitive_coeff = 1.6\n                social_coeff = 2.0\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                if len(self.archive) > 3:\n                    archive_indices = np.random.choice(len(self.archive), 3, replace=False)\n                    a, b, c = self.archive[archive_indices[0]], self.archive[archive_indices[1]], self.archive[archive_indices[2]]\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.particles[indices[0]], self.particles[indices[1]], self.particles[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.particles[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.particles[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "EnhancedQuantumCollaborativeDE", "description": "Enhanced Quantum-Collaborative DE with Dynamic Adaptive Strategies and Control Mechanism for Improved Exploration and Exploitation Balance in Photonic Optimization.", "configspace": "", "generation": 78, "fitness": 0.2784736315353916, "feedback": "The algorithm EnhancedQuantumCollaborativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2784736315353916]}, "mutation_prompt": null}
{"id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "solution": "import numpy as np\n\nclass QuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "QuantumLevyAdaptiveDE", "description": "Quantum-Inspired Levy Flight with Adaptive Differential Evolution for Robust Global Optimization in Photonic Structures.", "configspace": "", "generation": 79, "fitness": 0.2972781850219124, "feedback": "The algorithm QuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "4e8dd741-6e7f-42e5-80a3-1047fc7d3ea9", "metadata": {"aucs": [0.2972781850219124]}, "mutation_prompt": null}
{"id": "8646296a-f650-4815-a9e5-a11664c3e886", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.init_population_size = 60\n        self.population_size = self.init_population_size\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def resize_population(self):\n        factor = 1.0 - (self.fitness_evaluations / self.budget)\n        self.population_size = max(20, int(self.init_population_size * factor))\n        self.individuals = self.individuals[:self.population_size]\n        self.personal_best = self.personal_best[:self.population_size]\n        self.personal_best_fitness = self.personal_best_fitness[:self.population_size]\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.3 * np.cos(np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.5 + 0.5 * np.sin(2 * np.pi * evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            self.resize_population()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    step_size = np.tanh(self.fitness_evaluations / self.budget) * levy_step\n                    self.individuals[i] += step_size * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "QuantumEnhancedAdaptiveDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Population Resizing and Adaptive Levy Step for Efficient Global Optimization in Photonic Structures.", "configspace": "", "generation": 80, "fitness": 0.27099711598175447, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.27099711598175447]}, "mutation_prompt": null}
{"id": "dbe461e8-3e7a-4eb2-a1f8-ac7585e7467d", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.cos(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.4:  # Increased probability for Levy steps\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n            # Self-adaptive mutation strategy\n            if self.fitness_evaluations / self.budget > 0.75:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # Apply additional mutation at a reduced rate\n                        mutation_vector = np.random.normal(0, 0.1, self.dim)\n                        self.individuals[i] = np.clip(self.individuals[i] + mutation_vector, lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight with Adaptive Differential Evolution incorporating Self-Adaptive Mutation Strategies for Improved Exploration and Exploitation in Photonic Structure Optimization.", "configspace": "", "generation": 81, "fitness": 0.2730530430905225, "feedback": "The algorithm EnhancedQuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2730530430905225]}, "mutation_prompt": null}
{"id": "31ae5073-0d48-4289-86fe-270b57b0cdc6", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 60\n        self.population_size = self.initial_population_size\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def dynamic_population_size(self):\n        return int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * self.fitness_evaluations / self.budget)))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            self.population_size = self.dynamic_population_size()\n            self.individuals = np.clip(self.individuals[:self.population_size], lower_bound, upper_bound)\n            self.personal_best = self.personal_best[:self.population_size]\n            self.personal_best_fitness = self.personal_best_fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight with Adaptive Differential Evolution using Dynamic Population Sizing for Efficient Global Optimization in Photonic Structures.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {}, "mutation_prompt": null}
{"id": "065422da-929a-428a-a011-422ccaa94d6e", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 60\n        self.population_size = self.initial_population_size\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            reduction_factor = 1 - (self.fitness_evaluations / self.budget)\n            self.population_size = max(10, int(self.initial_population_size * reduction_factor))\n            self.individuals = self.individuals[:self.population_size]\n            self.personal_best = self.personal_best[:self.population_size]\n            self.personal_best_fitness = self.personal_best_fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight with Adaptive Differential Evolution using Dynamic Population Size for Improved Global Optimization of Photonic Structures.", "configspace": "", "generation": 83, "fitness": 0.2972781850219124, "feedback": "The algorithm EnhancedQuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2972781850219124]}, "mutation_prompt": null}
{"id": "3dc77dd1-f001-44d8-a170-de4428fe35da", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n    \n    def adaptive_gaussian_perturbation(self, evals, dim):\n        std_dev = 0.1 * (1 - evals / self.budget)\n        return np.random.normal(0, std_dev, size=dim)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n                \n                # Apply adaptive Gaussian perturbation\n                trial += self.adaptive_gaussian_perturbation(self.fitness_evaluations, self.dim)\n                trial = np.clip(trial, lower_bound, upper_bound)\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight with Differential Evolution using Adaptive Gaussian Perturbation for Improved Convergence in Photonic Optimization.", "configspace": "", "generation": 84, "fitness": 0.2705085620817941, "feedback": "The algorithm EnhancedQuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2705085620817941]}, "mutation_prompt": null}
{"id": "479fa5ce-e509-4537-81cc-c00cc00472f4", "solution": "import numpy as np\n\nclass QuantumLevyFireflyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.light_intensity = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_intensity = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def move_firefly(self, i, j, alpha, beta, gamma):\n        distance = np.linalg.norm(self.individuals[i] - self.individuals[j])\n        attractiveness = beta * np.exp(-gamma * distance**2)\n        random_factor = alpha * (np.random.rand(self.dim) - 0.5)\n        move = attractiveness * (self.individuals[j] - self.individuals[i]) + random_factor\n        return move\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        alpha = 0.5\n        beta_base = 0.2\n        gamma = 1.0\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n                if fitness < self.light_intensity[i]:\n                    self.light_intensity[i] = fitness\n                    if fitness < self.best_intensity:\n                        self.best_intensity = fitness\n                        self.best_solution = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if self.light_intensity[j] < self.light_intensity[i]:\n                        move = self.move_firefly(i, j, alpha, beta_base, gamma)\n                        self.individuals[i] = np.clip(self.individuals[i] + move, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = 0.8\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.light_intensity[i]:\n                    self.individuals[i] = trial.copy()\n                    self.light_intensity[i] = trial_fitness\n                    if trial_fitness < self.best_intensity:\n                        self.best_intensity = trial_fitness\n                        self.best_solution = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.best_solution)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.best_solution", "name": "QuantumLevyFireflyDE", "description": "Quantum-Inspired Firefly with Levy-Enhanced Differential Evolution for Improved Exploration and Exploitation in Photonic Structures.", "configspace": "", "generation": 85, "fitness": 0.27627440427962435, "feedback": "The algorithm QuantumLevyFireflyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.27627440427962435]}, "mutation_prompt": null}
{"id": "c7aa3900-70ae-4ee1-ae6f-74fbfb7c051c", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.memory_archive = []\n        self.archive_size = self.population_size // 2\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def adaptive_mutation(self, evals):\n        return 0.6 + 0.3 * (1 - evals / self.budget)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n                if len(self.memory_archive) < self.archive_size:\n                    self.memory_archive.append((self.individuals[i].copy(), fitness))\n                else:\n                    worst_idx = np.argmax([fit for _, fit in self.memory_archive])\n                    if fitness < self.memory_archive[worst_idx][1]:\n                        self.memory_archive[worst_idx] = (self.individuals[i].copy(), fitness)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations) * self.adaptive_mutation(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Levy with Dynamic Memory Archive and Adaptive Mutation for Superior Global Optimization in Photonic Structures.", "configspace": "", "generation": 86, "fitness": 0.2972781850219124, "feedback": "The algorithm EnhancedQuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2972781850219124]}, "mutation_prompt": null}
{"id": "5add90ba-b181-4f43-9d35-21154c141197", "solution": "import numpy as np\n\nclass QuantumLevySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 60\n        self.particles = np.random.uniform(size=(self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, size=(self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.global_best_position = None\n        self.personal_best_fitness = np.full(self.swarm_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        def inertia_weight(evals):\n            return 0.9 - 0.5 * (evals / self.budget)\n\n        def cognitive_coeff(evals):\n            return 2.5 - 1.5 * (evals / self.budget)\n\n        def social_coeff(evals):\n            return 0.5 + 1.5 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.particles[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best_positions[i] = self.particles[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best_position = self.particles[i].copy()\n\n            for i in range(self.swarm_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                w = inertia_weight(self.fitness_evaluations)\n                c1 = cognitive_coeff(self.fitness_evaluations)\n                c2 = social_coeff(self.fitness_evaluations)\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_component = c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = c2 * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = w * self.velocities[i] + cognitive_component + social_component\n\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.particles[i] += levy_step * (self.particles[i] - self.global_best_position)\n                    self.particles[i] = np.clip(self.particles[i], lower_bound, upper_bound)\n\n        return self.global_best_position", "name": "QuantumLevySwarmOptimization", "description": "Adaptive Quantum-Inspired Swarm Optimization with Levy Flights and Dynamic Inertia for Efficient Optimization of Photonic Structures.", "configspace": "", "generation": 87, "fitness": 0.28036011206537315, "feedback": "The algorithm QuantumLevySwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.28036011206537315]}, "mutation_prompt": null}
{"id": "e0ada02e-536c-4618-b6ec-7038083db2ee", "solution": "import numpy as np\n\nclass QuantumChaosDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def chaos_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.8 - 0.5 * (evals / self.budget)\n\n        chaos = np.random.uniform(size=self.population_size)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                tournament = indices[np.argsort([self.personal_best_fitness[j] for j in indices])[:3]]\n                a, b, c = self.individuals[tournament[0]], self.individuals[tournament[1]], self.individuals[tournament[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                chaos[i] = self.chaos_map(chaos[i])\n                levy_step = chaos[i] * (self.individuals[i] - self.global_best)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "QuantumChaosDE", "description": "Hybrid Quantum Chaos-inspired Differential Evolution with Adaptive Tournament Selection for Efficient Photonic Structure Optimization.", "configspace": "", "generation": 88, "fitness": 0.2772187966501004, "feedback": "The algorithm QuantumChaosDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2772187966501004]}, "mutation_prompt": null}
{"id": "ad198b8f-76e8-4505-acbe-1a29d7cb1f87", "solution": "import numpy as np\n\nclass QuantumHarmonyDynamicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.dynamic_memory = self.individuals.copy()\n        self.global_best = None\n        self.dynamic_memory_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def tune_parameters(self, evals):\n        HMCR = 0.9 - 0.6 * (evals / self.budget)\n        PAR = 0.1 + 0.4 * np.cos(np.pi * evals / self.budget)\n        beta = 0.6 + 0.4 * np.sin(2 * np.pi * evals / self.budget)\n        return HMCR, PAR, beta\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        \n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.dynamic_memory_fitness[i]:\n                    self.dynamic_memory_fitness[i] = fitness\n                    self.dynamic_memory[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            new_population = []\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                \n                HMCR, PAR, beta = self.tune_parameters(self.fitness_evaluations)\n                \n                harmony_candidate = np.where(np.random.rand(self.dim) < HMCR, \n                                             self.dynamic_memory[np.random.choice(self.population_size)], \n                                             np.random.uniform(lower_bound, upper_bound, self.dim))\n                \n                if np.random.rand() < PAR:\n                    harmony_candidate += beta * (np.random.rand(self.dim) - 0.5)\n\n                harmony_candidate = np.clip(harmony_candidate, lower_bound, upper_bound)\n                new_population.append(harmony_candidate)\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = np.random.uniform(0.5, 0.8)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = 0.9 - 0.3 * (self.fitness_evaluations / self.budget)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, new_population[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.dynamic_memory_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.dynamic_memory[i] = trial.copy()\n                    self.dynamic_memory_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n        return self.global_best", "name": "QuantumHarmonyDynamicDE", "description": "Quantum-inspired Harmony Search with Dynamic Differential Evolution for Efficient Global Optimization in Photonic Structures.", "configspace": "", "generation": 89, "fitness": 0.27505238765177087, "feedback": "The algorithm QuantumHarmonyDynamicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.27505238765177087]}, "mutation_prompt": null}
{"id": "6e3c7eea-97dd-408a-8b6b-c298533ae55b", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 60\n        self.individuals = np.random.uniform(size=(self.initial_population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.initial_population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.success_count = 0\n        self.failed_attempts = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def adaptive_parameters(self):\n        base_F = 0.6 + 0.2 * np.sin(2 * np.pi * self.fitness_evaluations / self.budget)\n        base_CR = 0.7 - 0.4 * (self.fitness_evaluations / self.budget)\n        F = min(1, max(0, base_F + 0.1 * (self.success_count / (self.success_count + self.failed_attempts + 1))))\n        CR = min(1, max(0, base_CR + 0.1 * (self.failed_attempts / (self.success_count + self.failed_attempts + 1))))\n        return F, CR\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        population_size = self.initial_population_size\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n                    self.success_count += 1\n                else:\n                    self.failed_attempts += 1\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            F, CR = self.adaptive_parameters()\n\n            for i in range(population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_indices = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    self.success_count += 1\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n                else:\n                    self.failed_attempts += 1\n\n            for i in range(population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n            if self.success_count > self.failed_attempts:\n                population_size = min(self.initial_population_size + 10, 100)\n            else:\n                population_size = max(self.initial_population_size - 10, 20)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight with Adaptive Differential Evolution incorporating Dynamic Population Sizing and Success-based Parameter Adaptation for superior Global Optimization in Photonic Structures.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {}, "mutation_prompt": null}
{"id": "66536701-dc46-4034-93e8-02e6e2e87662", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 60\n        self.population_size = self.initial_population_size\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def dynamic_population_adjustment(self):\n        # Reduce the population size dynamically after 50% of the budget is used\n        if self.fitness_evaluations > 0.5 * self.budget:\n            self.population_size = max(10, self.population_size // 2)\n            self.individuals = self.individuals[:self.population_size]\n            self.personal_best = self.personal_best[:self.population_size]\n            self.personal_best_fitness = self.personal_best_fitness[:self.population_size]\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            self.dynamic_population_adjustment()\n            \n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight with Adaptive Differential Evolution and Dynamic Population Management for Improved Global Optimization in Photonic Structures.", "configspace": "", "generation": 91, "fitness": 0.2972781850219124, "feedback": "The algorithm EnhancedQuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2972781850219124]}, "mutation_prompt": null}
{"id": "4c1e8082-1b86-481a-a53f-52be1823e224", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.dynamic_population = True\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def gradient_local_search(self, individual, func):\n        local_result = minimize(func, individual, method='L-BFGS-B', bounds=[(l, u) for l, u in zip(func.bounds.lb, func.bounds.ub)], tol=1e-6)\n        return local_result.x, local_result.fun\n\n    def update_population_size(self):\n        if self.dynamic_population:\n            rate = 0.05 * (1 - self.fitness_evaluations / self.budget)\n            self.population_size = max(20, int(60 * (1 - rate)))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n            # Perform gradient-based local search on the global best\n            refined_solution, refined_fitness = self.gradient_local_search(self.global_best, func)\n            if refined_fitness < self.global_best_fitness:\n                self.global_best_fitness = refined_fitness\n                self.global_best = refined_solution\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight with Adaptive Differential Evolution using Dynamic Population and Gradient-Based Local Search for Photonic Structures.", "configspace": "", "generation": 92, "fitness": 0.2938152204076169, "feedback": "The algorithm EnhancedQuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2938152204076169]}, "mutation_prompt": null}
{"id": "fc9e3f63-864d-4a8a-9ffc-cb30f930e7fe", "solution": "import numpy as np\n\nclass QuantumEnhancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(size=(self.population_size, dim)) * 0.1\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n\n    def quantum_mutation(self, L, scale):\n        tau = scale / np.sqrt(self.dim)\n        return np.random.normal(0, tau, size=L)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n        \n        inertia_weight = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n        cognitive_component = lambda evals: 1.5 + 1.0 * (evals / self.budget)\n        social_component = lambda evals: 1.5 - 1.0 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                \n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n            \n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n                \n                inertia = inertia_weight(self.fitness_evaluations)\n                cognitive = cognitive_component(self.fitness_evaluations)\n                social = social_component(self.fitness_evaluations)\n\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocities[i] = (inertia * self.velocities[i] +\n                                      cognitive * r1 * (self.personal_best[i] - self.individuals[i]) +\n                                      social * r2 * (self.global_best - self.individuals[i]))\n                \n                self.individuals[i] += self.velocities[i]\n                self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n                quantum_step = self.quantum_mutation(self.dim, self.fitness_evaluations / self.budget)\n                if np.random.rand() < 0.2:\n                    self.individuals[i] += quantum_step\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "QuantumEnhancedSwarmOptimization", "description": "Quantum-Enhanced Swarm Optimization with Multi-Scale Mutation and Dynamic Neighborhood Adaptation for High-Dimensional Problem Solving.", "configspace": "", "generation": 93, "fitness": 0.2681312404365943, "feedback": "The algorithm QuantumEnhancedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2681312404365943]}, "mutation_prompt": null}
{"id": "4a80584e-ac4b-4d50-aa7e-cc73a3d6c3e3", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.dynamic_population_size = self.population_size\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def dynamic_population_control(self):\n        reduction_factor = int(self.budget * 0.1)  # Reduce the population by 10% of the budget\n        if self.fitness_evaluations % reduction_factor == 0 and self.dynamic_population_size > 10:\n            self.dynamic_population_size = int(self.dynamic_population_size * 0.9)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            self.dynamic_population_control()\n            \n            for i in range(self.dynamic_population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.dynamic_population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.dynamic_population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations)\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.dynamic_population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyAdaptiveDE", "description": "Enhanced Quantum-Inspired Levy Flight and Adaptive Differential Evolution with Dynamic Population Control for Optimized Global Convergence in Photonic Structures.", "configspace": "", "generation": 94, "fitness": 0.2975410681497709, "feedback": "The algorithm EnhancedQuantumLevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "2d67419e-5b5e-4787-b949-ae20899a8f64", "metadata": {"aucs": [0.2975410681497709]}, "mutation_prompt": null}
{"id": "0ce498ac-f38e-47e9-a858-7049f312204b", "solution": "import numpy as np\n\nclass QuantumLevyMemoryAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.memory_factor = np.random.uniform(0.4, 0.9, self.population_size)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations) * (1.0 - self.memory_factor[i])\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "QuantumLevyMemoryAdaptiveDE", "description": "A Quantum Levy and Adaptive DE hybrid with Stochastic Weighting and Memory Mechanisms for Enhanced Exploration and Exploitation in Photonic Structure Optimization.", "configspace": "", "generation": 95, "fitness": 0.29762408930989903, "feedback": "The algorithm QuantumLevyMemoryAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "4a80584e-ac4b-4d50-aa7e-cc73a3d6c3e3", "metadata": {"aucs": [0.29762408930989903]}, "mutation_prompt": null}
{"id": "f468333e-a125-4d7a-954a-6d7f4a213472", "solution": "import numpy as np\n\nclass EnhancedQuantumLevyMemoryAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.memory_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.memory_decay_rate = 0.95  # New dynamic memory decay rate\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def update_memory_factor(self, i, success):\n        if success:\n            self.memory_factor[i] = self.memory_decay_rate * self.memory_factor[i] + (1 - self.memory_decay_rate) * np.random.uniform(0.7, 0.9)\n        else:\n            self.memory_factor[i] = self.memory_decay_rate * self.memory_factor[i] + (1 - self.memory_decay_rate) * np.random.uniform(0.4, 0.6)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        adaptive_scale_factor = lambda evals: 0.6 + 0.2 * np.sin(2 * np.pi * evals / self.budget)\n        adaptive_crossover_rate = lambda evals: 0.7 - 0.4 * (evals / self.budget)\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.individuals[indices[0]], self.individuals[indices[1]], self.individuals[indices[2]]\n\n                F = adaptive_scale_factor(self.fitness_evaluations) * (1.0 - self.memory_factor[i])\n                mutant = np.clip(a + F * (b - c), lower_bound, upper_bound)\n                crossover_rate = adaptive_crossover_rate(self.fitness_evaluations)\n                crossover_indices = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_indices, mutant, self.individuals[i])\n\n                trial_fitness = func(trial)\n                self.fitness_evaluations += 1\n\n                successful_update = False\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.individuals[i] = trial.copy()\n                    self.personal_best[i] = trial.copy()\n                    self.personal_best_fitness[i] = trial_fitness\n                    successful_update = True\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial.copy()\n\n                self.update_memory_factor(i, successful_update)\n\n            for i in range(self.population_size):\n                levy_step = self.levy_flight(self.dim)\n                if np.random.rand() < 0.3:\n                    self.individuals[i] += levy_step * (self.individuals[i] - self.global_best)\n                    self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n        return self.global_best", "name": "EnhancedQuantumLevyMemoryAdaptiveDE", "description": "Enhanced Quantum Levy Memory Adaptive DE with Novel Dynamic Memory Mechanism for Improved Adaptation and Exploration in Photonic Structure Optimization.", "configspace": "", "generation": 96, "fitness": 0.2975743364122735, "feedback": "The algorithm EnhancedQuantumLevyMemoryAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "0ce498ac-f38e-47e9-a858-7049f312204b", "metadata": {"aucs": [0.2975743364122735]}, "mutation_prompt": null}
{"id": "6abf24c9-3144-4a6d-b291-3f6a90375ef4", "solution": "import numpy as np\n\nclass QuantumAntColonyOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_ants = 50\n        self.pheromone = np.ones((self.num_ants, dim))\n        self.best_path = None\n        self.best_path_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.memory = np.random.uniform(0.1, 0.5, self.num_ants)\n        self.evaporation_rate = 0.2\n\n    def quantum_noise(self):\n        return np.random.uniform(-1, 1, size=self.dim)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            all_paths = []\n            all_fitnesses = []\n\n            for ant in range(self.num_ants):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                path = np.random.normal(self.pheromone[ant], scale=self.memory[ant])\n                path = np.clip(path, lower_bound, upper_bound)\n\n                fitness = func(path)\n                self.fitness_evaluations += 1\n\n                all_paths.append(path)\n                all_fitnesses.append(fitness)\n\n                if fitness < self.best_path_fitness:\n                    self.best_path_fitness = fitness\n                    self.best_path = path.copy()\n\n            # Update pheromone trails based on fitness\n            for ant in range(self.num_ants):\n                if all_fitnesses[ant] < self.best_path_fitness:\n                    self.pheromone[ant] = (1 - self.evaporation_rate) * self.pheromone[ant] + self.evaporation_rate * (all_paths[ant] - self.best_path)\n\n                # Introduce quantum-based random exploration\n                if np.random.rand() < 0.1:\n                    self.pheromone[ant] += self.quantum_noise()\n\n        return self.best_path", "name": "QuantumAntColonyOptimization", "description": "Quantum-Inspired Ant Colony Optimization with Adaptive Evaporation and Memory-Driven Path Reinforcement for Robust Global Exploration in Photonic Structures.", "configspace": "", "generation": 97, "fitness": 0.2664968712099389, "feedback": "The algorithm QuantumAntColonyOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "0ce498ac-f38e-47e9-a858-7049f312204b", "metadata": {"aucs": [0.2664968712099389]}, "mutation_prompt": null}
{"id": "4631778e-43ad-483f-a787-b9fc163be90f", "solution": "import numpy as np\n\nclass StochasticGradientLevyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.inertia_weight = 0.9\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def adaptive_mutation(self, individual, global_best, evals):\n        mutation_rate = 0.05 + 0.45 * (1 - evals / self.budget)\n        if np.random.rand() < mutation_rate:\n            levy_step = self.levy_flight(self.dim)\n            mutation = individual + levy_step * (global_best - individual)\n            return mutation\n        return individual\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best[i] - self.individuals[i])\n                social_velocity = self.social_component * r2 * (self.global_best - self.individuals[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.individuals[i] += self.velocities[i]\n                self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n                self.individuals[i] = self.adaptive_mutation(self.individuals[i], self.global_best, self.fitness_evaluations)\n\n        return self.global_best", "name": "StochasticGradientLevyPSO", "description": "Stochastic Gradient-Inspired Levy PSO with Adaptive Mutation for Robust Exploration and Convergence in Photonic Optimization.", "configspace": "", "generation": 98, "fitness": 0.3163558267835964, "feedback": "The algorithm StochasticGradientLevyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.00.", "error": "", "parent_id": "0ce498ac-f38e-47e9-a858-7049f312204b", "metadata": {"aucs": [0.3163558267835964]}, "mutation_prompt": null}
{"id": "585c79bd-7cba-467c-997e-5c0e5838d0b5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemoryPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.individuals = np.random.uniform(size=(self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best = self.individuals.copy()\n        self.global_best = None\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.fitness_evaluations = 0\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.inertia_weight = 0.9\n        self.memory_factor = 0.05\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def adaptive_mutation(self, individual, global_best, evals):\n        mutation_rate = self.memory_factor + 0.45 * (1 - evals / self.budget)\n        if np.random.rand() < mutation_rate:\n            levy_step = self.levy_flight(self.dim)\n            mutation = individual + levy_step * (global_best - individual)\n            return np.clip(mutation, 0, 1)\n        return individual\n\n    def update_inertia_weight(self):\n        self.inertia_weight = 0.9 - 0.5 * (self.fitness_evaluations / self.budget)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        lower_bound, upper_bound = bounds[0], bounds[1]\n\n        while self.fitness_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                fitness = func(self.individuals[i])\n                self.fitness_evaluations += 1\n\n                if fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness\n                    self.personal_best[i] = self.individuals[i].copy()\n\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best = self.individuals[i].copy()\n\n            self.update_inertia_weight()\n\n            for i in range(self.population_size):\n                if self.fitness_evaluations >= self.budget:\n                    break\n\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best[i] - self.individuals[i])\n                social_velocity = self.social_component * r2 * (self.global_best - self.individuals[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.individuals[i] += self.velocities[i]\n                self.individuals[i] = np.clip(self.individuals[i], lower_bound, upper_bound)\n\n                self.individuals[i] = self.adaptive_mutation(self.individuals[i], self.global_best, self.fitness_evaluations)\n\n        return self.global_best", "name": "EnhancedAdaptiveMemoryPSO", "description": "Enhanced Adaptive Memory PSO with Lévy Flight and Dynamic Inertia for Efficient Global Exploration and Exploitation in Photonic Optimization", "configspace": "", "generation": 99, "fitness": 0.27320796417827187, "feedback": "The algorithm EnhancedAdaptiveMemoryPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4631778e-43ad-483f-a787-b9fc163be90f", "metadata": {"aucs": [0.27320796417827187]}, "mutation_prompt": null}
