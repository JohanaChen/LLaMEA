{"id": "1c737361-2fd2-4d34-90bc-ec94be7f146f", "solution": "import numpy as np\n\nclass AQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)  # Tunable parameter for constriction factor\n        self.beta = 0.5       # Quantum-inspired parameter\n        self.evaluations = 0\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        # Quantum-inspired update\n        if np.random.rand() < self.beta:\n            new_pos = (self.pbest[idx] + self.gbest) / 2 + np.abs(self.gbest - self.positions[idx]) * np.random.normal(size=self.dim)\n        \n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def __call__(self, func):\n        # Initialize positions and evaluate initial scores\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "AQPSO", "description": "Adaptive Quantum Particle Swarm Optimization (AQPSO) leveraging quantum mechanics-inspired dynamics for enhanced exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 0, "fitness": 0.2870264819494942, "feedback": "The algorithm AQPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2870264819494942]}, "mutation_prompt": null}
{"id": "7d4f3240-62e4-43fe-88a8-7fcaceba4244", "solution": "import numpy as np\n\nclass EQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2.07)  # Adjusted for improved convergence\n        self.beta_base = 0.5\n        self.beta_increase = 0.1\n        self.evaluations = 0\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        inertia_weight = 0.9 - (0.5 * self.evaluations / self.budget)  # Dynamic inertia weight\n        self.velocities[idx] = (inertia_weight * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n\n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        # Adaptive Quantum-inspired update\n        beta = self.beta_base + self.beta_increase * (self.evaluations / self.budget)\n        if np.random.rand() < beta:\n            new_pos = (self.pbest[idx] + self.gbest) / 2 + np.abs(self.gbest - self.positions[idx]) * np.random.normal(size=self.dim)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def __call__(self, func):\n        # Initialize positions and evaluate initial scores\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "EQPSO", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization (EQPSO) with dynamic learning parameters and adaptive quantum potential for robust exploration-exploitation balance in photonic structure optimization.", "configspace": "", "generation": 1, "fitness": 0.28673040629615776, "feedback": "The algorithm EQPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "1c737361-2fd2-4d34-90bc-ec94be7f146f", "metadata": {"aucs": [0.28673040629615776]}, "mutation_prompt": null}
{"id": "865235be-fcf1-4259-a821-fe0ee52f0020", "solution": "import numpy as np\n\nclass QAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)  # Start with smaller size, dynamically adapt\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3  # Start with smaller beta, adapt based on convergence\n        self.evaluations = 0\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        # Adaptive Quantum-inspired update\n        if np.random.rand() < self.beta:\n            new_pos = (self.pbest[idx] + self.gbest) / 2 + np.abs(self.gbest - self.positions[idx]) * np.random.normal(size=self.dim)\n        \n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        # Increase population size if budget allows and no improvement seen\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        # Increase beta in case of stagnation\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        # Initialize positions and evaluate initial scores\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "QAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization (QAPSO) with dynamic population resizing and adaptive beta for improved convergence in photonic structures optimization.", "configspace": "", "generation": 2, "fitness": 0.2882429505795794, "feedback": "The algorithm QAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "1c737361-2fd2-4d34-90bc-ec94be7f146f", "metadata": {"aucs": [0.2882429505795794]}, "mutation_prompt": null}
{"id": "78138c6e-78c8-4219-9ecb-f42b4be44b16", "solution": "import numpy as np\n\nclass EQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.chaotic_map = np.random.rand()\n\n    def _chaotic_beta(self):\n        # Chaotic map to adapt beta for improved exploration-exploitation\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        self.beta = 0.2 + 0.8 * self.chaotic_map\n\n    def _diversity_preservation(self):\n        # Preserve diversity by perturbing some positions\n        if self.evaluations % (self.budget // 5) == 0:\n            num_perturb = self.population_size // 5\n            indices = np.random.choice(self.population_size, num_perturb, replace=False)\n            for idx in indices:\n                self.positions[idx] += 0.1 * (np.random.rand(self.dim) - 0.5)\n                self.positions[idx] = np.clip(self.positions[idx], func.bounds.lb, func.bounds.ub)\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos = (self.pbest[idx] + self.gbest) / 2 + np.abs(self.gbest - self.positions[idx]) * np.random.normal(size=self.dim)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._chaotic_beta()\n            self._diversity_preservation()\n\n        return self.gbest", "name": "EQAPSO", "description": "Enhanced Quantum-Inspired Adaptive Particle Swarm Optimization (EQAPSO) with diversity preservation and chaotic map for adaptive beta to achieve better exploration-exploitation balance in photonic structures optimization.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "865235be-fcf1-4259-a821-fe0ee52f0020", "metadata": {}, "mutation_prompt": null}
{"id": "8c0061cb-87bc-45c2-9490-bb800c790193", "solution": "import numpy as np\n\nclass QAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        # Generate Levy flight steps\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        # Quantum-inspired update with Levy flight\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n        \n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "QAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization (QAPSO) with Levy flight exploration and self-adaptive mutation for enhanced exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 4, "fitness": 0.2895151891841752, "feedback": "The algorithm QAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "865235be-fcf1-4259-a821-fe0ee52f0020", "metadata": {"aucs": [0.2895151891841752]}, "mutation_prompt": null}
{"id": "01e358ee-4109-4f9d-8c44-fc11b6592bc4", "solution": "import numpy as np\n\nclass DIQA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.evaluations = 0\n\n    def quantum_tunneling(self):\n        scale = 0.1 * np.exp(-0.1 * self.evaluations / self.budget)\n        return np.random.normal(0, scale, self.dim)\n\n    def _update_particle(self, idx, func):\n        new_pos = self.positions[idx] + self.quantum_tunneling()\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx] or np.exp((self.pbest_scores[idx] - new_score) / self.temperature) > np.random.rand():\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _cool(self):\n        self.temperature *= self.cooling_rate\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._cool()\n\n        return self.gbest", "name": "DIQA", "description": "Diffusion-Inspired Quantum Annealing (DIQA) integrating quantum tunneling with adaptive cooling schedules to enhance exploration and convergence in black box optimization of photonic structures.", "configspace": "", "generation": 5, "fitness": 0.27527386991445246, "feedback": "The algorithm DIQA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.27527386991445246]}, "mutation_prompt": null}
{"id": "d4a58ab7-049f-4a08-a647-8ebff7d03590", "solution": "import numpy as np\n\nclass HQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.inertia_weight = 0.9\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n        \n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.inertia_weight = max(0.4, self.inertia_weight - 0.1)\n\n    def _gaussian_mutation(self, individual):\n        noise = np.random.normal(0, 1, self.dim)\n        return individual + noise * 0.1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n            self._adapt_parameters()\n\n            if self.evaluations % (self.population_size // 2) == 0:\n                for i in range(self.population_size):\n                    mutated_position = self._gaussian_mutation(self.positions[i])\n                    mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n                    mutated_score = func(mutated_position)\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest[i] = mutated_position\n                        self.pbest_scores[i] = mutated_score\n                    if mutated_score < self.gbest_score:\n                        self.gbest = mutated_position\n                        self.gbest_score = mutated_score\n                    self.evaluations += 1\n                    if self.evaluations >= self.budget:\n                        return self.gbest\n\n        return self.gbest", "name": "HQPSO", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization (HQPSO) integrating dynamic adaptive inertia weight and Gaussian mutation for improved exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 6, "fitness": 0.2889263407500158, "feedback": "The algorithm HQPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.2889263407500158]}, "mutation_prompt": null}
{"id": "71d99665-8973-43dc-a7ca-ad0135e1049e", "solution": "import numpy as np\n\nclass EQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = self._chaotic_map_init(dim, self.population_size)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.alpha = 0.5\n\n    def _chaotic_map_init(self, dim, population_size):\n        # Initialize positions using a logistic chaotic map\n        x = np.random.rand(population_size, dim)\n        r = 4.0  # Control parameter for logistic map\n        for _ in range(100):  # Iterate to bring into chaotic regime\n            x = r * x * (1 - x)\n        return x\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        # Quantum-inspired update with Levy flight\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        # Adaptive neighborhood exploration\n        if np.random.rand() < self.alpha:\n            neighborhood = np.random.normal(new_pos, 0.1, self.dim)\n            new_pos = neighborhood\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.alpha = max(0.1, self.alpha - 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * self.positions\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_parameters()\n\n        return self.gbest", "name": "EQIPSO", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization (EQIPSO) with chaotic map initialization, dynamic parameter adaptation, and adaptive neighborhood search for improved exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 7, "fitness": 0.2850020283183532, "feedback": "The algorithm EQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.2850020283183532]}, "mutation_prompt": null}
{"id": "4c3578dc-610e-4de4-86c6-90b59fdaaeb5", "solution": "import numpy as np\n\nclass EQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.omega = 0.9  # Initial inertia weight\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.omega * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta_and_omega(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.omega = max(0.4, self.omega - 0.05)  # Gradually decrease inertia weight\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta_and_omega()\n\n        return self.gbest", "name": "EQAPSO", "description": "Enhanced Quantum-Inspired Adaptive Particle Swarm Optimization (EQAPSO) with dynamic population control and adaptive inertia weight for better exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 8, "fitness": 0.28820256902743024, "feedback": "The algorithm EQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.28820256902743024]}, "mutation_prompt": null}
{"id": "99bc1cd1-88c7-49c4-91de-0a9d353e6fb5", "solution": "import numpy as np\n\nclass QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.best_individual = None\n        self.best_score = float('inf')\n        self.crossover_rate = 0.9\n        self.f = 0.5  # Differential weight\n        self.evaluations = 0\n\n    def stochastic_tunneling(self, score):\n        # Apply stochastic tunneling transformation\n        if score < self.best_score:\n            return score\n        return score * np.exp(-self.f * (score - self.best_score)**2)\n\n    def differential_evolution(self, idx, func):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant = self.positions[a] + self.f * (self.positions[b] - self.positions[c])\n        trial = np.copy(self.positions[idx])\n\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n        \n        trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n        trial_score = func(trial)\n        trial_score = self.stochastic_tunneling(trial_score)\n\n        if trial_score < self.scores[idx]:\n            self.positions[idx] = trial\n            self.scores[idx] = trial_score\n\n        if trial_score < self.best_score:\n            self.best_individual = trial\n            self.best_score = trial_score\n\n        self.evaluations += 1\n\n    def adapt_crossover_rate(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.crossover_rate = np.clip(self.crossover_rate + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.scores[i] = self.stochastic_tunneling(score)\n            if score < self.best_score:\n                self.best_individual = self.positions[i]\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_individual\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self.differential_evolution(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self.adapt_crossover_rate()\n\n        return self.best_individual", "name": "QIDE", "description": "Quantum-Inspired Differential Evolution (QIDE) with adaptive crossover rate and stochastic tunneling for enhanced exploration and robustness in optimizing photonic structures.", "configspace": "", "generation": 9, "fitness": 0.2835716124438763, "feedback": "The algorithm QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.2835716124438763]}, "mutation_prompt": null}
{"id": "c61c3fb2-67f4-473e-a926-6b0496be5e41", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.diversity_threshold = 0.1\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def diversity_guided_mutation(self, position):\n        mutation_strength = np.random.normal(0, 1, self.dim) * 0.1\n        if np.std(self.positions) < self.diversity_threshold:\n            return position + mutation_strength\n        return position\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight(scale=0.02 + 0.02 * self.beta)\n        \n        new_pos = self.diversity_guided_mutation(new_pos)\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization enhanced with Diversity-Guided Mutation and Adaptive Levy Flight for improved exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 10, "fitness": 0.28906150103112216, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.28906150103112216]}, "mutation_prompt": null}
{"id": "63b2bfdd-67dd-4add-8caa-5f6b97bcad56", "solution": "import numpy as np\n\nclass QDELAF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.best_position = None\n        self.best_score = float('inf')\n        self.scaling_factor = 0.5\n        self.crossover_rate = 0.7\n        self.beta = 0.2\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _mutate(self, idx):\n        indices = np.arange(self.population_size)\n        indices = indices[indices != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + self.scaling_factor * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, 0, 1)\n\n    def _crossover(self, parent, mutant):\n        crossover = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, parent)\n        return crossover\n\n    def _select(self, idx, trial_pos, trial_score):\n        if trial_score < self.scores[idx]:\n            self.positions[idx] = trial_pos\n            self.scores[idx] = trial_score\n            if trial_score < self.best_score:\n                self.best_position = trial_pos\n                self.best_score = trial_score\n\n    def _adaptive_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.scores[i] = func(self.positions[i])\n            if self.scores[i] < self.best_score:\n                self.best_position = self.positions[i]\n                self.best_score = self.scores[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_position\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.positions[i], mutant)\n                \n                if np.random.rand() < self.beta:\n                    trial += self.levy_flight()\n\n                trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n                trial_score = func(trial)\n\n                self._select(i, trial, trial_score)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            self._adaptive_beta()\n\n        return self.best_position", "name": "QDELAF", "description": "Quantum Differential Evolution with Adaptive Levy Flights (QDELAF) combines differential evolution with adaptive quantum-based Levy flights for enhanced exploration and convergence in the global optimization of photonic structures.", "configspace": "", "generation": 11, "fitness": 0.27647061152279506, "feedback": "The algorithm QDELAF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.27647061152279506]}, "mutation_prompt": null}
{"id": "eb2ba5fe-fc8d-487d-a192-17a8461f9284", "solution": "import numpy as np\n\nclass AMPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.F = 0.5 + 0.3 * np.random.rand(self.population_size)\n        self.CR = 0.9 + 0.1 * np.random.rand(self.population_size)\n        self.best = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n\n    def _mutate(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F[idx] * (self.population[b] - self.population[c])\n        return np.clip(mutant, 0.0, 1.0)\n\n    def _crossover(self, target, mutant):\n        rand_idx = np.random.randint(self.dim)\n        cross_points = np.random.rand(self.dim) < self.CR\n        cross_points[rand_idx] = True\n        return np.where(cross_points, mutant, target)\n\n    def _select(self, idx, trial, func):\n        trial_denormalized = func.bounds.lb + trial * (func.bounds.ub - func.bounds.lb)\n        trial_score = func(trial_denormalized)\n        if trial_score < self.fitness[idx]:\n            self.population[idx] = trial\n            self.fitness[idx] = trial_score\n            self.F[idx] = np.clip(np.random.normal(0.5, 0.15), 0.1, 1.0)\n            self.CR[idx] = np.clip(np.random.normal(0.9, 0.05), 0.0, 1.0)\n            if trial_score < self.best_score:\n                self.best = trial_denormalized\n                self.best_score = trial_score\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.best_score:\n                self.best = self.population[i]\n                self.best_score = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                self._select(i, trial, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best", "name": "AMPDE", "description": "Adaptive Multi-Phase Differential Evolution (AMPDE) combining self-adaptive parameter control and niche-based competition for enhanced exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (50,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (50,) ')", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {}, "mutation_prompt": null}
{"id": "0196bda9-de5e-4cde-882b-aab4b0726438", "solution": "import numpy as np\n\nclass QDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.best_global_position = None\n        self.best_global_score = float('inf')\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover rate\n        self.evaluations = 0\n\n    def _quantum_superposition(self):\n        \"\"\"Generate a new solution based on quantum superposition principle.\"\"\"\n        return np.random.uniform(0, 1, self.dim)\n\n    def _mutation(self, idx, func):\n        \"\"\"Perform differential mutation and crossover.\"\"\"\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n        trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.positions[idx])\n        trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n        \n        trial_score = func(trial)\n        if trial_score < self.best_global_score:\n            self.best_global_position = trial\n            self.best_global_score = trial_score\n        \n        if trial_score < func(self.positions[idx]):\n            self.positions[idx] = trial\n\n        self.evaluations += 1\n\n    def __call__(self, func):\n        # Initialize with quantum superposition\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.array([self._quantum_superposition() for _ in range(self.population_size)])\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            if score < self.best_global_score:\n                self.best_global_position = self.positions[i]\n                self.best_global_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_global_position\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._mutation(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_global_position", "name": "QDE", "description": "Quantum Differential Evolution (QDE) leveraging quantum superposition for enhanced diversity and differential mutation for convergence in photonic structures optimization.", "configspace": "", "generation": 13, "fitness": 0.27780735024254255, "feedback": "The algorithm QDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.27780735024254255]}, "mutation_prompt": null}
{"id": "d314f90d-4544-4436-85d8-8910641898e9", "solution": "import numpy as np\n\nclass EDQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1 * (func.bounds.ub - func.bounds.lb)\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.w = 0.9  # Inertia weight\n        self.w_decay = 0.98  # Decay factor for inertia weight\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.w * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight(scale=self.w)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _decay_inertia_weight(self):\n        self.w = max(0.4, self.w * self.w_decay)\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._decay_inertia_weight()\n\n        return self.gbest", "name": "EDQPSO", "description": "Enhanced Dynamic Quantum-Inspired Particle Swarm Optimization (EDQPSO) with adaptive inertia weight and mutation scaling for improved convergence and exploration in photonic structures optimization.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {}, "mutation_prompt": null}
{"id": "ae2d1477-608c-471b-87c9-8e5fb9f8b88c", "solution": "import numpy as np\n\nclass AdaptiveDE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.F = 0.5  # Scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.mutation_strategies = [\n            self.de_rand_1,\n            self.de_best_1,\n            self.de_current_to_best_1\n        ]\n\n    def obl(self, bounds):\n        # Opposition-based Learning for initial population\n        return bounds.lb + bounds.ub - self.positions\n\n    def de_rand_1(self, target_idx):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.positions[idxs]\n        return a + self.F * (b - c)\n\n    def de_best_1(self, target_idx):\n        idxs = np.random.choice(self.population_size, 2, replace=False)\n        a, b = self.positions[idxs]\n        return self.best_solution + self.F * (a - b)\n\n    def de_current_to_best_1(self, target_idx):\n        idxs = np.random.choice(self.population_size, 2, replace=False)\n        a, b = self.positions[idxs]\n        return self.positions[target_idx] + self.F * (self.best_solution - self.positions[target_idx]) + self.F * (a - b)\n\n    def mutate(self, idx, func):\n        strategy = np.random.choice(self.mutation_strategies)\n        mutant = strategy(idx)\n        for i in range(self.dim):\n            if np.random.rand() > self.CR:\n                mutant[i] = self.positions[idx, i]\n        mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n        return mutant\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        opposite_positions = self.obl(func.bounds)\n        \n        # Combine initial and opposite populations\n        all_positions = np.vstack((self.positions, opposite_positions))\n        all_fitness = np.array([func(pos) for pos in all_positions])\n        \n        # Select best individuals\n        best_idxs = np.argsort(all_fitness)[:self.population_size]\n        self.positions = all_positions[best_idxs]\n        self.fitness = all_fitness[best_idxs]\n        \n        self.best_solution = self.positions[0]\n        self.best_fitness = self.fitness[0]\n        self.evaluations = self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                trial = self.mutate(i, func)\n                trial_fitness = func(trial)\n                \n                if trial_fitness < self.fitness[i]:\n                    self.positions[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_solution", "name": "AdaptiveDE_OBL", "description": "Hybrid Differential Evolution with Adaptive Multi-Strategy and Opposition-Based Learning for robust exploration and accelerated convergence in photonic structure optimization.", "configspace": "", "generation": 15, "fitness": 0.2877261946128715, "feedback": "The algorithm AdaptiveDE_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.2877261946128715]}, "mutation_prompt": null}
{"id": "2b14f70c-4292-428d-9211-822bc338d265", "solution": "import numpy as np\n\nclass EQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.initial_temperature = 1.0\n        self.temperature = self.initial_temperature\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        inertia_weight = 0.5 + np.random.rand() / 2  # Dynamic inertia weight\n        self.velocities[idx] = (inertia_weight * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        # Quantum-inspired update with adaptive Levy flight\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight(scale=self.temperature)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        # Simulated annealing acceptance condition\n        if new_score < self.pbest_scores[idx] or np.random.rand() < np.exp((self.pbest_scores[idx] - new_score) / self.temperature):\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _cool_down(self):\n        self.temperature *= 0.9  # Cooling schedule\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._cool_down()\n\n        return self.gbest", "name": "EQAPSO", "description": "Enhanced Quantum-Inspired Adaptive Particle Swarm Optimization (EQAPSO) with dynamic exploration-exploitation trade-off using simulated annealing and adaptive Levy flight for superior convergence in photonic structures optimization.", "configspace": "", "generation": 16, "fitness": 0.28693191028204135, "feedback": "The algorithm EQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.28693191028204135]}, "mutation_prompt": null}
{"id": "da1cb3f0-3eeb-4d0f-9752-dcf5d78b2f70", "solution": "import numpy as np\n\nclass ADEQMRM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.F = 0.5\n        self.CR = 0.9\n        self.beta = 0.3\n        self.evaluations = 0\n\n    def quantum_rotational_mutation(self, base, target, scale=0.01):\n        angle = np.random.normal(0, 1) * scale\n        rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)],\n                                    [np.sin(angle), np.cos(angle)]])\n        idx = np.random.choice(self.dim, 2, replace=False)\n        temp_vec = np.array([base[idx[0]], base[idx[1]]]) - np.array([target[idx[0]], target[idx[1]]])\n        rotated_vec = np.dot(rotation_matrix, temp_vec)\n        base[idx[0]] += rotated_vec[0]\n        base[idx[1]] += rotated_vec[1]\n        return base\n\n    def mutate(self, idx):\n        candidates = np.random.choice([i for i in range(self.population_size) if i != idx], 3, replace=False)\n        base, a, b = self.positions[candidates]\n        mutant = base + self.F * (a - b)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.positions[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_solution = trial\n                self.best_fitness = trial_fitness\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.positions[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_solution = self.positions[i]\n                self.best_fitness = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.positions[i], mutant)\n                trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n                trial = self.quantum_rotational_mutation(trial, self.positions[i])\n                trial_fitness = func(trial)\n                self.select(i, trial, trial_fitness)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_solution", "name": "ADEQMRM", "description": "Adaptive Differential Evolution with Quantum Mechanics-Inspired Rotational Mutation for enhanced diversity and convergence in photonic structures optimization.", "configspace": "", "generation": 17, "fitness": 0.28851932666706037, "feedback": "The algorithm ADEQMRM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.28851932666706037]}, "mutation_prompt": null}
{"id": "a9afb018-5440-4d19-b985-9a723ab9acc8", "solution": "import numpy as np\n\nclass QIGA_ACM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.crossover_prob = 0.9\n        self.mutation_prob = 0.1\n\n    def adaptive_mutation(self, individual):\n        mutation_strength = np.random.rand(self.dim) * (self.best_score / (self.scores.min() + 1e-10))\n        mutation_vector = np.random.normal(0, mutation_strength, self.dim)\n        return np.clip(individual + mutation_vector, 0, 1)\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_prob:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        else:\n            child = parent1\n        return np.clip(child, 0, 1)\n\n    def select_parents(self):\n        idx1, idx2 = np.random.choice(self.population_size, 2, replace=False)\n        return self.population[idx1], self.population[idx2]\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.population[i])\n            self.scores[i] = score\n            if score < self.best_score:\n                self.best_solution = self.population[i]\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                parent1, parent2 = self.select_parents()\n                child = self.crossover(parent1, parent2)\n                if np.random.rand() < self.mutation_prob:\n                    child = self.adaptive_mutation(child)\n                child_score = func(child)\n                if child_score < self.best_score:\n                    self.best_solution = child\n                    self.best_score = child_score\n                if child_score < self.scores[i]:\n                    self.population[i] = child\n                    self.scores[i] = child_score\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_solution", "name": "QIGA_ACM", "description": "Quantum-Inspired Genetic Algorithm with Adaptive Crossover Mutation (QIGA-ACM) using dynamic diversity control to enhance exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 18, "fitness": 0.27520033712251246, "feedback": "The algorithm QIGA_ACM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.27520033712251246]}, "mutation_prompt": null}
{"id": "f978ed0b-a5bf-4897-bc51-961458e839ae", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.w = 0.9  # Initial inertia weight\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def cauchy_mutation(self, position, scale=0.01):\n        return position + np.random.standard_cauchy(size=self.dim) * scale\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.w * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n        \n        if np.random.rand() < 0.1:  # Apply Cauchy mutation occasionally\n            new_pos = self.cauchy_mutation(new_pos)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta_and_inertia(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.w = max(0.4, self.w - 0.05)  # Decrease inertia weight over time\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta_and_inertia()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Enhanced QAPSO with Cauchy mutation and adaptive inertia weight for balancing exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 19, "fitness": 0.2866077776418481, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.2866077776418481]}, "mutation_prompt": null}
{"id": "04a9245f-010b-4ea1-a0fc-eb917089b2da", "solution": "import numpy as np\n\nclass QADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def _mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, 0, 1)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _adapt_parameters(self):\n        # Dynamic adjustment of mutation factor and crossover rate\n        progress = self.evaluations / self.budget\n        self.mutation_factor = 0.4 + 0.6 * (1 - np.exp(-10 * progress))\n        self.crossover_rate = 0.3 + 0.7 * np.sin(np.pi / 2 * progress)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.positions])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for idx in range(self.population_size):\n                mutant = self._mutate(idx)\n                trial = self._crossover(self.positions[idx], mutant)\n                trial_denorm = func.bounds.lb + trial * (func.bounds.ub - func.bounds.lb)\n                trial_fitness = func(trial_denorm)\n                if trial_fitness < fitness[idx]:\n                    fitness[idx] = trial_fitness\n                    self.positions[idx] = trial\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_parameters()\n\n        best_idx = np.argmin(fitness)\n        return func.bounds.lb + self.positions[best_idx] * (func.bounds.ub - func.bounds.lb)", "name": "QADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QADE) with neighborhood-based mutation and dynamic scaling for efficient exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 20, "fitness": 0.27520033712251246, "feedback": "The algorithm QADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.27520033712251246]}, "mutation_prompt": null}
{"id": "34c80294-cdd3-4462-bd92-4f0184967a66", "solution": "import numpy as np\n\nclass DEQCC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.best_position = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.dynamic_groups = max(2, dim // 5)\n\n    def _quantum_mutation(self, target_idx, func):\n        idxs = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(idxs, 3, replace=False)\n        mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n        crossover = np.random.rand(self.dim) < self.CR\n        crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, self.positions[target_idx])\n        trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n        return trial\n\n    def _evaluate_and_update(self, pos, func, idx):\n        score = func(pos)\n        if score < self.best_score:\n            self.best_score = score\n            self.best_position = pos\n        if score < func(self.positions[idx]):\n            self.positions[idx] = pos\n        self.evaluations += 1\n\n    def _dynamic_grouping(self):\n        group_size = max(1, self.dim // self.dynamic_groups)\n        groups = [np.random.permutation(self.dim)[:group_size] for _ in range(self.dynamic_groups)]\n        return groups\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for idx in range(self.population_size):\n            self._evaluate_and_update(self.positions[idx], func, idx)\n            if self.evaluations >= self.budget:\n                return self.best_position\n\n        while self.evaluations < self.budget:\n            groups = self._dynamic_grouping()\n            for group in groups:\n                for idx in range(self.population_size):\n                    trial = self._quantum_mutation(idx, func)\n                    trial[group] = self.positions[idx][group]  # Cooperative Coevolution\n                    self._evaluate_and_update(trial, func, idx)\n                    if self.evaluations >= self.budget:\n                        return self.best_position\n\n        return self.best_position", "name": "DEQCC", "description": "Differential Evolution with Quantum-inspired Cooperative Coevolution (DEQCC) leveraging dynamic grouping and adaptive mutation for enhanced exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 21, "fitness": 0.2785750523150923, "feedback": "The algorithm DEQCC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.2785750523150923]}, "mutation_prompt": null}
{"id": "7b8590d7-0819-4084-971f-a314689becd5", "solution": "import numpy as np\n\nclass EQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n                                \n        velocity_magnitude = np.linalg.norm(self.velocities[idx])\n        if velocity_magnitude > self.phi:\n            self.velocities[idx] *= self.phi / velocity_magnitude\n        \n        new_pos = self.positions[idx] + self.velocities[idx]\n        \n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n        \n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        diversity = np.mean(np.std(self.positions, axis=0))\n        threshold = (func.bounds.ub - func.bounds.lb).mean() * 0.1\n        if diversity < threshold and self.population_size > 10:\n            self.population_size = max(10, self.population_size - 5)\n            self.positions = self.positions[:self.population_size]\n            self.velocities = self.velocities[:self.population_size]\n            self.pbest = self.pbest[:self.population_size]\n            self.pbest_scores = self.pbest_scores[:self.population_size]\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EQIPSO", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization (EQIPSO) with dynamic adaptive mechanisms for population size and velocity adjustments to improve convergence in photonic structures optimization.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {}, "mutation_prompt": null}
{"id": "12cbb9a6-0ca9-4207-ad49-67f25031e167", "solution": "import numpy as np\n\nclass DQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.entanglement_strength = 0.1\n        self.evaluations = 0\n\n    def quantum_superposition(self):\n        # Generate quantum superposition states\n        theta = np.random.uniform(0, np.pi, self.dim)\n        phi = np.random.uniform(0, 2 * np.pi, self.dim)\n        q_state = np.array([np.cos(theta) * np.exp(1j * phi), np.sin(theta) * np.exp(-1j * phi)])\n        return np.real(q_state[0] + q_state[1])\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n\n        q_superposition = self.quantum_superposition() * self.entanglement_strength\n        new_pos = self.positions[idx] + self.velocities[idx] + q_superposition\n        \n        # Quantum-inspired update with Levy flight\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n        \n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _adapt_entanglement(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.entanglement_strength = min(0.5, self.entanglement_strength + 0.02)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._adapt_entanglement()\n\n        return self.gbest", "name": "DQPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Quantum Superposition for enhanced exploration using entangled states in photonic structures optimization.", "configspace": "", "generation": 23, "fitness": 0.288597464508215, "feedback": "The algorithm DQPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.288597464508215]}, "mutation_prompt": null}
{"id": "fb24119f-2abd-4efb-a0d6-b0245cbb3670", "solution": "import numpy as np\n\nclass DQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n\n    def _quantum_superposition(self, pos1, pos2):\n        return 0.5 * (pos1 + pos2) + np.random.normal(0, 0.1, self.dim)\n\n    def _mutate(self, idx, func):\n        idxs = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.positions[np.random.choice(idxs, 3, replace=False)]\n        mutant = a + self.f * (b - c)\n        mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.cr:\n                trial[j] = mutant[j]\n        return trial\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        scores = np.array([func(pos) for pos in self.positions])\n        self.gbest_score = scores.min()\n        self.gbest = self.positions[scores.argmin()]\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, func)\n                trial = self._crossover(self.positions[i], mutant)\n                trial_score = func(trial)\n\n                if trial_score < scores[i]:\n                    scores[i] = trial_score\n                    self.positions[i] = trial\n\n                if trial_score < self.gbest_score:\n                    self.gbest_score = trial_score\n                    self.gbest = trial\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return self.gbest\n\n            # Dynamic strategy adaptation\n            if self.evaluations % (self.budget // 5) == 0:\n                self.f = max(0.2, self.f * 0.9)\n                self.cr = min(1.0, self.cr + 0.05)\n\n        return self.gbest", "name": "DQIDE", "description": "Dynamic Quantum-Inspired Differential Evolution (DQIDE) utilizes quantum superposition and dynamic strategy adaptation to optimize complex photonic structures efficiently.", "configspace": "", "generation": 24, "fitness": 0.2834934492395774, "feedback": "The algorithm DQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.2834934492395774]}, "mutation_prompt": null}
{"id": "8bb2ed25-9b19-4faf-9964-36944b25440a", "solution": "import numpy as np\n\nclass HQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.qbit_angles = np.pi * (2 * np.random.rand(self.population_size, dim) - 1)\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.mutation_rate = 0.1\n\n    def _quantum_rotation(self, angles):\n        return np.sign(np.sin(angles)) * np.sqrt(np.abs(np.sin(angles)))\n\n    def _update_individual(self, idx, func):\n        # Apply quantum rotation to generate new position\n        self.qbit_angles[idx] += np.pi * (2 * np.random.rand(self.dim) - 1) * 0.05\n        new_pos = self._quantum_rotation(self.qbit_angles[idx])\n\n        # Crossover with personal best\n        crossover_mask = np.random.rand(self.dim) < 0.5\n        new_pos[crossover_mask] = self.pbest[idx, crossover_mask]\n\n        # Mutation\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        new_pos[mutation_mask] = func.bounds.lb[mutation_mask] + \\\n                                 (func.bounds.ub[mutation_mask] - func.bounds.lb[mutation_mask]) * np.random.rand(np.sum(mutation_mask))\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_individual(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "HQEA", "description": "Hybrid Quantum Evolutionary Algorithm (HQEA) combining quantum rotation gates and genetic algorithms for robust exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 25, "fitness": 0.28048300615845545, "feedback": "The algorithm HQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.28048300615845545]}, "mutation_prompt": null}
{"id": "d1fc33e8-5122-4341-a4cc-25da0bdbf887", "solution": "import numpy as np\n\nclass HyQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        # Generate Levy flight steps\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def differential_mutation(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _update_particle(self, idx, func):\n        mutant = self.differential_mutation(idx)\n        trial = self.crossover(self.positions[idx], mutant)\n        \n        # Quantum-inspired update with Levy flight\n        if np.random.rand() < 0.5:\n            trial += self.levy_flight()\n        \n        trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n        trial_score = func(trial)\n\n        if trial_score < self.pbest_scores[idx]:\n            self.pbest[idx] = trial\n            self.pbest_scores[idx] = trial_score\n\n        if trial_score < self.gbest_score:\n            self.gbest = trial\n            self.gbest_score = trial_score\n\n        self.positions[idx] = trial\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "HyQIDE", "description": "Hybrid Quantum-Inspired Differential Evolution (HyQIDE) combining quantum-inspired position update and differential mutation for robust exploration and convergence in optimizing photonic structures.", "configspace": "", "generation": 26, "fitness": 0.27520033712251246, "feedback": "The algorithm HyQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.27520033712251246]}, "mutation_prompt": null}
{"id": "860c0323-9374-4d67-be4f-297cefc3baca", "solution": "import numpy as np\n\nclass EADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.population_scores = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.F = 0.5  # mutation factor\n        self.CR = 0.9  # crossover probability\n        self.beta = 0.5\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def differential_evolution(self, idx, func):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(candidates, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n        trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.population[idx])\n        \n        # Quantum-inspired mutation with Levy flight\n        if np.random.rand() < self.beta:\n            trial += self.levy_flight()\n\n        trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n        trial_score = func(trial)\n        if trial_score < self.population_scores[idx]:\n            self.population[idx] = trial\n            self.population_scores[idx] = trial_score\n            if trial_score < self.best_score:\n                self.best_solution = trial\n                self.best_score = trial_score\n        self.evaluations += 1\n\n    def adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_population = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.population = np.vstack((self.population, additional_population))\n                self.population_scores = np.hstack((self.population_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.population[i])\n            self.population_scores[i] = score\n            if score < self.best_score:\n                self.best_solution = self.population[i]\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self.differential_evolution(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self.adapt_population()\n\n        return self.best_solution", "name": "EADE", "description": "Enhanced Adaptive Differential Evolution (EADE) with Dynamic Population Control and Quantum-inspired Levy Mutation for improved exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 27, "fitness": 0.27953348803220956, "feedback": "The algorithm EADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.27953348803220956]}, "mutation_prompt": null}
{"id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)  # Dynamic multi-swarm based on dimensionality\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Enhanced Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Multi-Swarm Strategy and Adaptive Exploration for improved convergence and robustness in photonic structures optimization.", "configspace": "", "generation": 28, "fitness": 0.29120535572855577, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "8c0061cb-87bc-45c2-9490-bb800c790193", "metadata": {"aucs": [0.29120535572855577]}, "mutation_prompt": null}
{"id": "6b071e0d-7571-4f8c-8b09-c7772378469c", "solution": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best = None\n        self.best_score = float('inf')\n        self.mutation_strategies = [self._rand_1, self._best_1, self._current_to_best_1]\n        self.strategy_probabilities = np.array([1/3, 1/3, 1/3])\n        self.evaluations = 0\n\n    def _rand_1(self, a, b, c, d, F=0.8):\n        return a + F * (b - c)\n\n    def _best_1(self, a, b, c, best, F=0.8):\n        return best + F * (b - c)\n\n    def _current_to_best_1(self, a, b, c, best, F=0.8):\n        return a + F * (best - a) + F * (b - c)\n\n    def _select_parents(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        selected = np.random.choice(indices, size=3, replace=False)\n        return selected\n\n    def _mutate(self, idx):\n        a, b, c = self._select_parents(idx)\n        best_idx = np.argmin(self.fitness)\n        strategy_idx = np.random.choice(len(self.mutation_strategies), p=self.strategy_probabilities)\n        return self.mutation_strategies[strategy_idx](self.positions[a], self.positions[b], self.positions[c], self.positions[best_idx])\n\n    def _crossover(self, target, donor, CR=0.9):\n        mask = np.random.rand(self.dim) < CR\n        trial = np.where(mask, donor, target)\n        return trial\n\n    def _update_strategy_probabilities(self):\n        success_rates = self.strategy_successes / (self.strategy_tries + 1e-6)\n        self.strategy_probabilities = success_rates / success_rates.sum()\n\n    def _adapt_search_space(self, factor=0.9):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.positions = self.best + factor * (self.positions - self.best)\n            self.positions = np.clip(self.positions, self.bounds.lb, self.bounds.ub)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.positions = self.bounds.lb + (self.bounds.ub - self.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        self.strategy_successes = np.zeros(len(self.mutation_strategies))\n        self.strategy_tries = np.zeros(len(self.mutation_strategies))\n\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.fitness[i] = score\n            if score < self.best_score:\n                self.best = self.positions[i].copy()\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                donor = self._mutate(i)\n                trial = self._crossover(self.positions[i], donor)\n                trial = np.clip(trial, self.bounds.lb, self.bounds.ub)\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.fitness[i]:\n                    self.positions[i] = trial\n                    self.fitness[i] = trial_score\n                    self.strategy_successes[strategy_idx] += 1\n                    if trial_score < self.best_score:\n                        self.best = trial\n                        self.best_score = trial_score\n\n                self.strategy_tries[strategy_idx] += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            self._update_strategy_probabilities()\n            self._adapt_search_space()\n\n        return self.best", "name": "AQIDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Multi-Strategy Mutation and Adaptive Search Space Reduction for enhanced convergence and exploration in photonic structures optimization.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'strategy_idx' is not defined\").", "error": "NameError(\"name 'strategy_idx' is not defined\")", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "5dcb2aca-7b3a-40ac-8a06-44800c42e4b5", "solution": "import numpy as np\n\nclass DHSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(15, 6 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.alpha = 0.5 + np.random.rand(self.population_size, 1)\n        self.evaluations = 0\n        self.hierarchy_levels = max(3, dim // 4)\n        self.local_gbests = [None] * self.hierarchy_levels\n        self.local_gbest_scores = [float('inf')] * self.hierarchy_levels\n\n    def gaussian_perturbation(self, scale=0.1):\n        return np.random.normal(0, scale, self.dim)\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        level = idx % self.hierarchy_levels\n        local_gbest = self.local_gbests[level] if self.local_gbests[level] is not None else self.gbest\n        self.velocities[idx] = (self.alpha[idx] * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < 0.1:  # Intensification with Gaussian perturbation\n            new_pos += self.gaussian_perturbation()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[level]:\n            self.local_gbests[level] = new_pos\n            self.local_gbest_scores[level] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_hierarchy(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            new_hierarchy_levels = min(self.hierarchy_levels + 1, 5 * self.dim)\n            if new_hierarchy_levels > self.hierarchy_levels:\n                self.local_gbests.extend([None] * (new_hierarchy_levels - self.hierarchy_levels))\n                self.local_gbest_scores.extend([float('inf')] * (new_hierarchy_levels - self.hierarchy_levels))\n                self.hierarchy_levels = new_hierarchy_levels\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_hierarchy()\n\n        return self.gbest", "name": "DHSO", "description": "Dynamic Hierarchical Swarm Optimization (DHSO) integrates hierarchical structuring with adaptive learning rates and local search intensification through Gaussian perturbations for enhanced convergence in high-dimensional photonic optimization.", "configspace": "", "generation": 30, "fitness": 0.2856805498743661, "feedback": "The algorithm DHSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2856805498743661]}, "mutation_prompt": null}
{"id": "cfef5faa-6186-4427-b720-27795cd1129c", "solution": "import numpy as np\n\nclass HybridQuantumParticleEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 7 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.q_factor = 0.5\n        self.diff_weight = 0.8\n        self.chaos_beta = 0.3\n        self.evaluations = 0\n\n    def differential_mutation(self, target_idx, func):\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + self.diff_weight * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n    def chaos_local_search(self, pos, func):\n        chaos_seq = np.random.rand(self.dim)\n        chaos_step = self.q_factor * (chaos_seq - 0.5)\n        new_pos = pos + chaos_step\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        score = func(new_pos)\n        return new_pos, score\n\n    def _update_particle(self, idx, func):\n        new_pos = self.differential_mutation(idx, func)\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        velocity = (self.q_factor * self.velocities[idx] \n                    + r1 * (self.pbest[idx] - self.positions[idx]) \n                    + r2 * (self.gbest - self.positions[idx]))\n        candidate_pos = new_pos + velocity\n        candidate_pos = np.clip(candidate_pos, func.bounds.lb, func.bounds.ub)\n        candidate_score = func(candidate_pos)\n\n        if candidate_score < self.pbest_scores[idx]:\n            self.pbest[idx] = candidate_pos\n            self.pbest_scores[idx] = candidate_score\n\n        if candidate_score < self.gbest_score:\n            self.gbest = candidate_pos\n            self.gbest_score = candidate_score\n\n        if np.random.rand() < self.chaos_beta:\n            chaos_pos, chaos_score = self.chaos_local_search(candidate_pos, func)\n            if chaos_score < candidate_score:\n                candidate_pos, candidate_score = chaos_pos, chaos_score\n\n        self.positions[idx] = candidate_pos\n        self.evaluations += 1\n\n    def _adapt_q_factor(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.q_factor = max(0.3, self.q_factor - 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_q_factor()\n\n        return self.gbest", "name": "HybridQuantumParticleEvolution", "description": "Hybrid Quantum Particle Evolution (HQPE) employing quantum-inspired particle evolution with adaptive differential mutation and chaos-enhanced local search for robust exploration and exploitation in photonic optimization.", "configspace": "", "generation": 31, "fitness": 0.2784920787596872, "feedback": "The algorithm HybridQuantumParticleEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2784920787596872]}, "mutation_prompt": null}
{"id": "63a38a5b-123f-483f-81ac-e436315ad279", "solution": "import numpy as np\n\nclass AdvancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.2\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 4)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.inertia_weight = 0.9\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] +\n                                self.phi * r1 * (self.pbest[idx] - self.positions[idx]) +\n                                self.phi * r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.inertia_weight = max(0.4, self.inertia_weight - 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_parameters()\n\n        return self.gbest", "name": "AdvancedQAPSO", "description": "Advanced Quantum-Inspired Particle Swarm Optimization with Adaptive Multi-Swarm Strategy and Modified Lévy Flights for enhanced exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 32, "fitness": 0.28413946040876137, "feedback": "The algorithm AdvancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28413946040876137]}, "mutation_prompt": null}
{"id": "86488ac0-ffa5-4368-b625-6603adeffebd", "solution": "import numpy as np\n\nclass AdaptiveDynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMS = max(10, 2 * dim)  # Harmony Memory Size\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3  # Pitch Adjustment Rate\n        self.HM = np.random.rand(self.HMS, dim)  # Harmony Memory\n        self.HM_scores = np.full(self.HMS, float('inf'))\n        self.best_harmony = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _adaptive_PAR(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.PAR = min(0.5, self.PAR + 0.05)\n\n    def _generate_harmony(self, func):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                idx = np.random.randint(0, self.HMS)\n                new_harmony[i] = self.HM[idx, i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-0.1, 0.1)\n            else:\n                new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n        new_harmony += self.levy_flight()\n        new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n\n        return new_harmony\n\n    def __call__(self, func):\n        self.HM = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.HMS, self.dim)\n        for i in range(self.HMS):\n            score = func(self.HM[i])\n            self.HM_scores[i] = score\n            if score < self.best_score:\n                self.best_harmony = self.HM[i]\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_harmony\n\n        while self.evaluations < self.budget:\n            new_harmony = self._generate_harmony(func)\n            new_score = func(new_harmony)\n            self.evaluations += 1\n\n            if new_score < self.best_score:\n                self.best_harmony = new_harmony\n                self.best_score = new_score\n\n            worst_idx = np.argmax(self.HM_scores)\n            if new_score < self.HM_scores[worst_idx]:\n                self.HM[worst_idx] = new_harmony\n                self.HM_scores[worst_idx] = new_score\n\n            self._adaptive_PAR()\n\n            if self.evaluations >= self.budget:\n                break\n\n        return self.best_harmony", "name": "AdaptiveDynamicHarmonySearch", "description": "Adaptive Dynamic Harmony Search with Quantum-Inspired Levy Flights for efficient exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 33, "fitness": 0.2881891881508437, "feedback": "The algorithm AdaptiveDynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2881891881508437]}, "mutation_prompt": null}
{"id": "9c1dbd87-f64c-49ae-8676-fb9d6af2addd", "solution": "import numpy as np\n\nclass EnhancedQAPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.f = 0.5  # DE scaling factor\n        self.cr = 0.9  # DE crossover probability\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def differential_evolution(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + self.f * (self.positions[b] - self.positions[c])\n        return np.where(np.random.rand(self.dim) < self.cr, mutant, self.positions[idx])\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        if np.random.rand() < 0.5:\n            new_pos = self.differential_evolution(idx)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO_DE", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Integrated Differential Evolution for enhanced exploration and exploitation balance in photonic structures optimization.", "configspace": "", "generation": 34, "fitness": 0.2813947152174051, "feedback": "The algorithm EnhancedQAPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2813947152174051]}, "mutation_prompt": null}
{"id": "97a80f0d-025d-4c77-a5b4-4f090cf2134b", "solution": "import numpy as np\n\nclass HybridQIGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n\n    def differential_mutation(self, idx):\n        idxs = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(idxs, 3, replace=False)\n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        mutant_vector = np.clip(mutant_vector, func.bounds.lb, func.bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _update_particle(self, idx, func):\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        \n        mutant = self.differential_mutation(idx)\n        trial = self.crossover(self.positions[idx], mutant)\n        \n        new_score = func(trial)\n        \n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = trial\n            self.pbest_scores[idx] = new_score\n        \n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = trial\n            self.local_gbest_scores[swarm_idx] = new_score\n        \n        if new_score < self.gbest_score:\n            self.gbest = trial\n            self.gbest_score = new_score\n        \n        self.positions[idx] = trial\n        self.evaluations += 1\n\n    def _adapt_mutation_factor(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_mutation_factor()\n\n        return self.gbest", "name": "HybridQIGA", "description": "Hybrid Quantum-Inspired Genetic Algorithm with Adaptive Differential Mutation and Dynamic Multi-Swarm Strategy for enhanced exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "fffcd7e3-288f-495a-9b0f-aef50a137c1d", "solution": "import numpy as np\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.best_pos = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def _quantum_initialize(self, bounds):\n        theta = np.random.rand(self.population_size, self.dim) * 2 * np.pi\n        r = np.random.rand(self.population_size, self.dim)\n        self.positions = bounds.lb + (0.5 * np.abs(np.cos(theta)) * (bounds.ub - bounds.lb))\n\n    def _adaptive_mutation(self, f_idx, bounds):\n        a, b, c = np.random.choice([i for i in range(self.population_size) if i != f_idx], 3, replace=False)\n        mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def _crossover(self, target_vector, mutant_vector):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        trial_vector = np.where(crossover_mask, mutant_vector, target_vector)\n        return trial_vector\n\n    def __call__(self, func):\n        self._quantum_initialize(func.bounds)\n        scores = np.full(self.population_size, float('inf'))\n\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            scores[i] = score\n            if score < self.best_score:\n                self.best_score = score\n                self.best_pos = self.positions[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_pos\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant_vector = self._adaptive_mutation(i, func.bounds)\n                trial_vector = self._crossover(self.positions[i], mutant_vector)\n                trial_score = func(trial_vector)\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial_vector\n                    scores[i] = trial_score\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_pos = trial_vector\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_pos", "name": "QuantumEnhancedDE", "description": "Quantum-Enhanced Differential Evolution (QDE) with Adaptive Mutation Strategy leverages quantum-inspired individuals and adaptive mutation to explore photonic structures effectively.", "configspace": "", "generation": 36, "fitness": 0.28699928028647315, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28699928028647315]}, "mutation_prompt": null}
{"id": "20e9f5cf-6549-4a2f-a1db-515173cf4205", "solution": "import numpy as np\n\nclass AdaptiveHybridGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, 10 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_rate = 0.1\n        self.evaluations = 0\n\n    def quantum_mutation(self, individual):\n        scale = 0.05\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return individual + step\n\n    def crossover(self, parent1, parent2):\n        alpha = np.random.rand(self.dim)\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n\n    def select_parents(self):\n        idx = np.random.choice(np.arange(self.population_size), size=2, replace=False, p=self.fitness / self.fitness.sum())\n        return self.population[idx[0]], self.population[idx[1]]\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            fitness = func(self.population[i])\n            self.fitness[i] = fitness\n            if fitness < self.best_fitness:\n                self.best_fitness = fitness\n                self.best_solution = self.population[i].copy()\n            self.evaluations += 1\n\n    def _update_population(self, func):\n        new_population = []\n        for _ in range(self.population_size // 2):\n            parent1, parent2 = self.select_parents()\n            child1 = self.crossover(parent1, parent2)\n            child2 = self.crossover(parent2, parent1)\n            new_population.append(child1)\n            new_population.append(child2)\n        if self.evaluations + len(new_population) >= self.budget:\n            new_population = new_population[:self.budget - self.evaluations]\n\n        for i in range(len(new_population)):\n            if np.random.rand() < self.mutation_rate:\n                new_population[i] = self.quantum_mutation(new_population[i])\n            new_population[i] = np.clip(new_population[i], func.bounds.lb, func.bounds.ub)\n\n        self.population = np.array(new_population)\n        self.fitness = np.full(len(self.population), float('inf'))\n        self._evaluate_population(func)\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        self._evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            self._update_population(func)\n            if self.evaluations % (self.budget // 4) == 0:\n                self.mutation_rate = min(0.5, self.mutation_rate + 0.05)\n\n        return self.best_solution", "name": "AdaptiveHybridGA", "description": "Adaptive Hybrid Genetic Algorithm with Quantum-Inspired Mutation for enhanced exploration and exploitation in optimizing complex photonic structures.", "configspace": "", "generation": 37, "fitness": 0.27991508768298135, "feedback": "The algorithm AdaptiveHybridGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27991508768298135]}, "mutation_prompt": null}
{"id": "f6a35747-a417-4294-8e59-b7009e0e41e4", "solution": "import numpy as np\n\nclass QIMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.alpha = 0.5  # Influence of differential mutation\n        self.phi = np.log(2)\n        self.beta = 0.2\n        self.evaluations = 0\n\n    def differential_mutation(self, idx, func):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + self.alpha * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        neighborhood = self._select_neighborhood(idx)\n        local_best = min(neighborhood, key=lambda x: self.pbest_scores[x])\n\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.pbest[local_best] - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos = self.differential_mutation(idx, func)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _select_neighborhood(self, idx):\n        neighborhood_size = max(2, self.population_size // 5)\n        indices = [i for i in range(self.population_size) if i != idx]\n        return np.random.choice(indices, neighborhood_size, replace=False)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "QIMPSO", "description": "Quantum-Inspired Memetic Particle Swarm Optimization (QIMPSO) with Adaptive Neighborhoods and Differential Mutation for enhanced exploration-exploitation balance in global optimization of photonic structures.", "configspace": "", "generation": 38, "fitness": 0.28527124681037896, "feedback": "The algorithm QIMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28527124681037896]}, "mutation_prompt": null}
{"id": "84a15a80-1cb6-48c5-833b-e0a827df0a5d", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.phase = 1\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            growth = 10 if self.phase == 1 else 5\n            new_population_size = min(self.population_size + growth, 30 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n            if self.evaluations >= self.budget // 2:\n                self.phase = 2  # Switch to phase 2 for refined exploration\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            delta = 0.05 if self.phase == 1 else 0.02\n            self.beta = min(1.0, self.beta + delta)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Enhanced Quantum-Inspired Adaptive Particle Swarm Optimization with Multi-phase Adaptive Strategy and Stochastic Parameter Tuning for improved convergence and performance in photonic structures optimization.", "configspace": "", "generation": 39, "fitness": 0.2893044143418486, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2893044143418486]}, "mutation_prompt": null}
{"id": "209ee720-012a-4575-bd07-115e684bc613", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.pbest_positions = self.positions.copy()\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.mutation_factor = 0.5  # DE mutation factor\n        self.crossover_prob = 0.9  # DE crossover probability\n        self.alpha = 0.1  # Quantum-inspired parameter\n\n    def quantum_inspired_mutation(self, target_idx):\n        # A quantum-inspired mutation to increase diversity\n        r1, r2, r3 = np.random.choice([i for i in range(self.population_size) if i != target_idx], 3, replace=False)\n        mutant_vector = self.positions[r1] + self.mutation_factor * (self.positions[r2] - self.positions[r3])\n        # Apply quantum-inspired influence\n        mutant_vector += self.alpha * np.random.normal(size=self.dim)\n        return mutant_vector\n\n    def _update_individual(self, idx, func):\n        mutant_vector = self.quantum_inspired_mutation(idx)\n        trial_vector = np.copy(mutant_vector)\n        \n        for j in range(self.dim):\n            if np.random.rand() > self.crossover_prob:\n                trial_vector[j] = self.positions[idx, j]\n\n        trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n        trial_score = func(trial_vector)\n\n        if trial_score < self.pbest_scores[idx]:\n            self.pbest_positions[idx] = trial_vector\n            self.pbest_scores[idx] = trial_score\n\n        if trial_score < self.gbest_score:\n            self.gbest = trial_vector\n            self.gbest_score = trial_score\n\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest_positions[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_individual(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution (QIDE) combines differential evolution with quantum-inspired probability control for enhanced diversity and convergence in photonic structures optimization.", "configspace": "", "generation": 40, "fitness": 0.2786988275853052, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2786988275853052]}, "mutation_prompt": null}
{"id": "daf3d248-fc32-4c65-aec3-5137e67f77d1", "solution": "import numpy as np\n\nclass RefinedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.dispersion_rate = 0.1  # Dynamic dispersion rate for diversity\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        # Adding diversity-enhancing dispersion\n        if np.random.rand() < self.dispersion_rate:\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            new_pos += perturbation\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta_and_dispersion(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.dispersion_rate = max(0.05, self.dispersion_rate * 0.9)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta_and_dispersion()\n\n        return self.gbest", "name": "RefinedQAPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization enhanced with Levy flights and multi-swarm strategies, augmented by dynamic diversity and exploration adjustments for optimized photonic structures.", "configspace": "", "generation": 41, "fitness": 0.2877453384186208, "feedback": "The algorithm RefinedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2877453384186208]}, "mutation_prompt": null}
{"id": "f4ab3b42-cbad-4f84-9500-2bf57387ff4d", "solution": "import numpy as np\n\nclass HybridQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def local_search(self, position, func, step_size=0.1):\n        perturb = step_size * (np.random.rand(self.dim) - 0.5)\n        new_pos = np.clip(position + perturb, func.bounds.lb, func.bounds.ub)\n        return new_pos, func(new_pos)\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        if self.evaluations < self.budget:\n            # Local search integration\n            l_pos, l_score = self.local_search(new_pos, func)\n            if l_score < new_score:\n                new_pos, new_score = l_pos, l_score\n                if new_score < self.pbest_scores[idx]:\n                    self.pbest[idx] = new_pos\n                    self.pbest_scores[idx] = new_score\n                if new_score < self.local_gbest_scores[swarm_idx]:\n                    self.local_gbests[swarm_idx] = new_pos\n                    self.local_gbest_scores[swarm_idx] = new_score\n                if new_score < self.gbest_score:\n                    self.gbest = new_pos\n                    self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "HybridQAPSO", "description": "Hybrid Quantum-Inspired Adaptive Particle Swarm Optimization with Local Search Integration for enhanced convergence and robustness in optimizing photonic structures.", "configspace": "", "generation": 42, "fitness": 0.2853154126546176, "feedback": "The algorithm HybridQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2853154126546176]}, "mutation_prompt": null}
{"id": "704b70e6-9242-4b46-b334-01dc223699ac", "solution": "import numpy as np\n\nclass AdaptiveQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.diversity_threshold = 0.1\n        self.dynamic_grouping_interval = int(np.sqrt(budget))\n        self.adaptive_phi_interval = self.budget // 5\n        self.num_groups = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_groups\n        self.local_gbest_scores = [float('inf')] * self.num_groups\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        group_idx = idx % self.num_groups\n        local_gbest = self.local_gbests[group_idx] if self.local_gbests[group_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[group_idx]:\n            self.local_gbests[group_idx] = new_pos\n            self.local_gbest_scores[group_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % self.dynamic_grouping_interval == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _adapt_phi(self):\n        if self.evaluations % self.adaptive_phi_interval == 0:\n            diversity = np.std(self.positions, axis=0).mean()\n            if diversity < self.diversity_threshold:\n                self.phi *= 1.1\n            else:\n                self.phi = max(np.log(2), self.phi * 0.9)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._adapt_phi()\n\n        return self.gbest", "name": "AdaptiveQIPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization with Dynamic Grouping and Adaptive Learning for enhanced exploration-exploitation balance and convergence in photonic structures optimization.", "configspace": "", "generation": 43, "fitness": 0.28949446752869956, "feedback": "The algorithm AdaptiveQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28949446752869956]}, "mutation_prompt": null}
{"id": "b28551b2-b1fa-40ac-934d-c91c18fe8585", "solution": "import numpy as np\n\nclass QuantumGeneticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.crossover_rate = 0.8\n        self.mutation_rate = 0.2\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(self, individual):\n        mutation_vector = np.random.normal(0, 0.1, self.dim) * (np.random.rand(self.dim) < self.mutation_rate)\n        return np.clip(individual + mutation_vector, 0, 1)\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = self.crossover(new_pos, self.gbest)\n        new_pos = self.mutate(new_pos)\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "QuantumGeneticPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Genetic Algorithm-inspired Crossover and Mutation for enhanced exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 44, "fitness": 0.27520033712251246, "feedback": "The algorithm QuantumGeneticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27520033712251246]}, "mutation_prompt": null}
{"id": "f70fd862-10ff-42bb-b9e9-4aef9bddc1d1", "solution": "import numpy as np\n\nclass HQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def differential_evolution_mutation(self, idx):\n        candidates = list(range(self.population_size))\n        candidates.remove(idx)\n        selected = np.random.choice(candidates, 3, replace=False)\n        a, b, c = self.positions[selected]\n        F = 0.8  # Scale factor\n        mutated = np.clip(a + F * (b - c), 0, 1)\n        return mutated\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n        \n        # Apply differential evolution mutation\n        if np.random.rand() < 0.2:\n            new_pos = self.differential_evolution_mutation(idx)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "HQAPSO", "description": "Hybrid Quantum-Inspired Adaptive Particle Swarm Optimization (HQAPSO) with Guided Search Enhancement through Differential Evolution for enhanced convergence precision in photonic structures optimization.", "configspace": "", "generation": 45, "fitness": 0.2868540057258, "feedback": "The algorithm HQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2868540057258]}, "mutation_prompt": null}
{"id": "87d2800b-8e14-40bf-85d2-ecdf3769ea58", "solution": "import numpy as np\n\nclass HybridAdaptiveQuantumBees:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, 10 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_position = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.neighborhood_size = 0.1  # Percentage of dimension for local search\n        self.alpha = 0.5  # Probability to use quantum adaptation\n        self.beta = 0.5  # Adaptive parameter for local bee search\n\n    def quantum_adaptation(self):\n        scale = 0.1\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        return u / (np.abs(v) ** (1 / 3))\n\n    def local_bee_search(self, position, func):\n        new_position = position + self.beta * (np.random.rand(self.dim) - 0.5) * 2 * self.neighborhood_size\n        new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_position)\n        if new_score < self.best_score:\n            self.best_position = new_position\n            self.best_score = new_score\n        return new_position, new_score\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            if np.random.rand() < self.alpha:\n                new_position = self.positions[i] + self.quantum_adaptation()\n            else:\n                new_position, new_score = self.local_bee_search(self.positions[i], func)\n                if new_score < self.fitness[i]:\n                    self.positions[i] = new_position\n                    self.fitness[i] = new_score\n                    continue\n\n            new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n            new_score = func(new_position)\n            self.evaluations += 1\n\n            if new_score < self.fitness[i]:\n                self.positions[i] = new_position\n                self.fitness[i] = new_score\n\n            if new_score < self.best_score:\n                self.best_position = new_position\n                self.best_score = new_score\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.fitness[i] = score\n            if score < self.best_score:\n                self.best_position = self.positions[i]\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_position\n\n        while self.evaluations < self.budget:\n            self.update_positions(func)\n            self.beta = min(1.0, self.beta + 0.02)\n\n        return self.best_position", "name": "HybridAdaptiveQuantumBees", "description": "Hybrid Adaptive Quantum Bees Algorithm combines quantum-inspired exploration with bee-inspired local search and adaptive strategies for efficient optimization of photonic structures.", "configspace": "", "generation": 46, "fitness": 0.2786129752109381, "feedback": "The algorithm HybridAdaptiveQuantumBees got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2786129752109381]}, "mutation_prompt": null}
{"id": "2fc013b3-3dbd-44ca-b2cf-e0a6321e4a48", "solution": "import numpy as np\n\nclass HQGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.chromosomes = np.random.rand(self.population_size, dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.best_chromosome = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.crossover_rate = 0.8\n        self.mutation_rate = 0.1\n        self.alpha = 0.9  # Adaptive parameter for mutation rate\n\n    def quantum_encoding(self):\n        return np.cos(np.pi * self.chromosomes), np.sin(np.pi * self.chromosomes)\n\n    def crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            point = np.random.randint(1, self.dim - 1)\n            return np.concatenate((parent1[:point], parent2[point:]))\n        return parent1 if np.random.rand() > 0.5 else parent2\n\n    def mutate(self, chromosome):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                chromosome[i] = np.random.rand()\n        return chromosome\n\n    def adapt_parameters(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.mutation_rate = max(0.05, self.alpha * self.mutation_rate)\n\n    def __call__(self, func):\n        # Initialize population\n        bounds_range = func.bounds.ub - func.bounds.lb\n        self.chromosomes = func.bounds.lb + bounds_range * self.chromosomes\n\n        for i in range(self.population_size):\n            score = func(self.chromosomes[i])\n            self.scores[i] = score\n            if score < self.best_score:\n                self.best_chromosome = self.chromosomes[i]\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_chromosome\n\n        # Main optimization loop\n        while self.evaluations < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parents = self.chromosomes[np.random.choice(self.population_size, 2, replace=False)]\n                offspring1 = self.crossover(parents[0], parents[1])\n                offspring2 = self.crossover(parents[1], parents[0])\n                new_population.extend([self.mutate(offspring1), self.mutate(offspring2)])\n            \n            new_population = np.clip(new_population, func.bounds.lb, func.bounds.ub)\n            \n            for i in range(self.population_size):\n                score = func(new_population[i])\n                if score < self.scores[i]:\n                    self.chromosomes[i] = new_population[i]\n                    self.scores[i] = score\n                    if score < self.best_score:\n                        self.best_chromosome = new_population[i]\n                        self.best_score = score\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return self.best_chromosome\n\n            self.adapt_parameters()\n\n        return self.best_chromosome", "name": "HQGA", "description": "Hybrid Quantum Genetic Algorithm (HQGA) combining quantum-inspired encoding with genetic operations and adaptive parameter tuning to optimize photonic structures effectively.", "configspace": "", "generation": 47, "fitness": 0.28095133150586127, "feedback": "The algorithm HQGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28095133150586127]}, "mutation_prompt": null}
{"id": "8bb2db37-a7fd-4c74-aa4b-0f1e87b57f08", "solution": "import numpy as np\n\nclass HybridQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def gaussian_mutation(self, position, scale=0.01):\n        mutation = np.random.normal(0, scale, position.shape)\n        return position + mutation\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            if np.random.rand() < 0.5:\n                new_pos += self.levy_flight()\n            else:\n                new_pos = self.gaussian_mutation(new_pos)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "HybridQAPSO", "description": "Hybrid Quantum-Inspired Adaptive Particle Swarm Optimization with Enhanced Exploration using Gaussian and Lévy Mutations for Robust Photonic Structures Optimization.", "configspace": "", "generation": 48, "fitness": 0.2895733545765673, "feedback": "The algorithm HybridQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2895733545765673]}, "mutation_prompt": null}
{"id": "b193dcaa-6f31-4142-a58a-99541363d45d", "solution": "import numpy as np\n\nclass QuantumGeneticSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.8\n\n    def quantum_mutation(self, position):\n        mutation_vector = np.random.uniform(-1, 1, self.dim)\n        new_position = position + self.mutation_rate * mutation_vector\n        return new_position\n\n    def quantum_crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n            return child\n        return parent1\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (0.5 * self.velocities[idx] + \n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n        new_pos = self.quantum_mutation(new_pos)\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n        \n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n        \n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n        \n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _perform_crossover(self):\n        for i in range(0, self.population_size, 2):\n            if i + 1 < self.population_size:\n                child1 = self.quantum_crossover(self.positions[i], self.positions[i + 1])\n                child2 = self.quantum_crossover(self.positions[i + 1], self.positions[i])\n                self.positions[i], self.positions[i + 1] = child1, child2\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._perform_crossover()\n        \n        return self.gbest", "name": "QuantumGeneticSwarmOptimization", "description": "Quantum Genetic Swarm Optimization (QGSO) combines quantum-inspired genetic operators with PSO for enhanced exploration and exploitation in complex search spaces.", "configspace": "", "generation": 49, "fitness": 0.2889851819438688, "feedback": "The algorithm QuantumGeneticSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2889851819438688]}, "mutation_prompt": null}
{"id": "980b3775-252e-4e32-80de-45cfc40da9fa", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def opposition_based_learning(self, position, lb, ub):\n        return lb + ub - position\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        opposite_pos = self.opposition_based_learning(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n        opposite_score = func(opposite_pos)\n\n        if opposite_score < new_score:\n            new_pos, new_score = opposite_pos, opposite_score\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Multi-Swarm, Adaptive Exploration, and Informed Search leveraging Opposition-Based Learning for enhanced convergence in photonic structures optimization.", "configspace": "", "generation": 50, "fitness": 0.28823940854891283, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28823940854891283]}, "mutation_prompt": null}
{"id": "1923b382-3abe-4d7e-afbe-26b2f50dc054", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.elite_fraction = 0.2  # Fraction of top individuals to focus on\n        self.adaptive_neighborhood = 0.1 + 0.9 * (budget // 1000)  # Scales with budget\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        new_velocity = self.phi * self.velocities[idx] + \\\n                       r1 * (self.pbest[idx] - self.positions[idx]) + \\\n                       r2 * (local_gbest - self.positions[idx])\n        self.velocities[idx] = new_velocity\n        new_pos = self.positions[idx] + new_velocity\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _dynamic_neighborhood(self):\n        neighborhood_size = int(self.population_size * self.adaptive_neighborhood)\n        for i in range(self.population_size):\n            neighborhood = np.random.choice(self.population_size, neighborhood_size, replace=False)\n            for neighbor in neighborhood:\n                if self.pbest_scores[neighbor] < self.pbest_scores[i]:\n                    self.pbest[i] = self.pbest[neighbor]\n                    self.pbest_scores[i] = self.pbest_scores[neighbor]\n                    \n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            elite_indices = np.argsort(self.pbest_scores)[:int(self.elite_fraction * self.population_size)]\n            for i in elite_indices:\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._dynamic_neighborhood()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum Adaptive Particle Swarm Optimization (QAPSO) with Enhanced Exploitation and Dynamic Neighborhood Adjustment to improve convergence in photonic structure optimization by focusing on elite particles and adaptive neighborhood size.", "configspace": "", "generation": 51, "fitness": 0.2902257383135204, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2902257383135204]}, "mutation_prompt": null}
{"id": "6cf6b65c-021d-437f-9523-2708265ad400", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.tol = 1e-5  # Stagnation tolerance\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        return u / (np.abs(v) ** (1 / 3))\n\n    def hybrid_local_search(self, position, func, max_iters=10):\n        step_size = 0.1\n        for _ in range(max_iters):\n            new_pos = position + step_size * np.random.uniform(-1, 1, self.dim)\n            new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n            new_score = func(new_pos)\n            if new_score < func(position):\n                position = new_pos\n        return position\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def check_stagnation(self):\n        if np.std(self.pbest_scores) < self.tol:\n            self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                self.positions[i] = self.hybrid_local_search(self.positions[i], func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self.check_stagnation()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Hybrid Local Search and Adaptive Diversity Strategy for enhanced exploration-exploitation balance in photonic structures optimization.", "configspace": "", "generation": 52, "fitness": 0.27706253962137484, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27706253962137484]}, "mutation_prompt": null}
{"id": "fc1db662-7e05-4939-baca-df84720d4c56", "solution": "import numpy as np\n\nclass QIDEALF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_individual(self, idx, func):\n        a, b, c = np.random.choice(self.population_size, 3, replace=False)\n        mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n        trial = np.where(np.random.rand(self.dim) < self.cr, mutant, self.population[idx])\n        trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n\n        if np.random.rand() < 0.3:  # Add Levy flight for exploration\n            trial += self.levy_flight()\n\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[idx]:\n            self.population[idx] = trial\n            self.fitness[idx] = trial_fitness\n\n            if trial_fitness < self.best_fitness:\n                self.best_individual = trial\n                self.best_fitness = trial_fitness\n\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_individual = self.population[i]\n                self.best_fitness = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_individual\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_individual(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_individual", "name": "QIDEALF", "description": "Quantum-Inspired Differential Evolution with Adaptive Levy Flights (QIDEALF) combines quantum behavior in evolutionary strategies with adaptive levy flights for enhanced exploration and exploitation in complex photonic structures optimization.", "configspace": "", "generation": 53, "fitness": 0.2814907758975307, "feedback": "The algorithm QIDEALF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2814907758975307]}, "mutation_prompt": null}
{"id": "a68c2985-ab4e-4e34-a7cc-9c9a8c65359c", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.dynamic_neighborhood_size = max(3, dim // 3)\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        neighbors = np.random.choice(self.population_size, self.dynamic_neighborhood_size, replace=False)\n        local_gbest = min(neighbors, key=lambda n: self.pbest_scores[n])\n        local_gbest_position = self.pbest[local_gbest]\n\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest_position - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_dynamic_parameters(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.dynamic_neighborhood_size = min(self.dynamic_neighborhood_size + 1, self.population_size // 2)\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.ub) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_dynamic_parameters()\n\n        return self.gbest", "name": "AdaptiveQuantumPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization with Lévy Flight and Dynamic Neighborhoods for enhanced exploration and exploitation balance in photonic structure optimization.", "configspace": "", "generation": 54, "fitness": 0.26929435116936074, "feedback": "The algorithm AdaptiveQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.26929435116936074]}, "mutation_prompt": null}
{"id": "5a31d0d2-c34d-42c1-8971-d5d42cb3a928", "solution": "import numpy as np\n\nclass ImprovedEnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.inertia_weight = 0.9  # Adaptive inertia weight\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] +\n                                self.phi * r1 * (self.pbest[idx] - self.positions[idx]) +\n                                self.phi * r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _adapt_inertia_weight(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.inertia_weight = max(0.4, self.inertia_weight - 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._adapt_inertia_weight()\n\n        return self.gbest", "name": "ImprovedEnhancedQAPSO", "description": "Improved EnhancedQAPSO with Adaptive Inertia Weight and Dynamic Swarm Coordination for Enhanced Convergence and Robustness in Photonic Structure Optimization.", "configspace": "", "generation": 55, "fitness": 0.28889039251480664, "feedback": "The algorithm ImprovedEnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28889039251480664]}, "mutation_prompt": null}
{"id": "63f0de3b-6f83-47c3-b2c1-ca18039a7bf1", "solution": "import numpy as np\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.F = 0.5  # Scaling factor for differential mutation\n        self.CR = 0.9  # Crossover probability\n        self.levy_scale = 0.01\n\n    def levy_flight(self):\n        u = np.random.normal(0, 1, self.dim) * self.levy_scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        x1, x2, x3 = self.positions[indices]\n        mutant = x1 + self.F * (x2 - x3)\n        return mutant\n\n    def _crossover(self, idx, mutant):\n        trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.positions[idx])\n        if np.random.rand() < 0.2:  # Quantum-inspired mutation\n            trial += self.levy_flight()\n        return trial\n\n    def _select(self, idx, trial, func):\n        trial_score = func(trial)\n        if trial_score < self.pbest_scores[idx]:\n            self.pbest[idx] = trial\n            self.pbest_scores[idx] = trial_score\n        if trial_score < self.gbest_score:\n            self.gbest = trial\n            self.gbest_score = trial_score\n        if trial_score < func(self.positions[idx]):\n            self.positions[idx] = trial\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(i, mutant)\n                trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n                self._select(i, trial, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "QuantumEnhancedDE", "description": "Quantum-Enhanced Differential Evolution with Adaptive Quantum-Inspired Mutation and Diversity-Driven Selection for efficient exploration and exploitation in complex optimization landscapes.", "configspace": "", "generation": 56, "fitness": 0.27749727127162505, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27749727127162505]}, "mutation_prompt": null}
{"id": "25a5ece1-7344-4e39-9f8b-b53530d9369c", "solution": "import numpy as np\n\nclass HybridQIGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, 10 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.crossover_rate = 0.5\n        self.mutation_factor = 0.8\n\n    def _initialize_population(self, bounds):\n        self.positions = bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.population_size, self.dim)\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.fitness[i] = score\n            if score < self.best_fitness:\n                self.best_fitness = score\n                self.best_solution = self.positions[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                break\n\n    def _mutation(self, idx):\n        idxs = list(range(self.population_size))\n        idxs.remove(idx)\n        a, b, c = np.random.choice(idxs, 3, replace=False)\n        mutant = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, 0, 1)\n\n    def _crossover(self, target, mutant):\n        crossover = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, target)\n        return crossover\n\n    def _select(self, target_idx, candidate, func):\n        candidate_fitness = func(candidate)\n        if candidate_fitness < self.fitness[target_idx]:\n            self.positions[target_idx] = candidate\n            self.fitness[target_idx] = candidate_fitness\n            if candidate_fitness < self.best_fitness:\n                self.best_fitness = candidate\n                self.best_fitness = candidate_fitness\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds)\n        self._evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutation(i)\n                crossover = self._crossover(self.positions[i], mutant)\n                crossover = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * crossover\n                self._select(i, crossover, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_solution", "name": "HybridQIGA", "description": "Hybrid Quantum-Inspired Genetic Algorithm with Adaptive Differential Evolution for enhanced convergence and diversity in optimizing complex photonic structures.", "configspace": "", "generation": 57, "fitness": 0.27860326683928716, "feedback": "The algorithm HybridQIGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27860326683928716]}, "mutation_prompt": null}
{"id": "bd64889d-4fd8-4729-834d-c29729b433a4", "solution": "import numpy as np\n\nclass QEDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, 10 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.alpha = 0.5\n        self.delta = 0.2\n        self.evaluations = 0\n        self.local_search_pivot = np.random.rand(self.dim)\n\n    def _quantum_exploration(self, pos):\n        shift = np.random.normal(0, 1, self.dim) * (np.abs(pos - self.local_search_pivot) ** 2)\n        return pos + shift\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        quantum_jumps = self._quantum_exploration(self.positions[idx])\n        inertia = (1 - self.alpha) * self.velocities[idx] + self.alpha * (self.pbest[idx] - self.positions[idx])\n        cooperation = r1 * (self.pbest[idx] - self.positions[idx]) + r2 * (self.gbest - self.positions[idx])\n        self.velocities[idx] = inertia + cooperation\n        new_pos = self.positions[idx] + self.velocities[idx]\n        new_pos = np.clip(new_pos + quantum_jumps, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n        \n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_local_search_pivot(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            best_idx = np.argmin(self.pbest_scores)\n            self.local_search_pivot = self.pbest[best_idx] + self.delta * (np.random.rand(self.dim) - 0.5)\n\n    def _adjust_alpha(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.alpha = max(0.1, self.alpha - 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_local_search_pivot()\n            self._adjust_alpha()\n\n        return self.gbest", "name": "QEDSO", "description": "Quantum-Enhanced Dynamic Swarm Optimization (QEDSO) integrates quantum-inspired exploration with dynamic local search pivots and adaptive temporal coherence to enhance exploration and convergence in photonic structure optimization.", "configspace": "", "generation": 58, "fitness": 0.27861143241591846, "feedback": "The algorithm QEDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27861143241591846]}, "mutation_prompt": null}
{"id": "43973cca-8a71-47b5-8708-d432b366ca42", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = 2.05\n        self.kappa = 0.9  # Constriction coefficient\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = self.kappa * (self.velocities[idx] +\n                                             r1 * (self.pbest[idx] - self.positions[idx]) +\n                                             r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _adapt_kappa(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.kappa = max(0.5, self.kappa * 0.95)  # Reduce constriction slightly over time\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._adapt_kappa()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Constriction Coefficient and Adaptive Stochastic Search for enhanced exploration-exploitation balance in photonic structures optimization.", "configspace": "", "generation": 59, "fitness": 0.28846033268947446, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28846033268947446]}, "mutation_prompt": null}
{"id": "23529ce7-0545-4d7b-a2c0-3927b7b6d594", "solution": "import numpy as np\n\nclass QuantumBioSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.evaluations = 0\n        self.alpha = 0.1  # Quantum influence\n        self.gamma = 0.5  # Symbiosis factor\n\n    def quantum_move(self):\n        q_positions = np.random.uniform(-1, 1, self.positions.shape)\n        return self.alpha * q_positions\n\n    def symbiotic_interaction(self):\n        pair_indices = np.random.permutation(self.population_size)\n        symbiotic_moves = np.zeros_like(self.positions)\n        for i in range(0, self.population_size, 2):\n            if i + 1 < self.population_size:\n                diff = self.positions[pair_indices[i+1]] - self.positions[pair_indices[i]]\n                symbiotic_moves[pair_indices[i]] += self.gamma * diff\n                symbiotic_moves[pair_indices[i+1]] -= self.gamma * diff\n        return symbiotic_moves\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        quantum_part = self.quantum_move()\n        symbiotic_part = self.symbiotic_interaction()[idx]\n        new_pos = self.positions[idx] + self.velocities[idx] + quantum_part + symbiotic_part\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "QuantumBioSwarm", "description": "Quantum Biologically Inspired Swarm Optimization incorporates quantum superposition and biological symbiotic relationships for enhanced exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "fbb7708e-b0d9-450b-9443-ffb6e2e531f7", "solution": "import numpy as np\n\nclass EnhancedQAPSOPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.alpha = 0.5  # Learning rate variability factor\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx])) * self.alpha\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        progress = self.evaluations / self.budget\n        new_population_size = int((1 - progress) * 20 * self.dim) + 10\n        if new_population_size > self.population_size:\n            additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n            self.positions = np.vstack((self.positions, additional_positions))\n            self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n            self.pbest = np.vstack((self.pbest, additional_positions))\n            self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n            self.population_size = new_population_size\n\n    def _adapt_beta_and_alpha(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.alpha = max(0.1, self.alpha - 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta_and_alpha()\n\n        return self.gbest", "name": "EnhancedQAPSOPlus", "description": "EnhancedQAPSO+ with Adaptive Quantum-Inspired Swarm Size and Learning Rate Variability improves convergence by dynamically adjusting swarm resources and exploration intensity based on optimization progress.", "configspace": "", "generation": 61, "fitness": 0.28641583475419374, "feedback": "The algorithm EnhancedQAPSOPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28641583475419374]}, "mutation_prompt": null}
{"id": "38cc3773-0738-4e10-bb3c-6f0c7f3bb237", "solution": "import numpy as np\n\nclass AdaptiveQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 7 * dim)  # Increased initial population size for diversity\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.epsilon = 0.9  # Memory factor for adaptive step control\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 4)  # Dynamic multi-swarm based on dimensionality\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.previous_gbest = None  # Memory for previous best solution\n        self.stagnation_counter = 0\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        \n        if self.previous_gbest is not None:\n            self.velocities[idx] += self.epsilon * (self.previous_gbest - self.positions[idx])\n\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.previous_gbest = self.gbest  # Update memory of previous best\n            self.gbest = new_pos\n            self.gbest_score = new_score\n            self.stagnation_counter = 0\n        else:\n            self.stagnation_counter += 1\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 3) == 0:\n            new_population_size = min(self.population_size + 10, 25 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.stagnation_counter > self.budget // 20:\n            self.beta = min(1.0, self.beta + 0.1)\n            self.stagnation_counter = 0\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "AdaptiveQIPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization with Enhanced Memory and Dynamic Search Intensification for efficient convergence in complex photonic structures optimization.", "configspace": "", "generation": 62, "fitness": 0.2880967885424792, "feedback": "The algorithm AdaptiveQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2880967885424792]}, "mutation_prompt": null}
{"id": "1e42c7e7-4575-48b2-b8e9-423bab281ecc", "solution": "import numpy as np\n\nclass QuantumGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.best_pos = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.alpha = 0.1  # Adaptive mutation rate\n        self.mutation_scale = 0.02  # Scale for mutation step size\n\n    def mutation(self, individual):\n        mutation_step = np.random.normal(scale=self.mutation_scale, size=self.dim)\n        return np.clip(individual + mutation_step, 0, 1)\n\n    def crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim - 1)\n        child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n        return child1, child2\n\n    def _evaluate_population(self, func):\n        scores = np.array([func(ind * (func.bounds.ub - func.bounds.lb) + func.bounds.lb) for ind in self.positions])\n        best_idx = np.argmin(scores)\n        if scores[best_idx] < self.best_score:\n            self.best_score = scores[best_idx]\n            self.best_pos = self.positions[best_idx]\n        self.evaluations += len(self.positions)\n        return scores\n\n    def _select_parents(self, scores):\n        probabilities = 1 / (scores + 1e-9)\n        probabilities /= probabilities.sum()\n        parents_indices = np.random.choice(self.population_size, size=(self.population_size, 2), p=probabilities)\n        return parents_indices\n\n    def _adapt_mutation_scale(self):\n        self.mutation_scale = min(0.1, self.mutation_scale + self.alpha)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            scores = self._evaluate_population(func)\n            if self.evaluations >= self.budget:\n                break\n\n            parents_indices = self._select_parents(scores)\n            new_population = []\n            for parent1_idx, parent2_idx in parents_indices:\n                parent1, parent2 = self.positions[parent1_idx], self.positions[parent2_idx]\n                child1, child2 = self.crossover(parent1, parent2)\n                if np.random.rand() < self.alpha:\n                    child1 = self.mutation(child1)\n                if np.random.rand() < self.alpha:\n                    child2 = self.mutation(child2)\n                new_population.extend([child1, child2])\n                if len(new_population) >= self.population_size:\n                    break\n\n            self.positions = np.array(new_population[:self.population_size])\n            self._adapt_mutation_scale()\n\n        return self.best_pos * (func.bounds.ub - func.bounds.lb) + func.bounds.lb", "name": "QuantumGeneticAlgorithm", "description": "Quantum Genetic Algorithm with Adaptive Population and Dynamic Mutation to enhance exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 63, "fitness": 0.27916996632731206, "feedback": "The algorithm QuantumGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27916996632731206]}, "mutation_prompt": null}
{"id": "10da0335-1df7-4dd7-8712-6c0d5db0cf03", "solution": "import numpy as np\n\nclass QuantumEnhancedAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.inertia_min = 0.4\n        self.inertia_max = 0.9\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (self.evaluations / self.budget)\n        self.velocities[idx] = (inertia_weight * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "QuantumEnhancedAPSO", "description": "Quantum-enhanced Adaptive Particle Swarm Optimization with a Novel Exploration-Exploitation Balancing Technique using Adaptive Quantum-inspired Time-varying Inertia Weight to boost performance on photonic structures optimization.", "configspace": "", "generation": 64, "fitness": 0.2897442225495691, "feedback": "The algorithm QuantumEnhancedAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2897442225495691]}, "mutation_prompt": null}
{"id": "4acf8f63-aa9d-48f7-bd1a-8e8005a1587c", "solution": "import numpy as np\n\nclass AdaptiveQIGWO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.alpha_pos = np.zeros(dim)\n        self.beta_pos = np.zeros(dim)\n        self.delta_pos = np.zeros(dim)\n        self.alpha_score = float('inf')\n        self.beta_score = float('inf')\n        self.delta_score = float('inf')\n        self.evaluations = 0\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.leaders = {'alpha': None, 'beta': None, 'delta': None}\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_position(self, idx, func):\n        a = 2 - self.evaluations * (2 / self.budget)\n        A1 = 2 * a * np.random.rand(self.dim) - a\n        A2 = 2 * a * np.random.rand(self.dim) - a\n        A3 = 2 * a * np.random.rand(self.dim) - a\n        C1 = 2 * np.random.rand(self.dim)\n        C2 = 2 * np.random.rand(self.dim)\n        C3 = 2 * np.random.rand(self.dim)\n\n        D_alpha = np.abs(C1 * self.alpha_pos - self.positions[idx])\n        D_beta = np.abs(C2 * self.beta_pos - self.positions[idx])\n        D_delta = np.abs(C3 * self.delta_pos - self.positions[idx])\n\n        X1 = self.alpha_pos - A1 * D_alpha\n        X2 = self.beta_pos - A2 * D_beta\n        X3 = self.delta_pos - A3 * D_delta\n\n        new_pos = (X1 + X2 + X3) / 3\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        score = func(new_pos)\n        self.evaluations += 1\n\n        if score < self.alpha_score:\n            self.alpha_score, self.alpha_pos = score, new_pos\n        elif score < self.beta_score:\n            self.beta_score, self.beta_pos = score, new_pos\n        elif score < self.delta_score:\n            self.delta_score, self.delta_pos = score, new_pos\n\n        self.positions[idx] = new_pos\n\n    def _adapt_leaders(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            current_leader_scores = [self.alpha_score, self.beta_score, self.delta_score]\n            sorted_indices = np.argsort(current_leader_scores)\n            self.leaders['alpha'], self.leaders['beta'], self.leaders['delta'] = (\n                self.positions[sorted_indices[0]], \n                self.positions[sorted_indices[1]], \n                self.positions[sorted_indices[2]]\n            )\n            self.alpha_pos, self.beta_pos, self.delta_pos = (\n                self.leaders['alpha'],\n                self.leaders['beta'],\n                self.leaders['delta']\n            )\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            if score < self.alpha_score:\n                self.alpha_score, self.alpha_pos = score, self.positions[i]\n            elif score < self.beta_score:\n                self.beta_score, self.beta_pos = score, self.positions[i]\n            elif score < self.delta_score:\n                self.delta_score, self.delta_pos = score, self.positions[i]\n\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.alpha_pos\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_position(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_leaders()\n\n        return self.alpha_pos", "name": "AdaptiveQIGWO", "description": "Adaptive Quantum-Inspired Grey Wolf Optimizer with Dynamic Pack Restructuring and Levy Flight for Enhanced Exploration and Exploitation in Photonic Structure Optimization.", "configspace": "", "generation": 65, "fitness": 0.2872709887486389, "feedback": "The algorithm AdaptiveQIGWO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2872709887486389]}, "mutation_prompt": null}
{"id": "3d06f8b0-824b-46cb-870c-e6f67953fa3d", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.memory = []\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n\n        # Adaptive memory strategy\n        momentum_factor = 0.5\n        if self.memory:\n            memory_position = self.memory[np.random.randint(0, len(self.memory))]\n            momentum_factor = 0.7\n\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx])) * momentum_factor\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n            # Memory enhancement\n            if len(self.memory) < 10 or new_score < max([func(p) for p in self.memory]):\n                self.memory.append(new_pos)\n                if len(self.memory) > 10:\n                    self.memory.remove(max(self.memory, key=lambda p: func(p)))\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Adaptive Memory Strategies and Dynamic Convergence Enhancements for improved exploration-exploitation balance in photonic structures optimization.", "configspace": "", "generation": 66, "fitness": 0.2895572639810198, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2895572639810198]}, "mutation_prompt": null}
{"id": "84e64df6-9df0-43b7-9054-c248bcb89261", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.restart_threshold = budget // 3\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        inertia_weight = self.w_max - ((self.w_max - self.w_min) * (self.evaluations / self.budget))\n        self.velocities[idx] = (inertia_weight * self.velocities[idx] +\n                                self.phi * r1 * (self.pbest[idx] - self.positions[idx]) +\n                                self.phi * r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size * 2, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _adaptive_restart(self):\n        if self.evaluations > self.restart_threshold and self.gbest_score == min(self.pbest_scores):\n            self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                self.pbest[i] = self.positions[i]\n                self.pbest_scores[i] = score\n            self.gbest_score = float('inf')\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._adaptive_restart()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Multi-Swarm Strategy enhanced by Adaptive Restart Mechanism and Adaptive Inertia Weight for improved exploration-exploitation balance and robustness in photonic structures optimization.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "68239d6e-c773-4631-9fb9-5fbfaa35056c", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.mutation_rate = 0.01\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _dynamic_leader_selection(self, idx, func):\n        swarm_idx = idx % self.num_swarms\n        if np.random.rand() < 0.5:\n            return self.gbest\n        else:\n            return self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n\n    def _mutate(self, position):\n        if np.random.rand() < self.mutation_rate:\n            mutation_vector = np.random.normal(0, 0.1, self.dim)\n            return np.clip(position + mutation_vector, func.bounds.lb, func.bounds.ub)\n        return position\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        leader = self._dynamic_leader_selection(idx, func)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (leader - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_pos = self._mutate(new_pos)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[idx % self.num_swarms]:\n            self.local_gbests[idx % self.num_swarms] = new_pos\n            self.local_gbest_scores[idx % self.num_swarms] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Leader Selection and Adaptive Mutation for enhanced exploration-exploitation balance in photonic structures optimization.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "8df5a945-eef5-484b-b42e-125020266fd4", "solution": "import numpy as np\n\nclass QuantumGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, 10 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.mutation_rate = 0.05\n        self.elite_fraction = 0.1\n        self.evaluations = 0\n\n    def quantum_bit_flip(self, individual):\n        mutation_vector = np.random.rand(self.dim) < self.mutation_rate\n        new_individual = np.where(mutation_vector, 1 - individual, individual)\n        return new_individual\n\n    def crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim - 1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def select_parents(self):\n        probabilities = 1 / (1 + self.fitness)\n        probabilities /= probabilities.sum()\n        parent_indices = np.random.choice(self.population_size, size=2, p=probabilities)\n        return self.positions[parent_indices[0]], self.positions[parent_indices[1]]\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.positions[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_individual = self.positions[i].copy()\n                self.best_fitness = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_individual\n\n        while self.evaluations < self.budget:\n            new_population = []\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:elite_size]\n            new_population.extend(self.positions[elite_indices])\n            \n            while len(new_population) < self.population_size:\n                parent1, parent2 = self.select_parents()\n                child = self.crossover(parent1, parent2)\n                mutated_child = self.quantum_bit_flip(child)\n                new_population.append(mutated_child)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            self.positions = np.array(new_population)[:self.population_size]\n            self.positions = np.clip(self.positions, func.bounds.lb, func.bounds.ub)\n\n            for i in range(self.population_size):\n                self.fitness[i] = func(self.positions[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_individual = self.positions[i].copy()\n                    self.best_fitness = self.fitness[i]\n\n        return self.best_individual", "name": "QuantumGeneticAlgorithm", "description": "Quantum Genetic Algorithm with Adaptive Mutation and Elite Reinforcement Strategy for efficient exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 69, "fitness": 0.2812982083103951, "feedback": "The algorithm QuantumGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2812982083103951]}, "mutation_prompt": null}
{"id": "76edf0b6-dddc-4333-91c0-edcdf143b843", "solution": "import numpy as np\n\nclass DynamicAdaptiveQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.inertia_weight = 0.9  # Start with a high inertia\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] +\n                                self.c1 * r1 * (self.pbest[idx] - self.positions[idx]) +\n                                self.c2 * r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_inertia_weight(self):\n        # Decrease inertia weight adaptively\n        self.inertia_weight = max(0.4, self.inertia_weight - 0.01)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_inertia_weight()\n\n        return self.gbest", "name": "DynamicAdaptiveQAPSO", "description": "Introducing Dynamic Adaptive Multi-Swarm Strategy with Adaptive Inertia Weights for enhanced convergence and robustness in optimizing photonic structures.", "configspace": "", "generation": 70, "fitness": 0.2828088621017022, "feedback": "The algorithm DynamicAdaptiveQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2828088621017022]}, "mutation_prompt": null}
{"id": "09399b9c-fba8-43c7-9f1b-0abb60acab6e", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        \n        # Apply hybrid mutation strategy\n        if np.random.rand() < 0.1:\n            mutation = np.random.uniform(-1, 1, self.dim)\n            self.positions[idx] = np.clip(self.positions[idx] + mutation, func.bounds.lb, func.bounds.ub)\n\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta_and_inertia(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta_and_inertia()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with a Hybrid Mutation Strategy and Adaptive Inertia Weight Control for enhanced exploration and exploitation balance in photonic structures optimization.", "configspace": "", "generation": 71, "fitness": 0.2852864859591998, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2852864859591998]}, "mutation_prompt": null}
{"id": "122f1c1e-5be7-474f-9889-dd8549444e17", "solution": "import numpy as np\n\nclass QuantumInspiredGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.pbest = self.population.copy()\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.mutation_rate = 0.1\n        self.adaptive_factor = 0.3\n\n    def diversity_maintenance(self):\n        mean_vector = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_vector, axis=1))\n        if diversity < 0.1:\n            self.population += 0.1 * (np.random.rand(self.population_size, self.dim) - 0.5)\n\n    def adaptive_crossover(self, parent1, parent2):\n        alpha = np.random.rand(self.dim)\n        if self.gbest is not None:\n            beta = np.random.uniform(0, self.adaptive_factor, self.dim)\n            offspring = beta * self.gbest + (1 - beta) * (alpha * parent1 + (1 - alpha) * parent2)\n        else:\n            offspring = alpha * parent1 + (1 - alpha) * parent2\n        return offspring\n\n    def mutate(self, individual):\n        mutation_vector = np.random.normal(0, 1, self.dim) * self.mutation_rate\n        return np.clip(individual + mutation_vector, 0, 1)\n\n    def _update_population(self, func):\n        new_population = []\n        scores = []\n        for i in range(self.population_size):\n            parent1, parent2 = self.population[np.random.choice(self.population_size, 2, replace=False)]\n            offspring = self.adaptive_crossover(parent1, parent2)\n            offspring = self.mutate(offspring)\n            offspring = np.clip(func.bounds.lb + (func.bounds.ub - func.bounds.lb) * offspring, func.bounds.lb, func.bounds.ub)\n            score = func(offspring)\n            new_population.append(offspring)\n            scores.append(score)\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                break\n        return new_population, scores\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.population[i])\n            self.pbest[i] = self.population[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.population[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            self.diversity_maintenance()\n            new_population, new_scores = self._update_population(func)\n            for i in range(len(new_population)):\n                if new_scores[i] < self.pbest_scores[i]:\n                    self.pbest[i] = new_population[i]\n                    self.pbest_scores[i] = new_scores[i]\n                if new_scores[i] < self.gbest_score:\n                    self.gbest = new_population[i]\n                    self.gbest_score = new_scores[i]\n            self.population = new_population\n\n        return self.gbest", "name": "QuantumInspiredGeneticAlgorithm", "description": "Quantum-Inspired Genetic Algorithm with Enhanced Diversity and Adaptive Crossover Strategy for robust exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 72, "fitness": 0.27520033712251246, "feedback": "The algorithm QuantumInspiredGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27520033712251246]}, "mutation_prompt": null}
{"id": "20f427cc-7547-4f4a-8d74-156e3e71875f", "solution": "import numpy as np\n\nclass QIPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.9  # Crossover probability\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _differential_evolution(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.positions[a] + self.f * (self.positions[b] - self.positions[c])\n        trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.positions[idx])\n        return np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        if np.random.rand() < 0.5:\n            new_pos = self._differential_evolution(idx)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.gbest", "name": "QIPSO_ADE", "description": "Quantum-Inspired Particle Swarm Optimization with Adaptive Differential Evolution (QIPSO-ADE), integrating quantum-inspired mechanisms and adaptive differential evolution for enhanced exploration and exploitation in high-dimensional photonic structures optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "a74a8aa8-9600-414b-b625-8cac13d1f10f", "solution": "import numpy as np\n\nclass QuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.crossover_rate = 0.5\n        self.mutation_factor = 0.8\n\n    def _quantum_behavior(self, candidate, leader):\n        distance = candidate - leader\n        q_bit = np.random.normal(0, 1, self.dim)\n        step = self.mutation_factor * distance * q_bit\n        return candidate + step\n\n    def _select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def _mutate(self, a, b, c):\n        mutant_vector = a + self.mutation_factor * (b - c)\n        return np.clip(mutant_vector, 0, 1)\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.crossover_rate = np.clip(np.random.normal(self.crossover_rate, 0.1), 0.3, 0.9)\n            self.mutation_factor = np.clip(np.random.normal(self.mutation_factor, 0.1), 0.5, 1.0)\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_solution = self.population[i]\n                self.best_fitness = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self._select_parents()\n                mutant = self._mutate(a, b, c)\n                offspring = self._crossover(self.population[i], mutant)\n                offspring = self._quantum_behavior(offspring, self.best_solution)\n\n                offspring = np.clip(offspring, func.bounds.lb, func.bounds.ub)\n                offspring_fitness = func(offspring)\n\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n\n                    if offspring_fitness < self.best_fitness:\n                        self.best_solution = offspring\n                        self.best_fitness = offspring_fitness\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            self._adapt_parameters()\n\n        return self.best_solution", "name": "QuantumDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Crossover and Mutation Strategies for Robust Optimization of Photonic Structures.", "configspace": "", "generation": 74, "fitness": 0.28374288247514434, "feedback": "The algorithm QuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28374288247514434]}, "mutation_prompt": null}
{"id": "ddaadb16-c32f-4b7a-bfe4-7d7b1cf45b6b", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.F = 0.5  # Differential evolution parameter\n        self.CR = 0.9  # Crossover rate\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def differential_mutation(self, target_idx):\n        indices = list(range(self.population_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        mutant = self.differential_mutation(idx)\n        trial_pos = self.crossover(new_pos, mutant)\n        trial_pos = np.clip(trial_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(trial_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = trial_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = trial_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = trial_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = trial_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.F = np.clip(self.F + np.random.normal(0, 0.1), 0.4, 1.0)\n            self.CR = np.clip(self.CR + np.random.normal(0, 0.1), 0.6, 1.0)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_parameters()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Multi-Swarm Strategy, Enhanced Exploration through Adaptive Differential Evolution, and Self-Adjusting Parameters for improved convergence in photonic structures optimization.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "658571fe-d667-4476-90bd-8cd25b1ae9aa", "solution": "import numpy as np\n\nclass ADEQRL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_idx = None\n        self.best_fitness = float('inf')\n        self.f_cr = 0.9\n        self.f_f = 0.8\n        self.evaluations = 0\n        self.quantum_rotation = 0.1\n\n    def _quantum_rotation(self, current):\n        theta = np.random.uniform(-np.pi, np.pi, self.dim)\n        rotation_matrix = np.cos(theta) * current + np.sin(theta) * (1 - current)\n        return rotation_matrix\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.f_f * (b - c), 0, 1)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.f_cr\n        offspring = np.where(crossover_mask, mutant, target)\n        return offspring\n\n    def _select(self, idx, candidate, func):\n        candidate_real = func.bounds.lb + candidate * (func.bounds.ub - func.bounds.lb)\n        candidate_fitness = func(candidate_real)\n        if candidate_fitness < self.fitness[idx]:\n            self.positions[idx] = candidate\n            self.fitness[idx] = candidate_fitness\n            if candidate_fitness < self.best_fitness:\n                self.best_idx = idx\n                self.best_fitness = candidate_fitness\n        self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            real_pos = func.bounds.lb + self.positions[i] * (func.bounds.ub - func.bounds.lb)\n            self.fitness[i] = func(real_pos)\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_idx = i\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return func.bounds.lb + self.positions[self.best_idx] * (func.bounds.ub - func.bounds.lb)\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(self.positions[a], self.positions[b], self.positions[c])\n                trial = self._crossover(self.positions[i], mutant)\n                trial = np.clip(trial + self.quantum_rotation * self._quantum_rotation(trial), 0, 1)\n                self._select(i, trial, func)\n                if self.evaluations >= self.budget:\n                    break\n\n        return func.bounds.lb + self.positions[self.best_idx] * (func.bounds.ub - func.bounds.lb)", "name": "ADEQRL", "description": "Adaptive Differential Evolution with Quantum Rotation-based Local Search for robust and efficient global optimization of photonic structures.", "configspace": "", "generation": 76, "fitness": 0.28176966897715716, "feedback": "The algorithm ADEQRL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28176966897715716]}, "mutation_prompt": null}
{"id": "aeaf4e84-ac21-4493-9599-48af4af54c01", "solution": "import numpy as np\n\nclass QAGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.mutation_rate = 0.1\n        self.selection_pressure = 1.5\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(self.positions[i])\n            self.fitness[i] = score\n            if score < self.best_fitness:\n                self.best_fitness = score\n                self.best_solution = self.positions[i].copy()\n            self.evaluations += 1\n\n    def _select_parents(self):\n        fitness_inv = 1.0 / (self.fitness + 1e-12)\n        prob = fitness_inv ** self.selection_pressure\n        prob /= np.sum(prob)\n        parents_idx = np.random.choice(self.population_size, size=self.population_size, p=prob)\n        return self.positions[parents_idx]\n\n    def _crossover(self, parents):\n        offspring = parents.copy()\n        for i in range(0, self.population_size, 2):\n            if i+1 < self.population_size:\n                alpha = np.random.rand(self.dim)\n                offspring[i] = alpha * parents[i] + (1 - alpha) * parents[i+1]\n                offspring[i+1] = alpha * parents[i+1] + (1 - alpha) * parents[i]\n        return offspring\n\n    def _mutate(self, offspring):\n        mutation_matrix = np.random.rand(self.population_size, self.dim) < self.mutation_rate\n        mutations = np.random.randn(self.population_size, self.dim) * mutation_matrix\n        offspring += mutations\n        return offspring\n\n    def _adapt_mutation_rate(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.mutation_rate = min(0.5, self.mutation_rate + 0.01)\n\n    def _adapt_selection_pressure(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.selection_pressure = min(2.5, self.selection_pressure + 0.1)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        self._evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            parents = self._select_parents()\n            offspring = self._crossover(parents)\n            offspring = self._mutate(offspring)\n            self.positions = np.clip(offspring, func.bounds.lb, func.bounds.ub)\n            self._evaluate_population(func)\n            self._adapt_mutation_rate()\n            self._adapt_selection_pressure()\n\n        return self.best_solution", "name": "QAGA", "description": "Quantum-Inspired Adaptive Genetic Algorithm (QAGA) with Dynamic Mutation and Selection Pressure Adjustment for enhanced convergence and exploration in optimizing photonic structures.", "configspace": "", "generation": 77, "fitness": 0.2786815209230752, "feedback": "The algorithm QAGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2786815209230752]}, "mutation_prompt": null}
{"id": "d974e455-a4b7-4f24-bb47-961bf0445491", "solution": "import numpy as np\n\nclass QuantumEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.F = 0.5  # Differential mutation factor\n        self.CR = 0.9  # Crossover rate\n        self.cov_matrix = np.eye(dim)  # Initial covariance matrix for CMA\n\n    def quantum_leap(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _mutate_and_crossover(self, idx, func):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.F * (self.population[b] - self.population[c])\n        if np.random.rand() < 0.5:\n            mutant_vector += np.random.multivariate_normal(np.zeros(self.dim), self.cov_matrix)\n\n        trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.population[idx])\n        trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n        trial_score = func(trial_vector)\n\n        if trial_score < self.scores[idx]:\n            self.population[idx] = trial_vector\n            self.scores[idx] = trial_score\n            if trial_score < self.best_score:\n                self.best_solution = trial_vector\n                self.best_score = trial_score\n\n        self.evaluations += 1\n\n    def _adapt_covariance(self):\n        if self.evaluations % (self.budget // 5) == 0 and self.best_solution is not None:\n            deviations = self.population - self.best_solution\n            cov_updates = 0.1 * np.cov(deviations.T) + 0.9 * self.cov_matrix\n            self.cov_matrix = cov_updates\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n\n        for i in range(self.population_size):\n            score = func(self.population[i])\n            self.scores[i] = score\n            if score < self.best_score:\n                self.best_solution = self.population[i]\n                self.best_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._mutate_and_crossover(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_covariance()\n\n        return self.best_solution", "name": "QuantumEnhancedADE", "description": "Quantum-Enhanced Adaptive Differential Evolution with Covariance Matrix Adaptation for robust exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 78, "fitness": 0.2828153542452756, "feedback": "The algorithm QuantumEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2828153542452756]}, "mutation_prompt": null}
{"id": "283250d5-250e-422e-a376-e55e65e49d78", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.alpha = 0.9\n        self.delta = 0.01\n        \n    def quantum_tunneling(self):\n        q_step = np.random.randn(self.dim) * self.delta\n        return q_step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[idx] = (self.alpha * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (self.gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.quantum_tunneling()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.alpha = max(0.4, self.alpha - 0.05)\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_parameters()\n\n        return self.gbest", "name": "QuantumAdaptivePSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Adaptive Quantum Tunneling and Convergent Diversity Strategy to maintain exploration and exploitation balance in high-dimensional photonic structure optimization.", "configspace": "", "generation": 79, "fitness": 0.2879278044092779, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2879278044092779]}, "mutation_prompt": null}
{"id": "d0790c09-3007-4806-9cfc-8e3b8f87bdf9", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.social_component = np.random.rand(self.population_size, dim)\n        self.cognitive_component = np.random.rand(self.population_size, dim)\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                self.cognitive_component[idx] * r1 * (self.pbest[idx] - self.positions[idx]) +\n                                self.social_component[idx] * r2 * (local_gbest - self.positions[idx]))\n\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.social_component = np.vstack((self.social_component, np.random.rand(new_population_size - self.population_size, self.dim)))\n                self.cognitive_component = np.vstack((self.cognitive_component, np.random.rand(new_population_size - self.population_size, self.dim)))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "EnhancedQAPSO with Social and Cognitive Component Decoupling via Stochastic Swarm Interaction to improve exploration-exploitation balance and efficiency in high-dimensional photonic structures optimization.", "configspace": "", "generation": 80, "fitness": 0.285331985893881, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.285331985893881]}, "mutation_prompt": null}
{"id": "0f7bc486-359f-40f6-8232-35cec6385b5e", "solution": "import numpy as np\n\nclass QuantumLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.trial_positions = np.zeros((self.population_size, dim))\n        self.best_position = None\n        self.best_score = float('inf')\n        self.evaluations = 0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def quantum_state(self):\n        alpha = np.random.rand(self.dim)\n        beta = np.sqrt(1 - alpha**2)\n        return alpha * self.best_position + beta * np.random.rand(self.dim)\n\n    def _mutate_and_crossover(self, idx, func):\n        indices = np.arange(self.population_size)\n        np.random.shuffle(indices)\n        a, b, c = self.positions[indices[:3]]\n        \n        mutant = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        self.trial_positions[idx] = np.where(crossover_mask, mutant, self.positions[idx])\n\n        if np.random.rand() < 0.5:\n            self.trial_positions[idx] += self.levy_flight()\n\n        trial_score = func(self.trial_positions[idx])\n        if trial_score < self.best_score:\n            self.best_score = trial_score\n            self.best_position = self.trial_positions[idx]\n\n        return trial_score\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            if score < self.best_score:\n                self.best_score = score\n                self.best_position = self.positions[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_position\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                trial_score = self._mutate_and_crossover(i, func)\n                if trial_score < func(self.positions[i]):\n                    self.positions[i] = self.trial_positions[i]\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_position", "name": "QuantumLevyDifferentialEvolution", "description": "Quantum-Levy Differential Evolution (QLDE) integrates quantum-inspired superposition states with Levy flight enrichment and differential evolution strategies to enhance exploration and exploitation in optimizing photonic structures.", "configspace": "", "generation": 81, "fitness": 0.2794543559951248, "feedback": "The algorithm QuantumLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2794543559951248]}, "mutation_prompt": null}
{"id": "256014f6-b1d5-4194-92d0-4ebb12cf95a8", "solution": "import numpy as np\n\nclass AdaptiveHybridGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(15, 6 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.adaptive_rate = 0.2\n        self.evaluations = 0\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_individual = self.population[i].copy()\n            self.evaluations += 1\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            point = np.random.randint(1, self.dim)\n            child = np.concatenate([parent1[:point], parent2[point:]])\n        else:\n            child = parent1.copy()\n        return child\n\n    def _mutate(self, individual):\n        if np.random.rand() < self.mutation_rate:\n            idx = np.random.randint(self.dim)\n            individual[idx] += np.random.normal(0, 0.1)\n        return np.clip(individual, 0, 1)\n\n    def _adaptive_differential_evolution(self, individual, best_individual):\n        mutant = individual + self.adaptive_rate * (best_individual - individual)\n        return np.clip(mutant, 0, 1)\n\n    def _select_parents(self):\n        idx1, idx2 = np.random.choice(self.population_size, 2, replace=False)\n        return self.population[idx1], self.population[idx2]\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        self._evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            new_population = []\n            for _ in range(self.population_size):\n                parent1, parent2 = self._select_parents()\n                child = self._crossover(parent1, parent2)\n                child = self._mutate(child)\n                child = self._adaptive_differential_evolution(child, self.best_individual)\n                new_population.append(child)\n            self.population = np.array(new_population)\n            self._evaluate_population(func)\n\n        return self.best_individual", "name": "AdaptiveHybridGA", "description": "Adaptive Hybrid Genetic Algorithm (AHGA), combining genetic crossover, mutation, and adaptive differential evolution to enhance global exploration and local exploitation in photonic structures optimization.", "configspace": "", "generation": 82, "fitness": 0.27529627082138897, "feedback": "The algorithm AdaptiveHybridGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27529627082138897]}, "mutation_prompt": null}
{"id": "404e9692-f623-4a3e-940a-486a71dedb46", "solution": "import numpy as np\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, 10 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.scale_factor = 0.5\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_threshold = 0.1\n\n    def quantum_perturbation(self, position, factor=0.1):\n        quantum_noise = np.random.normal(0, factor, self.dim)\n        return np.clip(position + quantum_noise, 0, 1)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        \n        for i in range(self.population_size):\n            self.fitness[i] = func(self.positions[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_solution = self.positions[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.positions[indices]\n                mutant = np.clip(a + self.scale_factor * (b - c), lb, ub)\n                trial = np.copy(self.positions[i])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial[cross_points] = mutant[cross_points]\n\n                trial_fitness = func(trial)\n                if trial_fitness < self.fitness[i]:\n                    self.positions[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n                if np.random.rand() < self.adaptive_threshold:\n                    self.positions[i] = self.quantum_perturbation(self.positions[i])\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            self._adapt_population()\n\n        return self.best_solution\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.scale_factor = np.random.uniform(0.4, 0.9)\n            self.crossover_rate = np.random.uniform(0.7, 0.95)", "name": "QuantumEnhancedDE", "description": "Quantum-Enhanced Differential Evolution with Adaptive Strategy and Dynamic Population for efficient global optimization in photonic structures.", "configspace": "", "generation": 83, "fitness": 0.2820088036778633, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2820088036778633]}, "mutation_prompt": null}
{"id": "af10fd33-bf3f-47ee-97f5-b994ab485cdf", "solution": "import numpy as np\n\nclass HybridQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def compute_gradient_step(self, position, func, epsilon=1e-8):\n        gradient = np.zeros(self.dim)\n        for i in range(self.dim):\n            step = np.zeros(self.dim)\n            step[i] = epsilon\n            gradient[i] = (func(position + step) - func(position - step)) / (2 * epsilon)\n        return -gradient  # Gradient descent step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        if np.random.rand() < 0.1:  # Add a small chance to perform gradient informed step\n            new_pos += self.compute_gradient_step(new_pos, func)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "HybridQAPSO", "description": "Hybrid Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Swarm Adaptation and Gradient Informed Exploration for enhanced convergence and solution quality in photonic structures optimization.", "configspace": "", "generation": 84, "fitness": 0.28694607036967024, "feedback": "The algorithm HybridQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28694607036967024]}, "mutation_prompt": null}
{"id": "90e693ef-a651-4d76-90f3-272985877e24", "solution": "import numpy as np\n\nclass AdaptiveQuantumGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.mutation_rate = 0.05\n        self.crossover_rate = 0.7\n\n    def quantum_crossover(self, parent1, parent2):\n        alpha = np.random.rand(self.dim)\n        child1 = alpha * parent1 + (1 - alpha) * parent2\n        child2 = alpha * parent2 + (1 - alpha) * parent1\n        return child1, child2\n\n    def quantum_mutation(self, offspring):\n        mutation_vector = np.random.normal(0, 1, self.dim)\n        offspring += self.mutation_rate * mutation_vector\n        return offspring\n\n    def _evaluate(self, individual, func):\n        fitness = func(individual)\n        return fitness\n\n    def _select_parents(self):\n        indices = np.random.choice(self.population_size, 2, replace=False)\n        return self.population[indices[0]], self.population[indices[1]]\n\n    def _update_population(self, func, bounds):\n        new_population = []\n        for _ in range(self.population_size // 2):\n            parent1, parent2 = self._select_parents()\n            if np.random.rand() < self.crossover_rate:\n                child1, child2 = self.quantum_crossover(parent1, parent2)\n            else:\n                child1, child2 = parent1.copy(), parent2.copy()\n\n            child1 = self.quantum_mutation(child1)\n            child2 = self.quantum_mutation(child2)\n\n            child1 = np.clip(child1, bounds.lb, bounds.ub)\n            child2 = np.clip(child2, bounds.lb, bounds.ub)\n\n            new_population.extend([child1, child2])\n\n        self.population = np.array(new_population[:self.population_size])\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.mutation_rate = max(0.01, self.mutation_rate * 0.95)\n            self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.population = bounds.lb + (bounds.ub - bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = self._evaluate(self.population[i], func)\n            if self.fitness[i] < self.best_fitness:\n                self.best_solution = self.population[i]\n                self.best_fitness = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            self._update_population(func, bounds)\n            for i in range(self.population_size):\n                fitness = self._evaluate(self.population[i], func)\n                if fitness < self.fitness[i]:\n                    self.fitness[i] = fitness\n                    if fitness < self.best_fitness:\n                        self.best_solution = self.population[i]\n                        self.best_fitness = fitness\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return self.best_solution\n            self._adapt_parameters()\n\n        return self.best_solution", "name": "AdaptiveQuantumGeneticAlgorithm", "description": "Adaptive Quantum Genetic Algorithm (AQGA) combines quantum-inspired genetic operations with adaptive learning to optimize photonic structures effectively by leveraging quantum concepts and dynamic parameter adjustments.", "configspace": "", "generation": 85, "fitness": 0.27520033712251246, "feedback": "The algorithm AdaptiveQuantumGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27520033712251246]}, "mutation_prompt": null}
{"id": "fa8a605f-a374-4199-8571-c7b180f016a2", "solution": "import numpy as np\n\nclass QuantumGeneticHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.hmcr = 0.9  # Harmony Memory Consideration Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.qbit_population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n\n    def quantum_to_real(self, qbit):\n        return qbit * (self.ub - self.lb) + self.lb\n\n    def _initialize_population(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        for i in range(self.population_size):\n            real_position = self.quantum_to_real(self.qbit_population[i])\n            score = func(real_position)\n            self.fitness[i] = score\n            if score < self.gbest_score:\n                self.gbest_score = score\n                self.gbest = real_position\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return\n\n    def _crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) > 0.5\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def _harmony_search(self, func):\n        for _ in range(self.population_size):\n            if np.random.rand() < self.hmcr:\n                idx1, idx2 = np.random.choice(self.population_size, 2, replace=False)\n                new_qbit = self._crossover(self.qbit_population[idx1], self.qbit_population[idx2])\n            else:\n                new_qbit = np.random.rand(self.dim)\n            \n            if np.random.rand() < self.par:\n                adjustment = (np.random.rand(self.dim) - 0.5) * 0.05\n                new_qbit = (new_qbit + adjustment) % 1.0\n\n            new_real = self.quantum_to_real(new_qbit)\n            new_score = func(new_real)\n            worst_idx = np.argmax(self.fitness)\n            \n            if new_score < self.fitness[worst_idx]:\n                self.qbit_population[worst_idx] = new_qbit\n                self.fitness[worst_idx] = new_score\n                if new_score < self.gbest_score:\n                    self.gbest = new_real\n                    self.gbest_score = new_score\n            \n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return\n\n    def __call__(self, func):\n        self._initialize_population(func)\n        while self.evaluations < self.budget:\n            self._harmony_search(func)\n        return self.gbest", "name": "QuantumGeneticHarmonySearch", "description": "Quantum Genetic Harmony Search (QGHS), combining quantum-inspired encoding, genetic crossover, and harmony search principles for efficient exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 86, "fitness": 0.28309078978181235, "feedback": "The algorithm QuantumGeneticHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28309078978181235]}, "mutation_prompt": null}
{"id": "e1d9efbe-53c6-45a2-91f2-88b5ca37f500", "solution": "import numpy as np\n\nclass AdaptiveQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def differential_evolution(self, idx, func):\n        idxs = list(range(self.population_size))\n        idxs.remove(idx)\n        a, b, c = np.random.choice(idxs, 3, replace=False)\n        mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n        mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n        cross_points = np.random.rand(self.dim) < self.CR\n        trial = np.where(cross_points, mutant, self.positions[idx])\n        if np.random.rand() < 0.1:\n            trial += self.levy_flight()\n        trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n        trial_score = func(trial)\n\n        if trial_score < self.fitness[idx]:\n            self.positions[idx] = trial\n            self.fitness[idx] = trial_score\n\n        if trial_score < self.gbest_score:\n            self.gbest = trial\n            self.gbest_score = trial_score\n\n        self.evaluations += 1\n\n    def adapt_population_size(self):\n        if self.evaluations % (self.budget // 3) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.fitness = np.hstack((self.fitness, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.positions[i])\n            if self.fitness[i] < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self.differential_evolution(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self.adapt_population_size()\n\n        return self.gbest", "name": "AdaptiveQIDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Population Resizing and Enhanced Exploration for efficient photonic structures optimization.", "configspace": "", "generation": 87, "fitness": 0.28136122718347245, "feedback": "The algorithm AdaptiveQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28136122718347245]}, "mutation_prompt": null}
{"id": "99c8b545-c2c6-4e31-8df9-b6c960e76708", "solution": "import numpy as np\n\nclass HybridQGEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.crossover_prob = 0.8\n        self.mutation_scale = 0.02\n        self.evaluations = 0\n\n    def quantum_mutation(self, individual):\n        delta = np.random.normal(0, 1, self.dim) * self.mutation_scale\n        mutated_individual = individual + delta\n        return mutated_individual\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def select_parents(self):\n        idx1, idx2 = np.random.choice(self.population_size, size=2, replace=False)\n        return self.population[idx1], self.population[idx2]\n\n    def _adapt_mutation_scale(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.mutation_scale = max(0.01, self.mutation_scale * 0.9)\n\n    def __call__(self, func):\n        bounds_low, bounds_high = func.bounds.lb, func.bounds.ub\n        self.population = bounds_low + (bounds_high - bounds_low) * np.random.rand(self.population_size, self.dim)\n        \n        for i in range(self.population_size):\n            score = func(self.population[i])\n            self.fitness[i] = score\n            if score < self.best_fitness:\n                self.best_individual = self.population[i]\n                self.best_fitness = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_individual\n\n        while self.evaluations < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents()\n                if np.random.rand() < self.crossover_prob:\n                    child1 = self.crossover(parent1, parent2)\n                    child2 = self.crossover(parent2, parent1)\n                else:\n                    child1, child2 = parent1, parent2\n                \n                child1 = np.clip(child1, bounds_low, bounds_high)\n                child2 = np.clip(child2, bounds_low, bounds_high)\n\n                if np.random.rand() < 0.5:\n                    child1 = self.quantum_mutation(child1)\n                    child2 = self.quantum_mutation(child2)\n                \n                new_population.append(child1)\n                new_population.append(child2)\n\n            self.population = np.array(new_population)\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                if score < self.fitness[i]:\n                    self.fitness[i] = score\n                if score < self.best_fitness:\n                    self.best_individual = self.population[i]\n                    self.best_fitness = score\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_mutation_scale()\n\n        return self.best_individual", "name": "HybridQGEA", "description": "Hybrid Quantum Genetic Evolutionary Algorithm integrating quantum-inspired mutation and dynamic genetic operator adaptation for efficient exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 88, "fitness": 0.2756494716607798, "feedback": "The algorithm HybridQGEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2756494716607798]}, "mutation_prompt": null}
{"id": "84832992-5ae8-4ed0-8bc2-ce946b950541", "solution": "import numpy as np\n\nclass HybridQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.momentum = 0.9\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)  # Dynamic multi-swarm based on dimensionality\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.momentum * self.velocities[idx] +\n                                self.phi * (r1 * (self.pbest[idx] - self.positions[idx]) +\n                                            r2 * (local_gbest - self.positions[idx])))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta_momentum(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n            self.momentum = max(0.5, self.momentum * 0.95)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta_momentum()\n\n        return self.gbest", "name": "HybridQAPSO", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with Adaptive Momentum and Dynamic Swarm Partitioning for enhanced convergence in photonic structures optimization.", "configspace": "", "generation": 89, "fitness": 0.28942622704237564, "feedback": "The algorithm HybridQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28942622704237564]}, "mutation_prompt": null}
{"id": "13d4d239-295f-41ef-80ee-ac6f962a70d0", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.population = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.5\n\n    def _adapt_parameters(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.mutation_factor = np.clip(self.mutation_factor + np.random.normal(0, 0.1), 0.1, 1.0)\n            self.crossover_rate = np.clip(self.crossover_rate + np.random.normal(0, 0.1), 0.1, 1.0)\n\n    def _mutate(self, idx):\n        idxs = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)  # Keep within [0, 1] bounds\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.population = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * self.population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_solution = self.population[i]\n                self.best_fitness = self.fitness[i]\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(func.bounds.lb + (func.bounds.ub - func.bounds.lb) * trial)\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_parameters()\n\n        return self.best_solution", "name": "AdaptiveDE", "description": "Differential Evolution with Adaptive Mutation and Crossover Rates for Enhanced Global Exploration and Local Exploitation in Photonic Structures Optimization.", "configspace": "", "generation": 90, "fitness": 0.27044358023215687, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27044358023215687]}, "mutation_prompt": null}
{"id": "92cb7daa-e3a2-4968-8e69-ddfda6d61f4e", "solution": "import numpy as np\n\nclass RefinedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.restart_interval = budget // 5  # Periodic restart mechanism\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _restart_population(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return True\n        return False\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n            if self.evaluations % self.restart_interval == 0:\n                if self._restart_population(func):\n                    break\n\n        return self.gbest", "name": "RefinedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Multi-Swarm and Periodic Restart Mechanisms for enhanced exploration and convergence in photonic structures optimization.", "configspace": "", "generation": 91, "fitness": 0.2879861765228692, "feedback": "The algorithm RefinedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2879861765228692]}, "mutation_prompt": null}
{"id": "9d7ee22e-393a-4804-91ef-5b116562055f", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.inertia_weight = 0.9\n        self.c1, self.c2 = 2.0, 2.0\n        self.diff_mutation_factor = 0.5\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        \n        # Inertia weight adaptation\n        self.velocities[idx] = (self.inertia_weight * self.velocities[idx] +\n                                self.c1 * r1 * (self.pbest[idx] - self.positions[idx]) +\n                                self.c2 * r2 * (local_gbest - self.positions[idx]))\n        \n        # Differential mutation step\n        if np.random.rand() < self.diff_mutation_factor:\n            a, b, c = np.random.choice(self.population_size, 3, replace=False)\n            mutant_vector = self.positions[a] + 0.8 * (self.positions[b] - self.positions[c])\n            new_pos = mutant_vector\n        else:\n            new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _adapt_inertia_weight(self):\n        self.inertia_weight = max(0.4, self.inertia_weight - 0.01)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._adapt_inertia_weight()\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "EnhancedQAPSO with Adaptive Inertia and Differential Mutation for improved exploration and exploitation balance in photonic structures optimization.", "configspace": "", "generation": 92, "fitness": 0.2813965184626247, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2813965184626247]}, "mutation_prompt": null}
{"id": "c9fea267-4df2-4130-89a2-26b172bb30b9", "solution": "import numpy as np\n\nclass QuantumEnhancedES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.sigma = 0.1  # Step size for mutation\n        self.evaluations = 0\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.local_best_positions = np.zeros((self.population_size, dim))\n        self.local_best_scores = np.full(self.population_size, float('inf'))\n\n    def quantum_tunneling(self):\n        q_tunnel_prob = 0.1  # Probability for applying quantum tunneling\n        if np.random.rand() < q_tunnel_prob:\n            return np.random.normal(0, self.sigma, self.dim)\n        return np.zeros(self.dim)\n\n    def _update_individual(self, idx, func):\n        noise = np.random.normal(0, self.sigma, self.dim)\n        new_pos = self.positions[idx] + noise + self.quantum_tunneling()\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.local_best_scores[idx]:\n            self.local_best_positions[idx] = new_pos\n            self.local_best_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def adaptive_niching(self):\n        threshold = 0.2 * self.dim\n        for i in range(self.population_size):\n            if np.linalg.norm(self.positions[i] - self.gbest) < threshold:\n                self.positions[i] = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.dim)\n                self.local_best_scores[i] = float('inf')\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.local_best_positions[i] = self.positions[i]\n            self.local_best_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_individual(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self.adaptive_niching()\n\n        return self.gbest", "name": "QuantumEnhancedES", "description": "Quantum-Enhanced Evolutionary Strategy using Adaptive Niching for Diverse Exploration and Exploitation in Photonic Structures Optimization.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {}, "mutation_prompt": null}
{"id": "e2c65e1d-2ee9-47f7-8bf7-78440c58a70a", "solution": "import numpy as np\n\nclass BIHMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.random.randn(self.population_size, dim)\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.alpha = 0.1\n        self.beta = 0.7\n        self.gamma = 1.5\n        self.evaluations = 0\n\n    def biologically_mimicked_mutation(self, position, func):\n        mutation_strength = np.random.uniform(0.8, 1.2)\n        mutated_position = position + mutation_strength * np.random.randn(self.dim)\n        mutated_position = np.clip(mutated_position, func.bounds.lb, func.bounds.ub)\n        return mutated_position\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        inertia_component = self.alpha * self.velocities[idx]\n        cognitive_component = self.beta * r1 * (self.pbest[idx] - self.positions[idx])\n        social_component = self.gamma * r2 * (self.gbest - self.positions[idx])\n\n        self.velocities[idx] = inertia_component + cognitive_component + social_component\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < 0.2:\n            new_pos = self.biologically_mimicked_mutation(new_pos, func)\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_parameters(self):\n        self.alpha = 0.9 - 0.8 * (self.evaluations / self.budget)\n        self.beta = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        self.gamma = 0.5 + 0.5 * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_parameters()\n\n        return self.gbest", "name": "BIHMPSO", "description": "Biologically-Inspired Hybrid Mutation PSO (BIHM-PSO) combines adaptive swarm intelligence and biologically-mimicked mutation processes to enhance exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 94, "fitness": 0.28646609331631345, "feedback": "The algorithm BIHMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.28646609331631345]}, "mutation_prompt": null}
{"id": "91aacfd1-0e8b-4ffd-8346-9d023d2e8b63", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.scores = np.full(self.population_size, float('inf'))\n        self.gbest = None\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n\n    def _quantum_update(self, idx, func):\n        a, b, c = np.random.choice(self.population_size, 3, replace=False)\n        mutant = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n        mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n        trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.positions[idx])\n        trial_score = func(trial)\n\n        if trial_score < self.scores[idx]:\n            self.positions[idx] = trial\n            self.scores[idx] = trial_score\n\n        if trial_score < self.gbest_score:\n            self.gbest = trial\n            self.gbest_score = trial_score\n\n        self.evaluations += 1\n\n    def _dynamic_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            self.mutation_factor = np.random.uniform(0.4, 0.9)\n            self.crossover_rate = np.random.uniform(0.5, 0.9)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._quantum_update(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._dynamic_population()\n\n        return self.gbest", "name": "QuantumDifferentialEvolution", "description": "Quantum Differential Evolution with Adaptive Strategy and Randomized Population Dynamics for robust exploration and exploitation in photonic structures optimization.", "configspace": "", "generation": 95, "fitness": 0.27914725463651313, "feedback": "The algorithm QuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.27914725463651313]}, "mutation_prompt": null}
{"id": "7414df37-95f4-4c93-8736-72c042e28cfa", "solution": "import numpy as np\n\nclass HQIGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.evaluations = 0\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n\n    def _quantum_superposition(self, position, func):\n        delta = np.random.rand(self.dim)\n        q_position = position + delta * (self.gbest - position)\n        q_position = np.clip(q_position, func.bounds.lb, func.bounds.ub)\n        q_score = func(q_position)\n        return q_position, q_score\n\n    def _differential_mutation(self, idx, func):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        mutation_vector = self.positions[indices[0]] + self.mutation_factor * (self.positions[indices[1]] - self.positions[indices[2]])\n        mutant = np.clip(mutation_vector, func.bounds.lb, func.bounds.ub)\n\n        trial = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant, self.positions[idx])\n        trial_score = func(trial)\n\n        if trial_score < self.pbest_scores[idx]:\n            self.pbest[idx] = trial\n            self.pbest_scores[idx] = trial_score\n\n        if trial_score < self.gbest_score:\n            self.gbest = trial\n            self.gbest_score = trial_score\n\n        self.positions[idx] = trial\n        self.evaluations += 1\n\n    def _update_mutation_factor(self):\n        if self.evaluations % (self.budget // 5) == 0:\n            self.mutation_factor = 0.5 + 0.5 * np.random.rand()\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                q_position, q_score = self._quantum_superposition(self.positions[i], func)\n                if q_score < self.pbest_scores[i]:\n                    self.pbest[i] = q_position\n                    self.pbest_scores[i] = q_score\n                if q_score < self.gbest_score:\n                    self.gbest = q_position\n                    self.gbest_score = q_score\n\n                self._differential_mutation(i, func)\n                if self.evaluations >= self.budget:\n                    break\n\n            self._update_mutation_factor()\n\n        return self.gbest", "name": "HQIGA", "description": "Hybrid Quantum-Inspired Genetic Algorithm with Adaptive Differential Mutation Combines quantum-inspired population dynamics with genetic crossover and adaptive differential evolution mutation for enhanced exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 96, "fitness": 0.2829067435654955, "feedback": "The algorithm HQIGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2829067435654955]}, "mutation_prompt": null}
{"id": "6bc423ef-7f54-4187-9216-0db3180038fd", "solution": "import numpy as np\n\nclass EnhancedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.exploration_factor = 0.5\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        self.velocities[idx] = (self.phi * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, 20 * self.dim)\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            self.beta = min(1.0, self.beta + 0.05)\n\n    def _stochastic_restart(self, func):\n        if np.random.rand() < 0.05:  # 5% chance to restart\n            idx = np.random.randint(0, self.population_size)\n            self.positions[idx] = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.dim)\n            self.velocities[idx] = np.zeros(self.dim)\n            score = func(self.positions[idx])\n            self.pbest[idx] = self.positions[idx]\n            self.pbest_scores[idx] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[idx]\n                self.gbest_score = score\n            self.evaluations += 1\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n            self._stochastic_restart(func)\n\n        return self.gbest", "name": "EnhancedQAPSO", "description": "Enhancing Adaptive Quantum-Inspired Particle Swarm Optimization by integrating a Dynamic Exploration-Exploitation Balancing Strategy with Stochastic Restarts for improved convergence and robustness in photonic structures optimization.", "configspace": "", "generation": 97, "fitness": 0.29001625173242906, "feedback": "The algorithm EnhancedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.29001625173242906]}, "mutation_prompt": null}
{"id": "b0860659-bca7-4504-9a54-0df56597ed75", "solution": "import numpy as np\n\nclass RefinedQAPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.velocities = np.zeros((self.population_size, dim))\n        self.pbest = self.positions.copy()\n        self.gbest = None\n        self.pbest_scores = np.full(self.population_size, float('inf'))\n        self.gbest_score = float('inf')\n        self.phi = np.log(2)\n        self.beta = 0.3\n        self.evaluations = 0\n        self.num_swarms = max(2, dim // 5)\n        self.local_gbests = [None] * self.num_swarms\n        self.local_gbest_scores = [float('inf')] * self.num_swarms\n        self.acceleration_factor = 0.1\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def _update_particle(self, idx, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        swarm_idx = idx % self.num_swarms\n        local_gbest = self.local_gbests[swarm_idx] if self.local_gbests[swarm_idx] is not None else self.gbest\n        inertia = np.exp(-self.acceleration_factor * self.evaluations / self.budget)  # Adaptive inertia weight\n        self.velocities[idx] = (inertia * self.velocities[idx] +\n                                r1 * (self.pbest[idx] - self.positions[idx]) +\n                                r2 * (local_gbest - self.positions[idx]))\n        new_pos = self.positions[idx] + self.velocities[idx]\n\n        if np.random.rand() < self.beta:\n            new_pos += self.levy_flight()\n\n        new_pos = np.clip(new_pos, func.bounds.lb, func.bounds.ub)\n        new_score = func(new_pos)\n\n        if new_score < self.pbest_scores[idx]:\n            self.pbest[idx] = new_pos\n            self.pbest_scores[idx] = new_score\n\n        if new_score < self.local_gbest_scores[swarm_idx]:\n            self.local_gbests[swarm_idx] = new_pos\n            self.local_gbest_scores[swarm_idx] = new_score\n\n        if new_score < self.gbest_score:\n            self.gbest = new_pos\n            self.gbest_score = new_score\n\n        self.positions[idx] = new_pos\n        self.evaluations += 1\n\n    def _adapt_population(self):\n        if self.evaluations % (self.budget // 4) == 0:\n            new_population_size = min(self.population_size + 5, int(self.population_size * 1.1))\n            if new_population_size > self.population_size:\n                additional_positions = np.random.rand(new_population_size - self.population_size, self.dim)\n                self.positions = np.vstack((self.positions, additional_positions))\n                self.velocities = np.vstack((self.velocities, np.zeros((new_population_size - self.population_size, self.dim))))\n                self.pbest = np.vstack((self.pbest, additional_positions))\n                self.pbest_scores = np.hstack((self.pbest_scores, np.full(new_population_size - self.population_size, float('inf'))))\n                self.population_size = new_population_size\n\n    def _adapt_beta(self):\n        if self.evaluations % (self.budget // 10) == 0:\n            improvement = (self.gbest_score < min(self.pbest_scores))\n            self.beta = min(1.0, self.beta + 0.05 if not improvement else self.beta)\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            score = func(self.positions[i])\n            self.pbest[i] = self.positions[i]\n            self.pbest_scores[i] = score\n            if score < self.gbest_score:\n                self.gbest = self.positions[i]\n                self.gbest_score = score\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                return self.gbest\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                self._update_particle(i, func)\n                if self.evaluations >= self.budget:\n                    break\n            self._adapt_population()\n            self._adapt_beta()\n\n        return self.gbest", "name": "RefinedQAPSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Adaptive Learning Strategies and Fitness-Based Dynamic Population Adjustment for Enhanced Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 98, "fitness": 0.2889097814453575, "feedback": "The algorithm RefinedQAPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2889097814453575]}, "mutation_prompt": null}
{"id": "0c1bcf91-e275-417b-b087-1fbb8a931163", "solution": "import numpy as np\n\nclass AQGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.positions = np.random.rand(self.population_size, dim)\n        self.fitness = np.full(self.population_size, float('inf'))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n        self.quantum_mutation_rate = 0.05\n\n    def quantum_mutation(self, parent):\n        alpha = np.pi * np.random.rand(self.dim)\n        beta = np.pi * np.random.rand(self.dim)\n        quantum_bit = np.sin(alpha) * parent + np.cos(beta) * (1 - parent)\n        return quantum_bit\n\n    def tournament_selection(self):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        selected = indices[np.argmin(self.fitness[indices])]\n        return selected\n\n    def crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def _evaluate(self, individual, func):\n        individual = np.clip(individual, func.bounds.lb, func.bounds.ub)\n        score = func(individual)\n        self.evaluations += 1\n        return score\n\n    def __call__(self, func):\n        self.positions = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * np.random.rand(self.population_size, self.dim)\n        for i in range(self.population_size):\n            self.fitness[i] = self._evaluate(self.positions[i], func)\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_solution = self.positions[i]\n            if self.evaluations >= self.budget:\n                return self.best_solution\n\n        while self.evaluations < self.budget:\n            new_positions = []\n            for _ in range(self.population_size):\n                if np.random.rand() < self.quantum_mutation_rate:\n                    parent = self.positions[self.tournament_selection()]\n                    child = self.quantum_mutation(parent)\n                else:\n                    parent1 = self.positions[self.tournament_selection()]\n                    parent2 = self.positions[self.tournament_selection()]\n                    child = self.crossover(parent1, parent2)\n                \n                new_positions.append(child)\n\n            for i in range(self.population_size):\n                new_score = self._evaluate(new_positions[i], func)\n                if new_score < self.fitness[i]:\n                    self.positions[i] = new_positions[i]\n                    self.fitness[i] = new_score\n\n                if new_score < self.best_fitness:\n                    self.best_fitness = new_score\n                    self.best_solution = new_positions[i]\n\n                if self.evaluations >= self.budget:\n                    break\n\n            if self.evaluations % (self.budget // 5) == 0:\n                self.quantum_mutation_rate = min(0.2, self.quantum_mutation_rate + 0.01)\n\n        return self.best_solution", "name": "AQGA", "description": "Adaptive Quantum Genetic Algorithm (AQGA) with Dynamic Quantum Mutation and Diversity Preservation for enhanced exploration-exploitation balance in optimizing photonic structures.", "configspace": "", "generation": 99, "fitness": 0.2813899924390494, "feedback": "The algorithm AQGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b06a7736-9df5-4dfc-b239-7f2531b2b784", "metadata": {"aucs": [0.2813899924390494]}, "mutation_prompt": null}
