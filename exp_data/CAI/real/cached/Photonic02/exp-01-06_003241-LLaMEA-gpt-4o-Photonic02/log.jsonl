{"id": "75d182f7-15bd-4681-a5d4-95d5594d7124", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "A hybridized Particle Swarm Optimization with Differential Evolution for enhanced exploration and exploitation in global optimization tasks.", "configspace": "", "generation": 0, "fitness": 0.3086544585582941, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": null, "metadata": {"aucs": [0.29473070923858247, 0.314216362346452, 0.3170163040898478]}, "mutation_prompt": null}
{"id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.34645152451880995, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.01.", "error": "", "parent_id": "75d182f7-15bd-4681-a5d4-95d5594d7124", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "ae0136ab-3dd7-432e-9f2f-9dc4c4edb19d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.initial_inertia_weight = 0.9  # Changed to dynamic inertia weight\n        self.final_inertia_weight = 0.4\n        self.cognitive_coefficient = 1.2\n        self.social_coefficient = 1.8\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            current_inertia_weight = (self.initial_inertia_weight - self.final_inertia_weight) * \\\n                                     (1 - self.num_evaluations / self.budget) + self.final_inertia_weight\n            self.velocities[i] = (current_inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced a dynamic inertia weight to gradually shift from exploration to exploitation over iterations.", "configspace": "", "generation": 2, "fitness": 0.2856634088277094, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.285228214762567, 0.2980837332329761, 0.2736782784875851]}, "mutation_prompt": null}
{"id": "10d38070-9558-4a36-b1af-7c2b7cf5844d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        self.mutation_factor = 0.5 + 0.3 * (1 - self.num_evaluations / self.budget)  # Adaptive mutation factor\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced adaptive mutation factor to dynamically balance exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.3038677076957885, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2926109181360709, 0.31636983821539877, 0.30262236673589593]}, "mutation_prompt": null}
{"id": "a11e0ae2-3d7d-4b1c-ad4b-31113ac692fe", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.72  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved exploration by slightly increasing inertia weight in PSO.", "configspace": "", "generation": 4, "fitness": 0.3007217956617518, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3004324115975172, 0.2998651650477139, 0.3018678103400243]}, "mutation_prompt": null}
{"id": "d215a71e-baf1-45d7-a887-c83461cbfa5f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.75  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Tweak inertia weight in PSO update to slightly favor exploration over exploitation initially.", "configspace": "", "generation": 5, "fitness": 0.303496982270996, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.32767874923785545, 0.29611542833826643, 0.28669676923686604]}, "mutation_prompt": null}
{"id": "9ae6ef1c-827c-4621-b2d3-5983fe1271c3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.85  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased the social coefficient to enhance collective convergence towards the best solution.", "configspace": "", "generation": 6, "fitness": 0.31556306395656664, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.33948284153134745, 0.316822246840777, 0.2903841034975755]}, "mutation_prompt": null}
{"id": "2dfb9927-e93d-4e64-93e7-07fd2bf5ba75", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "ec2c57ac-76dc-4ccb-8bab-d30e49817708", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.9  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved convergence by slightly increasing the social coefficient for greater group influence.", "configspace": "", "generation": 8, "fitness": 0.2311181828232428, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2182554987622164, 0.22577777476720007, 0.24932127494031198]}, "mutation_prompt": null}
{"id": "150373ec-3206-489c-aaa9-22c437ef35c0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.72  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved exploration by slightly increasing inertia to try enhancing global search capabilities.", "configspace": "", "generation": 9, "fitness": 0.3007217956617518, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3004324115975172, 0.2998651650477139, 0.3018678103400243]}, "mutation_prompt": null}
{"id": "d661282f-6aa8-49a2-a294-143d3c1928e1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.72  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced exploration by slightly increasing inertia weight to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.3007217956617518, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3004324115975172, 0.2998651650477139, 0.3018678103400243]}, "mutation_prompt": null}
{"id": "d513fe8d-f648-4742-aa76-bc4156a8bb1b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "5207bb61-79aa-4e83-bab8-421bfd3ed816", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.72  # Adjusted inertia weight for better balance\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly adjusted inertia weight for better exploration-exploitation balance in PSO.", "configspace": "", "generation": 12, "fitness": 0.24607409944647118, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.24401824685112228, 0.22453585487381822, 0.26966819661447305]}, "mutation_prompt": null}
{"id": "b06edec1-4186-4045-80f6-4f070187c756", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n        self.inertia_weight *= 0.99  # Dynamic adjustment of inertia weight\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic adjustment of inertia weight to balance exploration and exploitation better.", "configspace": "", "generation": 13, "fitness": 0.3033200492515405, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30386971742140223, 0.30011832337256994, 0.30597210696064936]}, "mutation_prompt": null}
{"id": "8ce02f87-9b43-4a8b-92cb-8279a31b3060", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.inertia_weight = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Dynamic inertia weight\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduce a dynamic inertia weight that decreases over iterations to balance exploration and exploitation more effectively.", "configspace": "", "generation": 14, "fitness": 0.2917791795501199, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.28537904346043497, 0.29611542833826643, 0.2938430668516583]}, "mutation_prompt": null}
{"id": "5e682ef9-7522-4916-b466-9b9da4cea8c2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "3f37978f-e03b-4cf9-bbb5-7f972322891e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.72  # Slightly increased for enhanced exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Fine-tuned the inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.24607409944647118, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.24401824685112228, 0.22453585487381822, 0.26966819661447305]}, "mutation_prompt": null}
{"id": "c49207fe-08e9-4870-863b-e2e7388e88b4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.72  # Increased inertia weight for even better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved convergence by minimally adjusting the inertia weight for enhanced exploration.", "configspace": "", "generation": 17, "fitness": 0.3007217956617518, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3004324115975172, 0.2998651650477139, 0.3018678103400243]}, "mutation_prompt": null}
{"id": "fc8c1656-92b3-40e6-806e-7d2ee89c9ad2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.crossover_rate = 0.9 - 0.8 * (self.num_evaluations / self.budget)  # Dynamic crossover rate\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic crossover rate based on iteration to improve balance between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.2896521126756371, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29132925958782874, 0.300579143590332, 0.27704793484875057]}, "mutation_prompt": null}
{"id": "1b429070-9e39-4aaf-b32b-4540b0679032", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Dynamic inertia weight adjustment\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = ((self.inertia_weight - 0.5 * (self.num_evaluations / self.budget)) * self.velocities[i] +  # Dynamic adjustment\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic adjustment of inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 19, "fitness": 0.31649199467838524, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30446481718319374, 0.3383417087225751, 0.30666945812938684]}, "mutation_prompt": null}
{"id": "89956f0e-02da-429c-9891-ce82d3d5a2ed", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Fixed inertia weight changed to dynamic\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        # Dynamic inertia weight\n        self.inertia_weight = 0.7 - 0.5 * (self.num_evaluations / self.budget)\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduce dynamic inertia weight for improved convergence by increasing exploration in early iterations and focusing on exploitation in later iterations.", "configspace": "", "generation": 20, "fitness": 0.31649199467838524, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30446481718319374, 0.3383417087225751, 0.30666945812938684]}, "mutation_prompt": null}
{"id": "f39b6495-7f3a-47df-9cd0-19643ba912ee", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.25  # Slightly increased for improved personal learning\n        self.social_coefficient = 1.8\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Minor parameter adjustment to improve exploration-exploitation balance and achieve better convergence.", "configspace": "", "generation": 21, "fitness": 0.3098317871588531, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.31100893217762704, 0.3141007024402127, 0.3043857268587197]}, "mutation_prompt": null}
{"id": "2a0e78df-2581-487b-812d-335d890b47a1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75  # Slightly increased for better diversity\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increase the crossover rate to enhance diversity in the search process.", "configspace": "", "generation": 22, "fitness": 0.3121009625956862, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29776976104972985, 0.3296453158300626, 0.30888781090726614]}, "mutation_prompt": null}
{"id": "b6695130-d76d-439f-9845-d5fa4bff4c91", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Dynamic adjustment\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced with dynamic mutation factor adjustment for improved exploration and exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.3056373764114665, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3176664189212003, 0.2976245495438775, 0.30162116076932166]}, "mutation_prompt": null}
{"id": "7d14de60-0348-4691-be11-ecdf877ed253", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        # Update crossover rate dynamically\n        dynamic_crossover_rate = self.crossover_rate * (1 - self.num_evaluations / self.budget)\n\n        for j in range(self.dim):\n            if np.random.rand() < dynamic_crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduce a dynamic crossover rate that decreases linearly over iterations to balance exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.2795750418679135, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2908858114862466, 0.2630350770307761, 0.28480423708671776]}, "mutation_prompt": null}
{"id": "73afec38-09e4-49f3-a894-76d87ab690ae", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.15  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Altered the elitism rate for enhanced solution retention.", "configspace": "", "generation": 25, "fitness": 0.3001118234534679, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30305136527402043, 0.29611542833826643, 0.30116867674811676]}, "mutation_prompt": null}
{"id": "af5b91a7-27ec-4293-8340-b8d0f605425f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]) +\n                                  np.random.normal(0, 0.1, self.dim))  # Added Gaussian perturbation\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduce random Gaussian perturbation to velocities for enhanced exploration.", "configspace": "", "generation": 26, "fitness": 0.3214564417780381, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.03.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.33713845850902713, 0.3425767660629956, 0.28465410076209163]}, "mutation_prompt": null}
{"id": "41376dde-c7e2-4f51-8294-1b9a3b6e5a36", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.9  # Changed to enhance local search\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c) + 0.1 * (self.global_best_position - a)  # Enhance mutation\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved local search capabilities with enhanced mutation strategy and diversity preservation.", "configspace": "", "generation": 27, "fitness": 0.30292160367147775, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2886404669218089, 0.32167077284457457, 0.29845357124804983]}, "mutation_prompt": null}
{"id": "dcd24291-7316-4c3b-bba3-326cf7b19193", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Changed line: dynamic mutation factor\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic adjustment of mutation factor to balance exploration and exploitation adaptively.", "configspace": "", "generation": 28, "fitness": 0.3056373764114665, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3176664189212003, 0.2976245495438775, 0.30162116076932166]}, "mutation_prompt": null}
{"id": "3e9d3875-3572-40fc-b4fa-acc6bbf92763", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.inertia_weight = max(0.4, 0.7 - 0.3 * (self.num_evaluations / self.budget))  # Dynamic inertia weight\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced a dynamic inertia weight adjustment to improve convergence by reducing inertia weight as evaluations progress.", "configspace": "", "generation": 29, "fitness": 0.3008475548195317, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30565807871151307, 0.30127215559328546, 0.29561243015379646]}, "mutation_prompt": null}
{"id": "0c595908-3bbe-47d2-bb67-c20691313b0b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.6  # Modified inertia weight for improved balance\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Fine-tuned inertia weight for better exploration-exploitation balance in HybridPSODE.", "configspace": "", "generation": 30, "fitness": 0.30957465554127894, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.32999270640255984, 0.30012953957004485, 0.29860172065123214]}, "mutation_prompt": null}
{"id": "b3859f9a-0839-40c0-a945-b86d0150fe94", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.inertia_weight = 0.9 - 0.5 * (self.num_evaluations / self.budget)  # Adaptive inertia weight\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Added adaptive inertia weight to improve convergence speed while keeping the balance between exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.2856634088277094, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.285228214762567, 0.2980837332329761, 0.2736782784875851]}, "mutation_prompt": null}
{"id": "4c3a544c-270f-4e45-9b6a-a21608630909", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8  # Original value retained, adaptive modification happens in mutate_and_crossover\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        adaptive_mutation_factor = self.mutation_factor * (1 - self.num_evaluations / self.budget)  # Adaptive modification\n        mutant_vector = a + adaptive_mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced adaptive mutation factor based on evaluations to enhance exploration in early stages and exploitation in later stages.", "configspace": "", "generation": 32, "fitness": 0.3125910480829549, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29823337363168956, 0.31397109449521343, 0.3255686761219617]}, "mutation_prompt": null}
{"id": "5ce1a270-ed6f-4b2c-822e-58eab0dc3c12", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.11  # Increased from 0.1 to 0.11 for better elitism\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increase the elitism rate to enhance the retention of top performers for better convergence.", "configspace": "", "generation": 33, "fitness": 0.3066388807331914, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30206616599957903, 0.3076261832957595, 0.3102242929042357]}, "mutation_prompt": null}
{"id": "799caef6-d5b4-4a53-8cfa-e483a1b2c7c7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8  # Dynamic mutation factor for better adaptation\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced a dynamic mutation factor to adaptively improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.3066388807331914, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30206616599957903, 0.3076261832957595, 0.3102242929042357]}, "mutation_prompt": null}
{"id": "f73bbca8-3aa6-44bf-853a-74e48bee0148", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.8  # Slightly increased crossover rate\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased crossover rate to enhance exploration in the DE component of the algorithm.", "configspace": "", "generation": 35, "fitness": 0.3144622902851328, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.294859947632756, 0.3352438291112122, 0.31328309411143007]}, "mutation_prompt": null}
{"id": "dcc59005-a841-4bec-a427-4ffd526e7a8d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.3  # Increased for better local search capability\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased cognitive coefficient to enhance local search capability while maintaining global search balance.", "configspace": "", "generation": 36, "fitness": 0.2997394274176464, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30475523343421596, 0.29708655170379406, 0.2973764971149293]}, "mutation_prompt": null}
{"id": "cbac7795-5005-4b45-8462-f41be96dd98a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n        self.cognitive_coefficient *= 0.99  # Decay factor for cognitive coefficient\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced a decay mechanism for the cognitive coefficient to improve convergence.", "configspace": "", "generation": 37, "fitness": 0.3109112085320513, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2957562826167507, 0.31434005191014835, 0.3226372910692549]}, "mutation_prompt": null}
{"id": "2f6755c0-0edb-4a4d-b07c-858edb1471d2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        adaptive_mutation_factor = self.mutation_factor * (1 - self.num_evaluations / self.budget)\n        mutant_vector = a + adaptive_mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced adaptive mutation factor to enhance diversity and adaptation of the population over time.", "configspace": "", "generation": 38, "fitness": 0.3125910480829549, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29823337363168956, 0.31397109449521343, 0.3255686761219617]}, "mutation_prompt": null}
{"id": "d00cd27d-a03a-4d8c-b26e-1dddd0a80a27", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.72  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly adjusted the inertia weight to improve exploration-exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.3007217956617518, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3004324115975172, 0.2998651650477139, 0.3018678103400243]}, "mutation_prompt": null}
{"id": "2d0598ae-ac2e-44a8-9455-20505671a3d8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8  # Dynamic adjustment (0.8 -> 0.5 + 0.3 * np.random.rand())\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + (0.5 + 0.3 * np.random.rand()) * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic mutation factor adjustment for enhanced exploration and exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.3056373764114665, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3176664189212003, 0.2976245495438775, 0.30162116076932166]}, "mutation_prompt": null}
{"id": "4cc6637a-0b21-431e-9d27-f5ee6cfe4d02", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.6  # Reduced inertia weight for better exploitation\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Reduced inertia weight to 0.6 for better exploitation.", "configspace": "", "generation": 41, "fitness": 0.2910252142261512, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.282573285893885, 0.29978078500762195, 0.2907215717769466]}, "mutation_prompt": null}
{"id": "761e699f-be4c-4217-a9c6-0a272d95c696", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Initially high for exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n        # Dynamically adjust inertia weight\n        self.inertia_weight = 0.7 - 0.5 * (self.num_evaluations / self.budget)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved convergence rate by dynamically adjusting the inertia weight based on remaining evaluations.", "configspace": "", "generation": 42, "fitness": 0.3138009719722703, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3036404056096761, 0.31426708475900766, 0.32349542554812716]}, "mutation_prompt": null}
{"id": "2477ff8a-b6ac-4e82-ac4d-848cc39b114a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.85  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increase the social_coefficient to enhance convergence speed by amplifying the group influence.", "configspace": "", "generation": 43, "fitness": 0.31556306395656664, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.33948284153134745, 0.316822246840777, 0.2903841034975755]}, "mutation_prompt": null}
{"id": "072ae2b3-e9be-4bf9-a088-5c094a998ecc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Tweak the mutation factor to enhance exploration in DE phase of HybridPSODE.", "configspace": "", "generation": 44, "fitness": 0.31724191528170365, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3049147465158534, 0.2968319881505218, 0.34997901117873575]}, "mutation_prompt": null}
{"id": "083f5926-94f1-4152-9ba6-43997bdf9025", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7  # Changed line: Introduce initial crossover rate\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            self.crossover_rate = 0.7 + 0.2 * (self.num_evaluations / self.budget)  # Dynamic crossover rate based on evaluations\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced a dynamic crossover rate to enhance adaptability during the optimization process.", "configspace": "", "generation": 45, "fitness": 0.31802905152555205, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3468376042040605, 0.3038194471585419, 0.3034301032140537]}, "mutation_prompt": null}
{"id": "b67d4b52-cfcf-4eb1-9012-2e91af12f8a4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "58527ff3-1a4d-4c33-bc6c-19b50ea17c26", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = ((0.9 - 0.5) * (self.budget - self.num_evaluations) / self.budget + 0.5) * self.velocities[i] + self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) + self.social_coefficient * r2 * (self.global_best_position - self.population[i])\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic adjustment to the inertia weight to improve exploration and exploitation balance over iterations.", "configspace": "", "generation": 47, "fitness": 0.22974919009478767, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.22854778764354944, 0.22051176647731063, 0.24018801616350294]}, "mutation_prompt": null}
{"id": "e6da667c-bb96-4ff8-ab9c-42417096655c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.8  # Modified inertia weight for better balance\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Updated inertia weight for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 48, "fitness": 0.29083068603873835, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3149765969012428, 0.29851148815902684, 0.25900397305594536]}, "mutation_prompt": null}
{"id": "319b6b0b-a87e-4e77-b7f6-92a78c5050ec", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n        self.inertia_decay = 0.99  # New inertia decay factor\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n        self.inertia_weight *= self.inertia_decay  # Update inertia weight\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Implemented a decay factor for the inertia weight to enhance convergence speed and exploration balance.", "configspace": "", "generation": 49, "fitness": 0.3033200492515405, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30386971742140223, 0.30011832337256994, 0.30597210696064936]}, "mutation_prompt": null}
{"id": "bcd4869e-2324-4c8f-b77c-ee5d295f97d3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.3  # Slightly increased for improved exploration\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly adjusted cognitive coefficient for improved exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.2997394274176464, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30475523343421596, 0.29708655170379406, 0.2973764971149293]}, "mutation_prompt": null}
{"id": "774902f9-d58d-4d90-9d65-773e861b852d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = ((0.5 + np.random.rand() / 2) * self.velocities[i] +  # Updated inertia weight strategy\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced particle velocities with a new inertia weight updating strategy for better convergence.", "configspace": "", "generation": 51, "fitness": 0.2996240614850055, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3184387280378862, 0.29611542833826643, 0.28431802807886386]}, "mutation_prompt": null}
{"id": "c0859bd7-3b6d-40e5-afa6-12f3730383ff", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.3  # Adjusted for improved adaptation\n        self.social_coefficient = 1.7  # Slightly reduced to enhance stability\n        self.mutation_factor = 0.9  # Increased mutation for diversity\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia_weight_dynamic = 0.5 + np.random.rand() * 0.2  # Dynamically adjust inertia weight\n            self.velocities[i] = (inertia_weight_dynamic * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved adaptive control via dynamic coefficients adjustment and enhanced mutation strategy for better convergence.", "configspace": "", "generation": 52, "fitness": 0.2851646681278782, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.27409377528102574, 0.2774895285853429, 0.303910700517266]}, "mutation_prompt": null}
{"id": "b476a9c4-442c-45c6-89cd-1201d8560fd3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Base inertia weight\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        # Dynamic crossover rate\n        dynamic_crossover_rate = self.crossover_rate * np.random.rand()\n        \n        for j in range(self.dim):\n            if np.random.rand() < dynamic_crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            \n            # Stochastic inertia weight\n            stochastic_inertia_weight = self.inertia_weight * np.random.uniform(0.8, 1.2)\n            \n            self.velocities[i] = (stochastic_inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with stochastic inertia weight and dynamic crossover rate for improved adaptability.", "configspace": "", "generation": 53, "fitness": 0.2619923350810189, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.277134828240331, 0.2436411054180947, 0.265201071584631]}, "mutation_prompt": null}
{"id": "442ca942-279a-430e-af5c-6b87021f4f58", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Adjusted to start with higher exploration\n        self.cognitive_coefficient = 1.2\n        self.social_coefficient = 1.8\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n        self.inertia_weight *= 0.99  # Gradually decrease inertia weight for convergence\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved HybridPSODE with dynamic adjustment of inertia weight, enhancing exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.2454840512255907, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.251982062511267, 0.25071024459374613, 0.23375984657175897]}, "mutation_prompt": null}
{"id": "3f4abbce-80c1-44b2-b67d-71332d763f65", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75  # Increased to enhance search diversity\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation, now with a slightly higher crossover rate for improved search diversity.", "configspace": "", "generation": 55, "fitness": 0.3121009625956862, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29776976104972985, 0.3296453158300626, 0.30888781090726614]}, "mutation_prompt": null}
{"id": "749f082f-899e-403d-960e-bd448f16f05a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.15  # Adjusted rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased the elitism rate to enhance the retention of top-performing solutions.", "configspace": "", "generation": 56, "fitness": 0.3001118234534679, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30305136527402043, 0.29611542833826643, 0.30116867674811676]}, "mutation_prompt": null}
{"id": "acce4ebe-dd03-4cae-8900-31aaa5358ff7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.85  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased the social coefficient to enhance convergence speed by promoting stronger group influence.", "configspace": "", "generation": 57, "fitness": 0.32445101327357573, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.03.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.33713845850902713, 0.3564743842141803, 0.27974019709751974]}, "mutation_prompt": null}
{"id": "a84c34a1-c048-4a28-b122-bbe3e5cb39af", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.12  # Slightly increased elitism rate\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased elitism rate to retain more top performers for enhanced convergence.", "configspace": "", "generation": 58, "fitness": 0.3066388807331914, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30206616599957903, 0.3076261832957595, 0.3102242929042357]}, "mutation_prompt": null}
{"id": "37433977-6cfd-4f0e-b5fa-1bc021a7928b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.25  # Increased for enhanced personal best attraction\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved exploitation by slightly increasing the cognitive coefficient.", "configspace": "", "generation": 59, "fitness": 0.3098317871588531, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.31100893217762704, 0.3141007024402127, 0.3043857268587197]}, "mutation_prompt": null}
{"id": "0c5980aa-5681-4374-8859-f4b3b680bb3f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "4f4923d6-9ae1-4111-8d1e-f1dfd82d3596", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "8c6ba134-5856-4109-a529-3734a20565c9", "solution": "class HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 2.0  # Increased for a stronger group influence\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Adjusted social and mutation factors for improved balance in exploration and convergence.", "configspace": "", "generation": 62, "fitness": 0.30462481355654836, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.03.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3375503760960835, 0.31353937741944804, 0.2627846871541135]}, "mutation_prompt": null}
{"id": "2c31607a-aa74-4618-aacd-170f3ae7c54c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n        self.velocity_clamp = 0.5  # Introduced velocity clamping\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)  # Clamp velocities\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced velocity clamping in PSO updates to control excessive velocities and enhance convergence.", "configspace": "", "generation": 63, "fitness": 0.32696364277894513, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.03.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3377390930433175, 0.3593114940936861, 0.2838403411998318]}, "mutation_prompt": null}
{"id": "fcd7ddd1-1d3a-4be3-bfb8-5f114bc781a7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n        self.velocity_clamp = 0.1  # Added velocity clamping\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Added velocity clamping to improve stability and convergence rate of the algorithm.", "configspace": "", "generation": 64, "fitness": 0.31815463711683223, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29949892605177, 0.33648692494339905, 0.31847806035532766]}, "mutation_prompt": null}
{"id": "fde7452d-7b33-4f27-a81f-4893aabc11a0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        self.mutation_factor = 0.8 - 0.5 * (self.num_evaluations / self.budget)  # Adjust mutation factor\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved exploration by adjusting mutation factor dynamically based on evaluations.", "configspace": "", "generation": 65, "fitness": 0.32345742434744984, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.33785664183245023, 0.3181796305165784, 0.3143360006933209]}, "mutation_prompt": null}
{"id": "c3a67252-d2a4-4ad1-89fc-e78114694530", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            # Adjusting inertia weight dynamically\n            self.inertia_weight = 0.7 - 0.4 * (self.num_evaluations / self.budget)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Added dynamic adjustment for the inertia weight in PSO based on current evaluations to enhance exploitation over time.", "configspace": "", "generation": 66, "fitness": 0.3053892949621461, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2987233545923631, 0.30537747828608186, 0.31206705200799334]}, "mutation_prompt": null}
{"id": "37b81e3b-4c5b-4283-bb09-70bf2cb3337d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n        self.inertia_weight = 0.9 - (0.9 - 0.4) * (self.num_evaluations / self.budget)  # Dynamic inertia weight adjustment\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic inertia weight adjustment for better convergence over iterations.", "configspace": "", "generation": 67, "fitness": 0.2951194910116895, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.31215314848436193, 0.29611542833826643, 0.27708989621244007]}, "mutation_prompt": null}
{"id": "2873dbb5-a7e3-44b7-a3ab-fb0e71864ed8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        self.mutation_factor = 0.8 * (1 - self.num_evaluations / self.budget)  # Adaptive mutation factor\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced adaptive mutation factor to balance between exploration and exploitation dynamically.", "configspace": "", "generation": 68, "fitness": 0.3125910480829549, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29823337363168956, 0.31397109449521343, 0.3255686761219617]}, "mutation_prompt": null}
{"id": "908ac2c4-a2a9-4f14-8bf3-5b41d4ea0bf6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "22b62686-caab-4cd0-8520-0d40e53dfc9e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        adaptive_mutation_factor = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n        mutant_vector = a + adaptive_mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced adaptive mutation factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.24521227766393972, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.23154635381527655, 0.26258191076500514, 0.24150856841153745]}, "mutation_prompt": null}
{"id": "9d0f25bf-934e-41e6-842b-e903979f3c6d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  (self.cognitive_coefficient + self.num_evaluations / self.budget) * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic adjustment of cognitive coefficient based on convergence rate to enhance adaptability.", "configspace": "", "generation": 71, "fitness": 0.2769996620967757, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.28662645660964514, 0.27514680435632066, 0.2692257253243613]}, "mutation_prompt": null}
{"id": "caf30ae9-c6a4-4bb7-a519-824119575da1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        self.inertia_weight = 0.7 + 0.3 * (self.num_evaluations / self.budget)  # Adjust dynamically\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved particle diversity by adjusting inertia weight dynamically based on evaluations.", "configspace": "", "generation": 72, "fitness": 0.29044941347017145, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2979132990939397, 0.29611542833826643, 0.27731951297830826]}, "mutation_prompt": null}
{"id": "20cb30d6-dadc-4d03-a758-8426414e972f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            # Dynamically adjust inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.budget - self.num_evaluations) / self.budget\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly adjusted the inertia weight dynamically for better exploration-exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.2917791795501199, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.28537904346043497, 0.29611542833826643, 0.2938430668516583]}, "mutation_prompt": null}
{"id": "f8f41590-0d58-4de8-82d7-a3159a2c4e7e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i] * 0.95  # Velocity dampening for improved exploration\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved exploration by adding velocity dampening to avoid premature convergence.", "configspace": "", "generation": 74, "fitness": 0.316191228667174, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.03.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3620980523680888, 0.29815653186432933, 0.2883191017691038]}, "mutation_prompt": null}
{"id": "caaed00d-0ba5-43d5-91a1-a7c668ddf06c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.initial_crossover_rate = 0.7  # Changed to initial to allow dynamic adjustment\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        # Dynamic crossover rate\n        current_crossover_rate = self.initial_crossover_rate * (1 - self.num_evaluations / self.budget)\n        \n        for j in range(self.dim):\n            if np.random.rand() < current_crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced a dynamic crossover rate that decreases over time to enhance exploitation in later stages.", "configspace": "", "generation": 75, "fitness": 0.2934353654557192, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30220284735534864, 0.2978012269640775, 0.28030202204773136]}, "mutation_prompt": null}
{"id": "1bf6a423-59cc-4810-94a6-63c61469b724", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9 for better exploration and adaptability\n        self.cognitive_coefficient = 1.2\n        self.social_coefficient = 1.8\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced variable inertia weight for adaptive balance between exploration and exploitation.", "configspace": "", "generation": 76, "fitness": 0.28223148443762264, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2794214863994985, 0.29611542833826643, 0.27115753857510294]}, "mutation_prompt": null}
{"id": "8cb90879-86c3-42e5-8f9e-1963053dea86", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate * (1 - self.num_evaluations / self.budget):\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced exploration by adjusting crossover rate based on iteration progress.", "configspace": "", "generation": 77, "fitness": 0.2934353654557192, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30220284735534864, 0.2978012269640775, 0.28030202204773136]}, "mutation_prompt": null}
{"id": "df313d2d-2d1e-46df-a815-08ef9ff99647", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Dynamically decreasing inertia weight\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Adjusted inertia weight to dynamically decrease for improved exploitation over iterations.", "configspace": "", "generation": 78, "fitness": 0.28223148443762264, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2794214863994985, 0.29611542833826643, 0.27115753857510294]}, "mutation_prompt": null}
{"id": "d7a7d948-bb59-4b52-8505-8dfd581588e5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.inertia_weight -= 0.0001  # Updated line for dynamic inertia weight\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced a dynamic inertia weight decaying over iterations for improved convergence control.", "configspace": "", "generation": 79, "fitness": 0.304571669871673, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2997406918600962, 0.3064099955604862, 0.3075643221944365]}, "mutation_prompt": null}
{"id": "0119e8f4-85d2-4823-846e-265d346bb708", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "f5cd291f-6981-402a-8f19-cdf950954fa5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        # Adaptive mutation factor based on the number of evaluations\n        adaptive_mutation_factor = self.mutation_factor * (1 - self.num_evaluations / self.budget)\n        mutant_vector = a + adaptive_mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Incorporate adaptive mutation factor for enhanced exploration and exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.26679000491682264, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.03.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3138703407801663, 0.24446707843968574, 0.24203259553061585]}, "mutation_prompt": null}
{"id": "647f3fd9-a2bc-4ef6-b9a9-7558fc350aee", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        progress = self.num_evaluations / self.budget\n        adaptive_mutation_factor = self.mutation_factor * (1 + 0.5 * progress) # Change: adaptive mutation factor\n        mutant_vector = a + adaptive_mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced adaptive mutation factor based on iteration progress to enhance convergence.", "configspace": "", "generation": 82, "fitness": 0.2968182576717359, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3094744171368903, 0.2942039886125778, 0.28677636726573974]}, "mutation_prompt": null}
{"id": "362697d4-a41f-4441-97f9-db648b488c74", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.85  # Slightly increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by tweaking the social coefficient to enhance group influence slightly.", "configspace": "", "generation": 83, "fitness": 0.31556306395656664, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.33948284153134745, 0.316822246840777, 0.2903841034975755]}, "mutation_prompt": null}
{"id": "ba1963a1-03f8-4be0-8a9b-2459cdb4cd51", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75  # Adjusted crossover rate for better exploration-exploitation balance\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly adjusting the crossover_rate to improve exploration and convergence balance.", "configspace": "", "generation": 84, "fitness": 0.3121009625956862, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29776976104972985, 0.3296453158300626, 0.30888781090726614]}, "mutation_prompt": null}
{"id": "e70ab06a-efc0-4f55-8334-4fea17dfe610", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.15  # Increased rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by increasing elitism rate slightly for better retention of top performers.", "configspace": "", "generation": 85, "fitness": 0.3001118234534679, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30305136527402043, 0.29611542833826643, 0.30116867674811676]}, "mutation_prompt": null}
{"id": "2daaccc9-63f7-49e0-8c49-837bd2134717", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75  # Slightly increased crossover rate\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased the crossover rate to enhance exploration capabilities in mutation and crossover phase.", "configspace": "", "generation": 86, "fitness": 0.3390582529691802, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.35053735148570697, 0.34556252718541103, 0.3210748802364225]}, "mutation_prompt": null}
{"id": "0473cd08-c4e6-4ce2-a89b-77f45135b054", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "0b151e73-3326-427c-8bad-cf8084a0554c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive coefficients and elitism for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3487686933731676, 0.327659316046338, 0.36292656413692415]}, "mutation_prompt": null}
{"id": "90ff2ff4-70f0-4662-b2b6-51c4a2fec440", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        self.elitism_rate = 0.05 + 0.1 * np.sin(np.pi * self.num_evaluations / self.budget)  # Dynamic adjustment\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic elitism rate adjustment for better convergence.", "configspace": "", "generation": 89, "fitness": 0.32158063532742626, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.03.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.36382009960866046, 0.2988520794020013, 0.30206972697161694]}, "mutation_prompt": null}
{"id": "a96dcbba-9b9b-44a0-afb7-926c6a3103e7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.2\n        self.social_coefficient = 1.8\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        self.inertia_weight = 0.5 + 0.5 * (1 - self.num_evaluations/self.budget)  # Change 1: Dynamic inertia weight\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                self.crossover_rate = 0.9 - 0.7 * (self.num_evaluations/self.budget)  # Change 2: Adaptive crossover rate\n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic inertia weight adjustment and adaptive crossover rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.1866689510682034, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.177052297203257, 0.18660984897668342, 0.19634470702466977]}, "mutation_prompt": null}
{"id": "5d005ef5-1722-4d92-9966-c7f0c02fd309", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            # Change: Dynamic inertia weight\n            self.velocities[i] = ((0.4 + (0.3 * (self.budget - self.num_evaluations) / self.budget)) * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic inertia weight to enhance exploration and exploitation adaptively.", "configspace": "", "generation": 91, "fitness": 0.30082727522163116, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.2949363288456136, 0.3016636349085414, 0.3058818619107385]}, "mutation_prompt": null}
{"id": "d47a50d6-f680-4304-9c70-79896b60715f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.85  # Adjusted for improved exploration\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased the mutation factor to enhance the exploration capability of the algorithm.", "configspace": "", "generation": 92, "fitness": 0.31724191528170365, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3049147465158534, 0.2968319881505218, 0.34997901117873575]}, "mutation_prompt": null}
{"id": "1d3d19a6-a526-499d-b562-d4130535a02b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.8  # Changed inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved balance by tweaking the inertia weight to enhance exploration in early iterations.", "configspace": "", "generation": 93, "fitness": 0.29083068603873835, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3149765969012428, 0.29851148815902684, 0.25900397305594536]}, "mutation_prompt": null}
{"id": "b8d3662d-914c-4ab3-b6f6-1f18996b4ada", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.11  # Increased rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increase the elitism rate to enhance convergence speed and maintain solution quality.", "configspace": "", "generation": 94, "fitness": 0.3066388807331914, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.00.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.30206616599957903, 0.3076261832957595, 0.3102242929042357]}, "mutation_prompt": null}
{"id": "7e1a5488-3413-45c1-9c8f-b382d84d7048", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75  # Increased from 0.7 to 0.75\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased crossover rate to enhance exploration capabilities in mutation and crossover phase.", "configspace": "", "generation": 95, "fitness": 0.3121009625956862, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29776976104972985, 0.3296453158300626, 0.30888781090726614]}, "mutation_prompt": null}
{"id": "945e45d3-59cb-473a-b6a3-eca934b21fb4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75  # Slightly increased crossover rate\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with slight modification in crossover rate for improved exploration.", "configspace": "", "generation": 96, "fitness": 0.3121009625956862, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29776976104972985, 0.3296453158300626, 0.30888781090726614]}, "mutation_prompt": null}
{"id": "f9dbf1e8-4759-4887-a416-cc01b2e75568", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75  # Slightly increased for better diversity\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Improved exploration by slightly increasing crossover rate for better diversity.", "configspace": "", "generation": 97, "fitness": 0.3121009625956862, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.29776976104972985, 0.3296453158300626, 0.30888781090726614]}, "mutation_prompt": null}
{"id": "fe28e69e-3753-4e9f-a6b4-44c302af3aa2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.8  # Slightly increased for enhanced exploration\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = a + self.mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Slightly increased crossover rate to enhance exploration capability.", "configspace": "", "generation": 98, "fitness": 0.3144622902851328, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.02.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.294859947632756, 0.3352438291112122, 0.31328309411143007]}, "mutation_prompt": null}
{"id": "02b990a2-cb24-4640-aaf0-26d10fba589b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_coefficient = 1.2  # Reduced for better balance\n        self.social_coefficient = 1.8  # Increased for a stronger group influence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.num_evaluations = 0\n        self.elitism_rate = 0.1  # Rate for elitism to retain top performers\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            score = func(self.population[i])\n            self.num_evaluations += 1\n            if score < self.best_personal_scores[i]:\n                self.best_personal_scores[i] = score\n                self.best_personal_positions[i] = self.population[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.population[i]\n\n    def mutate_and_crossover(self, index):\n        indices = [idx for idx in range(self.population_size) if idx != index]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        adaptive_mutation_factor = 0.5 + 0.3 * np.random.rand()  # Change\n        mutant_vector = a + adaptive_mutation_factor * (b - c)\n        trial_vector = np.copy(self.population[index])\n        \n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial_vector[j] = mutant_vector[j]\n        return trial_vector\n\n    def pso_update(self):\n        elite_size = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.best_personal_scores)[:elite_size]\n        for i in range(self.population_size):\n            if i in elite_indices:  # Preserve elite individuals\n                continue\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.cognitive_coefficient * r1 * (self.best_personal_positions[i] - self.population[i]) +\n                                  self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] += self.velocities[i]\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds)\n        while self.num_evaluations < self.budget:\n            self.evaluate_population(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break                \n                trial_vector = self.mutate_and_crossover(i)\n                trial_score = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_score < self.best_personal_scores[i]:\n                    self.population[i] = trial_vector\n                    self.best_personal_scores[i] = trial_score\n                    self.best_personal_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n            self.pso_update()\n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced adaptive mutation factor to enhance exploration-exploitation balance dynamically.", "configspace": "", "generation": 99, "fitness": 0.3056373764114665, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.01.", "error": "", "parent_id": "e9540d7f-2f8c-4e5d-8894-1ea3bdb1c5c7", "metadata": {"aucs": [0.3176664189212003, 0.2976245495438775, 0.30162116076932166]}, "mutation_prompt": null}
