{"id": "5e808fc1-afcf-4dbf-a685-a0d0bc7b1fbc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.7\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "A hybrid Particle Swarm Optimization (PSO) and Simulated Annealing (SA) algorithm that dynamically balances exploration and exploitation using adaptive temperature control for optimized global search in photonic structures.", "configspace": "", "generation": 0, "fitness": 0.2791840603691639, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2791840603691639]}, "mutation_prompt": null}
{"id": "50cf8440-6f63-487d-a944-4844023d28f1", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.7\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1/L)\n        return step\n    \n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n                \n                particles[i] += velocities[i] + self.levy_flight(1.5)\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "EnhancedHybridPSO_SA", "description": "Enhanced Hybrid PSO-SA by incorporating local search with a LÃ©vy flight step to refine exploitation while maintaining exploration capabilities for better convergence.", "configspace": "", "generation": 1, "fitness": 0.27678307445155015, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "5e808fc1-afcf-4dbf-a685-a0d0bc7b1fbc", "metadata": {"aucs": [0.27678307445155015]}, "mutation_prompt": null}
{"id": "c4e81225-b3b1-4ad8-869b-741bb4bab7c4", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9  # Changed this line: increased initial inertia weight\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98  # Changed this line: slightly increased cooling rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "An enhanced hybrid PSO and SA algorithm with improved velocity update using dynamic inertia weight for better convergence in photonic structure optimization.", "configspace": "", "generation": 2, "fitness": 0.27834561428456683, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "5e808fc1-afcf-4dbf-a685-a0d0bc7b1fbc", "metadata": {"aucs": [0.27834561428456683]}, "mutation_prompt": null}
{"id": "052b0ce6-bc50-4fb6-aae8-70bea32141ad", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995  # Added adaptive inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Randomize velocities for enhanced exploration occasionally\n                if evaluations % 50 == 0: \n                    velocities[i] += np.random.randn(self.dim) * 0.1 \n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved Hybrid PSO-SA by introducing adaptive inertia weight and enhanced exploration via chaotic randomization.", "configspace": "", "generation": 3, "fitness": 0.2818853623437564, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "5e808fc1-afcf-4dbf-a685-a0d0bc7b1fbc", "metadata": {"aucs": [0.2818853623437564]}, "mutation_prompt": null}
{"id": "8c4f4561-9ed2-46ad-adf2-5731802a0632", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.diversity_threshold = 0.1  # New parameter for diversity check\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))  # Adjusted velocity initialization\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * (1 - (evaluations / self.budget))  # Dynamic inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Diversity-driven exploration\n                if np.std(particles) < self.diversity_threshold:\n                    velocities[i] += np.random.uniform(-0.5, 0.5, self.dim)  # New exploration strategy\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced Hybrid PSO-SA using dynamic parameter adaptation and diversity-driven exploration strategies.", "configspace": "", "generation": 4, "fitness": 0.27678021356677585, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "052b0ce6-bc50-4fb6-aae8-70bea32141ad", "metadata": {"aucs": [0.27678021356677585]}, "mutation_prompt": null}
{"id": "6146cde6-10ae-42e8-9f0c-b1c2923e3be8", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995  # Added adaptive inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Randomize velocities for enhanced exploration more frequently\n                if evaluations % 20 == 0: \n                    velocities[i] += np.random.randn(self.dim) * 0.1 \n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "HybridPSO_SA with Enhanced Exploration using Periodic Velocity Perturbation.", "configspace": "", "generation": 5, "fitness": 0.2830979873717634, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "052b0ce6-bc50-4fb6-aae8-70bea32141ad", "metadata": {"aucs": [0.2830979873717634]}, "mutation_prompt": null}
{"id": "db21c97f-c5b0-43ad-953b-2af5e0bcb77b", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995  # Added adaptive inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Randomize velocities for enhanced exploration more frequently\n                if evaluations % 15 == 0:  # Changed exploration frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.15  # Enhanced exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Adaptive Parameter Control with Enhanced Exploration Frequency.", "configspace": "", "generation": 6, "fitness": 0.28327375797186793, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "6146cde6-10ae-42e8-9f0c-b1c2923e3be8", "metadata": {"aucs": [0.28327375797186793]}, "mutation_prompt": null}
{"id": "16c0897c-30aa-4b1c-9e1d-3af0728d8f0c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995  # Added adaptive inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Randomize velocities for enhanced exploration more frequently\n                if evaluations % 15 == 0:  # Changed exploration frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.15  # Enhanced exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature with an adaptive approach\n            self.temperature *= (0.98 + 0.02 * evaluations / self.budget)\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduced an adaptive temperature reduction strategy to improve convergence by dynamically adjusting the cooling rate.", "configspace": "", "generation": 7, "fitness": 0.2831513338670939, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "db21c97f-c5b0-43ad-953b-2af5e0bcb77b", "metadata": {"aucs": [0.2831513338670939]}, "mutation_prompt": null}
{"id": "a3db0e92-83a8-49f5-abc1-e7f01dfc039c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:  # Changed exploration frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.2  # Enhanced exploration intensity\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced Adaptive Exploration by Modulating Particle Refresh Rate.", "configspace": "", "generation": 8, "fitness": 0.28185113656964056, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "db21c97f-c5b0-43ad-953b-2af5e0bcb77b", "metadata": {"aucs": [0.28185113656964056]}, "mutation_prompt": null}
{"id": "d06dddf0-adf0-4ce2-bda7-8b28e7d22242", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995  # Adaptive inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Randomize velocities for enhanced exploration more frequently\n                if evaluations % 15 == 0:  # Changed exploration frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.15  # Enhanced exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Adaptive velocity scaling based on diversity\n            diversity = np.std(particles, axis=0).mean()\n            velocities *= (1 + diversity * 0.01)  # Change made here\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Adaptive velocity update strategy by incorporating swarm diversity measure.", "configspace": "", "generation": 9, "fitness": 0.28144476759329884, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "db21c97f-c5b0-43ad-953b-2af5e0bcb77b", "metadata": {"aucs": [0.28144476759329884]}, "mutation_prompt": null}
{"id": "03cfe997-5bbf-4e44-957d-c410ce0483d0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995  # Added adaptive inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Randomize velocities for enhanced exploration more frequently\n                if evaluations % 15 == 0:  # Changed exploration frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.15  # Enhanced exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate * 0.999  # Slightly increased cooling rate for better convergence\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced convergence through adaptive velocity scaling in PSO.", "configspace": "", "generation": 10, "fitness": 0.2831513338670939, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "db21c97f-c5b0-43ad-953b-2af5e0bcb77b", "metadata": {"aucs": [0.2831513338670939]}, "mutation_prompt": null}
{"id": "eb8a7a95-bec5-44eb-aead-cb9cb4dde481", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98  # Line 1: Adjusted cooling rate for more gradual cooling\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.2  # Line 2: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:  # Line 3: Introduce diversity every few cycles\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 4: Add diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced Particle Swarm Optimization with Adaptive Cooling and Diversity Introduction.", "configspace": "", "generation": 11, "fitness": 0.2848924813025582, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "db21c97f-c5b0-43ad-953b-2af5e0bcb77b", "metadata": {"aucs": [0.2848924813025582]}, "mutation_prompt": null}
{"id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Line 1: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Fine-tuned HybridPSO_SA by enhancing velocity dynamics and improving diversity with adaptive components.", "configspace": "", "generation": 12, "fitness": 0.28578985144076463, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "eb8a7a95-bec5-44eb-aead-cb9cb4dde481", "metadata": {"aucs": [0.28578985144076463]}, "mutation_prompt": null}
{"id": "e95588e6-be1c-4c80-9177-b12e364a0e63", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                dynamic_cognitive = self.cognitive_const * (1 - evaluations / self.budget)  # Line 1: Dynamic cognitive constant\n                dynamic_social = self.social_const * (evaluations / self.budget)  # Line 2: Dynamic social constant\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 dynamic_cognitive * r1 * (personal_best_positions[i] - particles[i]) +\n                                 dynamic_social * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by introducing dynamic cognitive and social constants to enhance convergence precision and exploration capability.", "configspace": "", "generation": 13, "fitness": 0.2756824413240183, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.2756824413240183]}, "mutation_prompt": null}
{"id": "27f712e8-b6dc-4c58-b024-21ee91ab4879", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.7  # Changed from 1.5 to 1.7\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Line 1: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by adjusting the cognitive component for better convergence.", "configspace": "", "generation": 14, "fitness": 0.2794129677874887, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.2794129677874887]}, "mutation_prompt": null}
{"id": "e73cf073-c85f-4297-9966-bd5f2100c4ee", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.5 + 0.4 * np.random.rand()  # Dynamic inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:  # Increased frequency for exploration boost\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Enhanced exploration\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Reduced perturbation range for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with dynamic parameter tuning and improved exploration to converge faster.", "configspace": "", "generation": 15, "fitness": 0.2781619702219772, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.2781619702219772]}, "mutation_prompt": null}
{"id": "b0705d7d-3a3a-4f61-9f2a-6a4243accbbb", "solution": "import numpy as np\n\nclass HybridPSO_SA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.mutation_probability = 0.1  # Line 1: Added for adaptive mutation\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if np.random.rand() < self.mutation_probability:  # Line 2: Adaptive mutation condition\n                    velocities[i] += np.random.randn(self.dim) * 0.5  # Line 3: Mutation effect\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n                self.mutation_probability = min(0.5, self.mutation_probability * 1.1)  # Line 4: Adjust mutation probability\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA_Enhanced", "description": "Enhanced HybridPSO_SA by introducing adaptive mutation and adaptive parameter tuning to balance exploration and exploitation dynamically.", "configspace": "", "generation": 16, "fitness": 0.2796720301768437, "feedback": "The algorithm HybridPSO_SA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.2796720301768437]}, "mutation_prompt": null}
{"id": "027fc2f0-ed80-4daf-8bf9-3978d69a190d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Line 1: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.2, 0.2, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved global exploration by slightly increasing the exploration intensity during the diversity enhancement phase.", "configspace": "", "generation": 17, "fitness": 0.28418073168094937, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.28418073168094937]}, "mutation_prompt": null}
{"id": "3a5275fc-de60-4f72-9d79-0a5a8c1b9c89", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def levy_flight(self, lamda=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(abs(np.random.normal(0, 1, self.dim)), 1/lamda))\n        return u\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 20 == 0:\n                    particles[i] += self.levy_flight()  # Line 1: Integrating LÃ©vy flight for exploration\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by integrating LÃ©vy flight for enhanced exploration and incorporating dynamic parameter tuning.", "configspace": "", "generation": 18, "fitness": 0.2839763784154561, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.2839763784154561]}, "mutation_prompt": null}
{"id": "c69cd1ac-2826-4b22-8b20-8e3860b0f341", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.97  # Changed from 0.98 to 0.97\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by adjusting the cooling rate to improve convergence speed without losing diversity.", "configspace": "", "generation": 19, "fitness": 0.28578985144076463, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.28578985144076463]}, "mutation_prompt": null}
{"id": "dae4cdf2-6c9e-4c7d-9df8-73409be4802d", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * ((self.budget - evaluations) / self.budget)  # Adaptive inertia\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 20 == 0:  # Adjusted exploration frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by incorporating adaptive inertia weight and dynamic exploration strategies for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.27786497855830494, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.27786497855830494]}, "mutation_prompt": null}
{"id": "07f9d51f-d4e9-4279-aaae-58d6f3039e94", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Line 1: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim)) + np.random.randn(self.num_particles, self.dim) * 0.05  # Line 2: Enhancing diversity with adaptive random walks\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced global exploration by incorporating adaptive random walks for particles.", "configspace": "", "generation": 21, "fitness": 0.28396960831110385, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.28396960831110385]}, "mutation_prompt": null}
{"id": "41f4613c-ce2e-41a8-a0ce-dd768e9f28e6", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.97  # Modified Line: Adjust cooling rate for better convergence\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Modified Line: Increase exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by dynamically adjusting the cooling rate and increasing exploration to improve convergence.", "configspace": "", "generation": 22, "fitness": 0.28578564954090613, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.28578564954090613]}, "mutation_prompt": null}
{"id": "fd9df3ff-652a-4aca-9c4f-9501e1b64b4f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:  # Line 1: Increased exploration intensity update frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Line 2: Enhanced random exploration\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by adjusting velocity randomization and increased diversity injection frequency.", "configspace": "", "generation": 23, "fitness": 0.2810307892553865, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.2810307892553865]}, "mutation_prompt": null}
{"id": "7324c1d9-0f2a-43c8-9073-8eb1eebc4bdb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Change 1: Adjust cooling rate for adaptive cooling\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:  # Change 2: Increase exploration frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Change 3: Increase exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Refinement of HybridPSO_SA by introducing adaptive cooling and modifying exploration to enhance convergence.", "configspace": "", "generation": 24, "fitness": 0.28218121931363294, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.28218121931363294]}, "mutation_prompt": null}
{"id": "aa5129f4-ce6e-47ab-8e79-2ba062ace4cc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.98\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # Line 1: Adaptive inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n                \n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n\n            if evaluations % 20 == 0:  # Line 2: Dynamically adjust number of particles\n                self.num_particles = max(15, int(self.num_particles * 0.95) + 1)  # Line 3: Ensure particles don't reduce below a threshold\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by introducing dynamic particle counts and adaptive inertia weight adjustments.", "configspace": "", "generation": 25, "fitness": 0.27951483351743267, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.27951483351743267]}, "mutation_prompt": null}
{"id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Line changed: Fine-tuned cooling rate for better performance\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Line 1: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Refined HybridPSO_SA by adjusting cooling rate for improved convergence and exploration balance.", "configspace": "", "generation": 26, "fitness": 0.2858252728297307, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "753fdc2e-220a-4853-94da-9086b42cd2b7", "metadata": {"aucs": [0.2858252728297307]}, "mutation_prompt": null}
{"id": "b384bfa6-a490-4710-a5ee-822c26e17fe9", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # Line changed: Dynamic inertia adaptation\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by adapting inertia weight dynamically for improved convergence speed and diversity.", "configspace": "", "generation": 27, "fitness": 0.2786631211278021, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.2786631211278021]}, "mutation_prompt": null}
{"id": "45854944-6ee6-417d-a0a1-aac44adf067c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Line changed: Fine-tuned cooling rate for better performance\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995 if self.best_global_value < np.min(personal_best_values) else 1.005\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Line 1: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduced adaptive inertia weight adjustment based on performance feedback to enhance convergence speed.", "configspace": "", "generation": 28, "fitness": 0.2744916549204621, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.2744916549204621]}, "mutation_prompt": null}
{"id": "3485df31-359c-4922-a8a5-231892d71ce6", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                adaptive_inertia = 0.5 + (0.5 - 0.5/evaluations) * (self.best_global_value / (personal_best_values[i]+1e-9))  # Line 1: Adaptive inertia\n                velocities[i] = (adaptive_inertia * velocities[i] +  # Line 2: Use adaptive inertia\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                velocities[i] *= 0.95  # Line 3: Introduce velocity damping\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 4: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by introducing adaptive inertia and velocity damping to better balance exploration and exploitation.", "configspace": "", "generation": 29, "fitness": 0.2764927083572434, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.2764927083572434]}, "mutation_prompt": null}
{"id": "29a4e59e-fead-49ff-b6fb-6cbebd1cc0f7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Line changed: Slightly increased the exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved the exploration strategy by slightly increasing the random perturbation effect to enhance diversity.", "configspace": "", "generation": 30, "fitness": 0.28578564954090613, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.28578564954090613]}, "mutation_prompt": null}
{"id": "d8aca20c-cb4a-4a28-ac0d-7a11bc020745", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.9975  # Line changed: Adjusted inertia weight decay for better convergence\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  # Line 1: Slightly increased exploration intensity\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Refined HybridPSO_SA by adjusting the inertia weight decay rate for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.2780040414877427, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.2780040414877427]}, "mutation_prompt": null}
{"id": "b25afc50-0f13-4fdc-bc13-331ed0d3cae2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Dynamic adjustment of cognitive and social constants\n                self.cognitive_const = 1.5 - (1.0 * evaluations / self.budget)  # Line changed 1\n                self.social_const = 1.5 + (1.0 * evaluations / self.budget)    # Line changed 2\n\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n            # Enhanced exploration strategy\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.2, 0.2, (self.num_particles, self.dim))  # Line changed 3\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA by dynamically adjusting cognitive and social coefficients to enhance convergence robustness.", "configspace": "", "generation": 32, "fitness": 0.27892831377945104, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.27892831377945104]}, "mutation_prompt": null}
{"id": "1ea9251e-fc26-4492-ae7b-75dace77ceb8", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995  # Line changed: Fine-tuned cooling rate for better performance\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Changing Line: Slightly changed exploration perturbation frequency\n                if evaluations % 10 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25  \n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Line 2: Enhancing diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved exploration by adjusting random perturbation frequency to balance exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.28228837583909205, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.28228837583909205]}, "mutation_prompt": null}
{"id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved diversity by adjusting random perturbation factor in particle positions for better exploration.", "configspace": "", "generation": 34, "fitness": 0.28582920319554983, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "f96cc7f0-cb7d-46ce-afd4-6ebb81cb8118", "metadata": {"aucs": [0.28582920319554983]}, "mutation_prompt": null}
{"id": "5289c219-47e3-43ee-99ba-569b1e5cd2dd", "solution": "import numpy as np\n\nclass HybridPSO_SA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    perturbation_factor = 0.25 * np.exp(-personal_best_values[i] / self.best_global_value)\n                    velocities[i] += np.random.randn(self.dim) * perturbation_factor\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                global_perturbation = np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n                particles += global_perturbation * np.exp(-0.1 * evaluations / self.budget)\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA_Enhanced", "description": "Introduced adaptive particle adjustment using a fitness-dependent perturbation and mixed exploration strategy to enhance convergence.", "configspace": "", "generation": 35, "fitness": 0.2832247340915188, "feedback": "The algorithm HybridPSO_SA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2832247340915188]}, "mutation_prompt": null}
{"id": "e5607c25-0d95-4dbd-83ae-0b0388c693fd", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.2, 0.2, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved global exploration by increasing the perturbation factor when adjusting particle position.", "configspace": "", "generation": 36, "fitness": 0.28418073168094937, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28418073168094937]}, "mutation_prompt": null}
{"id": "3f989c11-5ab2-4785-9a08-3bcbe65dcca7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                # Line 1: Dynamic inertia weight adjustment for exploration\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    # Line 2: Adaptive random perturbation for increased diversity\n                    velocities[i] += np.random.randn(self.dim) * np.random.uniform(0.2, 0.3)\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                # Line 3: Increase perturbation factor for exploration\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))\n                \n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration via adaptive random perturbation and dynamic particle velocity scaling.", "configspace": "", "generation": 37, "fitness": 0.2794945852185926, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2794945852185926]}, "mutation_prompt": null}
{"id": "7a19b13a-7b5c-4ea4-ae81-925f5f67d590", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                # Line 1: Introduce adaptive cognitive and social constants\n                c1 = self.cognitive_const * (1 - evaluations/self.budget)\n                c2 = self.social_const * (evaluations/self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 c2 * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced convergence through adaptive cognitive and social constants for improved particle coordination.", "configspace": "", "generation": 38, "fitness": 0.27568283698143814, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27568283698143814]}, "mutation_prompt": null}
{"id": "19661101-02c5-46f2-9f92-4ad8c5ebe7e0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                performance_ratio = personal_best_values[i] / self.best_global_value\n                self.cognitive_const = 2.0 if performance_ratio > 1 else 1.5\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by dynamically adjusting social and cognitive constants based on performance.", "configspace": "", "generation": 39, "fitness": 0.28076601792457023, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28076601792457023]}, "mutation_prompt": null}
{"id": "def478ac-67e6-459e-a3b4-407fdb426ebc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % (10 if evaluations < self.budget / 2 else 15) == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by dynamically adjusting velocity perturbation frequency based on evaluations.", "configspace": "", "generation": 40, "fitness": 0.2812888859443504, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2812888859443504]}, "mutation_prompt": null}
{"id": "779337a0-2321-4e4f-8155-8389685e0549", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 2.0  # Changed\n        self.social_const = 2.0  # Changed\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            # Adaptively adjust cognitive and social constants\n            self.cognitive_const = 2.0 - (evaluations / self.budget)  # Changed\n            self.social_const = 2.0 + (evaluations / self.budget)  # Changed\n\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhancing convergence by introducing adaptive social and cognitive constants based on exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.27792331900154343, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27792331900154343]}, "mutation_prompt": null}
{"id": "c807d13e-72b3-4610-ae9f-449a22598de5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                # Dynamic adjustment of cognitive and social constants\n                self.cognitive_const = 1.5 * (1 - evaluations / self.budget) + 0.5\n                self.social_const = 1.5 * (evaluations / self.budget) + 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.15  # Reduced perturbation factor\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by dynamic adaptation of social and cognitive coefficients, and introducing adaptive perturbation in velocities.", "configspace": "", "generation": 42, "fitness": 0.2826538205011364, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2826538205011364]}, "mutation_prompt": null}
{"id": "05b4d02a-d4bf-4126-93e4-ad80a3062ef1", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995 if evaluations % 20 else 0.98  # Changed line: Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by dynamic adaptive inertia weight adjustment for improved convergence.", "configspace": "", "generation": 43, "fitness": 0.28270396236427675, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28270396236427675]}, "mutation_prompt": null}
{"id": "520b400d-614e-45f8-a6e4-8a36c9362594", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate * (1.0 if evaluations < self.budget / 2 else 0.99)\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduced adaptive cooling rate based on performance to balance exploration and exploitation.", "configspace": "", "generation": 44, "fitness": 0.28582920319554983, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28582920319554983]}, "mutation_prompt": null}
{"id": "45be0bda-9f50-4a6e-a9f4-a645a4046e27", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.15  # Line 1: Reduced perturbation factor to 0.15\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.05, 0.05, (self.num_particles, self.dim))  # Line 2: Reduced perturbation range for finer adjustments\n\n            # Line 3: Introduce adaptive mutation to escape local minima\n            if evaluations % (self.num_particles * 10) == 0:\n                mutation_factor = np.random.uniform(-0.1, 0.1, self.dim) * (1 - (evaluations / self.budget))\n                particles += mutation_factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration and exploitation phases by dynamically adjusting swarm parameters and incorporating adaptive mutation.", "configspace": "", "generation": 45, "fitness": 0.28377592050721057, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28377592050721057]}, "mutation_prompt": null}
{"id": "caeb76d9-951f-4450-8088-802c86523348", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.990  # Line 1: Adjusted cooling rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 12 == 0:  # Line 2: Changed perturbation frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate  # Line 3: Removed extra line to adhere to the 4-line change restriction\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 4: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by adaptive perturbation frequency and dynamic cooling rate to maintain diversity.", "configspace": "", "generation": 46, "fitness": 0.28069339852351627, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28069339852351627]}, "mutation_prompt": null}
{"id": "a181a9d1-a49f-45cc-b674-a61d5d7ac98f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 2) == 0:  # Updated frequency of perturbation\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced perturbation factor for diversity by refining particle position adjustments more frequently.", "configspace": "", "generation": 47, "fitness": 0.28069341369906087, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28069341369906087]}, "mutation_prompt": null}
{"id": "5164d322-fe3a-4766-bb26-1d9c5b0cb820", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                self.cognitive_const = 2.0 - 1.5 * evaluations / self.budget  # Line 1: Adaptive cognitive constant\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduced adaptive cognitive and social constants to enhance convergence speed and solution quality.", "configspace": "", "generation": 48, "fitness": 0.28092548693460584, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28092548693460584]}, "mutation_prompt": null}
{"id": "accc99b5-b55a-4b59-b8d0-9136554dcc98", "solution": "import numpy as np\n\nclass HybridPSO_SA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n\n        # Dynamic population size\n        self.num_particles = max(10, min(50, self.budget // (self.dim * 10)))\n\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n\n                # Dynamic inertia weight\n                self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.2  # Adjusted perturbation frequency and factor\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 4) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA_Enhanced", "description": "Enhanced exploration with adaptive population size and dynamic inertia weight for improved convergence.", "configspace": "", "generation": 49, "fitness": 0.2823090907396061, "feedback": "The algorithm HybridPSO_SA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2823090907396061]}, "mutation_prompt": null}
{"id": "3683f13c-b226-4a73-ae65-af5f76687cdf", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n                    particles[i] += np.random.rand(self.dim) * 0.05  # Line modified: Additional position perturbation for exploration\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced perturbation strategy by diversifying both position and velocity updates for better exploration.", "configspace": "", "generation": 50, "fitness": 0.28398304117367, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28398304117367]}, "mutation_prompt": null}
{"id": "451809f7-5269-4daa-b5c7-bfb0199f4209", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 2.0  # Increased to enhance exploration\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 12 == 0:  # Slightly more frequent perturbations\n                    velocities[i] += np.random.randn(self.dim) * 0.35  # Increased perturbation scale\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.2, 0.2, (self.num_particles, self.dim))  # Increased exploration space\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved local search by adaptive perturbation scaling and increased exploration space with dynamic social influence.", "configspace": "", "generation": 51, "fitness": 0.27987098859037984, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27987098859037984]}, "mutation_prompt": null}
{"id": "f0b22857-0283-4b9e-8b5e-591165b3cff2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            learning_rate = 0.02  # Line modified: Introduced a learning rate for velocity update\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i])) * learning_rate\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced velocity update by introducing a learning rate to improve global exploration.", "configspace": "", "generation": 52, "fitness": 0.27284811186688385, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27284811186688385]}, "mutation_prompt": null}
{"id": "084ae625-0b9b-4801-bd35-739f5022ecc3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 (self.social_const + 0.5 * (personal_best_values[i] > self.best_global_value)) * r2 * (self.best_global_position - particles[i]))  # Line modified\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduce adaptive social constant based on particle improvements to balance exploration and exploitation.", "configspace": "", "generation": 53, "fitness": 0.2803867512595293, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2803867512595293]}, "mutation_prompt": null}
{"id": "de88782a-b871-4b66-9e4c-a1c37a0009fc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                self.social_const = 1.5 + 0.5 * np.std(particles, axis=0).mean()  # Line 1: Dynamic adjustment of social constant\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by dynamically updating social constant based on diversity measurements.", "configspace": "", "generation": 54, "fitness": 0.269250694020144, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.269250694020144]}, "mutation_prompt": null}
{"id": "5c004d34-3430-4e34-8f7b-515e6c22a72c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                adaptive_cognitive_const = self.cognitive_const * (1 - evaluations / self.budget)  # Line 1: Adaptive cognitive constant\n                adaptive_social_const = self.social_const * (evaluations / self.budget)            # Line 2: Adaptive social constant\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 adaptive_social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by introducing adaptive learning rates for cognitive and social components in PSO.", "configspace": "", "generation": 55, "fitness": 0.27568283698143814, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27568283698143814]}, "mutation_prompt": null}
{"id": "5431db7f-c4d0-49df-aab8-b3da57aba878", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.99  # Adjusted decay rate for better balance\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced convergence by adjusting the inertia weight decay rate for improved balance between exploration and exploitation.", "configspace": "", "generation": 56, "fitness": 0.2824198351956341, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2824198351956341]}, "mutation_prompt": null}
{"id": "2d7d8109-380c-47ae-9a20-e13b34c29c30", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= (0.995 + 0.0002)  # Change 1: Slightly slower decay of inertia weight\n                scaling_factor = 1 + 0.5 * np.random.rand()  # Change 2: Introduce adaptive scaling\n                velocities[i] = scaling_factor * (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i] \n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 4: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by introducing adaptive velocity scaling and dynamic inertia weight decay for improved convergence.", "configspace": "", "generation": 57, "fitness": 0.27891423567855056, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27891423567855056]}, "mutation_prompt": null}
{"id": "e5a55333-a9c5-451a-9096-7ce0b843c970", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                diversity = np.mean(np.std(particles, axis=0))  # Calculate diversity\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]) +\n                                 diversity * 0.05 * np.random.randn(self.dim))  # Line 1: Adjust velocity with diversity metric\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by dynamically adjusting particle velocities based on diversity metrics.", "configspace": "", "generation": 58, "fitness": 0.2817221005612415, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2817221005612415]}, "mutation_prompt": null}
{"id": "50188b0a-e8e5-4ff4-aeaf-62596362d2d4", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.992  # Slightly faster decay\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Adjust perturbation using a selective condition\n                if evaluations % 20 == 0 and np.random.rand() < 0.3:\n                    velocities[i] += np.random.randn(self.dim) * 0.3\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 7) == 0:  # Adjusted interval\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Increased perturbation range for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration and exploitation balance by adaptive learning rates and selective particle perturbation.", "configspace": "", "generation": 59, "fitness": 0.28054828380283314, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28054828380283314]}, "mutation_prompt": null}
{"id": "e7636a29-c829-459e-8709-b79f590f55f7", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by increasing the perturbation factor to promote diversity during optimization.", "configspace": "", "generation": 60, "fitness": 0.2858252728297307, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2858252728297307]}, "mutation_prompt": null}
{"id": "feb74d36-8297-4a95-9a90-dca37c98d1e5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.2  # Line 1: Refined perturbation factor\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.05, 0.05, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "A refined perturbation strategy and dynamic social constant adjustment for enhanced exploration and convergence in HybridPSO_SA.", "configspace": "", "generation": 61, "fitness": 0.2848970273468664, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2848970273468664]}, "mutation_prompt": null}
{"id": "1ff61a19-c6c1-43a8-9d87-25639fee6115", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:  # Adjusted from 15 to 10 for more frequent perturbations\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Adjusted perturbation factor\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by increasing the frequency of velocity random perturbations for diverse searching.", "configspace": "", "generation": 62, "fitness": 0.28267819972137487, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28267819972137487]}, "mutation_prompt": null}
{"id": "2b822f62-d316-4bd0-b904-89532931640f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.993  # Line 1: Slightly faster inertia decay\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:  # Line 2: More frequent perturbation\n                    velocities[i] += np.random.randn(self.dim) * 0.15  # Line 3: Reduced perturbation magnitude\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (self.cooling_rate + 0.002)  # Line 4: Adjusted cooling rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.05, 0.05, (self.num_particles, self.dim))  # Line 5: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration and exploitation by dynamically adjusting key parameters and introducing adaptive particle perturbations.", "configspace": "", "generation": 63, "fitness": 0.2797288264644314, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2797288264644314]}, "mutation_prompt": null}
{"id": "f068fbab-7b17-410c-a7b6-57a03317c405", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.base_cognitive_const = 1.5\n        self.base_social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                iteration_factor = 1 - (evaluations / self.budget)\n                cognitive_const = self.base_cognitive_const * iteration_factor + 0.5\n                social_const = self.base_social_const * iteration_factor + 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced convergence by dynamically adjusting social and cognitive constants based on iterations.", "configspace": "", "generation": 64, "fitness": 0.28087744135098536, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28087744135098536]}, "mutation_prompt": null}
{"id": "34b551b3-2d3e-4210-b7cd-0720d0eefd33", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % int(15 * (1 + self.best_global_value / 100)) == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by dynamically adjusting perturbation frequency based on performance.", "configspace": "", "generation": 65, "fitness": 0.28582920319554983, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28582920319554983]}, "mutation_prompt": null}
{"id": "4841e426-7b2a-40cc-ac19-c56f9830c5cb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # Adaptive inertia\n                r3 = np.random.uniform(0.8, 1.2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i])) * r3\n\n                if evaluations % 12 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.2\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                neighbor_offset = np.random.uniform(-0.1, 0.1, self.dim)\n                particles += neighbor_offset  # Dynamic neighborhood influence\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by introducing adaptive velocity scaling and dynamic neighborhood influence in the hybrid PSO-SA algorithm.", "configspace": "", "generation": 66, "fitness": 0.27666105122982654, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27666105122982654]}, "mutation_prompt": null}
{"id": "91e849df-e99c-4d96-b68c-b8aacd259841", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim)) \n\n            # Dynamic adjustment of coefficients\n            self.cognitive_const = 2.5 - 1.5 * (evaluations / self.budget)\n            self.social_const = 0.5 + 1.5 * (evaluations / self.budget)\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration-exploitation balance by dynamic adjustment of cognitive and social coefficients.", "configspace": "", "generation": 67, "fitness": 0.27804862730436863, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.27804862730436863]}, "mutation_prompt": null}
{"id": "50766136-323a-4728-964c-beb10e35abac", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25 * np.var(personal_best_values) # Line 1: Adaptive perturbation based on fitness variance\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.05, 0.05, (self.num_particles, self.dim))  # Line 2: Reduced perturbation range\n                self.social_const = 1.5 + 0.5 * np.random.rand()  # Line 3: Adjusting social influence dynamically\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by integrating adaptive perturbation and updating velocity dynamically based on fitness improvement rate.", "configspace": "", "generation": 68, "fitness": 0.28304244789932664, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28304244789932664]}, "mutation_prompt": null}
{"id": "d77f9dca-94e8-4ee4-9d04-bb6c0a80b8c3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                adaptive_inertia = 0.5 + (0.4 * np.random.rand())  # Line 1: Adaptive inertia weight\n                velocities[i] = (adaptive_inertia * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate * 0.99  # Line 2: Additional temperature adjustment\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced PSO-SA hybrid by spatially adaptive inertia weights and dynamic temperature adjustment to improve exploration and convergence.", "configspace": "", "generation": 69, "fitness": 0.276427638617914, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.276427638617914]}, "mutation_prompt": null}
{"id": "4eb6c8b0-f2e7-493e-b6bf-d077ae04a657", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.993  # Adjusted inertia decay\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 10 == 0:  # Adjusted perturbation frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))  # Line 2: Adjusted perturbation factor for diversity\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced balance between exploration and exploitation by tweaking inertia decay and perturbation frequency.", "configspace": "", "generation": 70, "fitness": 0.2800022786035963, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.2800022786035963]}, "mutation_prompt": null}
{"id": "e5302ec9-b027-4670-a792-be89be6cb753", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Adjusted random perturbation factor\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.15, 0.15, (self.num_particles, self.dim))  # Dynamic perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced global-best update mechanism and dynamic perturbation for improved exploration.", "configspace": "", "generation": 71, "fitness": 0.28578564954090613, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.28578564954090613]}, "mutation_prompt": null}
{"id": "5b3fb0f6-7e20-4b8e-88f2-9dd93125fceb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhancing diversity by dynamically scaling perturbation factor in particle positions based on evaluation progress.", "configspace": "", "generation": 72, "fitness": 0.285838433239592, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "4b13adc0-5143-4ee1-9ef0-68dfcb8fbe12", "metadata": {"aucs": [0.285838433239592]}, "mutation_prompt": null}
{"id": "4a62998a-02b8-4dc7-8bb4-1ea63c6a85f5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (self.cooling_rate - 0.002 * (evaluations / self.budget))  # Line: Adaptive cooling rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduce adaptive cooling rate based on evaluation progress to balance exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.285838433239592, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "5b3fb0f6-7e20-4b8e-88f2-9dd93125fceb", "metadata": {"aucs": [0.285838433239592]}, "mutation_prompt": null}
{"id": "f163ea35-c0d6-4c49-92d8-a19d7174f3b3", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                self.cognitive_const = 1.5 * (1 - evaluations / self.budget)  # Line: Adaptive cognitive constant\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= self.cooling_rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introducing adaptive social and cognitive constants to balance exploration and exploitation dynamically.", "configspace": "", "generation": 74, "fitness": 0.2836063241854998, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "5b3fb0f6-7e20-4b8e-88f2-9dd93125fceb", "metadata": {"aucs": [0.2836063241854998]}, "mutation_prompt": null}
{"id": "e399ae15-fd61-472f-a480-39baf26207df", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # Line: Adaptive inertia weight scaling\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= 0.95 ** (1 + evaluations / self.budget)  # Line: Non-linear cooling rate\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Optimize convergence by integrating non-linear cooling for temperature reduction and adaptive inertia weight scaling.", "configspace": "", "generation": 75, "fitness": 0.2789104636877139, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "5b3fb0f6-7e20-4b8e-88f2-9dd93125fceb", "metadata": {"aucs": [0.2789104636877139]}, "mutation_prompt": null}
{"id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introducing a non-linear cooling schedule for adjusting the temperature to improve convergence.", "configspace": "", "generation": 76, "fitness": 0.28590561580433127, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "5b3fb0f6-7e20-4b8e-88f2-9dd93125fceb", "metadata": {"aucs": [0.28590561580433127]}, "mutation_prompt": null}
{"id": "8c5c76dc-c3a7-4cb5-a9d5-b9704d3c6ed2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.9 - (0.5 * evaluations / self.budget)  # Change: Adaptive inertia\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * (0.5 - 0.5 * evaluations / self.budget)  # Change: Dynamic perturbation\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced velocity update with adaptive inertia and a dynamic perturbation strategy to balance exploration and exploitation.", "configspace": "", "generation": 77, "fitness": 0.28027309659088817, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28027309659088817]}, "mutation_prompt": null}
{"id": "56f818e4-4c8d-4ccf-a8dd-6721cff60434", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n                    velocities[i] += np.random.normal(0, 0.1 * (1 - evaluations / self.budget), self.dim)  # Line: Added adaptive mutation\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced global exploration by incorporating adaptive mutation into the velocity update for better diversity.", "configspace": "", "generation": 78, "fitness": 0.2821408786632533, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.2821408786632533]}, "mutation_prompt": null}
{"id": "ac8cb355-47ff-4975-a2f6-eedb64c1add5", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_num_particles = 30\n        self.num_particles = self.initial_num_particles\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            dynamic_inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)  # Line: Dynamic inertia adjustment\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                velocities[i] = (dynamic_inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))\n                self.num_particles = int(self.initial_num_particles * (1 - evaluations / self.budget)) + 5  # Line: Adaptive particle count\n                particles = np.vstack((particles, np.random.uniform(lb, ub, (self.num_particles - len(particles), self.dim))))  # Line: Reinitialize particles\n\n        return self.best_global_position, self.best_global_value", "name": "EnhancedHybridPSO_SA", "description": "Enhanced Hybrid PSO-SA with adaptive particle count and dynamic inertia weight scaling.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('negative dimensions are not allowed').", "error": "ValueError('negative dimensions are not allowed')", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {}, "mutation_prompt": null}
{"id": "39b99ad8-528d-4571-9e36-5dcd36f7ff49", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                time_varying_accel = (0.5 + 0.5 * (evaluations / self.budget))  # Added line\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 time_varying_accel * self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 time_varying_accel * self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced velocity update by introducing a time-varying acceleration coefficient.", "configspace": "", "generation": 80, "fitness": 0.28319746149461966, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28319746149461966]}, "mutation_prompt": null}
{"id": "1cda88e9-5ab0-4201-abee-e5446f543789", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n            velocities += 0.1 * np.sin(evaluations * 0.15)  # Line: Added chaos-based perturbation\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Incorporating a chaos-based perturbation in particle velocities to enhance exploration and avoid local optima.", "configspace": "", "generation": 81, "fitness": 0.28418833907799523, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28418833907799523]}, "mutation_prompt": null}
{"id": "8b13b1c7-b451-4929-a1bc-17f2fef0cfec", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        # Line 1 change: Use chaotic sequence for initialization\n        particles = lb + (ub - lb) * (np.sin(np.arange(self.num_particles * self.dim))**2).reshape(self.num_particles, self.dim)\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                # Line 2-3 change: Adaptive inertia weight\n                self.inertia_weight = 0.4 + (0.5 * (self.best_global_value - np.min(personal_best_values)) / (self.best_global_value + 1e-10))\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                # Line 4 change: Remove random velocity perturbation\n                # if evaluations % 15 == 0:\n                #     velocities[i] += np.random.randn(self.dim) * 0.25\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Line 5 change: Adjusted cooling further with sinusoidal component\n            self.temperature *= (0.85 + 0.15 * np.cos(evaluations / self.budget * np.pi))  \n\n            if evaluations % (self.num_particles * 5) == 0:\n                # Line 6-7 change: Enhanced perturbation with chaotic influence\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim)) * np.sin(evaluations)  \n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved exploration and exploitation balance by adapting dynamic coefficients and introducing chaos initialization.", "configspace": "", "generation": 82, "fitness": 0.28191181599612647, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28191181599612647]}, "mutation_prompt": null}
{"id": "3a56bbde-1607-4181-ae85-2d8e7cbc9b57", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            diversity = np.mean(np.std(particles, axis=0))  # Compute diversity\n            self.social_const = 1.5 + 1.5 * (diversity / (ub - lb).mean())  # Adaptive social constant\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introducing adaptive social constants based on swarm diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.28012065259939123, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28012065259939123]}, "mutation_prompt": null}
{"id": "a7e9b021-9c44-4e46-84bb-8015a32ff541", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                self.social_const = 1.5 + 0.5 * (evaluations / self.budget)  # Line: Adaptive social constant\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduced adaptive social constant to enhance convergence in later stages.", "configspace": "", "generation": 84, "fitness": 0.27894680091437796, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.27894680091437796]}, "mutation_prompt": null}
{"id": "34fdfef0-9245-4a21-aebc-3d162681148e", "solution": "import numpy as np\n\nclass HybridPSO_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                adaptive_cognitive_const = self.cognitive_const * (1 - evaluations / self.budget)\n                adaptive_social_const = self.social_const * (evaluations / self.budget)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 adaptive_social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.2  # Slightly reduced noise factor\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.05, 0.05 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Modified perturbation scope\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA_Refined", "description": "Enhanced particle diversity through adaptive cognitive and social coefficients and improved perturbation mechanism.", "configspace": "", "generation": 85, "fitness": 0.27548749893467717, "feedback": "The algorithm HybridPSO_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.27548749893467717]}, "mutation_prompt": null}
{"id": "0b494ca9-8ef4-4a3c-9cae-43c08ffe83bb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 20 == 0:  # Modified frequency of perturbation\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 4) == 0:  # Adjusted perturbation interval\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration by modifying perturbation factor frequency for better balance between exploration and exploitation.", "configspace": "", "generation": 86, "fitness": 0.2804133315673216, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.2804133315673216]}, "mutation_prompt": null}
{"id": "7c08e170-1278-4005-b1fa-7cc9c675b47f", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.993  # Changed decay rate for inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved convergence by adjusting the inertia weight decay rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.28159002622622265, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28159002622622265]}, "mutation_prompt": null}
{"id": "c7d018ab-1738-4008-a3b6-7c8917a8ec60", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n                \n                # Add adaptive velocity scaling based on fitness\n                velocities[i] *= (1 + np.abs(self.best_global_value - personal_best_values[i]) / (1 + np.abs(self.best_global_value)))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced convergence with adaptive particle velocity scaling using fitness-based dynamic parameters.", "configspace": "", "generation": 88, "fitness": 0.28083956372770247, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28083956372770247]}, "mutation_prompt": null}
{"id": "ed5ffa90-79d5-4c41-9d2e-a3e19b9917f5", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Line: Dynamic inertia weight update\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Introduce a dynamic update for inertia weight based on the evaluations ratio to balance exploration and exploitation.", "configspace": "", "generation": 89, "fitness": 0.27876449960984184, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.27876449960984184]}, "mutation_prompt": null}
{"id": "2c450ce9-824e-4eeb-a158-594b6cf786eb", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Line: Dynamic inertia weight\n                self.cognitive_const = 1.5 + 0.5 * np.sin(evaluations / self.budget * np.pi)  # Line: Adaptive cognitive factor\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Improved exploration with adaptive learning factors and a dynamic inertia weight.", "configspace": "", "generation": 90, "fitness": 0.28115754025881823, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28115754025881823]}, "mutation_prompt": null}
{"id": "56d58641-2618-4cbd-ad14-86a0dc438cd2", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.5 + 0.4 * np.cos(evaluations / self.budget * np.pi)  # Line: Adaptive inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i])) \n                \n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * np.random.uniform(0.2, 0.3)  # Line: Stochastic velocity update\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi)) \n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  \n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Integrate adaptive inertia weight and stochastic velocity update for enhanced exploration-exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.2762492402181723, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.2762492402181723]}, "mutation_prompt": null}
{"id": "6ea4a3d9-9578-45f6-a1ae-037e3e5eaee5", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] *= np.random.uniform(0.5, 1.5)  # Change: Adaptive velocity scaling\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 20 == 0:  # Change: Adjusted perturbation frequency\n                    velocities[i] += np.random.randn(self.dim) * 0.3  # Change: Increased perturbation magnitude\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 4) == 0:  # Change: More frequent diversity injection\n                particles += np.random.uniform(-0.2, 0.2 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Change: Adjusted diversity injection\n\n        return self.best_global_position, self.best_global_value", "name": "EnhancedHybridPSO_SA", "description": "Enhancing exploration with adaptive velocity scaling and diversity injection for improved global search capability.", "configspace": "", "generation": 92, "fitness": 0.27868397087817665, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.27868397087817665]}, "mutation_prompt": null}
{"id": "677b61e4-1c30-4896-8108-15529158fe79", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Line: Adjusted inertia weight dynamically\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))\n                particles += np.random.randn(self.num_particles, self.dim) * 0.01 * (1 - evaluations / self.budget)  # Line: Added small adaptive mutation\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhance exploration by adjusting inertia weight dynamically and introduce a small adaptive mutation to particle positions.", "configspace": "", "generation": 93, "fitness": 0.2792320864890655, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.2792320864890655]}, "mutation_prompt": null}
{"id": "9689fe1f-159e-4006-95b8-03b222a87550", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] *= 1.2  # Adjusted: Adaptive velocity scaling\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))\n                if np.random.rand() < 0.1:  # Added: Random restart mechanism\n                    particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))  # Re-randomize some particles\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced exploration and diversity by introducing adaptive velocity scaling and random restart mechanism.", "configspace": "", "generation": 94, "fitness": 0.28198114617276204, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28198114617276204]}, "mutation_prompt": null}
{"id": "049bcc2c-4c1a-402c-8043-b76867eea9d4", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.3 * (1 - evaluations / self.budget) ** 2, (self.num_particles, self.dim))  # Changed perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Adjusted perturbation factor to improve exploration near completion of the budget.", "configspace": "", "generation": 95, "fitness": 0.28573557111035464, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28573557111035464]}, "mutation_prompt": null}
{"id": "699bf561-165a-4e11-93a1-83acb2f422b0", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight *= 0.995\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.laplace(size=self.dim) * 0.25  # Changed random distribution to Laplace\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Slight adjustment to exploration factor by varying velocities with a different random distribution.", "configspace": "", "generation": 96, "fitness": 0.2821402651889334, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.2821402651889334]}, "mutation_prompt": null}
{"id": "9c7a6858-ec52-4c7c-9418-d7a5c56c7b55", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.7  # Adjusted cognitive constant for stronger personal attraction\n        self.social_const = 1.7  # Adjusted social constant for stronger global attraction\n        self.temperature = 1.0\n        self.cooling_rate = 0.993  # Slight change in cooling rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))  # Reduced initial velocity range\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # Adaptive inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 20 == 0:  # Less frequent, but stronger perturbation\n                    velocities[i] += np.random.randn(self.dim) * 0.3\n\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                acceptance_probability = np.exp((self.best_global_value - current_value) / self.temperature)\n                if current_value < self.best_global_value or acceptance_probability > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            self.temperature *= (0.8 + 0.2 * np.cos(evaluations / self.budget * np.pi))  # Non-linear cooling with adjusted parameters\n\n            if evaluations % (self.num_particles * 5) == 0:\n                perturbation_factor = 0.05 * (1 - evaluations / self.budget)\n                particles += np.random.uniform(-perturbation_factor, perturbation_factor, (self.num_particles, self.dim))\n\n        return self.best_global_position, self.best_global_value", "name": "EnhancedHybridPSO_SA", "description": "Enhanced hybrid strategy with adaptive inertia and diversity enhancement for improved exploration and convergence.", "configspace": "", "generation": 97, "fitness": 0.27965381750141216, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.27965381750141216]}, "mutation_prompt": null}
{"id": "a7bcd293-40b7-478e-9f72-5d241b483b4c", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                inertia_weight = 0.5 + 0.4 * np.cos(np.pi * evaluations / self.budget)  # Adaptive inertia weight\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.05 * np.cos(evaluations / self.budget * np.pi) + 0.05 * np.random.rand())  # Diversified cooling schedule\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Incorporating adaptive inertia weight and diversified cooling schedule to enhance exploration and exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.28133148047970047, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.28133148047970047]}, "mutation_prompt": null}
{"id": "f146904a-e861-476a-ba8b-6d76833478fc", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.inertia_weight = 0.9\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n        particles = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.num_particles\n\n        self.best_global_position = particles[np.argmin(personal_best_values)]\n        self.best_global_value = np.min(personal_best_values)\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                # Update velocities\n                r1, r2 = np.random.rand(2, self.dim)\n                self.inertia_weight = max(0.4, self.inertia_weight - 0.0005)  # Changed: Dynamically adjust inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_const * r2 * (self.best_global_position - particles[i]))\n\n                velocities[i] *= (1 + np.tanh(1 - evaluations / self.budget))  # Changed: Adaptive velocity scaling\n\n                if evaluations % 15 == 0:\n                    velocities[i] += np.random.randn(self.dim) * 0.25\n\n                # Update positions\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particle\n                current_value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                # Simulated Annealing acceptance criterion\n                if current_value < self.best_global_value or np.exp((self.best_global_value - current_value) / self.temperature) > np.random.rand():\n                    self.best_global_position = particles[i]\n                    self.best_global_value = current_value\n\n            # Cool the temperature\n            self.temperature *= (0.9 + 0.1 * np.cos(evaluations / self.budget * np.pi))  # Line: Introduced non-linear cooling\n\n            if evaluations % (self.num_particles * 5) == 0:\n                particles += np.random.uniform(-0.1, 0.1 * (1 - evaluations / self.budget), (self.num_particles, self.dim))  # Line: Adjusted perturbation factor\n\n        return self.best_global_position, self.best_global_value", "name": "HybridPSO_SA", "description": "Enhanced convergence by dynamically adjusting the inertia weight and introducing adaptive velocity scaling.", "configspace": "", "generation": 99, "fitness": 0.2741137096027465, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "0ab57b8b-5155-49fe-b30e-f4cbbaf1d5bc", "metadata": {"aucs": [0.2741137096027465]}, "mutation_prompt": null}
