{"id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Tunneling for efficient global search in constrained high-dimensional spaces.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 134, in evaluatePhotonic\n    algorithm = globals()[algorithm_name](budget=budget, dim=dim)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: QuantumParticle.__init__() got an unexpected keyword argument 'budget'\n.", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/scratch/hyin/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 134, in evaluatePhotonic\n    algorithm = globals()[algorithm_name](budget=budget, dim=dim)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: QuantumParticle.__init__() got an unexpected keyword argument 'budget'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "1f1f0550-2fc8-4c84-a56f-31b0631e4570", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds using reflection\n                out_of_bounds_indices = np.where((particle.position < bounds.lb) | (particle.position > bounds.ub))\n                particle.position[out_of_bounds_indices] = 2 * bounds.lb[out_of_bounds_indices] - particle.position[out_of_bounds_indices]\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization enhanced with an adaptive boundary reflection mechanism for increased exploration.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "3f856352-9641-4450-8033-a38b1ac02def", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic scaling\n                particle.velocity = (cognitive_component + social_component) * np.random.uniform(0.5, 1.5)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Hybrid Quantum-Inspired PSO using dynamic velocity scaling for improved exploration in high-dimensional spaces.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "142419e0-9cd9-4105-ae04-034070e442d2", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic scaling\n                particle.velocity = cognitive_component + social_component\n                particle.velocity *= np.random.uniform(0.8, 1.2)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization using Adaptive Quantum Tunneling with Dynamic Velocity Scaling for improved exploration across diverse photonic optimization landscapes.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "523bacf8-71f6-463a-b31a-3dfce42870ec", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(50, swarm_size + dim // 10)\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Swarm Size for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "777da05d-5653-42a4-adaa-cc7414bf4a16", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Dynamically adjust parameters\n            self.alpha = 0.5 + 0.5 * (1 - eval_count / self.budget)\n            self.beta = 0.9 * (1 - eval_count / self.budget)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with dynamic parameters for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "77430557-eb38-4d5f-816f-aeb323d333e0", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Dynamic tunneling strength based on eval_count\n                tunneling_strength = np.random.uniform(0.1, 1.0) * (1 - eval_count / self.budget)\n                if np.random.rand() < 0.1:\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Improved quantum tunneling strategy by dynamically adjusting tunneling strength based on function evaluations for enhanced convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "7011ed29-10db-41da-bf99-3113f9d2b6e2", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Adjust swarm size dynamically\n            if eval_count % (self.budget // 3) == 0:\n                self.swarm_size = max(10, int(self.swarm_size * 0.9))\n                self.particles = self.particles[:self.swarm_size]\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Swarm Size for improved exploration and convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "584a995e-1ffc-4b7e-b153-3e8bb98a3af5", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, initial_swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.initial_swarm_size = initial_swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.initial_swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Dynamically reduce swarm size as evaluations progress\n            current_swarm_size = max(5, int(self.initial_swarm_size * (1 - eval_count / self.budget)))\n            self.particles = self.particles[:current_swarm_size]\n\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Swarm Size Adaptation for Improved Exploration and Exploitation.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "582c06a0-586c-4e0a-a1d9-fff47ebea49d", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Dynamically adjust swarm size based on progress\n            if eval_count > 0 and eval_count % 10 == 0:\n                self.swarm_size = max(10, int(self.swarm_size * 0.9))\n\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Swarm Size for Adaptive Search Balance between Exploration and Exploitation.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "93721510-a8cb-488a-8af8-720dda43fe9c", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update - Adjusted coefficients\n                particle.velocity = 0.7 * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 0.5)  # Adjusted tunneling strength\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Optimized Velocity Update and Adaptive Tunneling", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "bf570169-b0d5-4f25-85e2-34d29989204a", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n                \n                # Quantum-inspired velocity update with adaptive scaling\n                scaling_factor = 0.5 + np.random.rand() * 0.5\n                particle.velocity = scaling_factor * (cognitive_component + social_component)\n\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Improved boundary handling\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Improved Boundary Handling and Adaptive Velocity Scaling for better convergence and exploration.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "6f65cc0c-4347-4c08-8b8f-18d900162294", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        inertia_weight = 0.9\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic inertia weight\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            inertia_weight *= 0.99  # Dynamic reduction of inertia weight for better convergence\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Inertia Weight for improved exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "70bbad73-90a9-497c-be0a-8d4978d886e8", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, max_velocity=0.5):  # Changed line 1\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.max_velocity = max_velocity  # Changed line 2\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Clamp velocity to prevent excessive growth\n                particle.velocity = np.clip(particle.velocity, -self.max_velocity, self.max_velocity)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with additional velocity clamping to prevent excessive particle velocity growth and improve convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "3f547305-5e04-468e-bfa5-fa8b956cf27e", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Dynamically adjust swarm size for better exploration/exploitation\n            self.swarm_size = max(10, int(self.swarm_size * 0.95 + 0.05 * (self.budget - eval_count) / self.budget * 30))\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Swarm Size for Improved Exploration and Exploitation Balance in High-Dimensional Spaces", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "1947388d-bbb4-4f51-99ce-6f40614cb7f0", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with scaling\n                velocity_scaling = np.random.uniform(0.5, 1.5)  # New line\n                particle.velocity = velocity_scaling * (cognitive_component + social_component)  # Modified line\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with adjustable velocity scaling for improved exploration and convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "b61cc1d0-c52a-4361-b7da-d0168ac5f7f2", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Refined Quantum tunneling: Enhanced adaptive jump strategy\n                if np.random.rand() < 0.15:  # Increased tunneling probability\n                    tunneling_strength = np.random.uniform(0.2, 1.0)  # Adjusted strength range\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Refined Quantum PSO with enhanced quantum tunneling strategy for improved global search efficiency.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "3fefee69-aa7a-48fb-9bab-0e13fee800e2", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling with diversity-preserving mutation\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity + np.random.normal(0, 0.1, self.dim)\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with diversity-preserving mutation for improved exploration.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "63a9d3b6-853f-4abc-8b8f-b96f2a476c55", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Stochastic tunneling adaptation\n                tunneling_prob = np.exp(-np.abs(particle.best_value - self.global_best_value))\n                if np.random.rand() < tunneling_prob:  # Line modified\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with stochastic tunneling based on energy landscapes for better exploration and avoidance of local optima.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "60bab3bf-d9a5-487f-a06b-b8031a5eebb8", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Enhanced strategy to avoid local maxima\n                if np.random.rand() < 0.05:  # Reduced tunneling probability\n                    tunneling_strength = np.random.uniform(0.5, 1.5)  # Adjusted tunneling strength range\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Improved Quantum Tunneling for accelerated escape from local optima in high-dimensional spaces.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "b168e145-eba3-4300-b456-f9840dd51364", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Stochastic velocity scaling\n                particle.velocity = (cognitive_component + social_component) * np.random.uniform(0.5, 1.5)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Stochastic Velocity Scaling for improved global search efficiency in variable dimensions.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "9345c8f4-9a2d-4617-a4b8-6f4f4b3b7701", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.15:  # Increased tunneling probability\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Tunable Exploration-Exploitation Balance for improved search in high-dimensional spaces.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "d0d01fe5-cc6c-4fd8-aad1-abc7a509f2ab", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                # Dynamic social component adjustment\n                adjusted_beta = self.beta * (1 - eval_count / self.budget)\n                social_component = adjusted_beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Incorporating dynamic adjustment of social influence to enhance exploration and convergence in Quantum-Inspired Particle Swarm Optimization.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "fe224c7d-259a-4d0b-afd0-c8be02e820c5", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                tunneling_strength = np.random.uniform(0.05, 0.5)  # adjusted range\n                if np.random.rand() < 0.1:\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Improved Quantum-Inspired PSO with adaptive tunneling to balance exploration and exploitation in photonic structure optimization.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "969896a2-9bf3-4aa9-a67f-1781883a59c6", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        inertia = 0.9  # Line 1 changed: Introduce inertia factor\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia\n                particle.velocity = inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            inertia *= 0.99  # Line 2 changed: Dynamic reduction of inertia over iterations\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Inertia for improved convergence and search efficiency.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "4753e753-ac6b-4b75-bae4-0933d7a03920", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = (cognitive_component + social_component) * 0.9\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Velocity Scaling for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "8778af4a-e35d-4100-ad5c-b0c3e72ea429", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Dynamic Quantum tunneling probability\n                tunneling_probability = 0.1 + 0.2 * (self.budget - eval_count) / self.budget\n                if np.random.rand() < tunneling_probability:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Tunneling Probability for improved balance between exploration and exploitation.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "8b9ff649-97aa-42b4-ab44-e1ec3fbd3e1b", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia_weight=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia_weight = inertia_weight\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic inertia weight\n                particle.velocity = self.inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Inertia Weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "e6d49b66-bcf9-4d84-976a-e260ab287069", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        inertia_weight = 0.9  # Line modified for adaptive inertia weight\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with adaptive inertia\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with Adaptive Inertia for improved convergence in complex landscapes.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "0f9e4768-d5c4-4408-8c68-500405f74d16", "solution": "# Description: Enhanced Quantum PSO with dynamic velocity scaling for improved search efficiency and exploration-exploitation balance.\n# Code:\nimport numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component * (1 - eval_count/self.budget)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with dynamic velocity scaling for improved search efficiency and exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "f546e253-633f-46ab-8280-e60cc3b9f081", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = (cognitive_component + social_component) * 0.5  # Added scaling factor\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced QuantumPSO with improved velocity update by scaling particle velocity to prevent overshooting.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "5d14f061-0313-4458-abc7-5226d2982004", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Dynamic adjustment of velocity\n                particle.velocity *= np.tanh(1 + eval_count / self.budget)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Velocity Adjustment for improved exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "12744136-ecf2-450a-b61c-285bc1951489", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        # Dynamic swarm size\n        dynamic_swarm_size = int(self.swarm_size * (1 + 0.1 * np.sin(eval_count/self.budget * np.pi)))\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles[:dynamic_swarm_size]:  # Adjust number of active particles\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Swarm Size Adjustment for Improved Performance in High-Dimensional Spaces.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "cf8e0095-5b01-468f-8e94-e93303847e04", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia = inertia\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Tunneling and Inertia Weighting for enhanced exploration-exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "400dd9a1-693c-43e3-a5b8-798bbd50368a", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Adaptive learning rate update\n            self.alpha = max(0.1, self.alpha * 0.99)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Adaptive Learning Rate for improved exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "0ab42b36-19ab-461e-94f0-94dcf5f196c9", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with scaling factor\n                particle.velocity = 0.5 * (cognitive_component + social_component)\n\n                # Quantum tunneling: Dynamic probability jump\n                if np.random.rand() < (1 - eval_count / self.budget):  # Change line 1\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with dynamic tunneling probability and velocity scaling to improve convergence without exceeding the change limit.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "d15be312-560b-47b7-ab71-3bc958779f61", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Dynamic tunneling probability\n                tunneling_probability = 0.1 + (0.5 * eval_count / self.budget)\n                if np.random.rand() < tunneling_probability:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with dynamic adjustment of tunneling probability for improved exploration-exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "13bbe84e-fcd0-409f-b723-5347dc8cf307", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        inertia = 0.7  # Introduce inertia\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia\n                particle.velocity = inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Adaptive Inertia for improved exploration-exploitation balance.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "9139a65e-1acb-4378-a8dc-3600d890ba11", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Introduce diversity by resetting some particles\n                if np.random.rand() < 0.05:  # Adjusted from 0.1 to 0.05\n                    particle.position = np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Hybrid Quantum-Inspired Particle Swarm Optimization with Diversification Strategy to Prevent Premature Convergence.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "b0315767-2bd6-49ad-8648-0d900249b738", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Enhanced adaptive jump to improve escape from local maxima\n                if np.random.rand() < 0.15:  # Changed tunneling probability\n                    tunneling_strength = np.random.uniform(0.1, 1.2)  # Increased max tunneling strength\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Quantum-Inspired Particle Swarm Optimization with enhanced adaptive tunneling to avoid premature convergence.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "81c85db9-7a43-458d-9948-2eedccb26066", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                tunneling_prob = 0.1 + 0.1 * (self.global_best_value - particle.best_value) / abs(self.global_best_value)\n                if np.random.rand() < tunneling_prob:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with dynamic tunneling probability for improved local maxima avoidance.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "9cde14c7-65f9-4ba1-80c4-98f517a97124", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia = inertia\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced QuantumPSO with adaptive inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "e16fb22a-4c76-4247-b9a9-4548a4b29de0", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Dynamic tunneling probability with budget adaptation\n                tunneling_prob = 0.1 + 0.1 * (1 - eval_count / self.budget)\n                if np.random.rand() < tunneling_prob:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Tunneling Probability for improved escape from local optima.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "bcaf49e6-055e-410b-beef-0c815f747d3d", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Dynamic swarm size adjustment\n            if eval_count % (self.budget // 10) == 0:\n                self.swarm_size = max(10, self.swarm_size - 1)\n                self.particles = sorted(self.particles, key=lambda p: p.best_value)[:self.swarm_size]\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced QuantumPSO with dynamic swarm size adjustment based on exploration-exploitation balance for improved convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "325a0628-7a89-459a-b956-df3caadddfd8", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Enhanced Quantum tunneling: Improved adaptive jump to explore diverse regions\n                if np.random.rand() < 0.15: # Changed tunneling probability\n                    tunneling_strength = np.random.uniform(0.1, 1.5) # Adjusted tunneling strength range\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Improved Quantum-Inspired PSO with Enhanced Tunneling for effective exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "eb516ec2-9b2e-43a1-8e3d-f44bca1a2381", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.9 - 0.4) * (eval_count / self.budget)  # Dynamic inertia weight\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Inertia Weight for improved convergence and exploration balance.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "7d5452a8-f483-4fb9-aa3c-0f790f9e815c", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                tunneling_probability = 0.1 * (1 - eval_count / self.budget)\n                if np.random.rand() < tunneling_probability:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Accelerated Quantum Tunneling to improve exploration by dynamically adjusting tunneling frequency.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "89771921-1c71-4716-a4f0-6bb208d09432", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Dynamic Quantum tunneling probability\n                tunneling_prob = 0.1 + 0.4 * (eval_count / self.budget)\n                if np.random.rand() < tunneling_prob:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced QuantumPSO with a dynamic tunneling probability to improve exploration capabilities.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "9ae30d47-611b-4a43-a7fb-8243ba46ebd8", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Dynamic tunneling probability\n                dynamic_tunneling_prob = 0.1 + 0.2 * (eval_count / self.budget)\n                if np.random.rand() < dynamic_tunneling_prob:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with dynamic tunneling probability for improved escape from local optima.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "2065967c-22bc-445a-8eaf-bebe62877bbc", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Calculate swarm diversity\n            swarm_positions = np.array([p.position for p in self.particles])\n            diversity = np.std(swarm_positions, axis=0).mean()\n\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adapt tunneling probability with diversity\n                if np.random.rand() < min(1.0, 0.1 + diversity):\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with adaptive tunneling rate based on swarm diversity for improved exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "0016d26e-324d-4157-81d1-39272f03d1fe", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        gamma = 0.1  # New dynamic parameter\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = gamma * cognitive_component + (1 - gamma) * social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Parameters for improved convergence through adaptive velocity and position updates.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "5ae1984d-3a40-4720-8087-66bda4a3719d", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n\n                # Change made here: Introduce dynamic social component\n                self.beta = np.clip(self.beta + 0.1 - 0.2 * np.random.rand(), 0.4, 1.0)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Dynamic Social Influence for improved convergence in complex search spaces.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "4d143b4b-4f68-4b29-8c3b-96dd2ae22165", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n        self.inertia_weight = 0.9  # Initialize inertia weight\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic inertia weight\n                particle.velocity = self.inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Reduce inertia weight for improved convergence\n            self.inertia_weight *= 0.99\n            \n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with dynamic inertia weight adjustment for improved convergence in photonic structure optimization.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "5f5d0b9b-1280-4600-88c2-3ad2f9551fec", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                particle.velocity = cognitive_component + social_component\n\n                if np.random.rand() < (1 / (1 + np.exp(-fitness_value))):  # Stochastic tunneling\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Stochastic Tunneling to improve convergence in multimodal landscapes by refining quantum tunneling triggers.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "23a04f2c-9f3d-40dd-9960-26382aa97f6e", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.5, 1.5)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Tunneling and Enhanced Exploration for efficient global search in constrained high-dimensional spaces.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "ee02afdc-9f93-4915-ae9a-828978471971", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Enhanced jump to avoid local maxima\n                if np.random.rand() < 0.15:  # Increased probability for tunneling\n                    tunneling_strength = np.random.uniform(0.05, 0.5)  # Adjusted tunneling range\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Modified Quantum Particle Swarm Optimization with Enhanced Quantum Tunneling for improved exploration in high-dimensional spaces.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "3fc60a1a-92dc-4b97-9a70-bbf663906c63", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia_weight = 0.9  # Line 1: Introduce dynamic inertia weight\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia weight\n                particle.velocity = self.inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Line 2: Dynamically adjust inertia weight for exploration and exploitation\n            self.inertia_weight *= 0.98\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Tunneling and Dynamic Inertia Weight for improved convergence in high-dimensional search spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "9c13092b-4e2e-4a5b-8da0-6071ba7346ee", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Dynamic tunneling probability\n                tunneling_probability = 0.1 + (0.9 * eval_count / self.budget)\n                if np.random.rand() < tunneling_probability:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Tunneling Probability to balance exploration and exploitation more effectively.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "baf9641b-07a7-4b1d-a817-3267e43fc8f2", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Dynamic Velocity Scaling\n                velocity_scale = 0.5 * np.random.uniform(0.5, 1.5)\n                particle.velocity *= velocity_scale\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Dynamic Velocity Scaling for improved search efficiency and exploration in high-dimensional spaces.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "44d50852-4e57-422a-9ee3-f25427aeca2c", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                inertia_weight = np.random.uniform(0.5, 1.0)  # Added stochastic inertia weight\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Stochastic Inertia Weight for improved exploration and convergence control.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "122014c2-8504-455d-bd4e-fcb76978873d", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia_max=0.9, inertia_min=0.4):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia_max = inertia_max\n        self.inertia_min = inertia_min\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n                \n                # Dynamic inertia weight\n                inertia_weight = self.inertia_max - ((self.inertia_max - self.inertia_min) * (eval_count / self.budget))\n\n                # Quantum-inspired velocity update\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization using dynamic inertia weight to balance exploration-exploitation.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "7c1bc72b-e58f-45ca-83ad-6fbbd0fbfe6e", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia = inertia\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic inertia\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Inertia Adjustment for improved exploration and convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "bd64a44f-54be-4cd0-a8b4-130ea18a3c86", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Dynamic adjustment of alpha and beta\n                self.alpha = 0.5 + 0.4 * (1 - eval_count / self.budget)\n                self.beta = 0.9 - 0.4 * (1 - eval_count / self.budget)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Cognitive and Social Coefficients for improved adaptability and convergence.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "23fa0b8d-fd97-49fc-b0d1-25277b32c49b", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        last_global_best_value = float('inf')\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Adjust swarm size based on convergence rate\n            if (last_global_best_value - self.global_best_value) < 1e-5:\n                self.swarm_size = min(50, self.swarm_size + 1)  # Increase swarm size if convergence is slow\n            last_global_best_value = self.global_best_value\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Refined Hybrid Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Tunneling including dynamic swarm size adjustment based on convergence rate for improved exploration-exploitation balance.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "626faac5-7b13-470a-a3f6-377d5393c542", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n        self.inertia = 0.9  # Adaptive inertia weight\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n                self.inertia *= 0.99  # Adaptive inertia update\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Quantum Tunneling and Adaptive Inertia for improved convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "8afc8e9f-88bc-4ab5-8c5a-28f52f3c2aad", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        # Local search enhancement (optimized per budget constraints)\n        if self.global_best_value > 1e-5 and eval_count < self.budget:\n            local_search_steps = min(self.budget - eval_count, 5)\n            for _ in range(local_search_steps):\n                perturbed_position = self.global_best_position + np.random.uniform(-0.1, 0.1, self.dim)\n                perturbed_position = np.clip(perturbed_position, bounds.lb, bounds.ub)\n                fitness_value = func(perturbed_position)\n                eval_count += 1\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(perturbed_position)\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced QuantumPSO with Local Search Enhancement for Improved Convergence.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "65021bf9-7790-4303-ad0a-d8681e5e03f7", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.normal(0.5, 0.2)  # Changed from uniform to normal distribution\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Modified the initialization to handle keyword arguments and improved quantum tunneling by using a bell curve distribution for adaptive jumps.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "b2895254-02da-47f2-aebd-38b0a87135cc", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Dynamic swarm size adjustment\n            if eval_count % 10 == 0 and self.swarm_size < 50:\n                self.swarm_size += 1\n                self.particles.append(QuantumParticle(self.dim, bounds))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Hybrid Quantum-Inspired PSO with Adaptive Quantum Tunneling and Dynamic Swarm Size Adjustment for improved global optimization in constrained high-dimensional spaces.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "7691a779-1a91-4b27-8175-91bb7dd17b2f", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with adaptive scaling\n                adapt_scale = np.random.uniform(0.8, 1.2)\n                particle.velocity = adapt_scale * (cognitive_component + social_component)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced QuantumPSO with adaptive velocity scaling for improved convergence rates.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "4021fdb6-ef27-46f9-b3ab-42c3fffd4b3c", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        # Dynamic adjustment of beta for improved exploration-exploitation\n        self.beta = beta * (1 - np.exp(-0.1 * budget))  \n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Social Component for improved exploration-exploitation balance.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "d6c8f1e7-a7c0-451c-9b7b-bc3e2886727d", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, w=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.w = w\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic inertia weight\n                particle.velocity = self.w * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with Dynamic Inertia Weight for enhanced global search and exploration balance.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "c87f2fba-9f6b-48c0-8d16-a6325a2d7238", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Enhanced frequency adjustment\n                if np.random.rand() < 0.15:  # Adjusted tunneling probability\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with enhanced quantum tunneling frequency adjustment for robust global search.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "454492bd-d8f4-4ebb-86b1-56fc4e9aca76", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic inertia\n                inertia_weight = 0.9 - (0.5 * eval_count / self.budget)\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with a dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "076b7862-4b55-4f47-8a56-15d7f13d24df", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n                \n                # Dynamic velocity scaling\n                particle.velocity *= np.random.uniform(0.8, 1.2)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Dynamic Velocity Scaling for improved convergence in photonic structure optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "2bcb101c-0032-4e00-8199-9728939f4b61", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            fitness_values = []\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                fitness_values.append(fitness_value)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Calculate fitness variance for adaptive tunneling probability\n            fitness_variance = np.var(fitness_values)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Adaptive Quantum tunneling: Adjust tunneling probability based on fitness variance\n                tunneling_probability = min(0.1 + fitness_variance / 100.0, 0.2)\n                if np.random.rand() < tunneling_probability:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with adaptive tunneling probability based on fitness variance for improved global search.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "ce54a3e0-4594-4036-a449-098f28f0c279", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n        self.momentum = np.zeros(dim)  # Added momentum for enhanced velocity\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, gamma=0.1):  # Added gamma for momentum's influence\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.gamma = gamma  # Momentum influence\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with momentum\n                particle.momentum = self.gamma * particle.velocity  # Compute momentum\n                particle.velocity = cognitive_component + social_component + particle.momentum\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Tunneling by including momentum for improved search efficiency.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "89ef24dc-3053-473a-b9f1-356fa6a87869", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.6, beta=0.9):  # Change 1\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.15:  # Change 2\n                    tunneling_strength = np.random.uniform(0.1, 1.5)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with refined tunneling to improve exploration and convergence in complex photonic optimization landscapes.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "686cf8d4-d99c-4c62-adac-d7b7f2dacef1", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n        self.tunneling_probability = 0.1  # Self-adaptive tunneling probability\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Self-adaptive jump to avoid local maxima\n                if np.random.rand() < self.tunneling_probability:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Dynamically adjust the tunneling probability\n            self.tunneling_probability = max(0.05, self.tunneling_probability * 0.99)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Self-Adaptive Tunneling Probability for dynamic balance between exploration and exploitation.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "2f6e5d57-db3f-49a6-86a2-332cda130d2e", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic scaling\n                particle.velocity = (cognitive_component + social_component) * np.random.uniform(0.5, 1.5)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Dynamic Velocity Scaling for improved adaptability across diverse optimization landscapes.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "de5dd218-885f-46fa-8354-f30bda86ba9b", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 2.0)  # Increased upper limit\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with Stochastic Tunneling for better exploration in high-dimensional spaces.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "7ffde573-5a0c-4fec-b623-54ff9bd7a54f", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n        self.inertia_weight = 0.9  # Initial inertia weight\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic inertia weight\n                particle.velocity = self.inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Linearly decrease inertia weight\n            self.inertia_weight = 0.4 + 0.5 * (1 - eval_count / self.budget)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Inertia Weight for improved global exploration and convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "99e7f5c2-7bec-4e60-b4b5-6f1a20a42932", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, momentum=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.momentum = momentum\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with momentum\n                particle.velocity = self.momentum * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Momentum to accelerate convergence in complex high-dimensional search spaces.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "38d208c6-63fc-4879-b61d-6a16e94d926d", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to improve local escape\n                if np.random.rand() < 0.15:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Hybrid Quantum-Inspired PSO with Fine-Tuned Quantum Tunneling Rate for Robust Exploration.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "520e7504-89ef-41ff-97a5-e8e679210ec1", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump with enhanced strategy\n                if np.random.rand() < 0.15:\n                    tunneling_strength = np.random.uniform(0.1, 0.5)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Improved Quantum Tunneling for enhanced exploration in high-dimensional spaces.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "4f9b1634-7274-43ca-a21c-5ee9f7441c91", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(bounds.lb - bounds.ub, bounds.ub - bounds.lb, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive frequency to avoid local maxima\n                if np.random.rand() < (1 - self.global_best_value / float('inf')) * 0.2:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Improved Quantum PSO with adaptive tunneling frequency and dynamic velocity range for enhanced convergence.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "f00fbce5-b296-420b-912a-0b0fe4d33b08", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                \n                inertia_weight = 0.5 + 0.5 * (self.budget - eval_count) / self.budget  # Dynamic inertia\n                \n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Dynamic Inertia for improved convergence control in high-dimensional spaces.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "3004e50c-295a-4782-95db-4d3b9f6e32aa", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n        self.inertia = 0.9  # Add inertia parameter\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Inertia for improved convergence by modifying inertia dynamically.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "b18e8acc-f18e-4fb7-b888-8cb34a7cf763", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia = inertia\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Dynamic Inertia Weight for improved exploration-exploitation balance.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "01d1f775-15d9-4e5f-99c9-372e19c5d954", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim) * (1 - 0.1 * (eval_count / self.budget))\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            # Adjust swarm size dynamically for exploration\n            if eval_count % (self.budget // 10) == 0:\n                self.swarm_size = max(5, self.swarm_size - 1)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Hybrid Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Tunneling and Dynamic Swarm Adaptation for robust global search.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "0b83a244-6af0-42e1-bac9-f252e7c91606", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia = 0.9  # Introduced inertia weight\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with adaptive inertia for improved exploration-exploitation balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "9f1b3604-4b97-4d0e-92f4-54ed331f7a23", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with stochastic scaling\n                scaling_factor = np.random.uniform(0.5, 1.5)\n                particle.velocity = scaling_factor * (cognitive_component + social_component)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Stochastic Velocity Scaling for improved global and local search balance.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "340012b0-9810-40a2-9341-a6e5513bea97", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic scaling\n                velocity_scale = 0.9 - (0.5 * eval_count / self.budget)\n                particle.velocity = velocity_scale * (cognitive_component + social_component)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with Dynamic Velocity Scaling for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "f15ce109-36cd-441c-8f43-6c2f27472f8c", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia = inertia  # Added inertia for velocity\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with inertia\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum Particle Swarm Optimization with Adaptive Quantum Tunneling using dynamic velocity inertia for improved convergence.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "c95396d9-0f90-4e4f-9627-611e853674aa", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, gamma=0.1):  # Added gamma parameter\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.gamma = gamma  # Initialize gamma\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)  # Added r3\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component + self.gamma * r3  # Included stochastic component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with Stochastic Component for improved exploration and exploitation balance.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "db4ae26b-1c4d-4d17-a484-ddbd7ba1fe15", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update with dynamic scaling\n                particle.velocity = 0.9 * (cognitive_component + social_component)  # Updated line\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Refined Quantum PSO with Dynamic Velocity Scaling for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "c742cf77-ac51-4f83-9e35-72dc186984f0", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = (cognitive_component + social_component) * np.cos(0.1 * eval_count)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired PSO with Adaptive Quantum Tunneling for improved global search by incorporating oscillatory velocity damping.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "4c860063-0211-4a62-9f6a-bac4d09ed1c3", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump based on fitness trend\n                if np.random.rand() < 0.1 and fitness_value > self.global_best_value:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum PSO with Selective Tunneling and Dynamic Social Influence for optimized photonic structure search.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "2e7571ea-fc4f-4e02-94e2-12511c97d3ec", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = cognitive_component + social_component\n\n                # Adaptive velocity reset to enhance exploration\n                if np.random.rand() < 0.05:\n                    particle.velocity = np.random.uniform(-1, 1, self.dim)\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Hybrid Quantum PSO with Adaptive Velocity Reset for improved exploration and global search.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "f09d2e05-21bf-4e60-b648-b2e4396aa67f", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n        inertia_weight = 0.9  # Introduced dynamic inertia weight\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Dynamic inertia weight adjustment\n                inertia_weight = 0.9 - (0.5 * eval_count / self.budget)\n\n                particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component\n\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Quantum-Inspired Particle Swarm Optimization with Dynamic Inertia to enhance exploration-exploitation balance.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
{"id": "f8bb8c74-1e9e-4dc3-929b-fdf53011c9ad", "solution": "import numpy as np\n\nclass QuantumParticle:\n    def __init__(self, dim, bounds):\n        self.position = np.random.uniform(bounds.lb, bounds.ub, dim)\n        self.velocity = np.random.uniform(-1, 1, dim)\n        self.best_position = np.copy(self.position)\n        self.best_value = float('inf')\n\nclass QuantumPSO:\n    def __init__(self, budget, dim, swarm_size=30, alpha=0.5, beta=0.9, inertia=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.inertia = inertia\n        self.particles = []\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        # Initialize particles\n        bounds = func.bounds\n        self.particles = [QuantumParticle(self.dim, bounds) for _ in range(self.swarm_size)]\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for particle in self.particles:\n                # Evaluate the fitness function\n                fitness_value = func(particle.position)\n                eval_count += 1\n\n                # Update personal best\n                if fitness_value < particle.best_value:\n                    particle.best_value = fitness_value\n                    particle.best_position = np.copy(particle.position)\n\n                # Update global best\n                if fitness_value < self.global_best_value:\n                    self.global_best_value = fitness_value\n                    self.global_best_position = np.copy(particle.position)\n\n            # Update particle positions and velocities\n            for particle in self.particles:\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.alpha * r1 * (particle.best_position - particle.position)\n                social_component = self.beta * r2 * (self.global_best_position - particle.position)\n\n                # Quantum-inspired velocity update\n                particle.velocity = self.inertia * particle.velocity + cognitive_component + social_component\n\n                # Quantum tunneling: Adaptive jump to avoid local maxima\n                if np.random.rand() < 0.1:\n                    tunneling_strength = np.random.uniform(0.1, 1.0)\n                    particle.position += tunneling_strength * np.random.uniform(bounds.lb, bounds.ub, self.dim)\n                else:\n                    particle.position += particle.velocity\n\n                # Ensure position stays within bounds\n                particle.position = np.clip(particle.position, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.global_best_position", "name": "QuantumParticle", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with Dynamic Inertia for improved exploration-exploitation balance in complex search spaces.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\").", "error": "TypeError(\"QuantumParticle.__init__() got an unexpected keyword argument 'budget'\")", "parent_id": "ff733f98-e3a4-406e-9c26-263783dc5d08", "metadata": {}, "mutation_prompt": null}
