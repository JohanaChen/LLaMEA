{"id": "6fd50d6e-0224-47bc-8068-4135e94222f5", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Rule of thumb\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three random indices different from i\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Perform mutation and crossover\n                mutant_vector = self.mutate(a, b, c, bounds)\n                trial_vector = self.crossover(population[i], mutant_vector)\n                \n                # Evaluate the trial vector\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                # Selection process\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def mutate(self, a, b, c, bounds):\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Hybrid Differential Evolution with Local Search using Self-Adaptive Scaling and Crossover for efficient exploration and exploitation balance.", "configspace": "", "generation": 0, "fitness": 0.28072987023235285, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.28072987023235285]}, "mutation_prompt": null}
{"id": "b8933e20-c6f1-4dd5-8f0f-bb4fc51870dd", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 8 * dim  # Reduced initial population size\n        self.population_size = self.base_population_size\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 5) == 0:\n                self.mutation_factor = 0.3 + 0.7 * np.random.rand()  # Dynamic scaling factor\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.mutate(a, b, c, bounds)\n                trial_vector = self.crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if self.evaluations % (self.budget // 3) == 0:\n                    self.population_size = min(self.base_population_size * 2, self.population_size + self.base_population_size // 2)\n                    population = np.vstack([population, np.random.rand(self.base_population_size // 2, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]])\n                    fitness = np.hstack([fitness, np.array([func(ind) for ind in population[-(self.base_population_size // 2):]])])\n                    self.evaluations += self.base_population_size // 2\n\n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def mutate(self, a, b, c, bounds):\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Scaling to improve convergence speed and solution quality.", "configspace": "", "generation": 1, "fitness": 0.27794256247024185, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "6fd50d6e-0224-47bc-8068-4135e94222f5", "metadata": {"aucs": [0.27794256247024185]}, "mutation_prompt": null}
{"id": "15434681-a589-47fe-b097-f25093eb2adb", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Rule of thumb\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic adaptation of the mutation factor based on evaluations\n                self.mutation_factor = 0.8 - 0.3 * (self.evaluations / self.budget)\n                # Select three random indices different from i\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Perform mutation and crossover\n                mutant_vector = self.mutate(a, b, c, bounds)\n                trial_vector = self.crossover(population[i], mutant_vector)\n                \n                # Evaluate the trial vector\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                # Selection process\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                else:\n                    # Local search around the best known solution\n                    local_search_vector = population[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_vector = np.clip(local_search_vector, bounds[:, 0], bounds[:, 1])\n                    local_fitness = func(local_search_vector)\n                    self.evaluations += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_search_vector\n                        fitness[i] = local_fitness\n                \n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def mutate(self, a, b, c, bounds):\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Hybrid Differential Evolution with Dynamic Local Search by incorporating adaptive component exploitation for enhanced convergence.", "configspace": "", "generation": 2, "fitness": 0.27747484543647505, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "6fd50d6e-0224-47bc-8068-4135e94222f5", "metadata": {"aucs": [0.27747484543647505]}, "mutation_prompt": null}
{"id": "08be8d25-7edc-443f-abd8-c81202bcc8dd", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Rule of thumb\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three random indices different from i\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Perform mutation and crossover\n                self.mutation_factor = 0.2 + (0.8 * (self.evaluations / self.budget))  # Adaptive mutation factor\n                mutant_vector = self.mutate(a, b, c, bounds)\n                trial_vector = self.crossover(population[i], mutant_vector)\n                \n                # Evaluate the trial vector\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                # Selection process\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def mutate(self, a, b, c, bounds):\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced Hybrid Differential Evolution with Adaptive Mutation Factor for Improved Exploration and Convergence.", "configspace": "", "generation": 3, "fitness": 0.2788533422649918, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "6fd50d6e-0224-47bc-8068-4135e94222f5", "metadata": {"aucs": [0.2788533422649918]}, "mutation_prompt": null}
{"id": "4246297a-6f83-4453-87d9-d138edee2fc0", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.9)  # Adaptive mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Hybrid Differential Evolution with Adaptive Parameters and Local Search to dynamically adjust strategies for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.28195891730230493, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "6fd50d6e-0224-47bc-8068-4135e94222f5", "metadata": {"aucs": [0.28195891730230493]}, "mutation_prompt": null}
{"id": "49465b93-788a-4460-b18c-16df8e187de0", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.9)  # Adaptive mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.85, 1.0)  # Fine-tuned adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced HybridDESA by fine-tuning the adaptive crossover probability range for better exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.28195891730230493, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4246297a-6f83-4453-87d9-d138edee2fc0", "metadata": {"aucs": [0.28195891730230493]}, "mutation_prompt": null}
{"id": "67fc08fc-8c95-4b18-9e73-0a2e6d216f01", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.9)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved exploration by adjusting adaptive mutation factor range for better global search.", "configspace": "", "generation": 6, "fitness": 0.28235778587191007, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "4246297a-6f83-4453-87d9-d138edee2fc0", "metadata": {"aucs": [0.28235778587191007]}, "mutation_prompt": null}
{"id": "e87568e2-4c69-4dca-ae80-46fda3b67a31", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.1, 0.9)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced diversity by widening the adaptive mutation factor range for improved exploration.", "configspace": "", "generation": 7, "fitness": 0.2816105084996302, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "67fc08fc-8c95-4b18-9e73-0a2e6d216f01", "metadata": {"aucs": [0.2816105084996302]}, "mutation_prompt": null}
{"id": "1b2e122a-2b1b-4349-904a-c8bd0c25bfad", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.8)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tuned mutation factor upper bound for enhanced convergence.", "configspace": "", "generation": 8, "fitness": 0.28220052518256544, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "67fc08fc-8c95-4b18-9e73-0a2e6d216f01", "metadata": {"aucs": [0.28220052518256544]}, "mutation_prompt": null}
{"id": "57ce044e-2bc6-4442-ac34-b0d2982b5dfb", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(np.random.uniform(0.3, 0.6), 0.9)  # Change: added randomization to adaptation factor range\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced mutation diversity by randomizing the adaptation factor range for better global search.", "configspace": "", "generation": 9, "fitness": 0.28073876847156454, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "67fc08fc-8c95-4b18-9e73-0a2e6d216f01", "metadata": {"aucs": [0.28073876847156454]}, "mutation_prompt": null}
{"id": "292a147c-607c-41d9-bff9-d5cc3ec11e80", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds) \n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.9)\n        chaos_factor = self.chaotic_sequence()  # New line for chaotic sequence\n        mutant = a + adapt_factor * (b - c) + chaos_factor * (bounds[:, 1] - bounds[:, 0]) * 0.1  # Modified line\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def chaotic_sequence(self):  # New function for chaotic sequence generation\n        return np.sin(np.pi * np.random.rand(self.dim))", "name": "HybridDESA", "description": "Enhanced diversity by integrating differential evolution with chaotic sequences for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.27959200921635396, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "67fc08fc-8c95-4b18-9e73-0a2e6d216f01", "metadata": {"aucs": [0.27959200921635396]}, "mutation_prompt": null}
{"id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced mutation by slightly increasing adapt_factor's variability for better diversity.", "configspace": "", "generation": 11, "fitness": 0.2835233634760719, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "67fc08fc-8c95-4b18-9e73-0a2e6d216f01", "metadata": {"aucs": [0.2835233634760719]}, "mutation_prompt": null}
{"id": "71753383-3d67-486f-9df1-723a703176ec", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.99)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced mutation further with dynamic adapt_factor initialization for improved exploration.", "configspace": "", "generation": 12, "fitness": 0.2824062150773844, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2824062150773844]}, "mutation_prompt": null}
{"id": "a7b3ff62-ab1a-481a-9c9d-269cace48d40", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 11 * dim  # Increased from 10 to 11 for improved exploration\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increased population size for enhanced exploration.", "configspace": "", "generation": 13, "fitness": 0.27903315474152834, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27903315474152834]}, "mutation_prompt": null}
{"id": "79e2c86f-cb6d-4dba-a003-a95cfcf1ac26", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Further adapt mutation factor variability by extending its range for increased exploration capabilities.", "configspace": "", "generation": 14, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "a44ccd4f-f8f5-41f3-a919-bddb4e6fe643", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.85, 1.0)  # Adjusted the adaptive crossover probability range\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly adjust the adaptive crossover probability range for better exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "3e3a0945-c71e-472b-a069-88636cfeaf21", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Changed population size from 10 * dim to 12 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increased the population size to improve diversity and potential exploration.", "configspace": "", "generation": 16, "fitness": 0.278849606988114, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.278849606988114]}, "mutation_prompt": null}
{"id": "5a955b7d-2754-458a-80ef-0bb463cec37b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved diversity through increased variability in adaptive mutation factor.", "configspace": "", "generation": 17, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "e8bd28de-2c80-4f3f-9023-8c52d2b95816", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the variability of the mutation factor's lower bound for enhanced diversity.", "configspace": "", "generation": 18, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "0707ed39-4293-4249-a626-76a477cc9459", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the range of mutation factor for better exploration\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced diversity by expanding adaptive mutation factor's range for improved exploration.", "configspace": "", "generation": 19, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "62462c3d-379f-4306-a1af-6bbaa94847bf", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10.2 * dim)  # Increased the population size by 2%\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the population size to improve diversity and exploit a larger search space.", "configspace": "", "generation": 20, "fitness": 0.27701523904853353, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27701523904853353]}, "mutation_prompt": null}
{"id": "7c320e67-713a-458b-9df3-5a4455c6a04d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Fine-tuned lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tuned adapt_factor's lower bound for enhanced exploration.", "configspace": "", "generation": 21, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "e1f3418b-62f6-4797-a146-55a3c0151487", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adjusted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Further diversifying the mutation strategy by adjusting the lower bound of the adapt_factor.", "configspace": "", "generation": 22, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "72b05825-8397-4705-8a64-0ed4506c4c2d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.28, 0.95)  # Slightly decreased the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the adaptive mutation factor's variability for enhanced exploration.", "configspace": "", "generation": 23, "fitness": 0.2823577249819128, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823577249819128]}, "mutation_prompt": null}
{"id": "c3f984d9-b431-4a83-923a-34dbdf6201d5", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.7, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced diversity through broader adaptive crossover probability for improved exploration.", "configspace": "", "generation": 24, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "0d00aa57-f13b-469c-9b7d-2464a09a87d7", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Refined adaptive mutation strategy by tweaking adapt_factor's lower variability for improved exploration.", "configspace": "", "generation": 25, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "7f208e12-d8c1-4cfe-9c14-14b9aa89a20a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Increased lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Increased lower bound of mutation factor for improved exploration.", "configspace": "", "generation": 26, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "3077428e-e580-4106-bc5e-42709b209f09", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.1, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Further diversified adaptive mutation enhances exploration by extending adapt_factor's lower bound.", "configspace": "", "generation": 27, "fitness": 0.280760955200971, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.280760955200971]}, "mutation_prompt": null}
{"id": "bb87554d-f40d-4c09-af34-1426e184b6b4", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.7, 1.0)  # Increased variability of the adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved convergence by increasing the crossover probability variability for better exploration.", "configspace": "", "generation": 28, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "8229b545-73cf-4dc6-bf66-8197c5ab38fa", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Further refine diversity by expanding the adaptive mutation factor's variability range.", "configspace": "", "generation": 29, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "d0c4ad4a-b985-4445-9463-c878f46b2dde", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Increased the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved adaptive mutation by gently increasing the lower bound of adapt_factor for potentially better exploration.", "configspace": "", "generation": 30, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "a5b84689-a53c-43a1-b300-48992ec6833c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Refine adaptive mutation range to improve diversity and convergence.", "configspace": "", "generation": 31, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "dd186eca-3779-4f7a-a0d3-06f87261d220", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 11 * dim  # Changed population size\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the population size to enhance exploration capabilities.", "configspace": "", "generation": 32, "fitness": 0.27903315474152834, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27903315474152834]}, "mutation_prompt": null}
{"id": "d5339d2d-b9f7-490e-8f18-b023ad4defae", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved diversity by slightly increasing the variability in adapt_factor's lower bound for mutation.", "configspace": "", "generation": 33, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "049a9f73-b868-4e19-9c4c-1110811cc399", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95) + np.random.normal(0, 0.01)  # Introduced small perturbation\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduced small random perturbations to the mutation factor for enhanced exploration.", "configspace": "", "generation": 34, "fitness": 0.27875853601891, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27875853601891]}, "mutation_prompt": null}
{"id": "a2120dc0-66dd-4eb8-b941-852471434001", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the mutation factor range lower bound to enhance exploration.", "configspace": "", "generation": 35, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "01bc2042-5f97-4ae2-8ae4-64a8753f63ba", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.75, 1.0)  # Slightly increased the variability in crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the crossover probability's variability to enhance exploration.", "configspace": "", "generation": 36, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "f8347d73-1e66-4e52-96be-6ef53596af03", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced diversity by introducing slight variability in mutation by tweaking the adaptation range.", "configspace": "", "generation": 37, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "6d0cca0c-cde4-4285-beaf-af8b1b411daf", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Increase the variability of the adaptive mutation factor to improve exploration capabilities.", "configspace": "", "generation": 38, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "c9b5a340-e842-4fe0-80b2-efc8892d4f2e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.5, 0.95)  # Changed lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced convergence by slightly increasing the lower bound of adapt_factor's variability for mutation.", "configspace": "", "generation": 39, "fitness": 0.28351455346459165, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28351455346459165]}, "mutation_prompt": null}
{"id": "8cc2e509-f73a-4216-92dd-0b1f852bc8f0", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Refined mutation factor range for better exploration in adaptive mutation.", "configspace": "", "generation": 40, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "04feda52-0573-41e4-8b95-a02bbfe53368", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved diversity by slightly increasing the range of the adaptive mutation factor.", "configspace": "", "generation": 41, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "07271837-f519-44e8-8101-fa9fdbbfdd40", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 1.0)  # Slightly increased the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the upper bound of the adaptation factor for mutation to enhance diversity further.", "configspace": "", "generation": 42, "fitness": 0.2823920441995881, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823920441995881]}, "mutation_prompt": null}
{"id": "497ef458-9d97-44b7-96ee-b5d279751f6b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adjusted lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "To enhance diversity, adjust the lower bound of the adaptive mutation factor.", "configspace": "", "generation": 43, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "46b51fd3-6c05-4f91-a422-aad189b3e6a7", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.85, 1.0)  # Slightly increased the lower bound of crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the crossover probability's adaptability range for better exploration.", "configspace": "", "generation": 44, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "a34ab27e-2274-4e6e-bb90-b81e909d8b2d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved diversity by using a wider range for adaptive mutation.", "configspace": "", "generation": 45, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "4df6505c-cc83-43c3-bc52-72902f4f8698", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly reduce the lower bound of the adaptive mutation factor to enhance exploration.", "configspace": "", "generation": 46, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "6882eb52-c89b-4bcb-84ac-bbf5663e8726", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.85, 1.0)  # Fine-tuned adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tune adaptation by slightly adjusting the adaptive crossover probability range for improved exploration.", "configspace": "", "generation": 47, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "4da420d1-d87e-4d0d-9715-53ba6f9db87c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.75, 1.0)  # Adaptive crossover probability with slightly increased range\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tune crossover adaptation by slightly increasing the variability of adapt_prob for better exploration.", "configspace": "", "generation": 48, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "57affe49-8c20-4013-b4ab-ff8a756dc41c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Adjusted adaptive mutation range for improved diversity and exploration.", "configspace": "", "generation": 49, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "54e6083e-dc4b-4130-9797-738f116a2896", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tune the mutation adapt_factor to range from 0.35 to 0.95 for improved balance between exploration and exploitation.", "configspace": "", "generation": 50, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "d90aef34-8984-4bc5-b416-0e852da3a49b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Changed lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tune the mutation factor's lower bound to enhance exploration.", "configspace": "", "generation": 51, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "65b531fb-453c-4ada-b53b-b0fd6ca4a9d6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adjusted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly adjust the lower bound of adapt_factor to improve exploration.", "configspace": "", "generation": 52, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "c24fe7cb-2f04-404b-b5ac-89b1fdac5896", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 11 * dim  # Increased from 10 to 11 per dimension\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if self.evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved exploration by increasing the population size slightly to enhance diversity without compromising convergence.", "configspace": "", "generation": 53, "fitness": 0.27903315474152834, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27903315474152834]}, "mutation_prompt": null}
{"id": "dbc26ba3-7959-4499-8772-128a9b8d4679", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 1.0)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Further enhance adaptation by extending mutation factor variability for improved exploration.", "configspace": "", "generation": 54, "fitness": 0.2823920441995881, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823920441995881]}, "mutation_prompt": null}
{"id": "d7b876a9-7ed6-40c5-b322-edbddcc8b2a6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced mutation by further adjusting adapt_factor's variability for even better diversity.", "configspace": "", "generation": 55, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "fbae1915-1a62-4ae5-a779-445f782ad062", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.9, 1.0)  # Slightly increased lower bound of crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increased crossover probability range to enhance exploration in adaptation process.", "configspace": "", "generation": 56, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "d65661d5-e123-4bdc-a2db-c31e8e1ca656", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved mutation adaptability by increasing the lower bound of adapt_factor for more robust exploration.", "configspace": "", "generation": 57, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "8c1e5e26-9a3d-4669-8ddc-30c7d3a5103f", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adjusted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved convergence by slightly adjusting the mutation factor's lower bound for better solution exploration.", "configspace": "", "generation": 58, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "4b620a18-073f-48a5-922a-a912b0b76516", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Decreased the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly decrease the lower bound of the mutation factor to enhance diversity.", "configspace": "", "generation": 59, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "dee2aeba-f383-4c54-a24f-1bd4d3caace3", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the population size for better exploration and diversity.", "configspace": "", "generation": 60, "fitness": 0.278849606988114, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.278849606988114]}, "mutation_prompt": null}
{"id": "a79cefce-8289-4a0c-b9e0-64613141c6b3", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Increased the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increased the lower bound of `adapt_factor` in mutation for improved exploration.", "configspace": "", "generation": 61, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "9a310589-575f-4378-8f33-c222b0c0ef8c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced mutation by slightly increasing adapt_factor's variability for better diversity and improved exploration.", "configspace": "", "generation": 62, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "86a89181-c4aa-4771-a5e7-0fe9f0866304", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 1.0)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved diversity by increasing variability of `adapt_factor` in the `adaptive_mutate` method.", "configspace": "", "generation": 63, "fitness": 0.2823920441995881, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823920441995881]}, "mutation_prompt": null}
{"id": "d9345f4c-e128-472f-915e-2dc79824324d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(12 * dim)  # Increased population size for better exploration\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduce dynamic adjustment of population size by slightly increasing it for enhanced exploration.", "configspace": "", "generation": 64, "fitness": 0.278849606988114, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.278849606988114]}, "mutation_prompt": null}
{"id": "b28e7fd5-3b3f-4de8-815d-dad1eb582adc", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced diversity by increasing the lower bound of the mutation factor.", "configspace": "", "generation": 65, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "60f62223-cf98-4581-adda-4ecdb608c08d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adjusted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced diversity by adjusting the mutation factor's lower bound to improve exploration.", "configspace": "", "generation": 66, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "56f9c849-2676-486f-b75a-5e67821c2b4e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Slightly increased lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the mutation factor range to enhance exploration capability.", "configspace": "", "generation": 67, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "836e0e2e-33d9-4aff-b6e4-b8ce10a1f57b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            current_pop_size = int(self.population_size * (1 - self.evaluations / self.budget)) + 1  # Adjust population size\n            for i in range(min(self.population_size, current_pop_size)):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduce a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 68, "fitness": 0.28282954870918375, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28282954870918375]}, "mutation_prompt": null}
{"id": "70bdb94a-3946-4c28-9163-cc473694bb3a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved the range of the adaptive mutation factor to enhance exploration and convergence.", "configspace": "", "generation": 69, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "4c3a9254-da15-4343-bb65-698e7ba1a13c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Refined the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Refined adaptive mutation factor range to enhance search space exploration.", "configspace": "", "generation": 70, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "0bd36a98-c2fd-4955-a500-2dccc91af79c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adaptation: slightly widened mutation factor range\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduced slight variability in the adapt_factor range to enhance diversity in mutation.", "configspace": "", "generation": 71, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "c70b0ab1-cfc1-4f80-996d-4882b4366e90", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.99)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved exploration by expanding the mutation factor range for better search dynamics.", "configspace": "", "generation": 72, "fitness": 0.2824062150773844, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2824062150773844]}, "mutation_prompt": null}
{"id": "2e06f086-6422-45f7-bc73-f656bdf4d2ed", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Adapted the lower bound of mutation factor to improve exploration\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved adaptive mutation by slightly increasing adapt_factor's variability to better explore search space.", "configspace": "", "generation": 73, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "6387f453-e7da-42be-a67d-c3161493c677", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 1.0)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increased the adaptive mutation factor's variability to promote exploration.", "configspace": "", "generation": 74, "fitness": 0.2823920441995881, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823920441995881]}, "mutation_prompt": null}
{"id": "e69139be-7e97-4e67-90e0-8991ddc65a32", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                # Introducing elitism\n                if trial_fitness < np.min(fitness):\n                    best_individual = trial_vector\n                    best_fitness = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved selection mechanism by introducing elitism to preserve best solutions.", "configspace": "", "generation": 75, "fitness": 0.2835233634760719, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2835233634760719]}, "mutation_prompt": null}
{"id": "d50800bb-830a-4cbf-821b-c7cc94ebd440", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95 - 0.4 * (self.evaluations / self.budget))  # Dynamic mutation range\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduce a dynamic mutation factor range to adjust exploration and exploitation over iterations.", "configspace": "", "generation": 76, "fitness": 0.2825014158471394, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2825014158471394]}, "mutation_prompt": null}
{"id": "58d0fe42-53ad-4ab7-b854-6c5885e3c00a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95) + np.random.normal(0, 0.01)  # Added stochastic perturbation\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduced a small stochastic perturbation in the adaptation factor for increased exploration.", "configspace": "", "generation": 77, "fitness": 0.27875853601891, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27875853601891]}, "mutation_prompt": null}
{"id": "6877fb43-8a79-40da-b0b4-365a3eb712da", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adjusted lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced diversity with dynamic mutation factor range adjustment.", "configspace": "", "generation": 78, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "ff76aa44-b791-4a45-a378-5eb00581af1d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the population size to enhance exploration capabilities.", "configspace": "", "generation": 79, "fitness": 0.278849606988114, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.278849606988114]}, "mutation_prompt": null}
{"id": "8d017230-1256-4073-8d34-ccaa38b700fa", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.2, 0.95)  # Fine-tuned mutation factor range\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Further enhance exploration by expanding the adaptive mutation factor's range to improve diversity.", "configspace": "", "generation": 80, "fitness": 0.28186725432338133, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28186725432338133]}, "mutation_prompt": null}
{"id": "30f3f07a-2cfb-4b30-b791-573b006e8c88", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, np.random.uniform(0.8, 0.95))  # Adjusted adaptation factor range with randomness\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduced randomness in adaptation factors to slightly enhance population diversity and exploration.", "configspace": "", "generation": 81, "fitness": 0.27857828927000405, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27857828927000405]}, "mutation_prompt": null}
{"id": "8217ca98-dad6-4244-8d26-3f0b30e9bd5b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Dynamic adaptation based on evaluations\n                adapt_factor = 0.3 + 0.65 * (self.evaluations / self.budget)  \n                mutant_vector = self.adaptive_mutate(a, b, c, bounds, adapt_factor)  # Update to use dynamic adapt_factor\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds, adapt_factor):\n        mutant = a + adapt_factor * (b - c)  # Now uses dynamic adapt_factor\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduce a dynamic adaptation strategy for mutation and crossover to enhance exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.2780585834694964, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2780585834694964]}, "mutation_prompt": null}
{"id": "5fb61100-e5c4-4ac7-afc7-d0896cc7f59d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Improved mutation range variability for enhanced exploration and diversity.", "configspace": "", "generation": 83, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "07399655-a28e-4dc5-8c71-67a7293e6e4b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Slightly changed lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly broadened mutation factor range for increased population diversity.", "configspace": "", "generation": 84, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "a17f4251-e0b5-4d28-aaea-a585d208fe09", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Adjusted adaptive mutation factor range for improved convergence balance.", "configspace": "", "generation": 85, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "6bb66e34-f708-46ab-abf4-e061bb7cfff6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.99)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Adjusted the mutation factor to enhance the exploration capability of the algorithm within the confines of a strict change limit.", "configspace": "", "generation": 86, "fitness": 0.2824062150773844, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2824062150773844]}, "mutation_prompt": null}
{"id": "aea9d08a-39f4-426b-94dd-b66deeceff6e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10*dim to 12*dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhance exploration by increasing the population size slightly.", "configspace": "", "generation": 87, "fitness": 0.278849606988114, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.278849606988114]}, "mutation_prompt": null}
{"id": "161b8ba1-08b7-49ed-ae7c-6ecbb06e2056", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adjusted lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly adjust the mutation factor's lower bound to enhance exploration capability.", "configspace": "", "generation": 88, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "8a48d7d0-0d10-43ef-9ab7-40e04b4760eb", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly adjust the mutation factor's lower bound to enhance exploration.", "configspace": "", "generation": 89, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
{"id": "75420d20-67ab-4891-948e-4e063d6c5fb9", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.95  # Adjusted initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly adjust the initial crossover probability for more exploration.", "configspace": "", "generation": 90, "fitness": 0.2835233634760719, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2835233634760719]}, "mutation_prompt": null}
{"id": "a282568a-c018-47c3-a022-35326b63dbff", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.7, 1.0)  # Slight change here to improve exploration\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Refined adaptive crossover to enhance exploration capabilities.", "configspace": "", "generation": 91, "fitness": 0.2823679217118822, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2823679217118822]}, "mutation_prompt": null}
{"id": "7b0e8c30-6fd2-4ecd-9be5-3b299994a297", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Changed lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly adjusted mutation factor's lower bound for improved exploitation.", "configspace": "", "generation": 92, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "cf69202b-075d-4a62-a697-60ac5959dfe0", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Narrowed the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tuned the adaptive mutation factor for better convergence by slightly narrowing its range.", "configspace": "", "generation": 93, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "70ce3e34-cad5-45a8-872a-67d066f4df59", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Enhanced mutation by adjusting the adaptation factor's lower limit for improved exploration.", "configspace": "", "generation": 94, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "32c9e9eb-8d47-42db-86bb-cc7010395b64", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.4, 0.95)  # Fine-tuned range of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Fine-tuned the adaptation range of the mutation factor for enhanced exploration.", "configspace": "", "generation": 95, "fitness": 0.28175327224549584, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28175327224549584]}, "mutation_prompt": null}
{"id": "a2c0974a-437f-4c95-960c-d717bbe92424", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 11 * dim  # Changed population size\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.3, 0.95)\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase the population size to enhance exploration and diversity.", "configspace": "", "generation": 96, "fitness": 0.27903315474152834, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.27903315474152834]}, "mutation_prompt": null}
{"id": "ffd03a39-d0dd-4355-9467-0afea2465534", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        diversity = np.std(population, axis=0).mean()  # New line: calculate diversity\n        adapt_factor = np.random.uniform(0.3, 0.95) * (1 + diversity)  # Adapted the upper bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Introduced adaptive scaling of the mutation factor based on the diversity of the population to enhance exploration.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {}, "mutation_prompt": null}
{"id": "069fa789-809a-4eb6-a74c-bae027936cb2", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.35, 0.95)  # Increased lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly increase mutation's adaptability to enhance exploration.", "configspace": "", "generation": 98, "fitness": 0.28219384611541687, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.28219384611541687]}, "mutation_prompt": null}
{"id": "0020697d-1ba7-43eb-a6ad-79ae1e9f817e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = self.adaptive_mutate(a, b, c, bounds)  # Changed mutation method\n                trial_vector = self.adaptive_crossover(population[i], mutant_vector)  # Changed crossover method\n                \n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    \n                if self.evaluations >= self.budget:\n                    break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n    def adaptive_mutate(self, a, b, c, bounds):\n        adapt_factor = np.random.uniform(0.25, 0.95)  # Adapted the lower bound of mutation factor\n        mutant = a + adapt_factor * (b - c)\n        return np.clip(mutant, bounds[:, 0], bounds[:, 1])\n\n    def adaptive_crossover(self, target, mutant):\n        adapt_prob = np.random.uniform(0.8, 1.0)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < adapt_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial", "name": "HybridDESA", "description": "Slightly adjust the mutation factor's lower bound for improved exploration.", "configspace": "", "generation": 99, "fitness": 0.2822562431227156, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2bc2a964-0e9c-4479-9184-8b32c6f0f6c6", "metadata": {"aucs": [0.2822562431227156]}, "mutation_prompt": null}
