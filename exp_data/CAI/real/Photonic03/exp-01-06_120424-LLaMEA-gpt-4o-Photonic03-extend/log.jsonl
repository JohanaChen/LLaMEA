{"id": "895d61ee-086e-4a21-9156-bc9a48f204da", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities\n            positions = np.clip(positions, lb, ub)\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) leveraging quantum superposition principles for enhanced exploration and exploitation in black-box optimizations.", "configspace": "", "generation": 0, "fitness": 0.13407752313112728, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.13349777137371366, 0.13358026115229604, 0.1351545368673721]}, "mutation_prompt": null}
{"id": "3078e715-da01-49d1-ba33-43c0793dfb9e", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            self.w = 0.9 - 0.5 * (evals / self.budget)  # Dynamic inertia weight adjustment\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities\n            positions = np.clip(positions, lb, ub)\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization (QIPSO) with dynamic inertia weight adjustment for improved convergence.", "configspace": "", "generation": 1, "fitness": 0.1325602456206858, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "895d61ee-086e-4a21-9156-bc9a48f204da", "metadata": {"aucs": [0.1320134860047495, 0.1322726608444006, 0.13339459001290732]}, "mutation_prompt": null}
{"id": "dd58d0bf-9894-4dc5-81ae-a7eb2bb17b1e", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) with adaptive inertia weight for improved convergence in black-box optimizations.", "configspace": "", "generation": 2, "fitness": 0.13412033202771914, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "895d61ee-086e-4a21-9156-bc9a48f204da", "metadata": {"aucs": [0.1335783617441051, 0.13381929841565232, 0.13496333592340004]}, "mutation_prompt": null}
{"id": "7ee6b037-7859-418b-bbe5-bb2ad39ecbdb", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Dynamic social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) with adaptive inertia weight and dynamic social coefficient for enhanced exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.13414400680611185, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "dd58d0bf-9894-4dc5-81ae-a7eb2bb17b1e", "metadata": {"aucs": [0.1336486559579907, 0.13385851809927685, 0.13492484636106805]}, "mutation_prompt": null}
{"id": "30be58b1-e300-474b-92ce-ae852ac6c9a9", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * evals / self.budget  # Dynamic cognitive coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "QIPSO with enhanced cognitive coefficient dynamics for improved local search capabilities.", "configspace": "", "generation": 4, "fitness": 0.13341890466173792, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7ee6b037-7859-418b-bbe5-bb2ad39ecbdb", "metadata": {"aucs": [0.1336557425009388, 0.13346776050118747, 0.1331332109830875]}, "mutation_prompt": null}
{"id": "ad11b19d-9db4-4d40-bd22-14666fc7a867", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive cognitive coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive quantum cognition coefficient for improved exploration.", "configspace": "", "generation": 5, "fitness": 0.13414992839686116, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7ee6b037-7859-418b-bbe5-bb2ad39ecbdb", "metadata": {"aucs": [0.1335689433920847, 0.13387156563863334, 0.13500927615986547]}, "mutation_prompt": null}
{"id": "fc40dcbd-ee60-433f-9dbf-a6796343fa42", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive quantum cognition and social coefficients for improved exploration.", "configspace": "", "generation": 6, "fitness": 0.1342563129451512, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ad11b19d-9db4-4d40-bd22-14666fc7a867", "metadata": {"aucs": [0.1335770028438008, 0.13391217073425388, 0.13527976525739893]}, "mutation_prompt": null}
{"id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities * (0.9 + 0.1 * np.random.rand())  # Dynamic velocity scaling\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Improved QIPSO with dynamic velocity scaling to enhance convergence speed and accuracy.", "configspace": "", "generation": 7, "fitness": 0.13444584105354876, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "fc40dcbd-ee60-433f-9dbf-a6796343fa42", "metadata": {"aucs": [0.13557622952937287, 0.13445974181565257, 0.13330155181562087]}, "mutation_prompt": null}
{"id": "5e571ac7-c0cc-475a-924f-d98af1db35a5", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            positions += velocities * (0.9 + 0.1 * np.random.rand())\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.2 + 0.8 * np.exp(-2 * evals / self.budget)  # Adaptive cognitive coefficient\n            self.c2 = 1.2 + 0.8 * np.exp(-2 * evals / self.budget)  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive cognitive and social coefficients for improved balance between exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.13432596802863647, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13571477947753963, 0.1339673598546709, 0.13329576475369886]}, "mutation_prompt": null}
{"id": "b3e5be7d-8b85-490d-8559-648489d528ba", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n                velocities[i] += np.random.normal(0, 0.1 * (ub - lb), self.dim)  # Stochastic perturbation\n\n            positions += velocities * (0.9 + 0.1 * np.random.rand())\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * np.sin(np.pi * evals / self.budget)  # Adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * np.cos(np.pi * evals / self.budget)  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive learning parameters and stochastic perturbation for improved exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.13311959703120912, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13336589512655128, 0.13235316969098798, 0.1336397262760881]}, "mutation_prompt": null}
{"id": "aadb33d4-ab97-450e-9034-f26de3758a8e", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities * (0.9 + 0.1 * np.random.rand(self.population_size, 1))  # Adaptive position scaling\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive position scaling to refine convergence precision.", "configspace": "", "generation": 10, "fitness": 0.13234005363724063, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.12988790313533494, 0.13363933087202673, 0.1334929269043602]}, "mutation_prompt": null}
{"id": "b46429aa-0b68-4658-9bf8-9077041ea1c9", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities * (0.8 + 0.2 * np.sin(np.pi * evals / self.budget))  # Non-linear dynamic velocity scaling\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO by introducing a non-linear dynamic velocity scaling factor to improve convergence.", "configspace": "", "generation": 11, "fitness": 0.13338658591089972, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13380872037851355, 0.13276066867574032, 0.13359036867844531]}, "mutation_prompt": null}
{"id": "070ae1b6-c2e7-4a47-bc6d-7f136e4938c1", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            positions += velocities * (0.9 + 0.1 * np.random.rand())  # Dynamic velocity scaling\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n            self.w = 0.5 + 0.5 * (global_best_score - np.min(personal_best_scores)) / global_best_score  # Adjusted\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Improved QIPSO with adaptive exploration-exploitation balance to enhance convergence.", "configspace": "", "generation": 12, "fitness": 0.1336641066291369, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13323447272025346, 0.13395860455727093, 0.1337992426098863]}, "mutation_prompt": null}
{"id": "50e4e92f-59f6-4c72-8642-4cb3da28d9c7", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n        self.initial_population_size = self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            positions += velocities * (0.9 + 0.1 * np.random.rand())\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n            # Dynamic adaptation of the population size\n            self.population_size = max(10, int(self.initial_population_size * (1 - evals / self.budget)))\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with dynamic swarm size adaptation for improved exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.13380980132765477, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13354624436792195, 0.13279226152873946, 0.13509089808630292]}, "mutation_prompt": null}
{"id": "f8e4b3fc-1428-4fd9-b3eb-06ff18f2f9ca", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        exploration_factor = 0.5  # Added exploration factor\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n                # Introduced hybrid exploration mechanism\n                if np.random.rand() < exploration_factor:\n                    velocities[i] += np.random.normal(size=self.dim)\n\n            # Update positions and handle boundaries\n            positions += velocities * (0.8 + 0.2 * np.random.rand())  # Dynamic velocity scaling\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update with enhanced dynamic tuning\n            self.w = 0.3 + 0.4 * (self.budget - evals) / self.budget\n            self.c1 = 1.4 + 0.6 * (self.budget - evals) / self.budget\n            self.c2 = 1.4 + 0.6 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance QIPSO with hybrid exploration mechanisms and adaptive parameter tuning for improved convergence.", "configspace": "", "generation": 14, "fitness": 0.1330379690281499, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13335746523659386, 0.13377941385080117, 0.13197702799705469]}, "mutation_prompt": null}
{"id": "c10ed6bc-088a-42d1-815f-7fa5b81d9725", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            mutation = np.random.normal(0, 0.1, (self.population_size, self.dim))\n            positions += velocities * (0.9 + 0.1 * np.random.rand()) + mutation  # Added mutation\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive velocity scaling and directional mutation for improved exploration.", "configspace": "", "generation": 15, "fitness": 0.13374506797499, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13365568054773813, 0.13399051585218358, 0.13358900752504832]}, "mutation_prompt": null}
{"id": "e7ae43af-03ec-4948-bf18-2be8aba321fc", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions and handle boundaries\n            perturbation = 0.1 * np.random.randn(self.population_size, self.dim)  # Adaptive quantum perturbation\n            positions += (velocities + perturbation) * (0.9 + 0.1 * np.random.rand())  # Dynamic velocity scaling\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive quantum perturbation for improved exploration and convergence.", "configspace": "", "generation": 16, "fitness": 0.1337449752553719, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.1336422789272501, 0.13399118916244634, 0.1336014576764193]}, "mutation_prompt": null}
{"id": "1ade3c62-819e-4b55-85b9-bf27f630d976", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles' positions using quantum superposition principle\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                # Quantum-inspired velocity update\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Update positions with crossover and handle boundaries\n            for i in range(self.population_size):\n                crossover_rate = 0.5 + 0.5 * (global_best_score - personal_best_scores[i]) / global_best_score\n                if np.random.rand() < crossover_rate:\n                    partner = np.random.randint(self.population_size)\n                    positions[i] = 0.5 * (positions[i] + positions[partner])\n            positions = np.clip(positions, lb, ub)\n            # Adaptive inertia weight update\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget  # Adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO with adaptive crossover for improved exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.12623649315110327, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.12416114248359711, 0.12656595172985652, 0.12798238523985617]}, "mutation_prompt": null}
{"id": "a525b67d-d4dd-4bd2-bd30-55b2092e96f7", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            positions += velocities * (0.9 + 0.1 * np.random.rand())\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhanced QIPSO by fine-tuning adaptive coefficients for improved exploration and exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.13474025302210083, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "aa1e7044-25f5-40ca-8e16-a2755a23cc60", "metadata": {"aucs": [0.13555201232979974, 0.13549640523637208, 0.1331723415001307]}, "mutation_prompt": null}
{"id": "06d15ba1-5ab8-4806-85c0-a11e55e04dda", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            positions += velocities * (0.8 + 0.2 * np.random.rand())  # Dynamic velocity scaling adjustment\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive quantum perturbation and dynamic velocity scaling for enhanced convergence speed and accuracy.", "configspace": "", "generation": 19, "fitness": 0.1349528284021626, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "a525b67d-d4dd-4bd2-bd30-55b2092e96f7", "metadata": {"aucs": [0.1357314586058701, 0.13384578336213737, 0.13528124323848034]}, "mutation_prompt": null}
{"id": "c20c06f3-3dea-44b2-8975-bc4893f0c854", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            adaptive_size = int(self.population_size * (0.5 + 0.5 * evals / self.budget))\n            positions = positions[:adaptive_size]\n            velocities = velocities[:adaptive_size]\n            for i in range(adaptive_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + (np.random.rand(self.dim) - 0.5) * (1 - evals / self.budget)\n\n            positions += velocities * (0.8 + 0.2 * np.random.rand())  # Dynamic velocity scaling adjustment\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Augment QIPSO with dynamic population resizing and adaptive mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "06d15ba1-5ab8-4806-85c0-a11e55e04dda", "metadata": {}, "mutation_prompt": null}
{"id": "f0da2908-bbe2-4996-b9b1-587a35e8c5f2", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            positions += velocities * (0.8 + 0.2 * np.random.rand())\n\n            mutation = np.random.rand(self.population_size, self.dim) < 0.1  # Mutation operator\n            positions[mutation] += np.random.normal(0, 0.1, positions[mutation].shape)  # Apply mutation\n\n            positions = np.clip(positions, lb, ub)\n            positions = np.where(positions < lb, lb + np.abs(positions - lb), positions)  # Adaptive boundary reflection\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance diversity and convergence by introducing a mutation operator and adaptive boundary reflection.", "configspace": "", "generation": 21, "fitness": 0.1349293570141441, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "06d15ba1-5ab8-4806-85c0-a11e55e04dda", "metadata": {"aucs": [0.13570533255552664, 0.13371373697884126, 0.1353690015080644]}, "mutation_prompt": null}
{"id": "0f1ce498-3e65-4c6a-aa70-18efba851574", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            positions += velocities * (0.8 + 0.3 * np.random.rand())  # Increased dynamic velocity scaling adjustment\n\n            positions += np.random.normal(0, 0.1, positions.shape)  # Introduced stochastic perturbation\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.3 * (self.budget - evals) / self.budget  # Updated adaptive inertia weight\n            self.c1 = 1.6 + 0.5 * (self.budget - evals) / self.budget  # Updated adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget  # Updated adaptive social coefficient\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce stochastic perturbation and adaptive coefficients to enhance exploration and exploitation balance.", "configspace": "", "generation": 22, "fitness": 0.13461320461418017, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "06d15ba1-5ab8-4806-85c0-a11e55e04dda", "metadata": {"aucs": [0.13598238888475134, 0.13249258954059073, 0.13536463541719845]}, "mutation_prompt": null}
{"id": "467e48a7-2a6d-4e7b-8a0f-385db82b14be", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim)\n\n            positions += velocities * (0.8 + 0.2 * np.random.rand())  # Dynamic velocity scaling adjustment\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance exploration by integrating stochastic rotation during velocity updates.", "configspace": "", "generation": 23, "fitness": 0.13491431193595035, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "06d15ba1-5ab8-4806-85c0-a11e55e04dda", "metadata": {"aucs": [0.13585230363885104, 0.133736193732793, 0.135154438436207]}, "mutation_prompt": null}
{"id": "8603b5f4-cc84-4fc5-84dd-acbfa0a8f735", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.01, self.dim)\n            \n            positions += velocities * (0.8 + 0.2 * np.random.rand())  # Dynamic velocity scaling adjustment\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance exploration by incorporating a stochastic component in velocity update.", "configspace": "", "generation": 24, "fitness": 0.13483182207695812, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "06d15ba1-5ab8-4806-85c0-a11e55e04dda", "metadata": {"aucs": [0.13567512244975888, 0.1337632804413802, 0.13505706333973533]}, "mutation_prompt": null}
{"id": "de7d7f58-77a8-4543-a2bd-669015317430", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            # Updated line for dynamic velocity scaling\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget) * np.pi))  \n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance frequency of dynamic velocity scaling using a sine function for better exploration.", "configspace": "", "generation": 25, "fitness": 0.1349901369312414, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "06d15ba1-5ab8-4806-85c0-a11e55e04dda", "metadata": {"aucs": [0.13598155592444683, 0.13379357633587208, 0.1351952785334053]}, "mutation_prompt": null}
{"id": "7af3d7f7-48d8-40f8-be18-56a54d08de2b", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi * 0.5)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            # Updated line for dynamic velocity scaling\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget) * np.pi))  \n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance quantum cognitive component using cosine function for improved balance.", "configspace": "", "generation": 26, "fitness": 0.13498433317000316, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "de7d7f58-77a8-4543-a2bd-669015317430", "metadata": {"aucs": [0.1359751557900537, 0.13379506216320391, 0.1351827815567519]}, "mutation_prompt": null}
{"id": "e322b970-4909-4467-8c0d-5bf56dbee492", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            # Line modified to introduce a random factor\n            positions += velocities * (0.8 + 0.2 * np.random.rand(self.population_size, self.dim))  \n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a random factor in velocity scaling for increased stochasticity and exploration.", "configspace": "", "generation": 27, "fitness": 0.13487713654022324, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "de7d7f58-77a8-4543-a2bd-669015317430", "metadata": {"aucs": [0.13564705264371435, 0.1337767150192647, 0.13520764195769064]}, "mutation_prompt": null}
{"id": "5db0f8d2-927f-4f95-af12-386b11e59c99", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            # Updated line for dynamic velocity scaling with phase shift\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))  \n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Optimize dynamic velocity scaling by adjusting the sine function phase for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.1350416507564373, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "de7d7f58-77a8-4543-a2bd-669015317430", "metadata": {"aucs": [0.13599559360008762, 0.13382203750123967, 0.1353073211679846]}, "mutation_prompt": null}
{"id": "3b8edac1-7380-454b-98b6-51f230bb3d5d", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n\n            # Updated line for dynamic velocity scaling with parabolic modulation\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4)) * (1 - (evals/self.budget)**2)\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a parabolic modulation in velocity scaling to enhance convergence stability.", "configspace": "", "generation": 29, "fitness": 0.13503829088727448, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "5db0f8d2-927f-4f95-af12-386b11e59c99", "metadata": {"aucs": [0.13599286031293134, 0.13381783992782625, 0.13530417242106585]}, "mutation_prompt": null}
{"id": "2e1ce6c4-1075-4a1b-a9ff-bd19dbbaf2ca", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            # Modified line for dynamic velocity scaling with random inertia weight factor\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4)) * np.random.uniform(0.9, 1.1)\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance convergence by introducing a random inertia weight factor to improve exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.13500440845423414, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "5db0f8d2-927f-4f95-af12-386b11e59c99", "metadata": {"aucs": [0.135819020410345, 0.13384945216213706, 0.1353447527902204]}, "mutation_prompt": null}
{"id": "0fd8affc-643b-4a75-bc9a-5f62b3afeca4", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                phase = (evals / self.budget * np.pi)\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(phase * 1.5)  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(phase / 1.5)  # Modified line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social\n            \n            positions += velocities * (0.8 + 0.2 * np.sin(phase + np.pi/4))  \n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive sine and cosine scaling for quantum components to enhance search exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.13488105694318164, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "5db0f8d2-927f-4f95-af12-386b11e59c99", "metadata": {"aucs": [0.13588601642973286, 0.1336791975603666, 0.13507795683944546]}, "mutation_prompt": null}
{"id": "4f03fa28-e786-413a-81c4-aa3ba434214a", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim)  # Added Gaussian noise\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.5 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce Gaussian noise in velocity update for enhanced exploration.", "configspace": "", "generation": 32, "fitness": 0.1350485027129806, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "5db0f8d2-927f-4f95-af12-386b11e59c99", "metadata": {"aucs": [0.1359457774393268, 0.13367308204135286, 0.13552664865826214]}, "mutation_prompt": null}
{"id": "8ae43822-520d-41ab-af0f-00f3ccc6a049", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim)  # Added Gaussian noise\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget  # Slightly increased the adaptive update rate\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance adaptive update of social coefficient to improve exploration.", "configspace": "", "generation": 33, "fitness": 0.13508902268510373, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "4f03fa28-e786-413a-81c4-aa3ba434214a", "metadata": {"aucs": [0.13596213236002497, 0.13373585709907165, 0.1355690785962146]}, "mutation_prompt": null}
{"id": "9acb9504-6277-4315-9c77-965e36271d22", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1 * (self.budget - evals) / self.budget, self.dim)  # Adaptive Gaussian noise\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget  # Slightly increased the adaptive update rate\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive Gaussian noise based on function evaluations to improve exploration.", "configspace": "", "generation": 34, "fitness": 0.13508745047951057, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "8ae43822-520d-41ab-af0f-00f3ccc6a049", "metadata": {"aucs": [0.13596162622763175, 0.13372961071394096, 0.13557111449695902]}, "mutation_prompt": null}
{"id": "6324edd5-a107-467b-a6d3-d9edd2e4eef3", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)  # Added nonlinear perturbation\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget  # Slightly increased the adaptive update rate\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Incorporate a nonlinear perturbation in velocity update to enhance local search capability.", "configspace": "", "generation": 35, "fitness": 0.13509067205955563, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "8ae43822-520d-41ab-af0f-00f3ccc6a049", "metadata": {"aucs": [0.13596283646830454, 0.13373892418404876, 0.13557025552631363]}, "mutation_prompt": null}
{"id": "eaf9b32e-58be-41cd-b89b-598af053b70b", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi)\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) * np.exp(-evals / (0.1 * self.budget))  # Added nonlinear perturbation\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted adaptive inertia weight update\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget  # Adjusted adaptive cognitive coefficient\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget  # Slightly increased the adaptive update rate\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce an exponential decay factor to the velocity update for enhanced convergence control.", "configspace": "", "generation": 36, "fitness": 0.1350902050275358, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "6324edd5-a107-467b-a6d3-d9edd2e4eef3", "metadata": {"aucs": [0.13596354470001404, 0.1337374335143392, 0.13556963686825418]}, "mutation_prompt": null}
{"id": "1eab87d6-2e23-4c72-8970-9aa2bcc79ed3", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a dynamic perturbation factor in quantum cognition to improve adaptive exploration.", "configspace": "", "generation": 37, "fitness": 0.13509122153099654, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "6324edd5-a107-467b-a6d3-d9edd2e4eef3", "metadata": {"aucs": [0.1359576190847921, 0.13372972273435846, 0.13558632277383909]}, "mutation_prompt": null}
{"id": "7e9b36b8-df79-44d7-b603-b745d3b9a91e", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) * np.sin(evals * np.pi / self.budget)  # Modified line\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a dynamic sinusoidal perturbation in velocity update to enhance adaptive exploration.", "configspace": "", "generation": 38, "fitness": 0.13508766896716862, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "1eab87d6-2e23-4c72-8970-9aa2bcc79ed3", "metadata": {"aucs": [0.1359573359962868, 0.13372128668352878, 0.13558438422169028]}, "mutation_prompt": null}
{"id": "654dbc54-b90f-43d8-8bdc-bb3a2736ccf5", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = ((global_best_position - positions[i]) + np.random.normal(0, 0.1, self.dim)) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)  # Modified line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce Gaussian perturbation in the social component to enhance exploration diversity.", "configspace": "", "generation": 39, "fitness": 0.13497794332858096, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "1eab87d6-2e23-4c72-8970-9aa2bcc79ed3", "metadata": {"aucs": [0.1358172558315408, 0.13370213727419666, 0.13541443688000543]}, "mutation_prompt": null}
{"id": "58ddc78f-1bd8-4181-b6b2-fb1857ad0d40", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.cos(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * 2 * np.pi) + np.pi/4))  # Changed line\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance convergence by introducing a sinusoidal variation in velocity update for adaptive exploration.", "configspace": "", "generation": 40, "fitness": 0.13509073304883035, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "1eab87d6-2e23-4c72-8970-9aa2bcc79ed3", "metadata": {"aucs": [0.13596124302849644, 0.13371992396996057, 0.13559103214803403]}, "mutation_prompt": null}
{"id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Modify the quantum cognition factor for better convergence by changing the cosine function to a sine function.", "configspace": "", "generation": 41, "fitness": 0.13510535510022323, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "1eab87d6-2e23-4c72-8970-9aa2bcc79ed3", "metadata": {"aucs": [0.13597689215152786, 0.1337538076913708, 0.135585365457771]}, "mutation_prompt": null}
{"id": "c8368747-0d86-4990-9d27-cb69ae61f239", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * (np.cos(evals / self.budget * np.pi) + np.sin(evals / self.budget * np.pi)) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance quantum cognition adjustment by introducing a cosine term for smoother convergence dynamics.", "configspace": "", "generation": 42, "fitness": 0.1350245199952507, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.13589431009185426, 0.13359122839814241, 0.13558802149575544]}, "mutation_prompt": null}
{"id": "b5556d11-8281-4e5e-9268-41c1e1ffd86e", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin((evals / self.budget * np.pi) + np.pi/6) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance convergence by adjusting the phase of the sine function in the velocity update.", "configspace": "", "generation": 43, "fitness": 0.13508870283344146, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.1359544080496471, 0.13374160264498036, 0.13557009780569695]}, "mutation_prompt": null}
{"id": "5247fa78-0010-4272-8e68-be3db20adf91", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * np.cos(np.pi * evals / self.budget)  # Modified line\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a cosine-based inertia weight modulation for enhanced exploration capabilities.", "configspace": "", "generation": 44, "fitness": 0.13507231073284662, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.1359658731264587, 0.1336827784534803, 0.13556828061860082]}, "mutation_prompt": null}
{"id": "0bcfb5f8-7143-4605-99ec-d00b29ebba31", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals / self.budget * np.pi))  # Modified line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance convergence by dynamically scaling quantum factors based on evaluation ratio.", "configspace": "", "generation": 45, "fitness": 0.13506244301267534, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.13596476754489517, 0.13363540705572585, 0.135587154437405]}, "mutation_prompt": null}
{"id": "999e16aa-f7d1-4ac0-a422-b777951a898b", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget  # Adjusting the inertia weight\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance diversity by introducing dynamic adjustment of the inertia weight.", "configspace": "", "generation": 46, "fitness": 0.13509738181837297, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.13597581926545732, 0.1337322502430517, 0.13558407594660993]}, "mutation_prompt": null}
{"id": "3508f1b7-e8fd-4bce-80c4-2124774ba22c", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Adjust velocity update by introducing a sinusoidal factor for improved trajectory exploration.", "configspace": "", "generation": 47, "fitness": 0.13510535510022323, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.13597689215152786, 0.1337538076913708, 0.135585365457771]}, "mutation_prompt": null}
{"id": "dc2621a9-7919-43c9-ae95-d0d5f9fecae8", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi * 0.9) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Refine the quantum cognition factor to improve convergence by adjusting the weight of the sinusoidal component.", "configspace": "", "generation": 48, "fitness": 0.13509303028960348, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.13597473799232407, 0.13373193212954582, 0.13557242074694054]}, "mutation_prompt": null}
{"id": "c99a7f87-2887-42c6-bd12-2583c212251b", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin((evals / self.budget * np.pi) + np.pi/8) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Fine-tune the quantum cognition factor to enhance adaptability with a phase adjustment.", "configspace": "", "generation": 49, "fitness": 0.13508714247813333, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.1359667932232278, 0.13373345680990878, 0.1355611774012634]}, "mutation_prompt": null}
{"id": "4ef7b7a8-d8d2-4ed5-b293-238d547cfbe3", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)  # Adjusted line\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Slightly enhance global best influence by adjusting the velocity update rule.", "configspace": "", "generation": 50, "fitness": 0.13511611234678964, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "70ed2c4c-5012-4382-b410-386f5af5e7e5", "metadata": {"aucs": [0.13599148993440713, 0.13369835101742, 0.13565849608854175]}, "mutation_prompt": null}
{"id": "96b0c6af-95c5-4fb0-9583-ab0ebd3b5caa", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))  # Modified line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi)\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)  # Adjusted line\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget  # Changed line\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Refine the inertia weight update rule for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 51, "fitness": 0.13513296428264154, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "4ef7b7a8-d8d2-4ed5-b293-238d547cfbe3", "metadata": {"aucs": [0.1359983818107351, 0.13373627391763554, 0.135664237119554]}, "mutation_prompt": null}
{"id": "8630bb9d-37fa-4ec2-aca6-926375d408c6", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.9 + 0.1 * np.cos(evals * np.pi / self.budget)) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a decay factor for social influence to enhance convergence precision in later stages of optimization.", "configspace": "", "generation": 52, "fitness": 0.1351370460976895, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "96b0c6af-95c5-4fb0-9583-ab0ebd3b5caa", "metadata": {"aucs": [0.13599911563409706, 0.13374855909070338, 0.13566346356826808]}, "mutation_prompt": null}
{"id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance velocity update by adjusting social factor to improve convergence in diverse search spaces.", "configspace": "", "generation": 53, "fitness": 0.13514073559793274, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "8630bb9d-37fa-4ec2-aca6-926375d408c6", "metadata": {"aucs": [0.1359991767759633, 0.13376006612382507, 0.1356629638940099]}, "mutation_prompt": null}
{"id": "efe30e93-c521-45ce-b419-e756a2568af3", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) * (1 - evals / self.budget) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Refine the quantum social factor to adaptively enhance convergence by adding a decaying component based on iterations.", "configspace": "", "generation": 54, "fitness": 0.13505733898862404, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.1360036873822339, 0.13357341498793407, 0.13559491459570416]}, "mutation_prompt": null}
{"id": "7e4bae27-3286-4e28-be87-ec95b4b10da6", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                \n                # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1 * (self.budget - evals) / self.budget, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive noise to velocity update for enhanced exploration.", "configspace": "", "generation": 55, "fitness": 0.13513903844770028, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.13599956683658165, 0.13375432075207727, 0.13566322775444195]}, "mutation_prompt": null}
{"id": "070dbfae-4ca0-4507-bbb8-6089bf0c2a75", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) \n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4)) * np.cos(evals * np.pi / (2*self.budget))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Increase exploration by adding a cosine adjustment to position updates for enhanced diversity.", "configspace": "", "generation": 56, "fitness": 0.13500389400366528, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.13600357208745417, 0.1333469201917461, 0.13566118973179553]}, "mutation_prompt": null}
{"id": "126ea8d6-7ccd-49df-9a45-66d13b0672cf", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) * np.cos(evals / self.budget * np.pi) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a decay factor influenced by the cosine of evaluations to enhance quantum social component and boost exploration.", "configspace": "", "generation": 57, "fitness": 0.13505943416413335, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.1359970327681479, 0.13356812286799047, 0.1356131468562617]}, "mutation_prompt": null}
{"id": "1adcb0c2-5d68-4058-833b-f5b1b8ed9c43", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Fine-tune quantum social factor to better balance exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.13513834282880247, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.13600031710363947, 0.13375239641618641, 0.13566231496658154]}, "mutation_prompt": null}
{"id": "1a894764-f1c8-4e29-b906-d1e000abab02", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.1  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Slightly increase the cognitive coefficient to fine-tune personal influence, improving convergence rate in diverse landscapes.", "configspace": "", "generation": 59, "fitness": 0.13514073559793274, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.1359991767759633, 0.13376006612382507, 0.1356629638940099]}, "mutation_prompt": null}
{"id": "dd9ce445-8f61-4bee-8b7b-0b267905b2cf", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.15 * np.sin(evals * np.pi / self.budget))  # Changed line\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Refine particle velocity adjustment by dynamically scaling quantum cognition influence.", "configspace": "", "generation": 60, "fitness": 0.1350179130186536, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.13600006601507764, 0.133389060800286, 0.13566461224059712]}, "mutation_prompt": null}
{"id": "010407f7-dc59-47c1-92b6-d1d85aa8e851", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) * 0.99  # Changed line\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/4))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a decay factor to the velocity update to enhance convergence precision.", "configspace": "", "generation": 61, "fitness": 0.13514069335237133, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.13599929990101178, 0.13375998981036674, 0.13566279034573547]}, "mutation_prompt": null}
{"id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))  # Phase-shifted oscillation change\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Refine position update by incorporating phase-shifted oscillation for diversification.", "configspace": "", "generation": 62, "fitness": 0.13516964504683152, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "47c86d76-8ec8-4545-a620-a34ac713d1ca", "metadata": {"aucs": [0.1360269036618018, 0.1338521813680087, 0.13562985011068407]}, "mutation_prompt": null}
{"id": "481e5295-2e6c-4ecd-9bf6-64e9387bac8b", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/3))  # Phase-shifted oscillation change\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance the phase-shifted oscillation adjustment to improve convergence precision.", "configspace": "", "generation": 63, "fitness": 0.13516876100583927, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.13602526452589836, 0.13386518516917179, 0.13561583332244764]}, "mutation_prompt": null}
{"id": "848623b5-6818-4a92-91ad-d6611d2110f9", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                dim_variance = np.var(positions, axis=0)\n                adaptive_factor = 1.0 + 0.5 * np.tanh(dim_variance.sum() / self.dim)  # Changed line\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + adaptive_factor * (self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social) + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive scaling of personal and social components based on dimensional variance to enhance exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.13508027580827608, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.13598281331228235, 0.13387205475629604, 0.13538595935624986]}, "mutation_prompt": null}
{"id": "7f61ced5-e407-4928-9aba-625da27b55dc", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2)) * np.clip(1 - evals/self.budget, 0.5, 1.5)  # Change: Introduced adaptive scaling\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive scaling to velocities for balancing exploration and exploitation phases.", "configspace": "", "generation": 65, "fitness": 0.1351126362884112, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.13600275323086541, 0.13367670782761976, 0.1356584478067484]}, "mutation_prompt": null}
{"id": "1ea51f89-17f2-4ad9-9b1f-7351fe52bd91", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))  # Phase-shifted oscillation change\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (1 + np.cos(np.pi * evals / self.budget))  # Changed line\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance exploration by adjusting inertia weight dynamically based on cosine function of evaluations.", "configspace": "", "generation": 66, "fitness": 0.1345497605261654, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.13557936529640813, 0.13293353548910758, 0.13513638079298051]}, "mutation_prompt": null}
{"id": "fe1dc6b6-ab65-4f32-bd62-9807f63e9f28", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) + np.random.normal(0, 0.05, self.dim)  # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))  # Phase-shifted oscillation change\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance quantum social component by adding a dynamic perturbation for improved exploration.", "configspace": "", "generation": 67, "fitness": 0.1342202951180164, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.1338688884818795, 0.1336412302248744, 0.1351507666472953]}, "mutation_prompt": null}
{"id": "cef708a1-c2eb-44d8-a7a0-3048aae1300b", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))  # Phase-shifted oscillation change\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * (self.budget - evals) / self.budget  # Adjusted inertia weight dynamic range\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance global exploration by modifying the inertia weight dynamic range.", "configspace": "", "generation": 68, "fitness": 0.1351684989009209, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.1360153471857466, 0.13386076026260918, 0.13562938925440693]}, "mutation_prompt": null}
{"id": "0df405d8-c887-4c33-9193-a3fe72dd3745", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * ((0.8 + 0.2 * np.cos(evals * np.pi / self.budget)) + 0.1 * np.cos(evals * 2 * np.pi / self.budget))  # Changed line\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))  # Phase-shifted oscillation change\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive learning factor to enhance convergence by dynamically adjusting influence of global best.", "configspace": "", "generation": 69, "fitness": 0.13512579993576804, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.13605356388370748, 0.13365645825787487, 0.1356673776657218]}, "mutation_prompt": null}
{"id": "5a570aa2-cecc-4a40-bf75-c6ca63dfa620", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget * (1 - np.mean(np.linalg.norm(velocities, axis=1)) / np.linalg.norm(ub - lb))  # Changed line\n            self.c1 = 1.6 + 0.4 * (self.budget - evals) / self.budget\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance convergence by dynamically adjusting the inertia weight based on velocity magnitude to balance exploration and exploitation.", "configspace": "", "generation": 70, "fitness": 0.1351288619354295, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.13601140264068956, 0.13377293952682867, 0.13560224363877027]}, "mutation_prompt": null}
{"id": "c96c4eeb-394f-4ddc-9c2c-d9ed3d24d393", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce dynamic adjustment of cognitive and social coefficients based on current fitness progress for enhanced convergence.", "configspace": "", "generation": 71, "fitness": 0.13519587443820613, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "877c32e3-f9cc-46bb-986c-efaff6fa1511", "metadata": {"aucs": [0.13602674943914006, 0.13388275655905368, 0.13567811731642465]}, "mutation_prompt": null}
{"id": "62561a13-6420-42cc-b0ce-6029b06fef75", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * (self.budget - evals) / self.budget\n            self.c1 = (1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))) * (1 - evals/self.budget)  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce slight decay in cognitive coefficient for better exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.13519573526242523, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "c96c4eeb-394f-4ddc-9c2c-d9ed3d24d393", "metadata": {"aucs": [0.1360238626255197, 0.13388731721542857, 0.13567602594632744]}, "mutation_prompt": null}
{"id": "082e4d18-7bf7-4b74-890b-80a106450c4a", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.8 + 0.2 * np.cos(evals * np.pi / self.budget))\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a dynamic inertia weight adjustment for better balance between exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.13519703344352385, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "c96c4eeb-394f-4ddc-9c2c-d9ed3d24d393", "metadata": {"aucs": [0.1360224591338799, 0.13389875160528042, 0.13566988959141124]}, "mutation_prompt": null}
{"id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance the quantum social influence by adjusting the velocity update to improve convergence efficiency.", "configspace": "", "generation": 74, "fitness": 0.13519870534884323, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "082e4d18-7bf7-4b74-890b-80a106450c4a", "metadata": {"aucs": [0.13602485959337374, 0.13390104308134554, 0.1356702133718104]}, "mutation_prompt": null}
{"id": "772b0c93-64b5-4679-aaa0-d6573788ad16", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1.0 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance the quantum update efficacy by refining social influence factors to improve convergence.", "configspace": "", "generation": 75, "fitness": 0.1349111342173063, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.136078278352052, 0.13299895426005426, 0.13565617003981267]}, "mutation_prompt": null}
{"id": "f4607c46-a613-44f8-a159-2fe356bf2fbb", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.15 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Slightly increase the impact of quantum social influence on velocities to boost convergence speed without compromising exploration.", "configspace": "", "generation": 76, "fitness": 0.13465982497466086, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13603545080322743, 0.1323293311719127, 0.13561469294884243]}, "mutation_prompt": null}
{"id": "4484ad1d-ea25-4eb0-b2a7-04c7eb29f613", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) + np.random.normal(0, 0.05, self.dim)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a stochastic perturbation in velocity to enhance exploration capabilities.", "configspace": "", "generation": 77, "fitness": 0.13424120074025445, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13385082443047225, 0.13372048715405394, 0.13515229063623713]}, "mutation_prompt": null}
{"id": "98532468-dfd4-4246-adff-4cd70f03a066", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.8  # Adjusted Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Fine-tune the cognitive coefficient for improved local exploration early in the optimization process.", "configspace": "", "generation": 78, "fitness": 0.13519870534884323, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602485959337374, 0.13390104308134554, 0.1356702133718104]}, "mutation_prompt": null}
{"id": "8c28f56e-c06e-4676-a7da-9753c8f86cfd", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1 * (1 - evals / self.budget), self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce adaptive noise scaling to velocities for enhancing exploration-exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.13519683311657524, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602138682803433, 0.13389984024902046, 0.1356692722726709]}, "mutation_prompt": null}
{"id": "49cb349f-7ac5-4887-97e7-075229bff5ea", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) * (0.9 + 0.1 * np.cos(evals * np.pi / self.budget))  # Dynamic scaling factor added\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a dynamic scaling factor to the velocity update for improved adaptability.", "configspace": "", "generation": 80, "fitness": 0.13519860128759661, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602511421108765, 0.1339008938105577, 0.13566979584114447]}, "mutation_prompt": null}
{"id": "49486df6-5557-491d-8318-85e35651210f", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social * (1 + 0.1 * np.sin(2 * np.pi * evals / self.budget)) + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a dynamic factor for velocity update, enhancing quantum social influence adaptability.", "configspace": "", "generation": 81, "fitness": 0.13492939880318708, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13603215517023814, 0.13310387777992738, 0.13565216345939568]}, "mutation_prompt": null}
{"id": "5ad3451f-e1dd-4fc3-9dd8-58525830cc9a", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Fine-tune inertia weight dynamics to enhance exploration-exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.13516521297776488, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602307142885106, 0.1338036176115167, 0.13566894989292688]}, "mutation_prompt": null}
{"id": "1216c4b2-4f65-4a55-8dcc-1e7c2edbf002", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2)) * (1 - evals / self.budget)\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a dynamic scaling factor to velocity updates for enhancing exploration-exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.13467407371125054, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360226399899146, 0.13235642578358142, 0.13564315536025562]}, "mutation_prompt": null}
{"id": "25025e23-0b1a-4a30-8be2-acddd6e897d1", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 1.8)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance velocity update with adaptive scaling based on evaluation ratio to improve convergence.", "configspace": "", "generation": 84, "fitness": 0.13519691972042477, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360202125713108, 0.13389883839848982, 0.13567170819147367]}, "mutation_prompt": null}
{"id": "a0fa5754-0cff-4148-96eb-48c8fc65cf70", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)**2  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Refine the dynamic inertia weight strategy by incorporating a squared cosine function for more adaptive exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.1351925653930869, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.136004551418912, 0.1339002680489707, 0.13567287671137807]}, "mutation_prompt": null}
{"id": "1ee0065f-6602-4b59-b3e3-0d6203200b31", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) + 0.05 * np.sin(evals * np.pi / (2 * self.budget))\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a dynamic perturbation factor into velocity to enhance exploration during early iterations.", "configspace": "", "generation": 86, "fitness": 0.1351978228808378, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360197846651755, 0.13390225725759475, 0.13567142671974308]}, "mutation_prompt": null}
{"id": "3afbbbac-0d7e-417f-896b-6bfd56cdb79b", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (evals / self.budget)  # Fine-tuned dynamic adjustment based on evaluation ratio\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Improve convergence by fine-tuning the cognitive coefficient based on the evaluation ratio.", "configspace": "", "generation": 87, "fitness": 0.13516442263788755, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360242798385125, 0.1338022083216328, 0.13566677975351737]}, "mutation_prompt": null}
{"id": "967bd579-0812-4abc-a841-365b02e516a2", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores))) * (1 - evals / self.budget)  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Enhance convergence by dynamically adjusting the cognitive factor based on iteration progress.", "configspace": "", "generation": 88, "fitness": 0.13519831002537708, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602490357712238, 0.13390071283558624, 0.1356693136634226]}, "mutation_prompt": null}
{"id": "10394e99-9dd3-47f5-9c44-a4c0da45da67", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.2, self.dim) + np.power(evals / self.budget, 2)  # Changed noise level\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce additional noise modulation to velocity updates for improved exploration.", "configspace": "", "generation": 89, "fitness": 0.1351852034717265, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360431807768382, 0.13383477770884933, 0.135677651929492]}, "mutation_prompt": null}
{"id": "70fc5e65-53c9-4372-b242-b89f509028fb", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.2 * np.sin(evals * np.pi / self.budget))  # Adjusted factor\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Adjust the quantum cognition factor to enhance exploration dynamics and improve convergence efficiency.", "configspace": "", "generation": 90, "fitness": 0.13519868316692654, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602443855230117, 0.13389909344912732, 0.13567251749935116]}, "mutation_prompt": null}
{"id": "d08813a5-7986-439f-b74b-22931ea83970", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.5 + 0.2 * np.cos(evals * np.pi / self.budget)  # Adjusted dynamic inertia weight\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Adjust the dynamic inertia weight formula for improved convergence behavior.", "configspace": "", "generation": 91, "fitness": 0.13516521297776488, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602307142885106, 0.1338036176115167, 0.13566894989292688]}, "mutation_prompt": null}
{"id": "a5e1c8b9-4f8e-4912-98cb-abef7753ed1a", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) + 0.05 * np.sin(2 * np.pi * evals / self.budget)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a sinusoidal component to the velocity update to subtly enhance adaptive exploration.", "configspace": "", "generation": 92, "fitness": 0.13519314251526163, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13601001084385822, 0.13389993943339562, 0.13566947726853107]}, "mutation_prompt": null}
{"id": "5eb7ce27-78f2-4ebc-91da-6c2f287a8034", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1 * (1.1 - evals / self.budget), self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce an adaptive noise scaling factor to enhance exploration.", "configspace": "", "generation": 93, "fitness": 0.13519796990527633, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360239981323551, 0.13389951473950756, 0.1356703968439663]}, "mutation_prompt": null}
{"id": "bb00e9b0-68f3-40bc-8f9d-ac8291572bb6", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi * 1.1) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Fine-tune the quantum cognition influence for improved exploration.", "configspace": "", "generation": 94, "fitness": 0.1351818041138461, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602755578936387, 0.13387804259638592, 0.1356398139557885]}, "mutation_prompt": null}
{"id": "43535cb3-4839-4727-b26a-b0cfde6986fe", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) + np.random.normal(0, 0.05, self.dim)  # Added stochastic drift\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce stochastic drift in velocity update to enhance exploration and convergence.", "configspace": "", "generation": 95, "fitness": 0.13424120074025445, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13385082443047225, 0.13372048715405394, 0.13515229063623713]}, "mutation_prompt": null}
{"id": "281e28c9-b9f9-4397-8434-fa155a402346", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2) * np.sin(2 * np.pi * evals / self.budget)  # Frequency-based oscillation factor\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce a frequency-based oscillation factor in the velocity update for enhanced exploration and exploitation balance.", "configspace": "", "generation": 96, "fitness": 0.13519788871138097, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360224592666388, 0.13390162736792732, 0.1356695794995768]}, "mutation_prompt": null}
{"id": "7b1f466d-d8c5-4ff1-a503-c2e14c9bec73", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores))) * np.cos(global_best_score)  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Fine-tune cognitive influence by dynamically adjusting based on global score improvements.", "configspace": "", "generation": 97, "fitness": 0.13519869450193378, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.1360248562990416, 0.13390104750120535, 0.1356701797055544]}, "mutation_prompt": null}
{"id": "4b30dc0b-545f-49f7-89fd-6b58aa3bf814", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1, self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores))) * (0.5 + 0.5 * np.sin(evals * np.pi / self.budget))  # Dynamic cognitive coefficient\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Incorporate a dynamic cognitive coefficient to enhance adaptability in the search process.", "configspace": "", "generation": 98, "fitness": 0.13516442911013704, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602459252492416, 0.13380058941905837, 0.1356681053864286]}, "mutation_prompt": null}
{"id": "1c643ca0-1322-452f-a6cf-2de3a1172aae", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([float('inf')] * self.population_size)\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                fitness_value = func(positions[i])\n                evals += 1\n                if fitness_value < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness_value\n                    personal_best_positions[i] = positions[i].copy()\n                if fitness_value < global_best_score:\n                    global_best_score = fitness_value\n                    global_best_position = positions[i].copy()\n\n                quantum_cognition = (personal_best_positions[i] - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (1 + 0.1 * np.sin(evals * np.pi / self.budget))\n                quantum_social = (global_best_position - positions[i]) * np.random.rand(self.dim) * np.sin(evals / self.budget * np.pi) * (0.85 + 0.15 * np.cos(evals * np.pi / self.budget))  # Adjusted factor\n                velocities[i] = self.w * velocities[i] + self.c1 * quantum_cognition + self.c2 * 1.1 * quantum_social + np.random.normal(0, 0.1 * (1 + np.sin(evals * np.pi / self.budget)), self.dim) + np.power(evals / self.budget, 2)\n\n            positions += velocities * (0.8 + 0.2 * np.sin((evals / self.budget * np.pi) + np.pi/2))\n\n            positions = np.clip(positions, lb, ub)\n            self.w = 0.4 + 0.3 * np.cos(evals * np.pi / self.budget)  # Dynamic inertia weight adjustment\n            self.c1 = 1.6 + 0.4 * (global_best_score / (1 + np.min(personal_best_scores)))  # Dynamic adjustment based on fitness progress\n            self.c2 = 1.5 + 0.6 * (self.budget - evals) / self.budget\n\n        return global_best_position, global_best_score", "name": "QIPSO", "description": "Introduce an adaptive factor to dynamically adjust the variance of the random noise added to velocities for better exploration-exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.1351990395251076, "feedback": "The algorithm QIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "9d171c91-4ddc-4523-807c-7b179a4b8758", "metadata": {"aucs": [0.13602713390611154, 0.13389991021939462, 0.1356700744498166]}, "mutation_prompt": null}
