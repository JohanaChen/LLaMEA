{"id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with Differential Evolution for enhanced exploration and exploitation in global optimization problems.", "configspace": "", "generation": 0, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "4e08bd1e-00a9-442b-b555-17951de195ae", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9  # Changed from 0.7 to 0.9 for improved convergence\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE by fine-tuning the inertia weight to improve balance between exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "217ad41d-2989-4103-857f-63b4387ccbe8", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            self.inertia = 0.9 - 0.7 * (func_eval_count / self.budget)  # Dynamic inertia weighting\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Introduced a dynamic inertia weighting strategy to balance the exploration and exploitation phases in QuantumPSODE.", "configspace": "", "generation": 2, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "7066fe74-46df-4cac-bac6-dacc84bf8940", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.initial_inertia = 0.9  # Updated initial inertia for dynamism\n        self.final_inertia = 0.4\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            inertia = self.initial_inertia - ((self.initial_inertia - self.final_inertia) * (func_eval_count / self.budget))\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with a dynamic inertia weight to balance exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "442b7ce1-0800-43ce-ab05-54d3a3fdbf3c", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia = 0.4 + 0.3 * (1 - func_eval_count / self.budget)  # Self-adaptive inertia weight\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Introduced self-adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 4, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "c12a558a-e994-4e14-bd09-177ae1b81b3a", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.8  # Adjusted from 1.5 for better convergence\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced global optimization by adjusting cognitive coefficient for improved convergence.", "configspace": "", "generation": 5, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "b6dbbbe3-e7e2-4287-a343-d3a18d05cb27", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Change: Dynamic inertia\n                self.velocities[i] = ((0.5 + 0.2 * (self.budget - func_eval_count) / self.budget) * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE by adjusting the inertia weight dynamically for better balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "8dfb5aa1-32b9-4cd2-9894-6574c45b1e17", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia = 0.7 - 0.5 * (func_eval_count / self.budget)  # Adaptive inertia\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Add adaptive inertia adjustment to enhance convergence by dynamically updating the inertia weight. ", "configspace": "", "generation": 7, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "e2a843f3-2bb8-4b29-8d68-b01e44f0c86d", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Adaptive inertia: gradually reduce inertia over time\n                self.inertia = max(0.4, 0.7 * (1 - func_eval_count / self.budget))\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "QuantumPSODE with adaptive inertia for improved convergence by dynamically adjusting exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "32b3c1ce-1ce2-4fe0-a5fb-18a8bab39fbb", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 20 + 2 * int(np.sqrt(dim))  # Increased particle count\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE by increasing the swarm size for better exploration.", "configspace": "", "generation": 9, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "6020b9be-1f08-4315-8a5e-05af738dbd54", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            # Adaptive inertia adjustment\n            self.inertia = 0.4 + 0.3 * (1 - func_eval_count / self.budget)\n            # Diversity preservation mechanism\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Add small random noise\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with adaptive inertia and population diversity preservation for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.0874295116293989, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.00.", "error": "", "parent_id": "331c7c9e-c122-4cef-9cd8-555e70bfa496", "metadata": {"aucs": [0.08598930143060668, 0.08958288101122236, 0.08671635244636766]}, "mutation_prompt": null}
{"id": "e8d4a2ed-3510-4c40-bde1-096319c6c89e", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 2 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9  # Start with higher inertia\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.85  # Slightly increased mutation factor\n        self.de_crossover_rate = 0.95  # Slightly increased crossover rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            # Chaotic inertia adjustment using a logistic map\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            # Enhanced diversity preservation\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)  # Increase noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with chaotically adaptive inertia and exploration-exploitation balance for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.09486083116861595, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.00.", "error": "", "parent_id": "6020b9be-1f08-4315-8a5e-05af738dbd54", "metadata": {"aucs": [0.09683733322086086, 0.09063315680957063, 0.09711200347541638]}, "mutation_prompt": null}
{"id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Adaptive QuantumPSODE with improved diversity through self-adjusting mutation and dynamic particle count for enhanced exploration and convergence.", "configspace": "", "generation": 12, "fitness": 0.09862743866762531, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.00.", "error": "", "parent_id": "e8d4a2ed-3510-4c40-bde1-096319c6c89e", "metadata": {"aucs": [0.09964509526075127, 0.09631145522888085, 0.09992576551324384]}, "mutation_prompt": null}
{"id": "b558ab7e-c718-4993-8517-0d758c394a69", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        penalty_coeff = 0.1  # Added penalty coefficient for boundary handling\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i]) + penalty_coeff * np.sum(np.maximum(0, self.pop[i] - ub))\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = max(0.4, 0.9 - 0.5 * (func_eval_count / self.budget))  # Adaptive inertia\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                quantum_tunneling = np.random.normal(0, 0.1, self.pop.shape)  # Quantum tunneling\n                self.pop += quantum_tunneling \n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced Particle Swarm Optimization with Quantum Tunneling and Adaptive Learning Rates to balance exploration and exploitation for photonic structure optimization.", "configspace": "", "generation": 13, "fitness": 0.09114803230833705, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.0888150088559152, 0.09178720158796538, 0.09284188648113056]}, "mutation_prompt": null}
{"id": "93ad92bb-1ff4-426d-89dd-840728a747e7", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            self.de_mutation_factor *= 0.995  # Introducing mutation factor decay\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Introduced a decay factor for the mutation factor to enhance convergence control over iterations.", "configspace": "", "generation": 14, "fitness": 0.09792244998005366, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.09752590098816194, 0.09637108324065446, 0.09987036571134456]}, "mutation_prompt": null}
{"id": "43e64151-5999-4d73-a672-7561fd16f35c", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia_initial = 0.9\n        self.inertia_final = 0.4\n        self.inertia = self.inertia_initial\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            neighbors = np.random.choice(self.particle_count, 3, replace=False)\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = neighbors\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < self.pbest_scores[i]:\n                        self.pop[i] = trial\n\n            self.inertia = (self.inertia_final + (self.inertia_initial - self.inertia_final) * \n                            ((self.budget - func_eval_count) / self.budget))\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.1 * (1 - func_eval_count / self.budget), self.pop.shape)\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Improved QuantumPSODE by incorporating adaptive inertia and neighborhood-based particle interactions for enhanced exploration and convergence.", "configspace": "", "generation": 15, "fitness": 0.08518165676697494, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.08648916039960752, 0.08098578847192717, 0.08807002142939013]}, "mutation_prompt": null}
{"id": "e8658fdb-bb77-4157-a6d5-ef9ed5da16fb", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5  # Dynamic adjustment added here\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE by dynamically adjusting the cognitive coefficient for improved balance between exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.09862743866762531, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.09964509526075127, 0.09631145522888085, 0.09992576551324384]}, "mutation_prompt": null}
{"id": "164912db-eb22-49b2-8114-0039fbbf67d2", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 12 + 2 * int(np.sqrt(dim))  # Changed initialization strategy\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.8  # Adjusted inertia for improved balance\n        self.cognitive_coeff = 2.0  # Enhanced learning component\n        self.social_coeff = 1.3\n        self.de_mutation_factor = 0.8  # Adaptive mutation factor\n        self.de_crossover_rate = 0.85  # Modified crossover rate for exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        momentum = np.zeros(self.dim)  # Added momentum component\n        alpha = 0.01  # Momentum learning rate\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i] + alpha * momentum  # Integrated momentum\n                momentum = 0.9 * momentum + self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.6 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)  # Adjusted inertia schedule\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Adjust noise intensity for escaping local minima\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE using hybrid strategies with differential evolution and adaptive learning for superior global optimization.", "configspace": "", "generation": 17, "fitness": 0.0944322650772856, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.09481971433282765, 0.090067813161266, 0.09840926773776315]}, "mutation_prompt": null}
{"id": "01b90293-d233-475b-b9e5-3a6c76d9451f", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.9 - 0.5 * (func_eval_count / self.budget)  # Changed line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Changed line\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with adaptive inertia and dynamic mutation control to refine exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.09114803230833705, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.0888150088559152, 0.09178720158796538, 0.09284188648113056]}, "mutation_prompt": null}
{"id": "900e603a-1da8-4fdb-85d5-9a8fa6ebe9d6", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Adaptive QuantumPSODE with improved diversity through self-adjusting mutation and dynamic particle count for enhanced exploration and convergence.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.09964509526075127, 0.09631145522888085, 0.09992576551324384]}, "mutation_prompt": null}
{"id": "b7e69832-0ab2-44de-a917-9eba302f7f6e", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n            # Adjust particle count dynamically\n            if func_eval_count / self.budget < 0.5:\n                self.particle_count = min(30, self.particle_count + 1)\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with dynamic particle count adjustment based on convergence rate to improve exploration and exploitation balance.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 16').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 16')", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {}, "mutation_prompt": null}
{"id": "c9650e56-6414-460c-a4ca-01cfbc8d4312", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.5 + 0.5 * np.sin(3.14 * func_eval_count / self.budget) # Adjusted inertia range\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with dynamic inertia range adjustment for improved balance between exploration and exploitation.", "configspace": "", "generation": 21, "fitness": 0.09853940417555292, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.09934789986570591, 0.09647262259847489, 0.09979769006247796]}, "mutation_prompt": null}
{"id": "812e060c-d93b-4fe2-8c00-dfb3f2ea9552", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8  # Adaptive mutation factor\n        self.de_crossover_rate = 0.9  # Adjusted crossover rate\n        self.inertia_decay = 0.99  # Inertia decay factor\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.inertia *= self.inertia_decay  # Decay inertia over time\n            if func_eval_count / self.budget > 0.7 and np.mean(self.pbest_scores) - self.gbest_score < 1e-6:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Reduced noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with adaptive inertia, dynamic mutation factor, and hybrid crossover for improved convergence and exploration.", "configspace": "", "generation": 22, "fitness": 0.08095456355879176, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.08060784562114365, 0.0815772017224694, 0.0806786433327622]}, "mutation_prompt": null}
{"id": "e62ca75e-3f03-49c0-a9a0-8f9d185c79d9", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.8 + 0.2 * np.sin(3.14 * func_eval_count / self.budget)  # Adjusted inertia range\n            if func_eval_count / self.budget > 0.4 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.05, self.pop.shape)  # Adjusted noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with adaptive inertia and noise for improved convergence and exploration in photonic structure optimization.", "configspace": "", "generation": 23, "fitness": 0.09709193304405823, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.09833043628291083, 0.09499366550120547, 0.09795169734805842]}, "mutation_prompt": null}
{"id": "78e246fd-c5e3-431e-bf1c-dc6e3ad569b2", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    tournament = [self.pbest[a], self.pbest[b], self.pbest[c]]\n                    tournament_scores = [func(ind) for ind in tournament]\n                    winner = tournament[np.argmin(tournament_scores)]\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, winner, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced diversity by modifying crossover strategy with tournament selection for better exploration.", "configspace": "", "generation": 24, "fitness": 0.08042481595410056, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.08042481595410056, 0.08042481595410056, 0.08042481595410056]}, "mutation_prompt": null}
{"id": "79dbc971-ae59-46db-b407-342918a2cb67", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n                self.pop[i] = np.clip(self.pop[i], lb, ub)  # Ensure bounds after update\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.5 + 0.4 * np.cos(3.14 * func_eval_count / self.budget)  # Adaptive inertia formula change\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n        return self.gbest", "name": "QuantumPSODE", "description": "QuantumPSODE with adaptive inertia and boundary handling for improved convergence and stability.", "configspace": "", "generation": 25, "fitness": 0.08912328020461531, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.01.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.0957385055016784, 0.08858225880342596, 0.08304907630874159]}, "mutation_prompt": null}
{"id": "7a08b956-db0f-41f7-9afd-e60218a1c08c", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8  # Reduced mutation factor\n        self.de_crossover_rate = 0.9  # Slightly reduced crossover rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        rankings = np.argsort(self.pbest_scores)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            if np.random.rand() < 0.1:  # 10% chance to reorder population\n                self.pop = self.pop[rankings]\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.6 + 0.4 * np.cos(2 * 3.14 * func_eval_count / self.budget)  # Use cos instead of sin\n            if func_eval_count / self.budget > 0.6 and np.mean(self.pbest_scores) - self.gbest_score < 1e-4:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Reduced noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced QuantumPSODE with stochastic ranking and adaptive noise to boost exploration-exploitation balance and convergence speed.", "configspace": "", "generation": 26, "fitness": 0.08451163470455436, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.08342637121057295, 0.08545143505917474, 0.0846570978439154]}, "mutation_prompt": null}
{"id": "a0db5386-32d8-4c0c-89f0-c483751f68c6", "solution": "import numpy as np\n\nclass QuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9  # Adaptive mutation factor\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            if func_eval_count >= self.budget:\n                break\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 * (1 + abs(self.pbest_scores[i] - self.gbest_score) / max(1e-10, abs(self.gbest_score)))  # Dynamic adjustment\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n            \n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)  # Adjust noise intensity\n\n        return self.gbest", "name": "QuantumPSODE", "description": "Enhanced exploration by dynamically adjusting the cognitive coefficient based on the relative difference between personal and global best scores.", "configspace": "", "generation": 27, "fitness": 0.09855392908368417, "feedback": "The algorithm QuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.09947780372706982, 0.09631435676112055, 0.09986962676286215]}, "mutation_prompt": null}
{"id": "2250be68-2aa0-4d80-837c-273af1c63f9b", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, 0.1, self.secondary_swarm.shape)\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced QuantumPSODE with dual-swarm cooperative strategy and adaptive learning to improve convergence and exploration capabilities.", "configspace": "", "generation": 28, "fitness": 0.11596380177335752, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "4d785af4-7ed6-4251-a0c2-fbe5a440f46b", "metadata": {"aucs": [0.1195047817904209, 0.11104457579598892, 0.11734204773366275]}, "mutation_prompt": null}
{"id": "509a9964-c26c-4e80-9cb5-c1dad920920f", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, 0.1, self.secondary_swarm.shape)\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            self.cognitive_coeff = 1.5 + 0.5 * np.sin(3.14 * func_eval_count / self.budget)  # Added line\n            self.social_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)     # Added line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved EnhancedQuantumPSODE by adjusting the cognitive and social coefficients dynamically to enhance learning and adaptability.", "configspace": "", "generation": 29, "fitness": 0.10625531523955227, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "2250be68-2aa0-4d80-837c-273af1c63f9b", "metadata": {"aucs": [0.11163874681610819, 0.10766823138978299, 0.09945896751276562]}, "mutation_prompt": null}
{"id": "3cbcab53-dc7c-4d0a-8839-082faabb179f", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, 0.1, self.secondary_swarm.shape)\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            self.de_mutation_factor = 0.8 + 0.2 * np.cos(3.14 * func_eval_count / self.budget)  # Line modified\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.secondary_swarm += np.random.normal(0, 0.2, self.secondary_swarm.shape)  # Line modified\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced exploration via strategic secondary swarm evolution and adaptive mutation factor.", "configspace": "", "generation": 30, "fitness": 0.10949228952128291, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "2250be68-2aa0-4d80-837c-273af1c63f9b", "metadata": {"aucs": [0.12033823763663942, 0.10586818313387114, 0.10227044779333816]}, "mutation_prompt": null}
{"id": "e02e128d-afcd-4462-bbfc-295c1c90fbbe", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, 0.1, self.secondary_swarm.shape)\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Enhanced perturbation\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced perturbation strategy for improved exploration of the search space.", "configspace": "", "generation": 31, "fitness": 0.11591391964887059, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "2250be68-2aa0-4d80-837c-273af1c63f9b", "metadata": {"aucs": [0.1195047817904209, 0.1108949294225281, 0.11734204773366275]}, "mutation_prompt": null}
{"id": "1ee63492-427f-4927-b42b-df27b9267037", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i] + np.random.normal(0, 0.01, self.dim)  # Added stochastic perturbation\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, 0.1, self.secondary_swarm.shape)\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced exploration by integrating stochastic perturbation in particle positions, improving convergence.", "configspace": "", "generation": 32, "fitness": 0.11056161290184718, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.00.", "error": "", "parent_id": "2250be68-2aa0-4d80-837c-273af1c63f9b", "metadata": {"aucs": [0.11542665413039976, 0.10934362788012775, 0.10691455669501404]}, "mutation_prompt": null}
{"id": "6129eb9a-591c-40b1-aa76-ce15bafcb5db", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1  # Added line 1: Introduce perturbation scale\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)  # Modified line 2\n            perturbation_scale *= 0.99  # Modified line 3: Adaptive perturbation decay\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce stochastic perturbation and adaptive mutation for enhanced exploration and convergence stability.", "configspace": "", "generation": 33, "fitness": 0.11617181476993932, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "2250be68-2aa0-4d80-837c-273af1c63f9b", "metadata": {"aucs": [0.12023854223833008, 0.110875043050921, 0.11740185902056688]}, "mutation_prompt": null}
{"id": "86806d19-8411-4cdf-82b8-4819ac829996", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1  # Added line 1: Introduce perturbation scale\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff * ((1 + np.sin(2 * np.pi * func_eval_count / self.budget)) / 2)) * r2 * (self.gbest - self.pop[i]))  # Modified line 1: Dynamic social coefficient adjustment\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)  # Modified line 2\n            perturbation_scale *= 0.99  # Modified line 3: Adaptive perturbation decay\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce dynamic social coefficient adjustment to improve swarm convergence and diversity.", "configspace": "", "generation": 34, "fitness": 0.11522105660506769, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6129eb9a-591c-40b1-aa76-ce15bafcb5db", "metadata": {"aucs": [0.11573872221668191, 0.1105336289286789, 0.11939081866984225]}, "mutation_prompt": null}
{"id": "55714590-3d4e-48d5-ad46-532c6df38a1f", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            dynamic_mutation_factor = self.de_mutation_factor * (1 - func_eval_count / self.budget)  # Modified line 1: Introduce dynamic mutation scaling\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce dynamic adaptive mutation scaling based on search progress to enhance convergence efficiency.", "configspace": "", "generation": 35, "fitness": 0.11617181476993932, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6129eb9a-591c-40b1-aa76-ce15bafcb5db", "metadata": {"aucs": [0.12023854223833008, 0.110875043050921, 0.11740185902056688]}, "mutation_prompt": null}
{"id": "6880cbbb-6e6e-4e6d-8bb1-1c9612b836a5", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Change 1: Dynamic cognitive and social coefficients\n                self.cognitive_coeff = 1.0 + 0.5 * np.random.rand()\n                self.social_coeff = 1.0 + 0.5 * np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                      self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                      self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce dynamic cognitive and social coefficients for improved adaptability and convergence.", "configspace": "", "generation": 36, "fitness": 0.10850622855291885, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "6129eb9a-591c-40b1-aa76-ce15bafcb5db", "metadata": {"aucs": [0.11084156507201715, 0.11631426873498574, 0.09836285185175364]}, "mutation_prompt": null}
{"id": "8ab37fea-f168-46dc-958c-1daaadfe1fc9", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        chaos_factor = 0.7  # Added line 1: Introduce chaos factor\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     self.cognitive_coeff * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + chaos_factor * np.sin(3.14 * func_eval_count / self.budget)  # Modified line 2: Use chaos factor\n            chaos_factor = 4 * chaos_factor * (1 - chaos_factor)  # Modified line 3: Logistic map for chaos factor\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance exploration by introducing chaotic maps for dynamic parameter adjustment and swarm diversity.", "configspace": "", "generation": 37, "fitness": 0.11061926867680971, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "6129eb9a-591c-40b1-aa76-ce15bafcb5db", "metadata": {"aucs": [0.11965973378848549, 0.110626866678327, 0.10157120556361665]}, "mutation_prompt": null}
{"id": "6368e722-530c-4a6a-9262-bab8c0631552", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)  # Added line 1: Introduce adaptive velocity boundary\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +  # Modified line 2: Dynamic cognitive coefficient\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce dynamic adjustment of cognitive coefficient and adaptive velocity boundary to enhance convergence and exploration.", "configspace": "", "generation": 38, "fitness": 0.1165538198860117, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6129eb9a-591c-40b1-aa76-ce15bafcb5db", "metadata": {"aucs": [0.12031806091459851, 0.11130876468228446, 0.11803463406115211]}, "mutation_prompt": null}
{"id": "f0c9a3ff-095e-4105-8d68-961e8412eaca", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))  # Modified line 1: Dynamic social coefficient\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.995  # Modified line 2: Improved perturbation scale reduction\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce dynamic social coefficient adjustment and improve secondary swarm perturbation reduction to enhance global and local search balance.", "configspace": "", "generation": 39, "fitness": 0.11631320370580238, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.11869880059451798, 0.11019578461623858, 0.12004502590665056]}, "mutation_prompt": null}
{"id": "163996b7-bfc8-4ed4-96a0-d328ada89515", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + (0.8 + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * (self.pbest[b] - self.pbest[c])  # Modified line 1\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (0.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)), self.secondary_swarm.shape)  # Modified line 2\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance solution diversity by introducing a time-varying perturbation scale and adaptive DE mutation factor.", "configspace": "", "generation": 40, "fitness": 0.11640101311629795, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.12046197218222887, 0.11156063922460058, 0.1171804279420644]}, "mutation_prompt": null}
{"id": "c3d7f24f-b643-4471-af53-aa7171448560", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    adaptive_factor = 0.5 + 0.5 * np.sin(3.14 * func_eval_count / self.budget)  # Added line: Adaptive mutation scaling\n                    mutant = self.pbest[a] + adaptive_factor * (self.pbest[b] - self.pbest[c])  # Modified line: Use adaptive factor\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce adaptive mutation scaling in the DE crossover to enhance exploration capabilities.", "configspace": "", "generation": 41, "fitness": 0.11557084499827826, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.11911766346987673, 0.1110896651302633, 0.11650520639469475]}, "mutation_prompt": null}
{"id": "a50337de-52c1-4350-a1b0-33fbb2758906", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        stagnation_threshold = 0.1 * self.budget  # Added line\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n                if func_eval_count % stagnation_threshold == 0:  # Added line\n                    self.velocities += np.random.normal(0, 0.1, self.velocities.shape)  # Added line\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improve solution diversity by introducing a stochastic perturbation to velocity when stagnation is detected.", "configspace": "", "generation": 42, "fitness": 0.1165538198860117, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.12031806091459851, 0.11130876468228446, 0.11803463406115211]}, "mutation_prompt": null}
{"id": "6d6e0d25-e8c8-4ce7-923d-a5eadf7016dd", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) + \n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate * 1.1, mutant, self.pop[i])  # Changed line 1: Enhanced crossover strategy\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.995  # Changed line 2: Adjusted perturbation scale decay\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce secondary swarm diversity by adjusting perturbation scale decay and enhancing crossover strategy.", "configspace": "", "generation": 43, "fitness": 0.11368541410930351, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.01.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.11720443057632257, 0.10654222602408814, 0.11730958572749983]}, "mutation_prompt": null}
{"id": "ab6ca1ea-c204-4191-acb0-01d09ba80ff3", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            # Stochastic ranking of particles based on scores\n            order = np.argsort(self.pbest_scores + np.random.normal(0, 1e-5, self.pbest_scores.shape))  # Added line: introduce stochastic ranking\n            self.pop = self.pop[order]  # Change line: reorder population based on stochastic ranking\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce stochastic ranking to balance exploration and exploitation, while maintaining dynamic coefficients.", "configspace": "", "generation": 44, "fitness": 0.11189701658082056, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.11459846904185977, 0.11445591808116073, 0.10663666261944116]}, "mutation_prompt": null}
{"id": "624ea321-b8d3-4ae2-91a3-33078af6eb07", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        convergence_threshold = 1e-4  # Added line: Introduce threshold for convergence\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < 0.9:  # Modified Crossover Probability\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + 0.8 * (self.pbest[b] - self.pbest[c])  # Modified Mutation Factor\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, self.pop[i])  # Modified Crossover Rate\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.98  # Modified Perturbation Decay\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            # Adjust exploration when convergence is detected\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < convergence_threshold:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Modified Exploration Strategy\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce a two-level convergence mechanism with adaptive exploration to enhance search efficiency and diversity.", "configspace": "", "generation": 45, "fitness": 0.11180671054914264, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.11185813907369901, 0.10660071632763768, 0.1169612762460912]}, "mutation_prompt": null}
{"id": "12a1a889-38b2-4ac3-bee8-5b7f9543801f", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.4 * np.sin(2 * np.pi * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) + \n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))  # Adjusted coefficients for better exploration\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            if np.random.rand() < 0.5:  # Introduce random exploration\n                perturbation = np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n                self.secondary_swarm += perturbation\n            perturbation_scale *= 0.98  # Adjust perturbation decay rate\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.6 + 0.4 * np.cos(2 * np.pi * func_eval_count / self.budget)  # Modulate inertia dynamically\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.1, self.pop.shape)  # Reduced perturbation to avoid premature convergence\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Accelerate convergence by incorporating adaptive control strategies for inertia and perturbation scale, enhancing exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.10937844820913027, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.10608676243864801, 0.1106844879183072, 0.11136409427043559]}, "mutation_prompt": null}
{"id": "96d4a410-817c-4299-bc20-c97df43961d1", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()  # Modified line 1: Add a new random coefficient\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]) +\n                                     r3 * (self.gbest - self.pbest[i]))  # Modified line 2: Use the new coefficient for diversification\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance dynamic adaptation by integrating random acceleration coefficients for improved exploration.", "configspace": "", "generation": 47, "fitness": 0.10960250401611123, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.11139794312316686, 0.11461960133319915, 0.10278996759196768]}, "mutation_prompt": null}
{"id": "e3e6c0b1-86e2-4edd-9f14-11531c7f9f20", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (1.2 + 0.3 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))  # Modified line 1: Adaptive social coefficient\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.98  # Modified line 2: Gradual reduction in perturbation scale\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce adaptive social coefficient and gradual reduction in perturbation scale to enhance solution precision.", "configspace": "", "generation": 48, "fitness": 0.11601479377912256, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.12027470616104063, 0.11057227862634045, 0.11719739654998662]}, "mutation_prompt": null}
{"id": "44ae0c7c-c5b5-4a92-935f-9a08076ffd2a", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (1.2 + 0.3 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))  # Modified line: Dynamic social coefficient\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance exploration by adjusting the social coefficient dynamically.", "configspace": "", "generation": 49, "fitness": 0.11560952811610554, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.11909560146177078, 0.11049196040901654, 0.11724102247752932]}, "mutation_prompt": null}
{"id": "d89800a9-ec37-4f83-91ea-6d530154bd07", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    self.de_mutation_factor = 0.8 + 0.2 * func_eval_count / self.budget  # Modified line 1: Dynamic mutation factor\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Strengthen global exploration by modifying mutation factor dynamically based on evaluation progress.", "configspace": "", "generation": 50, "fitness": 0.11631096503902176, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.12011405135604658, 0.11197239879500742, 0.11684644496601126]}, "mutation_prompt": null}
{"id": "4ddb5a0f-0104-4380-bd8b-ffdf42f9e232", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (1.2 + 0.3 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i))  # Modified line 1: Dynamic social coefficient\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99 * (1 + 0.1 * np.cos(3.14 * func_eval_count / self.budget))  # Modified line 2: Adaptive perturbation scale\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce an adaptive perturbation scale and dynamic social coefficient for improved exploration and convergence.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError(\"closing parenthesis ')' does not match opening parenthesis '['\", ('<string>', 45, 128, '                                     (1.2 + 0.3 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i))  # Modified line 1: Dynamic social coefficient')).", "error": "SyntaxError(\"closing parenthesis ')' does not match opening parenthesis '['\", ('<string>', 45, 128, '                                     (1.2 + 0.3 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i))  # Modified line 1: Dynamic social coefficient'))", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {}, "mutation_prompt": null}
{"id": "c2df11d4-7ae3-4f2e-be6c-a3f0fd2cc2aa", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)  # Added line 1: Introduce adaptive velocity boundary\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +  # Modified line 2: Dynamic cognitive coefficient\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (1 - func_eval_count / self.budget), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Further enhance exploration by dynamically scaling the perturbation in the secondary swarm.", "configspace": "", "generation": 52, "fitness": 0.11617159234637205, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.12013666539868473, 0.1109045554495609, 0.11747355619087052]}, "mutation_prompt": null}
{"id": "35866256-a0e2-4236-b4ab-c22aaff3fc84", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)  # Added line 1: Introduce adaptive velocity boundary\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +  # Modified line 2: Dynamic cognitive coefficient\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale, self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            diversity = np.mean(np.std(self.pop, axis=0))\n            self.inertia = 0.5 + 0.4 * (1 - diversity)  # Modified line for dynamic inertia based on diversity\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Integrate dynamic inertia adjustment based on swarm diversity to foster exploration and convergence balance.", "configspace": "", "generation": 53, "fitness": 0.1106086379992572, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.1159663609396584, 0.10679035229806166, 0.10906920076005155]}, "mutation_prompt": null}
{"id": "1a5d768f-c040-4177-b9c5-e036b25fffd3", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (ub - lb), self.secondary_swarm.shape)  # Enhanced secondary swarm perturbation\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)  # Adaptive inertia update\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduced adaptive inertia and enhanced secondary swarm velocity for improved convergence.", "configspace": "", "generation": 54, "fitness": 0.1301450280069986, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "6368e722-530c-4a6a-9262-bab8c0631552", "metadata": {"aucs": [0.13043747662180782, 0.1297637664082586, 0.13023384099092938]}, "mutation_prompt": null}
{"id": "3e875ea0-5cd1-47bd-b9fb-eae76c316945", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        # Changed mutation factor for enhanced exploration\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()  \n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                # Added adaptive crossover rate adjustment\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c])\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (ub - lb), self.secondary_swarm.shape)  # Enhanced secondary swarm perturbation\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)  # Adaptive inertia update\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced exploration by tuning the mutation factor and crossover rate to adaptively balance diversity and convergence.", "configspace": "", "generation": 55, "fitness": 0.1306949891173741, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "1a5d768f-c040-4177-b9c5-e036b25fffd3", "metadata": {"aucs": [0.13069318517957895, 0.13061751695985424, 0.1307742652126891]}, "mutation_prompt": null}
{"id": "2035b9a9-de0e-4b42-b016-3d21849e58ce", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved exploration and exploitation balance by introducing a Levy flight-inspired mutation strategy and adaptive parameter controls.", "configspace": "", "generation": 56, "fitness": 0.13102435792338932, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "3e875ea0-5cd1-47bd-b9fb-eae76c316945", "metadata": {"aucs": [0.13165802463978615, 0.13126745117606953, 0.1301475979543123]}, "mutation_prompt": null}
{"id": "271b91e7-d4c5-4671-86e2-650125ed1049", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim) + 0.01 * np.random.normal(0, 1, self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved mutation exploration by incorporating Gaussian noise into the mutation step.", "configspace": "", "generation": 57, "fitness": 0.1302959944685502, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2035b9a9-de0e-4b42-b016-3d21849e58ce", "metadata": {"aucs": [0.1305741221143636, 0.13064223040834255, 0.12967163088294442]}, "mutation_prompt": null}
{"id": "734470b4-8b95-4ed0-8040-03146208179d", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved exploration and exploitation balance by introducing a Levy flight-inspired mutation strategy and adaptive parameter controls.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "2035b9a9-de0e-4b42-b016-3d21849e58ce", "metadata": {"aucs": [0.13165802463978615, 0.13126745117606953, 0.1301475979543123]}, "mutation_prompt": null}
{"id": "fad1af57-b129-4380-8759-5f7e99d5b41b", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            self.secondary_swarm += np.random.normal(0, perturbation_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99 * (1 + 0.01 * (1 - func_eval_count / self.budget))  # Adjust perturbation scale\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced exploration by adapting the perturbation scale dynamically based on convergence progress.", "configspace": "", "generation": 59, "fitness": 0.13096105864083044, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2035b9a9-de0e-4b42-b016-3d21849e58ce", "metadata": {"aucs": [0.13140525480628928, 0.13113512788448423, 0.13034279323171782]}, "mutation_prompt": null}
{"id": "530b2844-bd58-4a56-9fa3-e09068cce636", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduced adaptive perturbation scaling for secondary swarm to enhance exploration in later stages.", "configspace": "", "generation": 60, "fitness": 0.13115629848747323, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "2035b9a9-de0e-4b42-b016-3d21849e58ce", "metadata": {"aucs": [0.1313874637763539, 0.13073591817063512, 0.13134551351543067]}, "mutation_prompt": null}
{"id": "e7bde104-a212-4d97-93ef-c3a9c946b66b", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_adaptive = self.inertia * (0.5 + 0.5 * np.random.rand())\n                self.velocities[i] = (inertia_adaptive * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(1.57 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                dynamic_noise = 0.2 * (1 - func_eval_count / self.budget)\n                self.pop += np.random.normal(0, dynamic_noise, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced exploration and exploitation balance using dynamic swarm adjustment and adaptive inertia scaling.", "configspace": "", "generation": 61, "fitness": 0.13083950916110706, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "530b2844-bd58-4a56-9fa3-e09068cce636", "metadata": {"aucs": [0.13171753606867365, 0.1314275636230241, 0.12937342779162342]}, "mutation_prompt": null}
{"id": "ed132db1-fe2b-4cf9-b787-5ac1198ee9bb", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            # Adjusted the inertia factor to vary sinusoidally across the full budget interval\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Optimized exploration by adjusting the inertia factor to vary sinusoidally across the full budget interval.", "configspace": "", "generation": 62, "fitness": 0.13110072911613155, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "530b2844-bd58-4a56-9fa3-e09068cce636", "metadata": {"aucs": [0.13144999264099522, 0.13057591178293826, 0.13127628292446114]}, "mutation_prompt": null}
{"id": "685663ab-7e89-4541-9e90-2bdfac991379", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n        self.cooperation_factor = 0.05\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        task_allocation = np.random.randint(0, 2, size=self.particle_count)\n        mutation_chance = np.linspace(0.1, 0.9, self.particle_count)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                subgroup = self.pop[i] if task_allocation[i] == 0 else self.secondary_swarm[i]\n                subgroup = np.clip(subgroup, lb, ub)\n                score = func(subgroup)\n                func_eval_count += 1\n                if task_allocation[i] == 0:\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest[i] = subgroup.copy()\n                    if score < self.gbest_score:\n                        self.gbest_score = score\n                        self.gbest = subgroup.copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (1.2 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     self.social_coeff * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + mutation_chance[i] * self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += self.cooperation_factor * (self.gbest - self.secondary_swarm) + np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n            task_allocation = np.random.randint(0, 2, size=self.particle_count)  # Dynamic task reassignment\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Integrate cooperative coevolution with dynamic task assignment to enhance adaptability and diversity in solution space.", "configspace": "", "generation": 63, "fitness": 0.13065028741300258, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "530b2844-bd58-4a56-9fa3-e09068cce636", "metadata": {"aucs": [0.13047232938552977, 0.13107776060888177, 0.13040077224459623]}, "mutation_prompt": null}
{"id": "841ab13a-63b9-4485-bd2e-e4714163da15", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Integrated adaptive weighting for the cognitive and social components to enhance convergence speed.", "configspace": "", "generation": 64, "fitness": 0.13129411012110812, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "530b2844-bd58-4a56-9fa3-e09068cce636", "metadata": {"aucs": [0.13139441784027406, 0.1310492977674439, 0.13143861475560636]}, "mutation_prompt": null}
{"id": "9966b716-c586-4df0-81c0-5888d6c87ce9", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                time_factor = func_eval_count / self.budget\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(2 * np.pi * time_factor)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(2 * np.pi * time_factor)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduced a sinusoidal variation in cognitive and social coefficients for better exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": 0.13126264307613741, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "841ab13a-63b9-4485-bd2e-e4714163da15", "metadata": {"aucs": [0.13133416772713657, 0.13099099445024454, 0.1314627670510311]}, "mutation_prompt": null}
{"id": "02ac720e-7852-48b2-a0c7-884c2d843ce8", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.6 * np.cos(3.14 * func_eval_count / self.budget))  # Modified line\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced convergence by refined adaptive scaling in the secondary swarm perturbation.", "configspace": "", "generation": 66, "fitness": 0.13111920840459404, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "841ab13a-63b9-4485-bd2e-e4714163da15", "metadata": {"aucs": [0.13139049341477504, 0.13061763149133432, 0.13134950030767278]}, "mutation_prompt": null}
{"id": "fcc2f44e-51ac-4e79-a2a3-fe80dd534c07", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.6  # Slightly increased the social coefficient\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.1\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved the velocity update formula by slightly increasing the influence of the social component to enhance convergence towards the global best.", "configspace": "", "generation": 67, "fitness": 0.13127798311142957, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "841ab13a-63b9-4485-bd2e-e4714163da15", "metadata": {"aucs": [0.13149188417175495, 0.13095829293858896, 0.13138377222394482]}, "mutation_prompt": null}
{"id": "8b88118a-6ead-4487-a21d-07113d3d3cb4", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced secondary swarm perturbation scale for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.1314206174010311, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "841ab13a-63b9-4485-bd2e-e4714163da15", "metadata": {"aucs": [0.13109996781790478, 0.13122063050592847, 0.13194125387926003]}, "mutation_prompt": null}
{"id": "14f9dfb5-7a05-441a-b989-4c30f045f3a1", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.11  # Adjusted from 0.12 to 0.11\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Fine-tune perturbation scale for better adaptive exploitation.", "configspace": "", "generation": 69, "fitness": 0.1313951997028945, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "8b88118a-6ead-4487-a21d-07113d3d3cb4", "metadata": {"aucs": [0.13135966571844104, 0.13119760851801543, 0.1316283248722271]}, "mutation_prompt": null}
{"id": "91b61392-fdb6-4978-8b0e-fadfececdb09", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.sin(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduced a sinusoidal variation to the cognitive coefficient for better temporal adaptation.", "configspace": "", "generation": 70, "fitness": 0.13149047640402012, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "8b88118a-6ead-4487-a21d-07113d3d3cb4", "metadata": {"aucs": [0.1313093721656705, 0.13118983897512637, 0.13197221807126347]}, "mutation_prompt": null}
{"id": "864910ff-6e90-423a-9f93-143de6dd6a34", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced global exploration by adjusting the cognitive coefficient with cosine variation instead of sinusoidal.", "configspace": "", "generation": 71, "fitness": 0.131590555354167, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "91b61392-fdb6-4978-8b0e-fadfececdb09", "metadata": {"aucs": [0.13142872647180304, 0.13148070983511917, 0.13186222975557882]}, "mutation_prompt": null}
{"id": "591e7b4f-ceb9-4db5-8a41-97eb7c5d2774", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.6 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Fine-tuning the cognitive coefficient adjustment to enhance exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.13154195789115, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.1314388962590476, 0.13133571841458236, 0.1318512589998201]}, "mutation_prompt": null}
{"id": "b4d5daf0-d382-4ff6-848b-8b61ee69fc31", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.15  # Adjusted perturbation scale\n        velocity_bound = 0.1 * (ub - lb)\n        adaptive_learning_rate = 0.1  # New adaptive learning rate\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.3 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i] + adaptive_learning_rate * (self.gbest - self.pop[i])  # Added learning component\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.6 * np.cos(3.14 * func_eval_count / self.budget))  # Adjusted scale\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98  # Adjusted decay rate\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced global exploration by introducing adaptive learning swarm and dynamic perturbations.", "configspace": "", "generation": 73, "fitness": 0.1301110617894767, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.12793927394654736, 0.1309438406040906, 0.13145007081779214]}, "mutation_prompt": null}
{"id": "5591bca4-4db7-4ca4-9554-cb96cedeb5b0", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.15  # Adjusted from 0.12 to 0.15\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Slightly increase the perturbation scale to enhance exploration in later stages.", "configspace": "", "generation": 74, "fitness": 0.13015375469358084, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.12804949850539982, 0.1310909704123221, 0.13132079516302064]}, "mutation_prompt": null}
{"id": "7dd8c02f-d54e-45c4-8bcb-6a457e2e1b63", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.6 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance convergence by fine-tuning the cognitive coefficient variation to improve exploration capabilities.", "configspace": "", "generation": 75, "fitness": 0.13154195789115, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.1314388962590476, 0.13133571841458236, 0.1318512589998201]}, "mutation_prompt": null}
{"id": "0170d140-17f5-41df-9196-e978d793ac39", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n        self.adaptive_velocity_scale = 0.1\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                velocity_bound = self.adaptive_velocity_scale * (ub - lb)\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n                self.adaptive_velocity_scale *= 0.95\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved convergence by incorporating adaptive velocity scaling and hybrid exploration-exploitation strategy.", "configspace": "", "generation": 76, "fitness": 0.1315905553540138, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13142872647180304, 0.13148070983511917, 0.1318622297551192]}, "mutation_prompt": null}
{"id": "dcb7a323-250c-4037-b0f3-77aa1fac6340", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.tanh(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Fine-tune the cognitive coefficient adjustment by using tanh instead of cosine for smoother transitions.", "configspace": "", "generation": 77, "fitness": 0.13148200185874925, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13122588562718673, 0.1313288521523035, 0.13189126779675753]}, "mutation_prompt": null}
{"id": "1656713c-49c7-4998-9fed-f004826aec51", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.55  # Changed line\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved global exploration by adjusting the social coefficient with a slight increase for better convergence.", "configspace": "", "generation": 78, "fitness": 0.13158794734131274, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.1314162070294419, 0.13144379934141837, 0.13190383565307795]}, "mutation_prompt": null}
{"id": "05941f40-d396-4e8a-86e2-4b6ee08bcdda", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] * np.random.uniform(0.9, 1.1) +  # Changed line\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * np.exp(-0.01 * func_eval_count / self.budget)  # Changed line\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduced adaptive perturbation scaling using exponential decay and added stochastic velocity multiplication to enhance exploration.", "configspace": "", "generation": 79, "fitness": 0.13053032113849614, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.1310018301330209, 0.13056742467112248, 0.130021708611345]}, "mutation_prompt": null}
{"id": "6cf9bc77-8a9e-4378-948b-fdeb5eaeff13", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.15  # Adjusted from 0.12 to 0.15\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.7 * np.cos(3.14 * func_eval_count / self.budget))  # Changed from 0.5 to 0.7\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved global convergence by fine-tuning perturbation scaling and exploitation-exploration balance adjustments.", "configspace": "", "generation": 80, "fitness": 0.13069582708503077, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13086143984447063, 0.13054031447947323, 0.13068572693114844]}, "mutation_prompt": null}
{"id": "79d09f7a-f766-4652-af95-e889ec88d3ac", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget) ** 2  # Modified line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Adjust the inertia weight to decay faster in the first half of the iterations for better convergence.", "configspace": "", "generation": 81, "fitness": 0.13139076464195498, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13111865911950782, 0.13124316680811554, 0.1318104679982416]}, "mutation_prompt": null}
{"id": "57741669-9178-4786-a632-53512a58268d", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.7 + 0.3 * np.sin(3.14 * func_eval_count / self.budget)  # Changed line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved global convergence by modifying the inertia weight to increase exploration during the initial phase.", "configspace": "", "generation": 82, "fitness": 0.13147938689897246, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13132678545193543, 0.13130288040352223, 0.13180849484145973]}, "mutation_prompt": null}
{"id": "164743b3-5111-4e83-af57-c7e48e7fb1f5", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.15  # Increased from 0.12 to 0.15\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Slightly increased the perturbation scale for more diverse exploration in search space.", "configspace": "", "generation": 83, "fitness": 0.13015375469358084, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.12804949850539982, 0.1310909704123221, 0.13132079516302064]}, "mutation_prompt": null}
{"id": "2855739a-58e6-47c4-b686-71cbb93c8e2b", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.55 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Slightly increase the cognitive coefficient for better convergence in later stages of optimization.", "configspace": "", "generation": 84, "fitness": 0.13157306891260803, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13142074472051657, 0.13143896617588646, 0.1318594958414211]}, "mutation_prompt": null}
{"id": "0507244a-da9e-4bf9-9761-47db74f47bb0", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff + 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))  # Changed line\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Slightly increased social influence with cosine-based dynamic adaptation to improve global exploration capability.", "configspace": "", "generation": 85, "fitness": 0.13145071005621092, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.1312958013722637, 0.13123571944948176, 0.13182060934688733]}, "mutation_prompt": null}
{"id": "b59bdf2f-7967-4ff4-97b3-aa2fc1dc6db2", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(2 * np.pi * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(2 * np.pi * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +  # Changed line\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.cos(2 * np.pi * func_eval_count / self.budget)  # Changed line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced exploration by further modulating the cognitive coefficient and adaptive inertia weight.", "configspace": "", "generation": 86, "fitness": 0.1314789568072174, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13142691700669507, 0.1312031587840441, 0.13180679463091305]}, "mutation_prompt": null}
{"id": "3974146a-ae17-4f6f-ba75-adaebf6d33d0", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + 0.5 * (self.pbest[b] - self.pbest[c]) + 0.005 * self.levy_flight(self.dim)  # Changed line\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.97  # Changed line\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Improved exploration by incorporating adaptive velocity updates and perturbation in DE.", "configspace": "", "generation": 87, "fitness": 0.1314266300886273, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.1314268720688383, 0.13103868126949314, 0.1318143369275504]}, "mutation_prompt": null}
{"id": "b86704af-c92a-407b-9a90-d3f3e69fa2cd", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.10  # Adjusted from 0.12 to 0.10\n        velocity_bound = 0.15 * (ub - lb)  # Adjusted from 0.1 to 0.15\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.6 * np.cos(3.14 * func_eval_count / self.budget))  # Adjusted from 0.5 to 0.6\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced quantum-inspired PSO by refining velocity updates and perturbation dynamics for improved convergence.", "configspace": "", "generation": 88, "fitness": 0.13114874331086893, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13121453523768367, 0.13092143803794498, 0.13131025665697815]}, "mutation_prompt": null}
{"id": "2df901fe-364c-460d-a30f-19ec3ba941db", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.cos(3.14 * func_eval_count / self.budget)  # Change this line to use sine\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance exploration by adjusting the inertia weight oscillation using sine variation instead of cosine.", "configspace": "", "generation": 89, "fitness": 0.13139677380880965, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.1312277990420495, 0.13120235446538153, 0.13176016791899792]}, "mutation_prompt": null}
{"id": "746b0803-c12c-450c-a771-82b6a46a5587", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12  # Adjusted from 0.1 to 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.5 + 0.5 * np.cos(3.14 * func_eval_count / self.budget)  # Changed line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.2 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.01 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.99\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.2, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced global exploration by adjusting the cognitive coefficient with cosine variation instead of sinusoidal.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13142872647180304, 0.13148070983511917, 0.13186222975557882]}, "mutation_prompt": null}
{"id": "4bceb680-6fe6-4be2-bf79-c6385ed8f694", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)  # Adjusted line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))  # Adjusted line\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)  # Adjusted line\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98  # Adjusted line\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.4 + 0.5 * np.sin(3.14 * func_eval_count / self.budget)  # Adjusted line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)  # Adjusted line\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Adaptive Differential Evolution and Particle Swarm Optimization with dynamic parameter tuning for enhanced convergence.", "configspace": "", "generation": 91, "fitness": 0.13159746653687796, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "864910ff-6e90-423a-9f93-143de6dd6a34", "metadata": {"aucs": [0.13133473622129532, 0.13110494476377155, 0.13235271862556697]}, "mutation_prompt": null}
{"id": "7c32c724-c553-4a39-a5fc-fa2ebf666481", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget + np.pi/4)  # Adjusted line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.4 + 0.5 * np.sin(3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Fine-tuned cognitive coefficient dynamics to enhance convergence rate by adjusting the phase of the cosine function.", "configspace": "", "generation": 92, "fitness": 0.13157513755184325, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "4bceb680-6fe6-4be2-bf79-c6385ed8f694", "metadata": {"aucs": [0.1312220248642395, 0.13115656956689792, 0.13234681822439232]}, "mutation_prompt": null}
{"id": "6d6281ed-3b17-4f74-9d69-d2a910285797", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)  # Adjusted line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))  # Adjusted line\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)  # Adjusted line\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98  # Adjusted line\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)  # Modified line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)  # Adjusted line\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced exploration by modifying the inertia weight oscillation to ensure better diversity and convergence balance.", "configspace": "", "generation": 93, "fitness": 0.13161415463359036, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "4bceb680-6fe6-4be2-bf79-c6385ed8f694", "metadata": {"aucs": [0.1314167246432656, 0.13114633710829682, 0.13227940214920864]}, "mutation_prompt": null}
{"id": "63d53ae8-41e5-4ed4-a201-55649b67d041", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)  # Adjusted line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))  # Adjusted line\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)  # Adjusted line\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.sin(3.14 * func_eval_count / self.budget))  # Changed line\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98  # Adjusted line\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)  # Modified line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)  # Adjusted line\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhanced convergence by refining the adaptive scale perturbation mechanism for improved local search.", "configspace": "", "generation": 94, "fitness": 0.13117252963150774, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "6d6281ed-3b17-4f74-9d69-d2a910285797", "metadata": {"aucs": [0.1315025295565876, 0.13123222807131252, 0.13078283126662316]}, "mutation_prompt": null}
{"id": "1d8cdeb4-4fa9-41b4-ad0a-8f662bda3b6e", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)\n                self.social_coeff = 1.8 - 0.6 * np.sin(3.14 * func_eval_count / self.budget)  # Modified line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Integrate adaptive learning of coefficients into particle velocity update to enhance convergence speed and precision.", "configspace": "", "generation": 95, "fitness": 0.1315615161007436, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "6d6281ed-3b17-4f74-9d69-d2a910285797", "metadata": {"aucs": [0.1312589981736778, 0.13111736580156352, 0.13230818432698943]}, "mutation_prompt": null}
{"id": "89863c15-2097-4504-8014-4ab1d9c0dc94", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)  # Adjusted line\n                stochastic_perturbation = 0.03 * np.random.randn(self.dim)  # New line for stochastic perturbation\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i] + stochastic_perturbation))  # Adjusted line\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)  # Adjusted line\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98  # Adjusted line\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)  # Modified line\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)  # Adjusted line\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance solution updates by introducing stochastic perturbation in the global best step for improved exploration.", "configspace": "", "generation": 96, "fitness": 0.13124326292263644, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "6d6281ed-3b17-4f74-9d69-d2a910285797", "metadata": {"aucs": [0.131087811740083, 0.13065146292135432, 0.131990514106472]}, "mutation_prompt": null}
{"id": "6863ec7b-e734-4de1-af74-313943ea9f7f", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)\n                self.social_coeff = 1.5 + 0.3 * np.sin(2 * 3.14 * func_eval_count / self.budget)  # Adjusted line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Incorporate adaptive social coefficient oscillation for improved convergence dynamics.", "configspace": "", "generation": 97, "fitness": 0.13167663502200402, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "6d6281ed-3b17-4f74-9d69-d2a910285797", "metadata": {"aucs": [0.13133108715681463, 0.1313938350485121, 0.13230498286068537]}, "mutation_prompt": null}
{"id": "dcb160eb-c64e-4308-ad03-73945c6a394c", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)\n                self.social_coeff = 1.5 + 0.3 * np.sin(2 * 3.14 * func_eval_count / self.budget)\n                velocity_bound = 0.1 * (ub - lb) * (1 - func_eval_count / self.budget)  # Adjusted line\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Enhance global exploration by modifying velocity bounds to adaptively tighten over iterations.", "configspace": "", "generation": 98, "fitness": 0.13163036495262714, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "6863ec7b-e734-4de1-af74-313943ea9f7f", "metadata": {"aucs": [0.13132170197767, 0.13126867738388015, 0.13230071549633127]}, "mutation_prompt": null}
{"id": "c125370f-2996-43fd-9fd2-ff0eadd80c26", "solution": "import numpy as np\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.particle_count = 10 + 3 * int(np.sqrt(dim))\n        self.pop = np.random.rand(self.particle_count, dim)\n        self.velocities = np.zeros_like(self.pop)\n        self.pbest = np.copy(self.pop)\n        self.pbest_scores = np.full(self.particle_count, np.inf)\n        self.gbest = None\n        self.gbest_score = np.inf\n        self.inertia = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.de_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.de_crossover_rate = 0.95\n        self.secondary_swarm = np.random.rand(self.particle_count, dim)\n        self.secondary_scores = np.full(self.particle_count, np.inf)\n        self.secondary_gbest = None\n        self.secondary_gbest_score = np.inf\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        func_eval_count = 0\n        perturbation_scale = 0.12\n        velocity_bound = 0.1 * (ub - lb)\n        while func_eval_count < self.budget:\n            for i in range(self.particle_count):\n                self.pop[i] = np.clip(self.pop[i], lb, ub)\n                score = func(self.pop[i])\n                func_eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.pop[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.pop[i].copy()\n\n            for i in range(self.particle_count):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.cognitive_coeff = 1.8 - 0.6 * np.cos(3.14 * func_eval_count / self.budget)\n                self.social_coeff = 1.5 + 0.3 * np.sin(2 * 3.14 * func_eval_count / self.budget)\n                self.velocities[i] = (self.inertia * self.velocities[i] +\n                                     (self.cognitive_coeff + 0.2 * np.sin(3.14 * func_eval_count / self.budget)) * r1 * (self.pbest[i] - self.pop[i]) +\n                                     (self.social_coeff - 0.1 * np.cos(3.14 * func_eval_count / self.budget)) * r2 * (self.gbest - self.pop[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_bound, velocity_bound)\n                self.pop[i] += self.velocities[i]\n\n                if np.random.rand() < (self.de_crossover_rate - 0.05 * np.cos(2 * np.pi * func_eval_count / self.budget)):\n                    a, b, c = np.random.choice(self.particle_count, 3, replace=False)\n                    mutant = self.pbest[a] + self.de_mutation_factor * (self.pbest[b] - self.pbest[c]) + 0.015 * self.levy_flight(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < self.de_crossover_rate, mutant, self.pop[i])\n                    trial = np.clip(trial, lb, ub)\n                    trial_score = func(trial)\n                    func_eval_count += 1\n                    if trial_score < score:\n                        self.pop[i] = trial\n\n            adaptive_scale = perturbation_scale * (1 + 0.5 * np.cos(3.14 * func_eval_count / self.budget))\n            self.secondary_swarm += np.random.normal(0, adaptive_scale * (ub - lb), self.secondary_swarm.shape)\n            perturbation_scale *= 0.98\n            for i in range(self.particle_count):\n                self.secondary_swarm[i] = np.clip(self.secondary_swarm[i], lb, ub)\n                secondary_score = func(self.secondary_swarm[i])\n                func_eval_count += 1\n                if secondary_score < self.secondary_scores[i]:\n                    self.secondary_scores[i] = secondary_score\n                    if secondary_score < self.secondary_gbest_score:\n                        self.secondary_gbest_score = secondary_score\n                        self.secondary_gbest = self.secondary_swarm[i].copy()\n\n            self.inertia = 0.5 + 0.4 * np.sin(2 * 3.14 * func_eval_count / self.budget)\n            if func_eval_count / self.budget > 0.5 and np.mean(self.pbest_scores) - self.gbest_score < 1e-5:\n                self.pop += np.random.normal(0, 0.15, self.pop.shape)\n\n            if self.gbest_score > self.secondary_gbest_score:\n                self.gbest_score = self.secondary_gbest_score\n                self.gbest = self.secondary_gbest.copy()\n\n            self.de_mutation_factor = 0.9 + 0.2 * np.sin(3.14 * func_eval_count / self.budget)  # Adjusted line\n\n        return self.gbest", "name": "EnhancedQuantumPSODE", "description": "Introduce dynamic adjustment to the mutation factor for enhanced adaptability.", "configspace": "", "generation": 99, "fitness": 0.13148391694649866, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "6863ec7b-e734-4de1-af74-313943ea9f7f", "metadata": {"aucs": [0.1310628028456411, 0.13105170636843377, 0.13233724162542115]}, "mutation_prompt": null}
