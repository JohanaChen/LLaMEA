{"id": "ad4698ed-401b-45be-a0e3-a3378a8fd5e8", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = 10\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += population_size\n\n        while self.evaluations < self.budget:\n            # Adaptive neighborhood size\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - self.evaluations / self.budget))\n            \n            # Quantum-inspired superposition and collapse\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Create a new candidate solution by quantum jump\n                new_candidate = population[i] + np.random.uniform(-1, 1, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                # Selection: Replace if the new candidate is better\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Adaptive Neighborhood Search with Quantum-Inspired Dynamics, leveraging both local exploitation and global exploration by dynamically adapting neighborhood sizes and jumping using quantum superposition principles.", "configspace": "", "generation": 0, "fitness": 0.12692800363888704, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.12670804699684624, 0.12919839564109836, 0.12487756827871654]}, "mutation_prompt": null}
{"id": "cdb160ba-f760-4ac8-9975-a5461905ec73", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            # Adaptive neighborhood size\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - self.evaluations / self.budget))\n            \n            # Dynamic population resizing\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and collapse\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Create a new candidate solution by quantum jump\n                new_candidate = population[i] + np.random.uniform(-1, 1, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                # Selection: Replace if the new candidate is better\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Quantum-Inspired Optimizer with Dynamic Population Resizing, enhancing exploration efficiency by adapting population size based on optimization progress and diversity.", "configspace": "", "generation": 1, "fitness": 0.12844261342343063, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "ad4698ed-401b-45be-a0e3-a3378a8fd5e8", "metadata": {"aucs": [0.1291527430168926, 0.13059384644857752, 0.12558125080482174]}, "mutation_prompt": null}
{"id": "7f9e7e84-1581-45b1-9e20-a56e17c0af69", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Quantum-Inspired Adaptive Mutation Optimizer, introducing adaptive mutation based on solution quality to enhance local exploration and convergence.", "configspace": "", "generation": 2, "fitness": 0.134358794624412, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cdb160ba-f760-4ac8-9975-a5461905ec73", "metadata": {"aucs": [0.13503274622895267, 0.13416354559969346, 0.13388009204458984]}, "mutation_prompt": null}
{"id": "721d292d-40b0-4262-8163-3c1d70d3be2b", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        elite_fraction = 0.1  # Added: Fraction of elite solutions to retain\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Preserve elite solutions\n            elite_count = max(1, int(elite_fraction * len(population)))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elites = population[elite_indices]\n\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n            \n            # Reinstate elite solutions\n            population[:elite_count] = elites\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Quantum-Inspired Optimizer with Elite Preservation, introducing elite solutions retention to enhance convergence and stability.", "configspace": "", "generation": 3, "fitness": 0.13434176259582106, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7f9e7e84-1581-45b1-9e20-a56e17c0af69", "metadata": {"aucs": [0.1350881489326925, 0.13358357820111288, 0.13435356065365778]}, "mutation_prompt": null}
{"id": "c85717b7-9a7b-4658-839f-3642b61a5b4c", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            fitness_range = np.max(fitness) - np.min(fitness) + 1e-10\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * np.log(1 + fitness_range)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.1 + 0.9 * (fitness[i] - best_fitness) / fitness_range\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhanced Quantum-Inspired Optimizer with Dynamic Population Sizing and Adaptive Mutation based on Fitness Diversity.", "configspace": "", "generation": 4, "fitness": 0.1340192175657663, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7f9e7e84-1581-45b1-9e20-a56e17c0af69", "metadata": {"aucs": [0.13436994268466484, 0.1327682055806111, 0.13491950443202294]}, "mutation_prompt": null}
{"id": "e35c8ea1-8cef-4126-92e0-b5041f0f15ee", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            progress_ratio = self.evaluations / self.budget\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - progress_ratio ** 2))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - progress_ratio ** 1.5)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                distance_to_bounds = np.minimum(population[i] - lb, ub - population[i])\n                mutation_strength = np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size * distance_to_bounds / (ub - lb)\n                new_candidate = population[i] + mutation_strength\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Hybrid Quantum-Inspired Optimizer with Dynamic Neighborhoods, enhancing local exploration by dynamically adjusting population size and mutation based on convergence trends and distance to bounds.", "configspace": "", "generation": 5, "fitness": 0.13389137872797527, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7f9e7e84-1581-45b1-9e20-a56e17c0af69", "metadata": {"aucs": [0.13453817357865117, 0.13212456839544973, 0.1350113942098249]}, "mutation_prompt": null}
{"id": "1437e438-972e-4f77-86c3-7bbabb9e172e", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n        regroup_interval = max(10, self.budget // 10)\n        iteration = 0\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n            \n            # Diversity boost through periodic regrouping\n            iteration += 1\n            if iteration % regroup_interval == 0:\n                random_indices = np.random.permutation(len(population))\n                population = population[random_indices]\n                fitness = fitness[random_indices]\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Quantum-Inspired Adaptive Mutation Optimizer with Diversity Boost, adding diversity maintenance through periodic regrouping to enhance global exploration and prevent premature convergence.", "configspace": "", "generation": 6, "fitness": 0.134358794624412, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7f9e7e84-1581-45b1-9e20-a56e17c0af69", "metadata": {"aucs": [0.13503274622895267, 0.13416354559969346, 0.13388009204458984]}, "mutation_prompt": null}
{"id": "c47f5272-0c5c-4d19-93f3-5809b57dc02a", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.1 + 0.8 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition, Lévy flights, and elite preservation\n            best_fitness = np.min(fitness)\n            best_individual = population[np.argmin(fitness)]\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                levy_flight = np.random.standard_cauchy(self.dim)  # Lévy flight\n                new_candidate = population[i] + levy_flight * (best_individual - population[i]) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhanced Quantum-Inspired Optimizer with Lévy Flights and Elite Preservation for improved exploration and faster convergence.", "configspace": "", "generation": 7, "fitness": 0.1186533504708323, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.01.", "error": "", "parent_id": "7f9e7e84-1581-45b1-9e20-a56e17c0af69", "metadata": {"aucs": [0.11887978504153252, 0.12656595172985652, 0.11051431464110784]}, "mutation_prompt": null}
{"id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget)) # Changed 0.1 to 0.05\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10) # Changed 0.1 to 0.05\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhancing Quantum-Inspired Optimizer by introducing accelerated convergence through dynamic neighborhood adjustment.", "configspace": "", "generation": 8, "fitness": 0.13471127413105588, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7f9e7e84-1581-45b1-9e20-a56e17c0af69", "metadata": {"aucs": [0.1354622420557916, 0.1337088989364864, 0.13496268140088963]}, "mutation_prompt": null}
{"id": "9cf3d002-a60e-4066-a011-397a4e5cf28d", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            gradient_step = 0.01 * (ub - lb) # Adding gradient-based local search\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate += gradient_step * (fitness[i] - best_fitness) # Local search adjustment\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Introducing a dynamic quantum neighborhood adaptation using a gradient-based local search to improve convergence speed.", "configspace": "", "generation": 9, "fitness": 0.13466998368713856, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "metadata": {"aucs": [0.1353781649552297, 0.133747379853149, 0.134884406253037]}, "mutation_prompt": null}
{"id": "2cb761f6-5eec-433b-9355-df2cbe25b806", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            diversity_factor = np.std(population, axis=0) / (ub - lb + 1e-10)\n            adjusted_neighborhood = neighborhood_size * (1 + 0.5 * (1 - np.mean(diversity_factor)))\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * adjusted_neighborhood\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Introducing adaptive population diversity management to enhance exploration and convergence in QuantumInspiredOptimizer.", "configspace": "", "generation": 10, "fitness": 0.13467455950614207, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "metadata": {"aucs": [0.13555243686382756, 0.13426831304905995, 0.13420292860553873]}, "mutation_prompt": null}
{"id": "eafe3e75-929e-49b3-a51e-98fe4e2eb13a", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            if self.evaluations > self.budget * 0.7 and np.std(fitness) < 1e-3: # Early convergence strategy\n                new_individuals = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += initial_population_size\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.7 * (1 - self.evaluations / self.budget))) # Adjusted growth\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Improved Quantum-Inspired Optimizer with dynamically adjusted population diversity and strategic reinitialization.", "configspace": "", "generation": 11, "fitness": 0.13383621885199085, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "metadata": {"aucs": [0.13448743536625418, 0.1332283359072599, 0.13379288528245847]}, "mutation_prompt": null}
{"id": "6f2434d4-92ce-4059-ad4e-c86319978df7", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n        \n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.7 * (1 - self.evaluations / self.budget))) # Changed 0.5 to 0.7\n            num_elites = max(1, population_size // 5) # Added elite-based selection\n            sorted_indices = np.argsort(fitness)\n            elites = population[sorted_indices[:num_elites]]\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                elite_individual = elites[np.random.randint(num_elites)] # Introduced elite guidance\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate + 0.1 * (elite_individual - population[i]), lb, ub) # Adjusted candidate creation\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Improved Quantum-Inspired Optimizer by introducing dynamic population scaling and elite-based selection for enhanced exploration and convergence.", "configspace": "", "generation": 12, "fitness": 0.13368510340462733, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "metadata": {"aucs": [0.13435241850485724, 0.13332872903573045, 0.13337416267329427]}, "mutation_prompt": null}
{"id": "cf7de062-9cc8-4d3c-bd2b-5cad0c3ba7ec", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            diversity_factor = np.std(fitness) / (np.mean(fitness) + 1e-10)  # new line\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                adaptive_mutation *= (1 + diversity_factor)  # changed line\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhance convergence by adjusting mutation adaptively using population diversity as a factor.", "configspace": "", "generation": 13, "fitness": 0.13446687666736926, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "metadata": {"aucs": [0.1353434283410958, 0.13289950562370068, 0.13515769603731131]}, "mutation_prompt": null}
{"id": "bd10411d-bd33-4648-8712-98512e5fc707", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            worst_fitness = np.max(fitness)\n            elite_indices = fitness < (best_fitness + (worst_fitness - best_fitness) / 2)  # Changed to half of the range\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                if elite_indices[i]:  # Recombine elite individuals\n                    partner_idx = np.random.choice(np.where(elite_indices)[0])\n                    new_candidate = (population[i] + population[partner_idx]) / 2  # Recombination\n                else:\n                    adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (worst_fitness - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                \n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Introducing a dynamic convergence accelerator by updating the population with elite recombination and variable mutation intensity.", "configspace": "", "generation": 14, "fitness": 0.1328603560771681, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "metadata": {"aucs": [0.13406629439457873, 0.13044261992688977, 0.1340721539100358]}, "mutation_prompt": null}
{"id": "481dd805-9b9a-47f6-84fe-97d129745158", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.04 + 0.96 * (1 - self.evaluations / self.budget)) # Changed 0.05 to 0.04\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Refining Quantum-Inspired Optimization by enhancing neighborhood size scaling to improve exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.13473060839326143, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "9ede0a4d-61f3-4566-8e98-bbf89820514c", "metadata": {"aucs": [0.13546638357967244, 0.1337604729922638, 0.134964968607848]}, "mutation_prompt": null}
{"id": "0aed0222-70d2-4b00-bbd7-7efe49d89cec", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity\n            neighborhood_size = (ub - lb) * (0.06 + 0.94 * (1 - self.evaluations / self.budget))  # Changed 0.04 to 0.06\n            population_size = int(initial_population_size * (1 + diversity))  # Dynamic resizing based on diversity\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                partner_idx = np.random.choice(population_size)  # Select a random partner\n                trial_vector = population[i] + 0.5 * (population[partner_idx] - population[i])  # DE-inspired crossover\n                trial_vector = np.clip(trial_vector, lb, ub)\n                new_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhance Quantum-Inspired Optimization by introducing dynamic population resizing based on diversity and integrating differential evolution-inspired crossover for improved performance.", "configspace": "", "generation": 16, "fitness": 0.12963083827402214, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "481dd805-9b9a-47f6-84fe-97d129745158", "metadata": {"aucs": [0.12949207422096154, 0.12919413021060822, 0.13020631039049668]}, "mutation_prompt": null}
{"id": "4b67128d-7256-4d4f-9746-c7069233e953", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 12  # Changed from 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))  # Changed 0.04 to 0.03\n            population_size = int(initial_population_size * (1 + 0.6 * (1 - self.evaluations / self.budget)))  # Changed from 0.5\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            # Quantum-inspired superposition and adaptive mutation\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                fitness_range = np.max(fitness) - best_fitness + 1e-10\n                adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / fitness_range  # Changed from 0.05\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhanced Quantum-Inspired Optimization with Dynamic Fitness Scaling and Neighborhood Adjustment to Boost Convergence.", "configspace": "", "generation": 17, "fitness": 0.1341721813182052, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "481dd805-9b9a-47f6-84fe-97d129745158", "metadata": {"aucs": [0.13578289151596268, 0.13237278999719215, 0.13436086244146084]}, "mutation_prompt": null}
{"id": "f6a6e97c-bc0a-42ec-94bd-4145423be1da", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.04 + 0.96 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                crossover_prob = 0.9 * (1 - self.evaluations / self.budget)  # New adaptive crossover rate\n                if np.random.rand() < crossover_prob:\n                    partner_idx = np.random.randint(0, population_size)\n                    new_candidate = 0.5 * (population[i] + population[partner_idx])\n                else:\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhanced Quantum-Inspired Optimization by integrating adaptive crossover to improve genetic diversity.", "configspace": "", "generation": 18, "fitness": 0.13467891411300015, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "481dd805-9b9a-47f6-84fe-97d129745158", "metadata": {"aucs": [0.13461133783414714, 0.13365896858213155, 0.13576643592272175]}, "mutation_prompt": null}
{"id": "72f9b2cf-23ce-40cf-b14d-327dd98d4a52", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        restart_interval = self.budget // 5  # New line: Introducing periodic restart\n        while self.evaluations < self.budget:\n            if self.evaluations % restart_interval == 0:  # New line: Condition for restarting\n                population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.evaluations += initial_population_size\n                continue  # New line: Restarting the loop after refreshing the population\n            \n            neighborhood_size = (ub - lb) * (0.04 + 0.96 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Introducing periodic restart strategy to enhance exploration in Quantum-Inspired Optimization by refreshing the population every few iterations.", "configspace": "", "generation": 19, "fitness": 0.1343864369096076, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "481dd805-9b9a-47f6-84fe-97d129745158", "metadata": {"aucs": [0.13521772639727914, 0.13319572751523157, 0.13474585681631213]}, "mutation_prompt": null}
{"id": "40a453f5-9017-457c-a3b4-c0a9e1536d92", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 12 # Changed from 10 to 12\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget)) # Changed 0.04 to 0.035\n            population_size = int(initial_population_size * (1.2 + 0.3 * (1 - self.evaluations / self.budget))) # Changed scaling formula\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10) # Changed mutation range\n                new_candidate = population[i] + np.random.normal(0, adaptive_mutation, self.dim) * neighborhood_size # Changed mutation method\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "QuantumInspiredOptimizer", "description": "Enhanced Quantum-Inspired Optimization incorporating dynamic population scaling and a novel mutation strategy to improve convergence.", "configspace": "", "generation": 20, "fitness": 0.1326865221147178, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "481dd805-9b9a-47f6-84fe-97d129745158", "metadata": {"aucs": [0.1336019549841856, 0.13338412382744125, 0.13107348753252657]}, "mutation_prompt": null}
{"id": "cbc34c0e-9a9c-43cb-b883-70317889699f", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.03 + 0.97 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance diversity and convergence by introducing quantum-inspired genetic operators with adaptive crossover and mutation rates.", "configspace": "", "generation": 21, "fitness": 0.13517276610111248, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "481dd805-9b9a-47f6-84fe-97d129745158", "metadata": {"aucs": [0.13515756770798348, 0.13600924024566108, 0.13435149034969285]}, "mutation_prompt": null}
{"id": "fd8858b2-525b-429c-a89f-1c1ce4f096c9", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            best_individual = population[np.argmin(fitness)]  # Track the best individual\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.03 + 0.97 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n            \n            if np.min(fitness) > best_fitness:  # Retain the best individual\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Integrate an elitism strategy to retain the best individual throughout the evolutionary process to improve convergence.", "configspace": "", "generation": 22, "fitness": 0.13517276610111248, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "cbc34c0e-9a9c-43cb-b883-70317889699f", "metadata": {"aucs": [0.13515756770798348, 0.13600924024566108, 0.13435149034969285]}, "mutation_prompt": null}
{"id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Slight increase in mutation scale\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Tune mutation scale by slightly increasing its influence to promote exploration.", "configspace": "", "generation": 23, "fitness": 0.1355765129327713, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "cbc34c0e-9a9c-43cb-b883-70317889699f", "metadata": {"aucs": [0.13561805546928551, 0.13598969781331294, 0.1351217855157154]}, "mutation_prompt": null}
{"id": "c4dbe856-44e3-45ff-b9b3-3b1d083e315f", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.03 + 0.97 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Slight increase in mutation scale\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Slightly adjust the adaptive mutation scale coefficient to enhance exploration.", "configspace": "", "generation": 24, "fitness": 0.13517276610111248, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13515756770798348, 0.13600924024566108, 0.13435149034969285]}, "mutation_prompt": null}
{"id": "98093404-877f-4e20-b576-d1e407ac85cc", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (1 - self.evaluations / self.budget)  # Altered crossover rate based on progress\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by adjusting crossover probability based on evaluation progress.", "configspace": "", "generation": 25, "fitness": 0.1337471053600284, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13547488913058325, 0.13323862908172301, 0.1325277978677789]}, "mutation_prompt": null}
{"id": "cae14a31-ed5b-4f7f-adf1-198d99866bba", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 1.0 * (np.std(fitness) / (np.mean(fitness) + 1e-10))  # More dynamic mutation scaling\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Adjust mutation scaling more dynamically based on fitness variance for improved exploration.", "configspace": "", "generation": 26, "fitness": 0.13539013904179012, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13510145209436863, 0.1357933852177945, 0.13527557981320726]}, "mutation_prompt": null}
{"id": "cb7ca9d2-6add-4b50-ab0b-fb0cb8c4f9f8", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))  # Modified line\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Modified line\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Utilize dynamic neighborhood scaling and crossover for enhanced exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.13499184205125603, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13589608617527482, 0.13405412453986565, 0.1350253154386276]}, "mutation_prompt": null}
{"id": "1cf291f1-c16b-4360-a128-bd8c23a10558", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.95 * (1 - self.evaluations / self.budget))  # Change 1\n            population_size = int(initial_population_size * (1 + 0.4 * (1 - self.evaluations / self.budget)))  # Change 2\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                relative_fitness = (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                crossover_rate = 0.15 + 0.85 * relative_fitness  # Change 3\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.03 + 0.97 * relative_fitness  # Change 4\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size  # Change 5\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Integrate dynamic mutation scaling and adaptive crossover to enhance convergence speed.", "configspace": "", "generation": 28, "fitness": 0.1349719802247681, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13574906837574052, 0.13402927631867712, 0.13513759597988673]}, "mutation_prompt": null}
{"id": "ad155cc7-2dcd-42df-b264-3e6539f14e71", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        best_individual = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.1 + 0.9 * (1 - self.evaluations / self.budget))  # Adaptive scaling\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.normal(0, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_fitness = new_fitness\n                        best_individual = new_candidate\n\n        return best_individual, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Integrate adaptive neighborhood scaling and elitist strategy to enhance exploration and convergence.", "configspace": "", "generation": 29, "fitness": 0.13455601896167124, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13459261969555292, 0.13392339095624617, 0.13515204623321464]}, "mutation_prompt": null}
{"id": "3e6328ca-fbcb-42cb-a5a5-5a60ed1072e7", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Change made here\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce diversity by altering the crossover rate scaling to encourage more varied exploration.", "configspace": "", "generation": 30, "fitness": 0.1352081838734658, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13504117774599034, 0.13593253383437442, 0.1346508400400327]}, "mutation_prompt": null}
{"id": "c9f9bcb3-43f3-4a02-be8e-ad33eed377e2", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            best_candidate = population[np.argmin(fitness)]\n\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                \n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n                    if new_fitness < best_fitness:\n                        worst_index = np.argmax(fitness)  # Preserve the elite\n                        population[worst_index] = best_candidate\n                        fitness[worst_index] = best_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce elite preservation by updating the worst current individual with the global best when a better individual is found.", "configspace": "", "generation": 31, "fitness": 0.1348833738045282, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.1358019172495838, 0.13306198965750582, 0.13578621450649497]}, "mutation_prompt": null}
{"id": "ba025045-b75f-455f-a478-9f5d08beca2d", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.4 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n\n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.15 + 0.85 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.03 + 0.97 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce dynamic crossover and neighborhood exploration scaling to enhance convergence speed and solution diversity.", "configspace": "", "generation": 32, "fitness": 0.1351138518847498, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13568032680820974, 0.13408179124367436, 0.13557943760236535]}, "mutation_prompt": null}
{"id": "a9269a74-9b16-4344-bec0-6ce8e6803528", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.02 + 0.08 * np.random.rand() * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.4 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    alpha = np.random.rand(self.dim)\n                    new_candidate = alpha * population[i] + (1 - alpha) * population[partner_idx] \n                else:\n                    adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce adaptive neighborhood size and geometric crossover to balance exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.135169640785441, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13558983338238328, 0.13562711765497748, 0.1342919713189622]}, "mutation_prompt": null}
{"id": "f593422c-2763-4c34-8151-5494ccda3b43", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_fitness = np.min(fitness)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                fitness_improvement_rate = (best_fitness - fitness[i]) / (np.abs(best_fitness) + 1e-10)\n                crossover_rate = 0.1 + 0.9 * fitness_improvement_rate \n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * fitness_improvement_rate \n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic crossover mechanism based on fitness improvement rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.13473410239822636, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13481031678314015, 0.13563242936610698, 0.13375956104543196]}, "mutation_prompt": null}
{"id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce elitism by retaining the best candidates throughout the optimization process.", "configspace": "", "generation": 35, "fitness": 0.1355970007075076, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "27de9ca3-2c66-4caa-b517-91ac74a97d7e", "metadata": {"aucs": [0.13561805546928551, 0.13598969781331294, 0.13518324883992439]}, "mutation_prompt": null}
{"id": "1454a985-d104-4abb-aefe-56463a665f89", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.02 + 0.98 * (1 - self.evaluations / self.budget))\n            population_size = min(15, int(initial_population_size * (1 + 0.4 * (1 - self.evaluations / self.budget))))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point1 = np.random.randint(1, self.dim)\n                    crossover_point2 = np.random.randint(1, self.dim)\n                    crossover_point1, crossover_point2 = min(crossover_point1, crossover_point2), max(crossover_point1, crossover_point2)\n                    new_candidate = np.hstack((population[i][:crossover_point1], \n                                               population[partner_idx][crossover_point1:crossover_point2],\n                                               population[i][crossover_point2:]))\n                else:\n                    adaptive_mutation = 0.03 + 0.97 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic population size adjustment and enhanced crossover strategy to improve convergence speed and solution quality.", "configspace": "", "generation": 36, "fitness": 0.133815485041183, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13400877718537552, 0.1324592883786322, 0.13497838955954133]}, "mutation_prompt": null}
{"id": "65db8bd3-81b7-456f-bd3a-b3e95234b55b", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))  # Changed\n            population_size = int(initial_population_size * (1 + 0.4 * (1 - self.evaluations / self.budget)))  # Changed\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.15 + 0.85 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Changed\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Changed\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance genetic diversity and adaptive mutation to improve convergence speed.", "configspace": "", "generation": 37, "fitness": 0.1349899949436076, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13568084578652861, 0.13379324507691526, 0.13549589396737893]}, "mutation_prompt": null}
{"id": "163404e1-58ed-4af0-93ed-c61625501ad0", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.02 + 0.98 * (1 - (self.evaluations+1) / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce flexible neighborhood sizing dynamically adjusted based on the budget usage.", "configspace": "", "generation": 38, "fitness": 0.13557605954516116, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13554604201935594, 0.13599115335727419, 0.13519098325885337]}, "mutation_prompt": null}
{"id": "1ea83fa9-8848-484d-a8d2-26a0faa18309", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                decay_factor = 0.5 + 0.5 * (self.evaluations / self.budget)\n                crossover_rate = (0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)) * decay_factor\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = (0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)) * decay_factor\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhanced survival pressure by introducing a decay factor for crossover and mutation rates based on budget utilization.", "configspace": "", "generation": 39, "fitness": 0.13539083971365898, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13491498845168826, 0.13568436894470637, 0.13557316174458234]}, "mutation_prompt": null}
{"id": "79679d23-533a-4a85-bfcc-a40158578434", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.4 * (1 - self.evaluations / self.budget)))  # Adjusted from 0.3 to 0.4\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic population scaling factor to better adapt exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 40, "fitness": 0.13489764870216614, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13603944361206832, 0.13348424671804981, 0.13516925577638028]}, "mutation_prompt": null}
{"id": "89c55be5-a9dc-48ed-8203-c902d494bca7", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            best_candidates = population[np.argsort(fitness)[:max(1, int(0.1 * population_size))]] # Modified line\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.choice(len(best_candidates)) # Modified line\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], best_candidates[partner_idx][crossover_point:])) # Modified line\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Incorporate adaptive elitism and a new selection mechanism to enhance convergence.", "configspace": "", "generation": 41, "fitness": 0.1352243285806862, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13606135588914958, 0.13396802025690868, 0.1356436095960003]}, "mutation_prompt": null}
{"id": "34db2bd9-692d-43eb-ac13-6490187840eb", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.02 + 0.98 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.normal(0, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Refine adaptive mutation strategy and enhance elitism retention mechanism.", "configspace": "", "generation": 42, "fitness": 0.1345821519304163, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.1345704902257041, 0.13394142889385585, 0.13523453667168894]}, "mutation_prompt": null}
{"id": "81c7529d-0559-452c-8c03-45f427ccb389", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            diversity = np.std(fitness) / (np.mean(fitness) + 1e-10)\n            neighborhood_size = (ub - lb) * (0.02 + 0.98 * (1 - diversity))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce adaptive neighborhood scaling based on fitness diversity to enhance exploration.", "configspace": "", "generation": 43, "fitness": 0.13484749456787856, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13381680492347403, 0.13570998566411985, 0.13501569311604178]}, "mutation_prompt": null}
{"id": "80b5db25-d778-488c-929c-a5bb53b032c4", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.04 to 0.05\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance mutation by slightly increasing the adaptive_mutation factor for better exploration.", "configspace": "", "generation": 44, "fitness": 0.13593688978030968, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "739b3417-c9b3-46f8-9f64-0adbabe62ff3", "metadata": {"aucs": [0.13626677898570638, 0.1357467509420327, 0.13579713941318994]}, "mutation_prompt": null}
{"id": "af4e0849-c0ae-4ce3-9617-5c0c361d97b9", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            fitness_variance = np.var(fitness)  # New line 1: Calculate fitness variance\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10 + fitness_variance)  # New line 2: Modify crossover_rate with variance\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce dynamic crossover rates based on the current fitness variance to balance exploration and exploitation.", "configspace": "", "generation": 45, "fitness": 0.1355534174183758, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13586093424883183, 0.13572998287014282, 0.1350693351361527]}, "mutation_prompt": null}
{"id": "99bc4e67-2611-437b-a880-c0c7e1508bc8", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            diversity_factor = np.std(population, axis=0).mean() / (ub - lb).mean()  # new line\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.3 + 0.7 * (1 - diversity_factor)  # modified line\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.95 * diversity_factor  # modified line\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic crossover rate and adaptive mutation scale based on population diversity for improved exploration.", "configspace": "", "generation": 46, "fitness": 0.13118176339979795, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13467831516952822, 0.13261594959451883, 0.12625102543534683]}, "mutation_prompt": null}
{"id": "1dbc9c5b-c675-4edb-b81e-6f315109f07b", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            # Dynamic neighborhood resizing strategy\n            neighborhood_size = (ub - lb) * (0.02 + 0.98 * np.exp(-self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Slightly adjusted adaptive_mutation for better exploration\n                    adaptive_mutation = 0.045 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introducing a dynamic neighborhood resizing strategy to improve exploration and exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.13545674738212524, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13596672326846226, 0.13531955860301892, 0.13508396027489455]}, "mutation_prompt": null}
{"id": "29494fe4-e145-4bcb-9edf-8b45c9b98cf6", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            diversity_factor = np.std(population, axis=0).mean()\n            neighborhood_size = (ub - lb) * (0.02 + 0.98 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.4 * diversity_factor))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = (0.05 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)) * (1 + diversity_factor)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce dynamic adaptive mutation based on evolutionary pressure and diversity to enhance exploration-exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.12831818321191843, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.12983695686050822, 0.12795904627289523, 0.1271585465023518]}, "mutation_prompt": null}
{"id": "baf25a86-ac8c-428f-b25b-d8b2e65e2fce", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-10)  # Added diversity factor\n                    adaptive_mutation = 0.04 + fitness_diversity * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Implement a dynamic adaptive mutation mechanism based on the fitness diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.13544937582730432, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13564940879530063, 0.13591668018467873, 0.1347820385019336]}, "mutation_prompt": null}
{"id": "63151af5-bde2-486e-9505-a2e62786c794", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = (0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)) * (1 - self.evaluations / self.budget)  # Introduce dynamic mutation scaling\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic mutation scaling factor to improve exploration adaptively based on budget utilization.", "configspace": "", "generation": 50, "fitness": 0.13564621319916026, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13587047743632386, 0.13562660976104346, 0.13544155240011346]}, "mutation_prompt": null}
{"id": "dbd30d21-c356-4096-8c15-bc08d979b9d5", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.5 * (1 - self.evaluations / self.budget)))  # Adjusted scaling factor\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            probabilities = fitness / np.sum(fitness)\n            selected_indices = np.random.choice(np.arange(population_size), size=population_size, p=probabilities)\n            for i in selected_indices:\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.07 + 0.93 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Adjusted mutation factor\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce dynamic population size adjustment and probabilistic elite selection to enhance exploration and convergence.", "configspace": "", "generation": 51, "fitness": 0.1345781552405413, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13540735266354464, 0.1333285729832434, 0.1349985400748358]}, "mutation_prompt": null}
{"id": "be58fdac-194e-4f0f-8853-199ddb88e5a2", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Refined adaptive_mutation strategy for better performance\n                    adaptive_mutation = 0.05 + 0.95 * (best_fitness - fitness[i]) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Refine the mutation strategy by introducing a more dynamic adaptation based on the best_fitness value.", "configspace": "", "generation": 52, "fitness": 0.13581410464052665, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.1363128363725753, 0.1359491490031145, 0.13518032854589013]}, "mutation_prompt": null}
{"id": "f4b3db44-9ec7-4ece-9e62-b9bef17f733b", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.15 + 0.85 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.06 + 0.94 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by modifying mutation factor and updating crossover rate to improve convergence.", "configspace": "", "generation": 53, "fitness": 0.13586263018831288, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13635496746827658, 0.13562113035573642, 0.1356117927409256]}, "mutation_prompt": null}
{"id": "7ab57c6a-e206-4992-b6e6-f58c9ce70eb2", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n            \n            # Preserve the best solution found so far\n            population[0], fitness[0] = best_solution, best_fitness\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce an elite preservation strategy to maintain the best solution across generations for improved convergence.", "configspace": "", "generation": 54, "fitness": 0.13523821287011142, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13581803523030966, 0.13408021472908427, 0.13581638865094037]}, "mutation_prompt": null}
{"id": "26643682-875d-425c-9028-cd65351d7e9f", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Changed crossover_rate to decrease as the evaluations progress\n                crossover_rate = (0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)) * (1 - self.evaluations / self.budget)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic crossover rate adjustment based on evaluation progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.1357686417628218, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13559879493039417, 0.13583107955867124, 0.13587605079940002]}, "mutation_prompt": null}
{"id": "87a4d083-57bb-400e-949b-f2896d2100ba", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Reduced crossover_rate decay factor from 0.9 to 0.8\n                crossover_rate = 0.1 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Minimize crossover rate decay for improved convergence stability.", "configspace": "", "generation": 56, "fitness": 0.13526937868857178, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13521798553437492, 0.13577198323532835, 0.13481816729601204]}, "mutation_prompt": null}
{"id": "4d82e359-9b04-47c9-aa6c-acbd82c67162", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Increased crossover_rate lower bound slightly from 0.1 to 0.11\n                crossover_rate = 0.11 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Fine-tune crossover rate by increasing its lower bound slightly for improved exploration.", "configspace": "", "generation": 57, "fitness": 0.13564486361870995, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13625448013497587, 0.13532547839837816, 0.13535463232277578]}, "mutation_prompt": null}
{"id": "1e6e58ae-dd9e-4afd-81cc-2d73fb648bb2", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Adjusted crossover_rate\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.choice([j for j in range(population_size) if j != i])  # Ensure different partner\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Improve the exploitation by adjusting the crossover mechanism to balance exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.13527925473019542, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13553365759159064, 0.13548274548612937, 0.13482136111286624]}, "mutation_prompt": null}
{"id": "74ec7cb2-9e0f-4610-9c5a-50e2ff743bed", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.05 to 0.06\n                    adaptive_mutation = 0.06 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Further enhance exploration by slightly increasing the adaptive_mutation factor from 0.05 to 0.06.", "configspace": "", "generation": 59, "fitness": 0.1358288319380677, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13630477991278422, 0.13562879543447737, 0.13555292046694145]}, "mutation_prompt": null}
{"id": "e2435548-74a6-4d6b-a6f8-82a46ad1209f", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.05 to 0.055\n                    adaptive_mutation = 0.055 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Fine-tune adaptive_mutation for improved exploration and exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.13558520078470082, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.1361432417131887, 0.1355350750244434, 0.13507728561647037]}, "mutation_prompt": null}
{"id": "9658da2c-acba-42bf-9ca8-d02600c48011", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.15 + 0.85 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Slight increase for more exploration\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.045 + 0.95 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Slight reduction for balance\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Refine exploration by adjusting crossover and mutation rates for better balance.", "configspace": "", "generation": 61, "fitness": 0.13509588059976815, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13589248881035676, 0.13395650363214495, 0.13543864935680272]}, "mutation_prompt": null}
{"id": "a492a4d5-f2c4-4e2a-9f3c-8f69c03319ca", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            # Random restart mechanism every 20% of the budget\n            if self.evaluations % (self.budget // 5) == 0:\n                population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.evaluations += initial_population_size\n                \n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by incorporating a periodic random restart mechanism to improve diversity.", "configspace": "", "generation": 62, "fitness": 0.135613394884856, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13611022151184848, 0.13515240546391305, 0.13557755767880642]}, "mutation_prompt": null}
{"id": "7adebd86-f306-46a7-a2e6-4dc6e33e9c3d", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            if np.random.rand() < 0.05:  # Introduce random immigrant strategy\n                random_immigrant = np.random.uniform(lb, ub, self.dim)\n                random_immigrant_fitness = func(random_immigrant)\n                self.evaluations += 1\n                if random_immigrant_fitness < best_fitness:\n                    best_solution, best_fitness = random_immigrant, random_immigrant_fitness\n\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Improve exploration by introducing occasional random immigrant strategy.", "configspace": "", "generation": 63, "fitness": 0.13457468380229617, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13544597801644398, 0.13363656583151962, 0.1346415075589249]}, "mutation_prompt": null}
{"id": "4b53ffc6-ebe2-4186-9070-fdb34ba12dcd", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = np.exp(-5 * self.evaluations / self.budget) * (ub - lb)\n            population_size = initial_population_size + int(5 * np.sin(np.pi * self.evaluations / self.budget))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.4 * (1 - self.evaluations / self.budget)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                    new_candidate = np.clip(new_candidate, lb, ub)\n                else:\n                    adaptive_mutation = 0.05 * np.cos(np.pi * self.evaluations / (2 * self.budget))\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                    new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduced a dynamic crossover and mutation strategy based on evaluation progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.13501808552365366, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13512320280577494, 0.13474848588625488, 0.13518256787893113]}, "mutation_prompt": null}
{"id": "945c11f5-afb1-4dcf-afcd-79d493db32b2", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 12  # Increased from 10 to 12\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Slightly increase the initial population size to improve exploration in the early stages.", "configspace": "", "generation": 65, "fitness": 0.13488084448166826, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13534257782543369, 0.13384967972969375, 0.13545027588987735]}, "mutation_prompt": null}
{"id": "a4568607-be84-4abf-9343-b668c5e7616d", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            decay_factor = np.exp(-self.evaluations / self.budget)\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = (0.05 + 0.96 * (fitness[i] - best_fitness) / \n                                         (np.max(fitness) - best_fitness + 1e-10)) * decay_factor\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n            # Elitism: Ensure best solution is retained\n            population[0] = best_solution\n            fitness[0] = best_fitness\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by introducing an exponential decay factor to the adaptive mutation rate and incorporating elitism to retain the best solution.", "configspace": "", "generation": 66, "fitness": 0.13538032791081608, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.1360032582702001, 0.1340752667717494, 0.1360624586904987]}, "mutation_prompt": null}
{"id": "37460997-4daf-453a-9fd5-32cb80a05745", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Changed adaptive_mutation slightly and added differential perturbation\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    differential_perturbation = 0.1 * (best_solution - population[i])\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size + differential_perturbation\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introducing Differential Perturbation for enhanced exploration and convergence speed.", "configspace": "", "generation": 67, "fitness": 0.1358106005065688, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13632361506583035, 0.13576133264648782, 0.1353468538073882]}, "mutation_prompt": null}
{"id": "23965c73-2338-4908-abba-da921a4d0179", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n            population[0] = best_solution  # Elite preservation\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce elite preservation by retaining the best individual in the population after each iteration for enhanced convergence.", "configspace": "", "generation": 68, "fitness": 0.13502707206990705, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13593091737999397, 0.13597729949618464, 0.13317299933354254]}, "mutation_prompt": null}
{"id": "3c953bad-430a-41fe-9316-69da5f8a39d4", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.15 + 0.85 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.04 to 0.05\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Refine convergence by slightly enhancing the crossover rate calculation for better balance between exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.13499274989585883, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13600132009146582, 0.13415527379453274, 0.1348216558015779]}, "mutation_prompt": null}
{"id": "1c44eae0-3514-460e-b456-164e48d2388a", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            diversity = np.std(population, axis=0).mean()  # Line modified\n            base_crossover_rate = 0.1 + 0.9 * (fitness - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Line modified\n            adaptive_mutation = 0.04 + 0.96 * (fitness - best_fitness) / (np.max(fitness) - best_fitness + 1e-10) * (1 - diversity)  # Line modified\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = base_crossover_rate[i] * (1 + diversity)  # Line modified\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation[i], adaptive_mutation[i], self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce dynamic crossover and mutation rates that adapt to the diversity in the population to enhance exploration and exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.12497540996110683, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.01.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.12977926435456089, 0.12990539102769894, 0.11524157450106065]}, "mutation_prompt": null}
{"id": "0bf1ac31-5803-461d-a4ab-60a1d725b1f6", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.05 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Fine-tune crossover rate calculation by decreasing its lower bound to improve convergence speed.", "configspace": "", "generation": 71, "fitness": 0.13441155806655888, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13421628624867843, 0.13469505340983046, 0.13432333454116774]}, "mutation_prompt": null}
{"id": "21ee6743-6e26-4b2f-905a-6167861f80ba", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adjusted crossover rate to include budget-based factor\n                crossover_rate = 0.1 + 0.9 * (1 - self.evaluations / self.budget) * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Improve diversity by altering crossover rate behavior to increase exploration in early stages.", "configspace": "", "generation": 72, "fitness": 0.13590668844202958, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13607847261149053, 0.13589273371653587, 0.13574885899806233]}, "mutation_prompt": null}
{"id": "4705ef44-36ad-42cf-9b25-92e428e5c29e", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size, int(0.7 * self.dim))  # change made here\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Slightly enhance crossover strategy by boosting partner selection variability for improved exploration.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 1 dimension(s) and the array at index 1 has 2 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 1 dimension(s) and the array at index 1 has 2 dimension(s)')", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {}, "mutation_prompt": null}
{"id": "d0426e7c-b332-45b6-8417-9f80b7fa4e59", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                scaled_fitness = (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                crossover_rate = 0.15 + 0.85 * (scaled_fitness)  # Changed from 0.1 to 0.15\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.06 + 0.94 * (scaled_fitness)  # Changed from 0.05 to 0.06\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by adjusting crossover and mutation rates based on dynamic fitness scaling.", "configspace": "", "generation": 74, "fitness": 0.13586263018831288, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13635496746827658, 0.13562113035573642, 0.1356117927409256]}, "mutation_prompt": null}
{"id": "c62901c5-b248-4d01-b188-592b8da2c550", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adjusted crossover rate for dynamic exploration\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Using a small mutation probability for diversity\n                    adaptive_mutation = 0.03 + 0.97 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by dynamically adjusting the crossover rate and using a small mutation probability for further diversity.", "configspace": "", "generation": 75, "fitness": 0.1346155338764556, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.1347864092308021, 0.13402017527030752, 0.1350400171282572]}, "mutation_prompt": null}
{"id": "510f5f54-40a4-4948-895d-890f532f9cfb", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Introduced fitness diversity factor for mutation scaling\n                    diversity = np.std(fitness) / (np.mean(fitness) + 1e-10)\n                    adaptive_mutation = (0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)) * (1 + diversity)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic mutation scaling factor based on the current population fitness diversity to enhance exploration.", "configspace": "", "generation": 76, "fitness": 0.13540710528897448, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13618566048565361, 0.1358987665861482, 0.13413688879512164]}, "mutation_prompt": null}
{"id": "66f66ab9-627d-4422-bfb8-3e590f109bd6", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        # Introducing elitism to retain the best solution found so far\n        while self.evaluations < self.budget:\n            elite = best_solution\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Make adaptive mutation dynamic based on remaining budget\n                    dynamic_factor = 1 - self.evaluations / self.budget\n                    adaptive_mutation = (0.05 + 0.96 * (fitness[i] - best_fitness) / \n                                         (np.max(fitness) - best_fitness + 1e-10)) * dynamic_factor\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            # Elitism: Ensure the best solution is retained\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n            population[0] = elite  # replace worst with elite\n            fitness[0] = func(elite)\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce dynamic adaptive mutation and elitism to improve exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.13486834187950217, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13570753941086966, 0.13411104935589724, 0.13478643687173963]}, "mutation_prompt": null}
{"id": "a1825f91-0202-4345-827e-d8ffc264e71e", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Introduced a dynamic crossover strategy\n                crossover_rate = 0.2 + 0.8 * (best_fitness - fitness[i]) / (best_fitness - np.min(fitness) + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic crossover strategy that increases crossover probability for higher fitness individuals to enhance exploration while maintaining exploitation.", "configspace": "", "generation": 78, "fitness": 0.13427224489506606, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.1348023703898904, 0.13355411603570766, 0.13446024825960012]}, "mutation_prompt": null}
{"id": "4fd84937-8ba7-49af-b1aa-ab046325b0fc", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Increased crossover_rate base value slightly from 0.1 to 0.12\n                crossover_rate = 0.12 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Improve exploration by increasing the crossover_rate base value slightly.", "configspace": "", "generation": 79, "fitness": 0.13519445856209225, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13622325761178944, 0.13374091334573612, 0.13561920472875122]}, "mutation_prompt": null}
{"id": "aaefd66e-fc18-49a8-97b6-bf10f2bcab6a", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 12  # Increased initial population size from 10 to 12\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adaptive crossover rate based on the evaluation progress\n                crossover_rate = 0.1 + 0.9 * (self.evaluations / self.budget) \n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduced adaptive crossover to balance exploration and exploitation, and slightly increased initial population size for better diversity.", "configspace": "", "generation": 80, "fitness": 0.1346378523064008, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13544941141801492, 0.1335649040323147, 0.13489924146887278]}, "mutation_prompt": null}
{"id": "4a57cb84-5617-4a96-bf14-053f1a68097b", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Increased crossover_rate slightly from 0.1 to 0.12\n                crossover_rate = 0.12 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance crossover probability by slightly increasing the crossover_rate factor for better solution exploration.", "configspace": "", "generation": 81, "fitness": 0.13519445856209225, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13622325761178944, 0.13374091334573612, 0.13561920472875122]}, "mutation_prompt": null}
{"id": "cc06b097-a8fc-417b-96f0-12e0880769f1", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.05 + 0.95 * (1 - self.evaluations / self.budget))  # Change 1\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            elite_indices = np.argsort(fitness)[:2]  # Change 2\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.04 to 0.05\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n                    \n            population[elite_indices] = population[np.argsort(fitness)[:2]]  # Change 3\n            \n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by adjusting neighborhood size dynamically and introduce elitism to preserve the best solutions.", "configspace": "", "generation": 82, "fitness": 0.135232019104059, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13623066856326194, 0.13550109735223392, 0.1339642913966811]}, "mutation_prompt": null}
{"id": "459d592b-e885-40c4-affb-684b1f433484", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.05 to 0.06\n                    adaptive_mutation = 0.06 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Further increase the adaptive_mutation factor to enhance exploration capabilities.", "configspace": "", "generation": 83, "fitness": 0.1358288319380677, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13630477991278422, 0.13562879543447737, 0.13555292046694145]}, "mutation_prompt": null}
{"id": "54309e08-34e4-4c52-a9b5-a11ff6ec7f99", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.04 to 0.06\n                    adaptive_mutation = 0.06 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Slightly modify adaptive mutation factor to enhance local exploration.", "configspace": "", "generation": 84, "fitness": 0.1358288319380677, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13630477991278422, 0.13562879543447737, 0.13555292046694145]}, "mutation_prompt": null}
{"id": "8eb9e775-2b3e-487e-ad04-c7018da27ea2", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 11  # Changed from 10 to 11\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Slightly increase the initial_population_size to enhance the diversity of initial solutions.", "configspace": "", "generation": 85, "fitness": 0.13586640603182562, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13614644335476134, 0.13599961431605212, 0.13545316042466338]}, "mutation_prompt": null}
{"id": "9ad26aa9-3f4b-46d9-a59c-73c569aa5cc6", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Increased adaptive_mutation slightly from 0.05 to 0.06\n                    adaptive_mutation = 0.06 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by adjusting mutation to 0.06 for better search space coverage.", "configspace": "", "generation": 86, "fitness": 0.1358288319380677, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13630477991278422, 0.13562879543447737, 0.13555292046694145]}, "mutation_prompt": null}
{"id": "322eb3a3-9209-4a10-80a4-2956d7f67017", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Decreased crossover_rate slightly from 0.1 to 0.09\n                crossover_rate = 0.09 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Slightly decrease the crossover rate to encourage more mutation, enhancing exploration.", "configspace": "", "generation": 87, "fitness": 0.13550022645425086, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.1351327623742833, 0.13579970401487362, 0.13556821297359567]}, "mutation_prompt": null}
{"id": "e59390a7-bc11-4fcb-a235-d0ca580b2aa6", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.03 + 0.97 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            elite_idx = np.argmin(fitness)  # Select the best individual\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                if i == elite_idx:\n                    continue  # Preserve elite\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance convergence by implementing an elite preservation strategy and adjusting crossover dynamics.", "configspace": "", "generation": 88, "fitness": 0.1347964284984059, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.1356497725734691, 0.13365054164286994, 0.13508897127887864]}, "mutation_prompt": null}
{"id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            # Changed neighborhood scaling factor from 0.03 to 0.035\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic neighborhood scaling to improve local exploration without significantly increasing randomness.", "configspace": "", "generation": 89, "fitness": 0.13594213421264953, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "80b5db25-d778-488c-929c-a5bb53b032c4", "metadata": {"aucs": [0.13626634769895996, 0.13575638883356778, 0.13580366610542083]}, "mutation_prompt": null}
{"id": "fa6cafc1-0908-4640-afb7-e1fdb9c018c8", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.15 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Slightly increased crossover rate\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance the balance between exploration and exploitation by slightly increasing the crossover rate, improving overall convergence.", "configspace": "", "generation": 90, "fitness": 0.13561555682099616, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.13592968510418513, 0.13547436825503734, 0.13544261710376604]}, "mutation_prompt": null}
{"id": "ef84f90d-9c1f-45c7-b3e0-8580716177b4", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.1 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Fine-tune the adaptive mutation rate to enhance convergence by increasing its lower bound.", "configspace": "", "generation": 91, "fitness": 0.13502274856238347, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.1355289225754004, 0.13596906584167645, 0.13357025727007354]}, "mutation_prompt": null}
{"id": "dcf1c30b-e85c-4c1f-8be9-31254c43cc23", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.4 * (self.evaluations / self.budget))) \n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    child = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.04 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    child = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                child = np.clip(child, lb, ub)\n                child_fitness = func(child)\n                self.evaluations += 1\n                \n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce adaptive population size and adaptive crossover to balance exploration and exploitation dynamically.", "configspace": "", "generation": 92, "fitness": 0.13436651294481927, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.13522784208138505, 0.1340214099025253, 0.13385028685054745]}, "mutation_prompt": null}
{"id": "58908e56-c273-4bdf-9029-afae3b943e3b", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.1 + 0.85 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Increase adaptive mutation factor for more diverse exploration in later stages of optimization.", "configspace": "", "generation": 93, "fitness": 0.13400324376579165, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.13512224395897354, 0.1351720084748519, 0.1317154788635495]}, "mutation_prompt": null}
{"id": "fc91cf1e-a980-49ca-8bca-4283155a4643", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.2 + 0.8 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)  # Modified line\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Adjusted crossover rate formula to enhance diversity and exploration during optimization.", "configspace": "", "generation": 94, "fitness": 0.13504147635063748, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.13610597570844174, 0.1338538598516399, 0.13516459349183085]}, "mutation_prompt": null}
{"id": "76b2342d-a585-431c-8af6-06e699dc6a92", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Apply stochastic tournament selection for partner\n                candidates = np.random.choice(range(population_size), size=3, replace=False)\n                partner_idx = candidates[np.argmin(fitness[candidates])]\n                crossover_point = np.random.randint(1, self.dim)\n                new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a stochastic tournament selection to enhance diversity and prevent premature convergence.", "configspace": "", "generation": 95, "fitness": 0.1351347576316073, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.1351327844614204, 0.13527351943584498, 0.13499796899755645]}, "mutation_prompt": null}
{"id": "98dfd179-1acd-46f5-aeb8-9f98e76c813d", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            diversity = np.std(population, axis=0).mean() / (ub - lb).mean()\n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.3 + (1.0 - diversity) * 0.7  # changed from 0.1\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.05 + (1.0 - diversity) * 0.95  # changed from 0.96\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n            \n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce adaptive crossover and mutation rates based on solution diversity to enhance exploration-exploitation balance.", "configspace": "", "generation": 96, "fitness": 0.1305323898617853, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.13241634795007073, 0.13032543225135051, 0.1288553893839347]}, "mutation_prompt": null}
{"id": "7314154b-8b44-4df3-b444-30dbdd075819", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Changed crossover_rate calculation to include population diversity\n                diversity_factor = np.std(population) / (ub - lb + 1e-10)\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10) * (1 - diversity_factor)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Changed adaptive_mutation calculation to include population diversity\n                    adaptive_mutation = 0.05 + 0.96 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10) * diversity_factor\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Enhance exploration by dynamically adjusting crossover and mutation rates based on the population diversity.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {}, "mutation_prompt": null}
{"id": "8d696d94-5d0b-4150-8e04-64c886f0ba14", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            neighborhood_size = (ub - lb) * (0.035 + 0.965 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.3 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.1 + 0.9 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    # Changed the scaling factor of adaptive_mutation from 0.96 to 0.98\n                    adaptive_mutation = 0.05 + 0.98 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce a dynamic mutation scaling factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.1357317587020989, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.13624577714142594, 0.13573855715751593, 0.13521094180735482]}, "mutation_prompt": null}
{"id": "090ab871-a305-4207-b177-6e73f843237a", "solution": "import numpy as np\n\nclass EnhancedQuantumGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        initial_population_size = 10\n        population = np.random.uniform(lb, ub, (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_index = np.argmin(fitness)\n        best_solution, best_fitness = population[best_index], fitness[best_index]\n        self.evaluations += initial_population_size\n\n        while self.evaluations < self.budget:\n            # Changed neighborhood scaling factor from 0.035 to 0.04\n            neighborhood_size = (ub - lb) * (0.04 + 0.96 * (1 - self.evaluations / self.budget))\n            population_size = int(initial_population_size * (1 + 0.4 * (1 - self.evaluations / self.budget)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n            else:\n                new_individuals = np.random.uniform(lb, ub, (population_size - len(population), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.evaluations += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                crossover_rate = 0.15 + 0.85 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                if np.random.rand() < crossover_rate:\n                    partner_idx = np.random.randint(0, population_size)\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_candidate = np.hstack((population[i][:crossover_point], population[partner_idx][crossover_point:]))\n                else:\n                    adaptive_mutation = 0.06 + 0.94 * (fitness[i] - best_fitness) / (np.max(fitness) - best_fitness + 1e-10)\n                    new_candidate = population[i] + np.random.uniform(-adaptive_mutation, adaptive_mutation, self.dim) * neighborhood_size\n                new_candidate = np.clip(new_candidate, lb, ub)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < best_fitness:\n                best_solution, best_fitness = population[current_best_index], fitness[current_best_index]\n\n        return best_solution, best_fitness", "name": "EnhancedQuantumGeneticOptimizer", "description": "Introduce adaptive population dynamics and enhanced local search through mutation diversity to improve convergence.", "configspace": "", "generation": 99, "fitness": 0.1355450133191309, "feedback": "The algorithm EnhancedQuantumGeneticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.00.", "error": "", "parent_id": "99501cd4-9c90-405c-8b8c-d13b20f5f29b", "metadata": {"aucs": [0.1356446193173667, 0.13573427435134655, 0.13525614628867944]}, "mutation_prompt": null}
