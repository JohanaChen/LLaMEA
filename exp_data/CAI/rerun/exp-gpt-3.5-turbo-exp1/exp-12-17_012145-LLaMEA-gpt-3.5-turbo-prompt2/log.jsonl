{"id": "c50d57d7-5ab4-44ae-ab52-24979b96c429", "solution": "import numpy as np\n\nclass DynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "DynamicHarmonySearch", "description": "A novel metaheuristic algorithm based on Harmony Search with dynamic parameter adaptation for black box optimization.", "configspace": "", "generation": 0, "fitness": 0.03829573345937688, "feedback": "The algorithm DynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": null, "metadata": {"aucs": [0.07393768451217497, 0.06626757843073705, 0.08492873618815489, 0.020816416452838493, 0.054326413712087906, 0.026670148295119045, 0.05315987676486489, 0.05334213863592763, 0.06894541257626174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011890902552091909, 0.025576535610287277, 9.999999999998899e-05, 0.006051718406725026, 0.005077892708276188, 0.0016866412262092068, 0.029881163257206023, 9.999999999998899e-05, 0.0018728857193461845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03602960276542888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04666766679192347, 0.034589528686543414, 0.044251848057575316, 0.040379710670142566, 0.04802900828643086, 0.03165513849643409, 0.03440396237484489, 0.050603934452395194, 0.026982834521237065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002283153399175508, 9.999999999998899e-05, 9.999999999998899e-05, 0.013047611918399316, 9.999999999998899e-05, 0.10026681181215302, 0.03775217826057542, 0.006845536539381802, 0.004561771729970299, 9.999999999998899e-05, 9.999999999998899e-05, 0.02627668515388637, 9.999999999998899e-05, 0.009907484787565202, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008519894123754645, 0.02195921153675917, 0.03758369257382288, 0.05840862677546954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006387192795206387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.081820342672145, 0.10989622139872046, 0.15089364666279692, 0.09593114858212559, 0.08289476619763614, 0.09754168701657384, 0.12615716563199075, 0.09934903752856228, 0.12290314868703356, 0.0022984585825528425, 9.999999999998899e-05, 9.999999999998899e-05, 0.0166730409546062, 9.999999999998899e-05, 0.03195792427335997, 0.0012233644321281156, 0.00032035650987272124, 0.05242032534719421, 0.07379827899315827, 0.0871653123663273, 0.060278075683834365, 0.10750837692781512, 0.07742903121770783, 0.06650921484319461, 0.07174873552065508, 0.054557240255682315, 0.0845135144260335, 0.10538042741855624, 0.11093986377364085, 0.11158546864322039, 0.11934853096987263, 0.09174682559226444, 0.09511321088693037, 0.13227031127525457, 0.1141378444905029, 0.08586299391761221, 0.050518243971114485, 0.051056955912473834, 0.04076652546645332, 0.0688392384192561, 0.04087448582072051, 0.05081469913402803, 0.06890507912414157, 0.05116362493071369, 0.023903465394679135, 0.14136280217213248, 0.07668862210512017, 0.14887752384581543, 0.1160052745231902, 0.09798518712325732, 0.12776683044456172, 0.12767891204899462, 0.1062265968650592, 0.1449914484728766, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048256137563332024, 0.0583742345152517, 0.06243391871145576, 0.07157005566827446, 0.13064237921636557, 0.0673746159283033, 0.06736834404362291, 0.06095185946778314, 0.05707710410271538, 0.04166183723553896, 0.05151776855326862, 0.017426036025739777, 0.021339263051097457, 0.022622166665608012, 0.05035325300642968, 0.020747349033505058, 0.0166642200760585, 0.05017453061169963, 0.1312637374079597, 0.17615334541631023, 0.17841122830558453, 0.1744976196708049, 0.19526562845515494, 0.1731725365441793, 0.14728755308703745, 0.14454862451749773, 0.22191335032309578, 0.021282014169916708, 0.03831820207266823, 0.05627710358086113, 0.01089487139907086, 0.025834796253276227, 0.014752683624470242, 0.032193350057369896, 0.02474618086758451, 0.028606356027237934]}, "mutation_prompt": null}
{"id": "7e24289a-0ad5-4057-a888-b9c2b1c7a1bc", "solution": "import numpy as np\n\nclass ImprovedDynamicHarmonySearch(DynamicHarmonySearch):\n    def __init__(self, budget, dim, levy_step_size=0.1):\n        super().__init__(budget, dim)\n        self.levy_step_size = levy_step_size\n\n    def levy_flight_step(self):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.math.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1/beta)\n        u = np.random.normal(0, sigma)\n        v = np.random.normal(0, 1)\n        step = u / abs(v)**(1/beta)\n        return step\n\n    def improvise_harmony(self, harmony_memory, par, bandwidth):\n        new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n        for i in range(self.dim):\n            if np.random.uniform() < par:\n                if np.random.rand() < 0.1:\n                    new_harmony[i] += self.levy_step_size * self.levy_flight_step()\n                else:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n        return new_harmony", "name": "ImprovedDynamicHarmonySearch", "description": "Improved DynamicHarmonySearch algorithm by incorporating a Levy flight step for enhanced exploration capability.", "configspace": "", "generation": 1, "fitness": 0.03829573345937688, "feedback": "The algorithm ImprovedDynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "c50d57d7-5ab4-44ae-ab52-24979b96c429", "metadata": {"aucs": [0.07393768451217497, 0.06626757843073705, 0.08492873618815489, 0.020816416452838493, 0.054326413712087906, 0.026670148295119045, 0.05315987676486489, 0.05334213863592763, 0.06894541257626174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011890902552091909, 0.025576535610287277, 9.999999999998899e-05, 0.006051718406725026, 0.005077892708276188, 0.0016866412262092068, 0.029881163257206023, 9.999999999998899e-05, 0.0018728857193461845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03602960276542888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04666766679192347, 0.034589528686543414, 0.044251848057575316, 0.040379710670142566, 0.04802900828643086, 0.03165513849643409, 0.03440396237484489, 0.050603934452395194, 0.026982834521237065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002283153399175508, 9.999999999998899e-05, 9.999999999998899e-05, 0.013047611918399316, 9.999999999998899e-05, 0.10026681181215302, 0.03775217826057542, 0.006845536539381802, 0.004561771729970299, 9.999999999998899e-05, 9.999999999998899e-05, 0.02627668515388637, 9.999999999998899e-05, 0.009907484787565202, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008519894123754645, 0.02195921153675917, 0.03758369257382288, 0.05840862677546954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006387192795206387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.081820342672145, 0.10989622139872046, 0.15089364666279692, 0.09593114858212559, 0.08289476619763614, 0.09754168701657384, 0.12615716563199075, 0.09934903752856228, 0.12290314868703356, 0.0022984585825528425, 9.999999999998899e-05, 9.999999999998899e-05, 0.0166730409546062, 9.999999999998899e-05, 0.03195792427335997, 0.0012233644321281156, 0.00032035650987272124, 0.05242032534719421, 0.07379827899315827, 0.0871653123663273, 0.060278075683834365, 0.10750837692781512, 0.07742903121770783, 0.06650921484319461, 0.07174873552065508, 0.054557240255682315, 0.0845135144260335, 0.10538042741855624, 0.11093986377364085, 0.11158546864322039, 0.11934853096987263, 0.09174682559226444, 0.09511321088693037, 0.13227031127525457, 0.1141378444905029, 0.08586299391761221, 0.050518243971114485, 0.051056955912473834, 0.04076652546645332, 0.0688392384192561, 0.04087448582072051, 0.05081469913402803, 0.06890507912414157, 0.05116362493071369, 0.023903465394679135, 0.14136280217213248, 0.07668862210512017, 0.14887752384581543, 0.1160052745231902, 0.09798518712325732, 0.12776683044456172, 0.12767891204899462, 0.1062265968650592, 0.1449914484728766, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048256137563332024, 0.0583742345152517, 0.06243391871145576, 0.07157005566827446, 0.13064237921636557, 0.0673746159283033, 0.06736834404362291, 0.06095185946778314, 0.05707710410271538, 0.04166183723553896, 0.05151776855326862, 0.017426036025739777, 0.021339263051097457, 0.022622166665608012, 0.05035325300642968, 0.020747349033505058, 0.0166642200760585, 0.05017453061169963, 0.1312637374079597, 0.17615334541631023, 0.17841122830558453, 0.1744976196708049, 0.19526562845515494, 0.1731725365441793, 0.14728755308703745, 0.14454862451749773, 0.22191335032309578, 0.021282014169916708, 0.03831820207266823, 0.05627710358086113, 0.01089487139907086, 0.025834796253276227, 0.014752683624470242, 0.032193350057369896, 0.02474618086758451, 0.028606356027237934]}, "mutation_prompt": null}
{"id": "aba4d43a-7cc1-41a0-98e2-53a49736a433", "solution": "class ImprovedDynamicHarmonySearch(DynamicHarmonySearch):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.explore_prob = 0.2\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n        \n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n            if np.random.uniform() < self.explore_prob:\n                harmony_memory = np.vstack([harmony_memory, new_harmony])\n                self.harmony_memory_size += 1\n\n        return best_solution", "name": "ImprovedDynamicHarmonySearch", "description": "Improved DynamicHarmonySearch algorithm with adaptive memory size for better exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.0349165928355223, "feedback": "The algorithm ImprovedDynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_id": "c50d57d7-5ab4-44ae-ab52-24979b96c429", "metadata": {"aucs": [0.0722780289231596, 0.06461691368170541, 0.08275894024251862, 0.019689000220123987, 0.05295326421122648, 0.025452995248270827, 0.05160002301685085, 0.05175612549909314, 0.06741309326492739, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01710098813850547, 9.999999999998899e-05, 0.0009797476111360615, 0.0021384454767073846, 9.999999999998899e-05, 0.022240090183863304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021790599433225033, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045492765684152614, 0.03380637157085509, 0.04316199873433668, 0.03937346284605425, 0.04705561379158574, 0.03078866774344513, 0.03345936469424271, 0.049174309602413646, 0.026071822432192304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006436603419169851, 9.999999999998899e-05, 9.999999999998899e-05, 0.011574017325500563, 9.999999999998899e-05, 0.10026681181215302, 0.03775217826057542, 0.006491308320532019, 0.004561771729970299, 9.999999999998899e-05, 9.999999999998899e-05, 0.02627668515388637, 9.999999999998899e-05, 0.009907484787565202, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020647676193737974, 9.999999999998899e-05, 0.03837484481222675, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07906827905666525, 0.10729317867349442, 0.14891582262370773, 0.09442532340391041, 0.08057185845894166, 0.09607373534128805, 0.124346903596533, 0.09762435830103933, 0.12123880523784214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00829748902318972, 9.999999999998899e-05, 0.01889429295643663, 9.999999999998899e-05, 9.999999999998899e-05, 0.029114167379758138, 0.07289049177920659, 0.0790090931946017, 0.06042372978656263, 0.10875564808853, 0.07412195954177336, 0.06497332691422364, 0.06135452082942505, 0.05121731643976768, 0.08310873597229151, 0.09783736254428765, 0.09788224217671326, 0.10555096373292705, 0.11056301933199009, 0.08440832915389762, 0.08528387368504387, 0.1193935434513207, 0.10073755421102504, 0.07976243978376585, 0.036533188905788494, 0.03296507238329682, 0.03622647001985446, 0.05300859277743242, 0.02269854749424871, 0.04196642220179514, 0.06714182286333614, 0.03957179871692551, 0.013901877586004918, 0.1610936467792059, 0.07457844093608113, 0.15018379185008457, 0.13930422505653073, 0.09943184384692871, 0.13523265182296695, 0.13015059886658686, 0.10002551504325763, 0.1433830836925819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044653516659228454, 0.05631725384452635, 0.05721473697552171, 0.06765925125997707, 0.12146404017553192, 0.06251929277157031, 0.06179391982868876, 0.057098648620006354, 0.0543555485899333, 0.038617165719645685, 0.041757796159542115, 0.01658983214208143, 0.01915694264320844, 0.02168799015727141, 0.04601915438713988, 0.0191530547449118, 0.015941376532340623, 0.04294318850084733, 0.128101516871845, 0.16178612144918314, 0.17703044801394063, 0.1434282565229007, 0.14745226818043744, 0.15313880219975784, 0.14027675556254304, 0.1301537275762481, 0.17655192695328847, 0.0032417337381454026, 0.02260309227575852, 0.04686177185559759, 0.008864393695891315, 0.012990167151792797, 0.018927429498714954, 0.012664139583991374, 0.009716115247321966, 0.015167649881763445]}, "mutation_prompt": null}
{"id": "3def1d6f-25b0-43a1-ac0b-5df7f6fbe2bd", "solution": "import numpy as np\n\nclass DynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "DynamicHarmonySearch", "description": "A novel metaheuristic algorithm based on Harmony Search with dynamic parameter adaptation for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "c50d57d7-5ab4-44ae-ab52-24979b96c429", "metadata": {"aucs": [0.07393768451217497, 0.06626757843073705, 0.08492873618815489, 0.020816416452838493, 0.054326413712087906, 0.026670148295119045, 0.05315987676486489, 0.05334213863592763, 0.06894541257626174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011890902552091909, 0.025576535610287277, 9.999999999998899e-05, 0.006051718406725026, 0.005077892708276188, 0.0016866412262092068, 0.029881163257206023, 9.999999999998899e-05, 0.0018728857193461845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03602960276542888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04666766679192347, 0.034589528686543414, 0.044251848057575316, 0.040379710670142566, 0.04802900828643086, 0.03165513849643409, 0.03440396237484489, 0.050603934452395194, 0.026982834521237065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002283153399175508, 9.999999999998899e-05, 9.999999999998899e-05, 0.013047611918399316, 9.999999999998899e-05, 0.10026681181215302, 0.03775217826057542, 0.006845536539381802, 0.004561771729970299, 9.999999999998899e-05, 9.999999999998899e-05, 0.02627668515388637, 9.999999999998899e-05, 0.009907484787565202, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008519894123754645, 0.02195921153675917, 0.03758369257382288, 0.05840862677546954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006387192795206387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.081820342672145, 0.10989622139872046, 0.15089364666279692, 0.09593114858212559, 0.08289476619763614, 0.09754168701657384, 0.12615716563199075, 0.09934903752856228, 0.12290314868703356, 0.0022984585825528425, 9.999999999998899e-05, 9.999999999998899e-05, 0.0166730409546062, 9.999999999998899e-05, 0.03195792427335997, 0.0012233644321281156, 0.00032035650987272124, 0.05242032534719421, 0.07379827899315827, 0.0871653123663273, 0.060278075683834365, 0.10750837692781512, 0.07742903121770783, 0.06650921484319461, 0.07174873552065508, 0.054557240255682315, 0.0845135144260335, 0.10538042741855624, 0.11093986377364085, 0.11158546864322039, 0.11934853096987263, 0.09174682559226444, 0.09511321088693037, 0.13227031127525457, 0.1141378444905029, 0.08586299391761221, 0.050518243971114485, 0.051056955912473834, 0.04076652546645332, 0.0688392384192561, 0.04087448582072051, 0.05081469913402803, 0.06890507912414157, 0.05116362493071369, 0.023903465394679135, 0.14136280217213248, 0.07668862210512017, 0.14887752384581543, 0.1160052745231902, 0.09798518712325732, 0.12776683044456172, 0.12767891204899462, 0.1062265968650592, 0.1449914484728766, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048256137563332024, 0.0583742345152517, 0.06243391871145576, 0.07157005566827446, 0.13064237921636557, 0.0673746159283033, 0.06736834404362291, 0.06095185946778314, 0.05707710410271538, 0.04166183723553896, 0.05151776855326862, 0.017426036025739777, 0.021339263051097457, 0.022622166665608012, 0.05035325300642968, 0.020747349033505058, 0.0166642200760585, 0.05017453061169963, 0.1312637374079597, 0.17615334541631023, 0.17841122830558453, 0.1744976196708049, 0.19526562845515494, 0.1731725365441793, 0.14728755308703745, 0.14454862451749773, 0.22191335032309578, 0.021282014169916708, 0.03831820207266823, 0.05627710358086113, 0.01089487139907086, 0.025834796253276227, 0.014752683624470242, 0.032193350057369896, 0.02474618086758451, 0.028606356027237934]}, "mutation_prompt": null}
{"id": "7a4ef068-edb7-49c8-92e8-4827a45df5e7", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearch(DynamicHarmonySearch):\n    def __init__(self, budget, dim, local_search_radius=0.1):\n        super().__init__(budget, dim)\n        self.local_search_radius = local_search_radius\n\n    def local_search(self, solution, func):\n        neighborhood = np.random.uniform(-self.local_search_radius, self.local_search_radius, size=(self.dim,))\n        new_solution = solution + neighborhood\n        new_solution = np.clip(new_solution, -5.0, 5.0)\n        return new_solution if func(new_solution) < func(solution) else solution\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = self.update_parameters(iteration)\n            new_harmony = self.improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony = self.local_search(new_harmony, func)\n            new_fitness = func(new_harmony)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearch", "description": "Enhancing DynamicHarmonySearch by incorporating a local search step after each improvisation to exploit the neighborhood of the new solution.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedDynamicHarmonySearch' object has no attribute 'initialize_harmony_memory'\").", "error": "AttributeError(\"'EnhancedDynamicHarmonySearch' object has no attribute 'initialize_harmony_memory'\")", "parent_id": "c50d57d7-5ab4-44ae-ab52-24979b96c429", "metadata": {}, "mutation_prompt": null}
{"id": "2cdcd91b-60df-45a3-973c-a52cc1e6096f", "solution": "class ImprovedDynamicHarmonySearch(DynamicHarmonySearch):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n\n    def opposition_based_improvisation(self, harmony):\n        opp_harmony = -1 * harmony\n        return opp_harmony\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            harmony_memory = np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n            opp_harmony_memory = np.array([self.opposition_based_improvisation(h) for h in harmony_memory])\n            return np.vstack((harmony_memory, opp_harmony_memory))\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, 2*self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = self.update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "ImprovedDynamicHarmonySearch", "description": "Improving DynamicHarmonySearch by incorporating opposition-based learning to enhance exploration and convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'ImprovedDynamicHarmonySearch' object has no attribute 'update_parameters'\").", "error": "AttributeError(\"'ImprovedDynamicHarmonySearch' object has no attribute 'update_parameters'\")", "parent_id": "c50d57d7-5ab4-44ae-ab52-24979b96c429", "metadata": {}, "mutation_prompt": null}
{"id": "e92db367-ddc9-4c3e-a83f-e3db7396f58f", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearch", "description": "Enhancing DynamicHarmonySearch by incorporating opposition-based learning to improve exploration and convergence.", "configspace": "", "generation": 6, "fitness": 0.040445087606743306, "feedback": "The algorithm EnhancedDynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "c50d57d7-5ab4-44ae-ab52-24979b96c429", "metadata": {"aucs": [0.07374056431730946, 0.0693121162715844, 0.08462737834239942, 0.026450372024533153, 0.054161643367529155, 0.0266616040324541, 0.10140557063027644, 0.06594520997212461, 0.09814845669558014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004841264157434133, 0.025103085241070078, 9.999999999998899e-05, 0.00560109813208276, 0.026291664592909325, 0.0012121519667931402, 0.029362151761023636, 9.999999999998899e-05, 0.0015312714647698344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034456699195912766, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023241457472162885, 9.999999999998899e-05, 9.999999999998899e-05, 0.046512369498148076, 0.038542425357255494, 0.04409358511010775, 0.04024274895431301, 0.04789266315535512, 0.03152875258928867, 0.034282786608782034, 0.05045180307573505, 0.02686335865782008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002080420795793514, 0.009243799644223505, 9.999999999998899e-05, 0.01286820270813982, 9.999999999998899e-05, 0.10025678837252983, 0.037748408896448704, 0.05416243926549036, 0.004561325418903972, 9.999999999998899e-05, 9.999999999998899e-05, 0.026274066699834675, 9.999999999998899e-05, 0.05488552413414405, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003133151268037593, 0.021784746491480877, 0.035289009375862435, 0.057860898743495426, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10971947452478215, 0.10961653388143855, 0.15057938791115155, 0.09579990082169698, 0.08261462306693013, 0.0973642196570117, 0.12594953511566875, 0.12162624483822115, 0.1324699678792376, 0.0016905486518042911, 9.999999999998899e-05, 9.999999999998899e-05, 0.016077903178085773, 0.004873560856456072, 0.030814214210566515, 0.0009614329034537406, 0.0008767329253738243, 0.05065511167713299, 0.07378253395003975, 0.08676654138474782, 0.06024417201586563, 0.10697549825996178, 0.0772992914324443, 0.0662151010911215, 0.07162250318643348, 0.05397942128861144, 0.08427247077790323, 0.10769328487419572, 0.1100837033089983, 0.11108645418729068, 0.11829393159574919, 0.090936464132642, 0.10284126286831141, 0.13291681589832538, 0.11320261037061519, 0.11484329903764046, 0.04975001349937758, 0.050309725068923394, 0.040122773959619384, 0.07170979476602501, 0.04179508116737618, 0.050250635727870585, 0.07046554257781845, 0.0505460603888227, 0.03586298949035993, 0.16051897136312288, 0.0833873394882998, 0.14833538804810342, 0.11671501084163616, 0.10141628210126108, 0.1263702811073374, 0.13555329041542208, 0.10609129898378855, 0.14430893942362477, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054370696169556476, 9.999999999998899e-05, 9.999999999998899e-05, 0.04784588379547172, 0.0581628632178639, 0.061746446375617214, 0.07112998949898464, 0.12946109073285517, 0.06674172795939615, 0.06681223235818345, 0.06152883461363168, 0.05679052814305885, 0.04133337628321043, 0.05048202963484494, 0.017319127290908565, 0.06206481380689677, 0.02248535448039024, 0.05141572671015637, 0.030721629728186373, 0.016584266736730524, 0.04922389640650615, 0.13166966980552441, 0.17516691152648067, 0.17808466162900494, 0.17523377982628607, 0.19437292825014507, 0.171718858959102, 0.14844789248899415, 0.14126960145366751, 0.22038767059692232, 0.020407937607604287, 0.03760296362275417, 0.055773462725816514, 0.017104647991110666, 0.02707225638168198, 0.023340692893032422, 0.031379165824345745, 0.02401254467004199, 0.028182869948699785]}, "mutation_prompt": null}
{"id": "aca5bc04-d06b-4c89-91c0-ebe2c6c4cf31", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearch", "description": "Enhancing DynamicHarmonySearch by incorporating opposition-based learning to improve exploration and convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e92db367-ddc9-4c3e-a83f-e3db7396f58f", "metadata": {"aucs": [0.07374056431730946, 0.0693121162715844, 0.08462737834239942, 0.026450372024533153, 0.054161643367529155, 0.0266616040324541, 0.10140557063027644, 0.06594520997212461, 0.09814845669558014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004841264157434133, 0.025103085241070078, 9.999999999998899e-05, 0.00560109813208276, 0.026291664592909325, 0.0012121519667931402, 0.029362151761023636, 9.999999999998899e-05, 0.0015312714647698344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034456699195912766, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023241457472162885, 9.999999999998899e-05, 9.999999999998899e-05, 0.046512369498148076, 0.038542425357255494, 0.04409358511010775, 0.04024274895431301, 0.04789266315535512, 0.03152875258928867, 0.034282786608782034, 0.05045180307573505, 0.02686335865782008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002080420795793514, 0.009243799644223505, 9.999999999998899e-05, 0.01286820270813982, 9.999999999998899e-05, 0.10025678837252983, 0.037748408896448704, 0.05416243926549036, 0.004561325418903972, 9.999999999998899e-05, 9.999999999998899e-05, 0.026274066699834675, 9.999999999998899e-05, 0.05488552413414405, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003133151268037593, 0.021784746491480877, 0.035289009375862435, 0.057860898743495426, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10971947452478215, 0.10961653388143855, 0.15057938791115155, 0.09579990082169698, 0.08261462306693013, 0.0973642196570117, 0.12594953511566875, 0.12162624483822115, 0.1324699678792376, 0.0016905486518042911, 9.999999999998899e-05, 9.999999999998899e-05, 0.016077903178085773, 0.004873560856456072, 0.030814214210566515, 0.0009614329034537406, 0.0008767329253738243, 0.05065511167713299, 0.07378253395003975, 0.08676654138474782, 0.06024417201586563, 0.10697549825996178, 0.0772992914324443, 0.0662151010911215, 0.07162250318643348, 0.05397942128861144, 0.08427247077790323, 0.10769328487419572, 0.1100837033089983, 0.11108645418729068, 0.11829393159574919, 0.090936464132642, 0.10284126286831141, 0.13291681589832538, 0.11320261037061519, 0.11484329903764046, 0.04975001349937758, 0.050309725068923394, 0.040122773959619384, 0.07170979476602501, 0.04179508116737618, 0.050250635727870585, 0.07046554257781845, 0.0505460603888227, 0.03586298949035993, 0.16051897136312288, 0.0833873394882998, 0.14833538804810342, 0.11671501084163616, 0.10141628210126108, 0.1263702811073374, 0.13555329041542208, 0.10609129898378855, 0.14430893942362477, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054370696169556476, 9.999999999998899e-05, 9.999999999998899e-05, 0.04784588379547172, 0.0581628632178639, 0.061746446375617214, 0.07112998949898464, 0.12946109073285517, 0.06674172795939615, 0.06681223235818345, 0.06152883461363168, 0.05679052814305885, 0.04133337628321043, 0.05048202963484494, 0.017319127290908565, 0.06206481380689677, 0.02248535448039024, 0.05141572671015637, 0.030721629728186373, 0.016584266736730524, 0.04922389640650615, 0.13166966980552441, 0.17516691152648067, 0.17808466162900494, 0.17523377982628607, 0.19437292825014507, 0.171718858959102, 0.14844789248899415, 0.14126960145366751, 0.22038767059692232, 0.020407937607604287, 0.03760296362275417, 0.055773462725816514, 0.017104647991110666, 0.02707225638168198, 0.023340692893032422, 0.031379165824345745, 0.02401254467004199, 0.028182869948699785]}, "mutation_prompt": null}
{"id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 8, "fitness": 0.04959137267352172, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "e92db367-ddc9-4c3e-a83f-e3db7396f58f", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "366644f2-adf9-45a0-b54a-ed27d431a5d3", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "78ae3a6c-c6bd-4ecd-b6b4-b154b66074b4", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "7b2abc49-8acd-43aa-a6e2-946479450935", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "af5308c4-4011-47c8-952a-1990abe151b2", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "51d92373-1646-4c7d-b048-ecf2cda4a6ae", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "43438cee-c050-47be-a3f7-4588722bf8c8", "solution": "class EnhancedDynamicHarmonySearchAdaptiveMutation(EnhancedDynamicHarmonySearchRefined):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.mutation_factors = np.linspace(0.1, 0.9, self.budget)\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = self.update_parameters(iteration)\n            mutation_factor = self.mutation_factors[iteration]\n            new_harmony = self.improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = self.apply_opposition(new_harmony)\n            \n            de_harmony = self.differential_evolution(harmony_memory, mutation_factor, self.crossover_prob)\n            de_harmony_opposite = self.apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchAdaptiveMutation", "description": "Introducing adaptive mutation factor to enhance exploration capability.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedDynamicHarmonySearchAdaptiveMutation' object has no attribute 'initialize_harmony_memory'\").", "error": "AttributeError(\"'EnhancedDynamicHarmonySearchAdaptiveMutation' object has no attribute 'initialize_harmony_memory'\")", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {}, "mutation_prompt": null}
{"id": "67971600-adf1-4e7c-bf05-17a4e2e9f5e9", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "b7351823-e0a4-463e-8066-c42b5bf6f6ed", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "aeeab4f6-c873-45cf-ab9d-2484bdbd2f54", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "c4742223-618c-4fed-96fd-6ae9b2837ce0", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "6631fe7d-0b00-4983-9376-db95d913af40", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    chaos_val = 0.5  # Chaotic map value\n                    new_harmony[i] += chaos_val * np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchImproved", "description": "Improving the exploration by incorporating a chaotic map to generate diverse solutions during harmony improvisation.", "configspace": "", "generation": 19, "fitness": 0.04912641500559688, "feedback": "The algorithm EnhancedDynamicHarmonySearchImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10565955633430968, 0.11165519685145664, 0.14153546480301904, 0.07707790901371225, 0.07814786482122804, 0.043918110119063214, 0.1327273081911342, 0.09812084667849064, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008896347398350213, 0.020223535541892823, 0.03643115351184856, 0.010763974029072365, 0.006861585933368719, 0.01812420750154775, 0.029263015079575183, 0.008318156633955964, 0.016978833189296938, 0.014055425834117008, 9.999999999998899e-05, 0.013659571832640327, 0.026652801373495683, 9.999999999998899e-05, 9.999999999998899e-05, 0.003916205663233474, 9.999999999998899e-05, 9.999999999998899e-05, 0.054837197489029266, 0.05906716234339815, 0.08213059262659683, 0.04948095422545573, 0.06201655962865027, 0.033765111145731, 0.04466985160815529, 0.050520679396890644, 0.030996442848774675, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022478083895149048, 0.0010159438445310753, 0.034802491861377516, 9.999999999998899e-05, 0.026461562190726373, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020224672845707614, 0.00989021656359923, 0.049850754348794935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20584345895619005, 0.1276782819955099, 0.15569339716618957, 0.11423534756211451, 0.11009185552407796, 0.11438576335955108, 0.17117994192614172, 0.09834109323043794, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027883850972781343, 0.01036213817036491, 0.0333209895380252, 0.010026410050162471, 0.00018184335826809672, 0.035733593436708566, 0.09952353998153307, 0.08569230920005899, 0.10174338156453411, 0.10953443035767485, 0.07473313172215457, 0.0762342375941123, 0.07673102809505694, 0.06167671847096423, 0.0807122577965842, 0.11581710191231942, 0.10495146503564357, 0.10758670684383631, 0.14355097560553165, 0.10951923915190254, 0.12090626593961229, 0.124176707640966, 0.10509748970912791, 0.12089565448352202, 0.091556538947702, 0.061765147085200645, 0.04685897786164828, 0.09496904487508251, 0.05282674659585651, 0.09083391493189452, 0.0922749768984944, 0.056981698612007525, 0.06114443954522142, 0.21393704753185083, 0.1424044881666483, 0.15096595057604878, 0.1436569665836498, 0.15787929223769115, 0.15025305743022055, 0.13897511895687353, 0.10763610414491553, 0.14578782233709386, 9.999999999998899e-05, 9.999999999998899e-05, 0.1458947224973114, 0.13727947563643605, 9.999999999998899e-05, 0.14460759121125522, 0.04957291689305188, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128528231403998, 0.05708530180806448, 0.06142155428621476, 0.06958487640031163, 0.12496728970348081, 0.06513953517610094, 0.06280028558556094, 0.07216553699801442, 0.06634662885489029, 0.042930393442346726, 0.04504032122090795, 0.042437764652771715, 0.09746825433652817, 0.06678515153072406, 0.04678118185170932, 0.035756077383480855, 0.042034351001043246, 0.048449077730359, 0.12332853954772305, 0.15311643422305588, 0.18497804206568036, 0.1563731566169021, 0.1790226854544571, 0.1680855871856931, 0.13171037409928377, 0.12853960181318502, 0.19596097355989084, 0.029354920440005317, 0.02973892433858838, 0.04776622032126543, 0.04288304373812224, 0.026114101806258394, 0.023335136370999154, 0.026729013436399884, 0.019538004797038044, 0.02781880356228139]}, "mutation_prompt": null}
{"id": "1d12eb72-30be-4dd6-b5ec-2e1817d6c9c6", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "18dcc3e3-00fd-40c5-8cb0-277d5fc9e49d", "solution": "class AdaptiveDynamicHarmonySearchRefined(EnhancedDynamicHarmonySearchRefined):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.gradient_threshold = 0.5\n\n    def adaptive_mutation(self, harmony_memory, best_fitness, new_fitness, iteration):\n        gradient = (best_fitness - new_fitness) / (self.budget - iteration)\n        if gradient > self.gradient_threshold:\n            self.mutation_factor *= 1.1\n        else:\n            self.mutation_factor *= 0.9\n\n    def __call__(self, func):\n        # Existing code remains the same until the iteration loop\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            adaptive_mutation(harmony_memory, best_fitness, new_fitness, iteration)\n            \n            # Rest of the existing code for updating best solution and memory\n            \n        return best_solution", "name": "AdaptiveDynamicHarmonySearchRefined", "description": "Incorporating a novel adaptive mutation mechanism based on the fitness landscape gradient to dynamically adjust the mutation factor during the optimization process.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'update_parameters' is not defined\").", "error": "NameError(\"name 'update_parameters' is not defined\")", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {}, "mutation_prompt": null}
{"id": "8b9665f3-eb9b-4d0b-ba02-d34a915cc8a3", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution strategy for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.10570655101241477, 0.11164646089724317, 0.14153151024511312, 0.07707796864403738, 0.07815131929141828, 0.043918110119063214, 0.13272717508630538, 0.09814615561151807, 0.08722515320039204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009576707920905592, 0.024339741541380522, 0.03643115351184856, 0.010527726114752278, 0.006905751222653134, 0.01812420750154775, 0.03109156823172543, 0.008318156633955964, 0.017039959418425177, 0.030037367452775632, 9.999999999998899e-05, 0.013659605777394557, 0.030216342970315835, 9.999999999998899e-05, 9.999999999998899e-05, 0.003918345756353525, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484452907436532, 0.05904794133225455, 0.08211485119335393, 0.049479151657176756, 0.06201662662586782, 0.03376511660544401, 0.04466985128198975, 0.05069759887217229, 0.030995300323093167, 0.008846606606371488, 9.999999999998899e-05, 9.999999999998899e-05, 0.022465685088164378, 0.0017358553943030985, 0.034802473812246215, 9.999999999998899e-05, 0.026492273225778407, 9.999999999998899e-05, 0.10025485400546497, 0.047852927020770264, 0.07420369210131172, 0.03174571145360383, 9.999999999998899e-05, 0.02119243456866171, 0.026268829791731285, 0.01904678417464234, 0.06123457432880963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02176124731924811, 0.03776299364945257, 0.055465547768363876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2058460091237394, 0.12770986833460207, 0.15570359661386624, 0.11423534756211451, 0.11007194798310505, 0.11438577407785755, 0.17120049354632283, 0.09944900676985924, 0.1407239989739033, 0.0048396542246955665, 9.999999999998899e-05, 9.999999999998899e-05, 0.027932397514881968, 0.01036213817036491, 0.03444685302803174, 0.010026410050162471, 0.00018184335826809672, 0.04387026711391351, 0.0893581080268937, 0.08790638480466695, 0.06459222439336554, 0.11263417415061905, 0.07470717666198756, 0.07707698852091349, 0.07673102809505694, 0.056698742848262706, 0.08432022795269567, 0.11588871154104086, 0.10948962417274943, 0.11071118226766707, 0.14268773055693162, 0.10951931433244755, 0.11950354993492018, 0.12724382225104514, 0.1109225307294811, 0.12171176637271675, 0.09155653327088953, 0.06155687485127004, 0.04682368168939943, 0.09496904487508251, 0.05328757383213922, 0.09083391493189452, 0.09390292718017734, 0.057630873736016164, 0.06114443954522142, 0.1996704401106546, 0.13066608430902837, 0.15070671771206545, 0.16073066742983844, 0.11163638031152112, 0.15039494226022887, 0.14270654433233043, 0.10865813423304793, 0.15194692323983583, 9.999999999998899e-05, 9.999999999998899e-05, 0.1455902720994987, 0.13723769619933157, 9.999999999998899e-05, 0.14460759121125522, 0.05029704509153621, 9.999999999998899e-05, 9.999999999998899e-05, 0.09128442514096402, 0.05809883592805365, 0.06192724125668192, 0.07032564723519863, 0.12999412290449452, 0.06701114164379651, 0.06451914286910776, 0.07216555906497957, 0.06635547579526391, 0.042963490573818985, 0.04936894301582817, 0.042437764652771715, 0.09746712008134129, 0.06668548901971494, 0.04790862791781947, 0.035756075343696625, 0.042049059536298006, 0.05078621285846019, 0.13718130882791724, 0.1497691121575957, 0.18131021346302068, 0.16621596637157798, 0.1767755664527878, 0.15343937690835652, 0.14917693992454228, 0.1378312831445737, 0.19700506697504705, 0.04650399065227162, 0.032687885626820234, 0.04981400057288521, 0.05498858909084903, 0.02876777057046942, 0.026312579098137445, 0.03566281463670007, 0.018434701787364283, 0.03073026443389426]}, "mutation_prompt": null}
{"id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 23, "fitness": 0.05097539412844571, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "44ec6c0e-9684-472c-a8b1-89016f0bf741", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "772d531a-b1bc-43a4-8333-d6280de78345", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "ce95a6d2-e117-4b40-bd4a-e2ed255b9f01", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "33f66e68-4ec3-4e05-b8b5-e3349bbe45cb", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "02ad86f2-2a23-4ece-9e69-0ca161fc8451", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "5f20ea47-dee5-4a76-b0e9-4f2076a4c4e3", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "3866caee-7610-4b2f-a4d3-2268db41121c", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "7a1af2a8-0de5-406f-9f41-554635e79454", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "6fc2b84d-3d19-4b9c-b993-a7f77975b1b6", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "dafa31c1-ae99-4d9f-8b39-92a213c16e41", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "2f5a3f1f-371c-4202-a0e4-c0a8976c0b32", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "835338bd-d818-4034-ab7d-8e5462488707", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "ef251b6b-4c56-4ab5-870e-1b8ebb29b03a", "solution": "class EnhancedDynamicHarmonySearchOppositionDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F_min = 0.1\n        self.F_max = 0.9\n        self.CR_min = 0.1\n        self.CR_max = 0.9\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            F = self.F_min + (self.F_max - self.F_min) * (iteration / self.budget)\n            CR = self.CR_min + (self.CR_max - self.CR_min) * (iteration / self.budget)\n            return par, bandwidth, F, CR\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, F, CR = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, F, CR)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchOppositionDE", "description": "Enhancing Dynamic Harmony Search by incorporating Opposition-based Learning and Differential Evolution for enhanced exploration and exploitation with adaptive parameter updates.", "configspace": "", "generation": 35, "fitness": 0.04660914627053776, "feedback": "The algorithm EnhancedDynamicHarmonySearchOppositionDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.11027757789337833, 0.1254814160748834, 0.08398299864480452, 0.0427016895120943, 0.10121318614182184, 0.03965760254274864, 0.10065146426914451, 0.17219574900635215, 0.10557622927577226, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008650092407726184, 0.024044708315684282, 9.999999999998899e-05, 0.024018466459163057, 0.026141060811171513, 0.005083995939305197, 0.027672178555840254, 9.999999999998899e-05, 0.0019494616996867942, 0.0019692561532714814, 9.999999999998899e-05, 0.023028358633141566, 0.03226400368976501, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05870105413343141, 0.05469409063523978, 0.043996754611599465, 0.04501581012260414, 0.05565530251475359, 0.033689953856619104, 0.04575471095595751, 0.050046708387027294, 0.036475979178898554, 9.999999999998899e-05, 9.999999999998899e-05, 0.023796011346031043, 0.009884928086380196, 0.008620211327272642, 0.009315696455940992, 0.028091903994219125, 0.012575340464580087, 9.999999999998899e-05, 0.10023674149328321, 0.03944284901394546, 0.05994158971805408, 0.04228709729077562, 9.999999999998899e-05, 9.999999999998899e-05, 0.026268829791731285, 0.04280205862588171, 0.054879021530724326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0209148654522332, 0.04277948751096827, 0.05748222279719484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11619847462252053, 0.10970485654687889, 0.16075233126204058, 0.14100837013155976, 0.08560746026648736, 0.09969343574391054, 0.1257992723922442, 0.12152935314333813, 0.12275807446534859, 0.009776079622025424, 9.999999999998899e-05, 9.999999999998899e-05, 0.03447528139949696, 0.009532446472076517, 0.031357387995361585, 0.0008330526033650809, 0.004193950254842482, 0.047522780674825627, 0.0756540808688877, 0.09438726740869807, 0.06357886910407573, 0.1071508914015954, 0.091437022274105, 0.10940337366457242, 0.09204018978487893, 0.08941938836351238, 0.08800301808748268, 0.1084950345771154, 0.11043681437019826, 0.11169448845350183, 0.12435892873842591, 0.10882230841571394, 0.12594903310975514, 0.1327255481640488, 0.11304802795908453, 0.11455875026297235, 0.06934112741491283, 0.05141788579456874, 0.042876553320747135, 0.08078616860150356, 0.049340960110605736, 0.07077494923329108, 0.06892973468782948, 0.04890521417054983, 0.06270840517592513, 0.21941376135373103, 0.10739266673068193, 0.16353488119006288, 0.15224050234359288, 0.1262473927682316, 0.14464916524751403, 0.14210233010748086, 0.11188275540381032, 0.1388972106056392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13674107721962192, 9.999999999998899e-05, 9.999999999998899e-05, 0.04999038611401063, 0.060633592359557564, 0.07209319639319145, 0.0723006504526238, 0.12857679205341643, 0.08388018337147385, 0.06649923994731088, 0.06076100519255778, 0.0706414965717217, 0.04095809642523507, 0.06897375399364114, 0.022549734847730707, 0.0758001535264875, 0.09861536862996634, 0.05094483729499755, 0.030680835261464368, 0.03553693343099551, 0.048587964985530974, 0.16555987638126102, 0.14997420701813302, 0.18685592136229345, 0.17447928346813657, 0.17538456966209126, 0.16426987935011783, 0.15362146414377587, 0.13439602437334874, 0.2021066917017098, 0.022982807392772475, 0.032407650509018615, 0.05241235455149651, 0.023031066867951866, 0.03047295764668656, 0.036222361622925026, 0.031182070503984916, 0.02447014586369478, 0.029027319631461213]}, "mutation_prompt": null}
{"id": "84aa1edf-56e5-4bed-bea3-586724562d4f", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "36d169c7-b04f-411b-a124-5648f8235b79", "solution": "import numpy as np\n\nclass HybridDynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "HybridDynamicHarmonySearch", "description": "Utilizing a hybrid of Differential Evolution and Opposition-based techniques for enhanced exploration and exploitation in the Harmony Search algorithm.", "configspace": "", "generation": 37, "fitness": 0.05097539412844571, "feedback": "The algorithm HybridDynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "55b8ecad-0f43-4d65-ab39-c37fba9a2b28", "solution": "class EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_prob_history = [self.crossover_prob]\n\n    def __call__(self, func):\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def update_mutation_factor(iteration, best_fitness):\n            if iteration > 0 and len(self.mutation_factor_history) > 1:\n                if best_fitness < np.mean(self.mutation_factor_history):\n                    self.mutation_factor *= 1.1\n                else:\n                    self.mutation_factor *= 0.9\n            self.mutation_factor_history.append(self.mutation_factor)\n\n        def update_crossover_prob(iteration, best_fitness):\n            if iteration > 0 and len(self.crossover_prob_history) > 1:\n                if best_fitness < np.mean(self.crossover_prob_history):\n                    self.crossover_prob = min(0.9, self.crossover_prob + 0.1)\n                else:\n                    self.crossover_prob = max(0.1, self.crossover_prob - 0.1)\n            self.crossover_prob_history.append(self.crossover_prob)\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            update_mutation_factor(iteration, best_fitness)\n            update_crossover_prob(iteration, best_fitness)\n\n            # remaining code as before", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Introducing a self-adaptive strategy to adjust the mutation factor and crossover probability based on the performance history of the algorithm.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'best_fitness' is not defined\").", "error": "NameError(\"name 'best_fitness' is not defined\")", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {}, "mutation_prompt": null}
{"id": "522da135-f3c0-433e-b7ac-0d420241b178", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "f0333dd9-2f37-4cd1-9c0f-250440bbc498", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "5db04ef7-3665-43af-9044-a00dcdd1fb9c", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "f104a176-21ce-4a09-9c29-418c3b7153f5", "solution": "def levy_flight(dim):\n    beta = 1.5\n    sigma = (gamma(1 + beta) * np.sin(np.pi * beta / 2) / (gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n    u = np.random.normal(0, sigma, dim)\n    v = np.random.normal(0, 1, dim)\n    step = u / np.abs(v) ** (1 / beta)\n    return step\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    step_size = levy_flight(1)[0]\n                    new_harmony[i] += step_size * np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        # Remaining code stays the same", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Introducing Levy flight optimization to enhance exploration capabilities in the Dynamic Harmony Search algorithm.", "configspace": "", "generation": 42, "fitness": 0.0, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "mutation_prompt": null}
{"id": "eb5af2b0-2ad6-4c19-8e05-df5adf837171", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "fa3b3344-24a9-4968-bc9f-930563106d3b", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "cbfe6d24-f0be-47bb-9df9-846b84db87c5", "solution": "class EnhancedDynamicHarmonySearchRefinedDynamicCR(EnhancedDynamicHarmonySearchRefined):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.dynamic_crossover_prob = 0.7\n\n    def __call__(self, func):\n        # Existing code remains unchanged\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            self.crossover_prob = self.dynamic_crossover_prob  # Dynamic adjustment\n            # Existing code remains unchanged\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedDynamicCR", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a dynamic adjustment of crossover probability during the optimization process for improved exploration and exploitation.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'update_parameters' is not defined\").", "error": "NameError(\"name 'update_parameters' is not defined\")", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {}, "mutation_prompt": null}
{"id": "ff57191f-2f9a-4e43-9bf8-ddd8c9bde3d1", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization and Opposition-based Learning for improved global exploration, exploitation, and diversity maintenance.", "configspace": "", "generation": 46, "fitness": 0.05097539412844571, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "432cc72e-effd-4d25-ac26-908cc09385ad", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "0b3c0e00-e9a4-4f01-8fdb-b23ec86370b7", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n    \n            de_harmony = np.array([differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob) for _ in range(self.harmony_memory_size)])\n            de_harmony_opposite = apply_opposition(de_harmony)\n    \n            new_fitness = np.array([func(h) for h in new_harmony])\n            new_fitness_opposite = np.array([func(h) for h in new_harmony_opposite])\n            de_fitness = np.array([func(h) for h in de_harmony])\n            de_fitness_opposite = np.array([func(h) for h in de_harmony_opposite])\n    \n            harmony_memory = np.array([new_harmony if nf < f else h for h, nf, f in zip(harmony_memory, new_fitness, func(harmony_memory))])\n            harmony_memory = np.array([new_harmony_opposite if nf < f else h for h, nf, f in zip(harmony_memory, new_fitness_opposite, func(harmony_memory))])\n            harmony_memory = np.array([dh if df < f else h for h, dh, df, f in zip(harmony_memory, de_harmony, de_fitness, func(harmony_memory))])\n            harmony_memory = np.array([de_h if df < f else h for h, de_h, df, f in zip(harmony_memory, de_harmony_opposite, de_fitness_opposite, func(harmony_memory))])\n    \n            idx = np.argmin([func(h) for h in harmony_memory])\n            best_solution = harmony_memory[idx]\n            best_fitness = func(best_solution)\n    \n        return best_solution\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(len(harmony_memory)), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(len(harmony_memory))])\n            return trial_vector", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Differential Evolution for improved global exploration and exploitation by integrating DE operators into the harmony search algorithm.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"free variable 'differential_evolution' referenced before assignment in enclosing scope\").", "error": "NameError(\"free variable 'differential_evolution' referenced before assignment in enclosing scope\")", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {}, "mutation_prompt": null}
{"id": "20e2c154-a865-458c-bb08-de3b9b80d25d", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "4ea4a35f-2cfc-4199-97a2-12611f11c3f8", "solution": "import numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def differential_evolution(harmony_memory, F, CR):\n            r1, r2, r3 = np.random.choice(range(self.harmony_memory_size), 3, replace=False)\n            mutant_vector = harmony_memory[r1] + F * (harmony_memory[r2] - harmony_memory[r3])\n            crossover_mask = np.random.rand(self.dim) < CR\n            trial_vector = np.where(crossover_mask, mutant_vector, harmony_memory[np.random.randint(self.harmony_memory_size)])\n            return trial_vector\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(harmony_memory, self.mutation_factor, self.crossover_prob)\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch with Particle Swarm Optimization for improved global exploration and exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.07415774904381922, 0.12766648965458938, 0.12627135465600348, 0.05094680692651399, 0.10121318614182184, 0.04989030717454901, 0.11010698758336035, 0.10873222876382638, 0.15859720428235835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016225249862052316, 0.02457376797009525, 0.015304702773343504, 0.004136933912659124, 0.02600624326426837, 0.01366700005756627, 0.02783350711602528, 0.005176131378586746, 0.01626469806333608, 0.024457718233455328, 9.999999999998899e-05, 0.025385100708100405, 0.03130103377699456, 9.999999999998899e-05, 9.999999999998899e-05, 0.002497622127036303, 9.999999999998899e-05, 9.999999999998899e-05, 0.05868983743265255, 0.04734916621945029, 0.04401271563391551, 0.04891881143150856, 0.05476440798685012, 0.07041317272421743, 0.04225943917161512, 0.06333728039798714, 0.0653536810548585, 0.020161192713085252, 9.999999999998899e-05, 0.0035112516327766574, 0.015160231379624967, 0.0017846341263521026, 0.009315696455940992, 9.999999999998899e-05, 0.012601455940824402, 9.999999999998899e-05, 0.12302534623966344, 0.037740870168195606, 0.05360958432395346, 0.019005883709182325, 0.040261164460889454, 0.06926298007226306, 0.03068003559971677, 0.01539968065957742, 0.051921341200308446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020971480921795793, 0.04335595565947037, 0.05743634819375998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1497854076113848, 0.1385521490494922, 0.1509504417152684, 0.13494615756225525, 0.08272704968440125, 0.11395874902124381, 0.15177664517863287, 0.1215282087984153, 0.14658570042789432, 0.016464678257466003, 0.018956937163133847, 0.004463646741330041, 0.016510644255162132, 0.029116198345507827, 0.026158197283906115, 0.009863303936049173, 0.002614754109373285, 0.050006676501282654, 0.07572278347471384, 0.08606644445929235, 0.0925120245038914, 0.1071991703900147, 0.09936482903081867, 0.08727254582727584, 0.09697889667442328, 0.08410690978366742, 0.08809570597881389, 0.13046188299863115, 0.14950737337643183, 0.11381106053816126, 0.1410377896226972, 0.12905592879831096, 0.14369142632343523, 0.1331868109871872, 0.12068065653458815, 0.12684631903811172, 0.056382438776182986, 0.05100510743491338, 0.03972650172903491, 0.07545812197417723, 0.07397760634077766, 0.09314574459700575, 0.06989823705747444, 0.059645284958404376, 0.08052184674535878, 0.21940675409950694, 0.11298339807375235, 0.16410575594057697, 0.1681557399396253, 0.12313582830895042, 0.15795195134949047, 0.14211103361259192, 0.11214336122452806, 0.14565248080689164, 9.999999999998899e-05, 9.999999999998899e-05, 0.13026773216257137, 9.999999999998899e-05, 0.12722282718604982, 9.999999999998899e-05, 0.13470218532676592, 9.999999999998899e-05, 9.999999999998899e-05, 0.07957609591141956, 0.05788768763541907, 0.06113971722609479, 0.08621164890832, 0.12866444848463066, 0.06611532414489907, 0.10732073354234395, 0.09485643153174328, 0.06949514871080864, 0.09500154926078885, 0.04924299498258222, 0.027599589228709864, 0.07564281518422467, 0.02258160330918013, 0.050965572873807874, 0.03441191262911503, 0.06439219226667825, 0.04863314899374749, 0.1527576571362793, 0.1504533989908461, 0.18827308569861234, 0.17612841397826773, 0.18101037441616652, 0.16459452683549536, 0.15479419102943814, 0.1350791811105877, 0.20532701085431448, 0.022543655685636654, 0.032317233792917066, 0.052529650330368494, 0.031983156932608336, 0.030683743852112588, 0.036283625739501946, 0.03524801215417195, 0.030594804650269203, 0.034065083124073636]}, "mutation_prompt": null}
{"id": "5478d6eb-04a2-4be9-b755-b3f0494dde34", "solution": "from scipy.optimize import differential_evolution\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch by incorporating Differential Evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 51, "fitness": 0.4020052115816193, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "4bf9bf41-7788-48ff-93d4-cfa27d739e9d", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.6292524893765881, 0.6235552089755864, 0.5819043617966315, 0.6594583968051069, 0.3906752781345856, 0.6422791440832551, 0.7457971949796383, 0.6837757653572007, 0.733531100970694, 0.1391949794266062, 0.12941973166101395, 0.15020807827308125, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.13861605040307767, 0.14532496554154872, 0.15971001100626803, 0.12572203767865087, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.16191182894949485, 0.14027251061266488, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.443748567142906, 0.4799823146404337, 0.562821999228035, 0.4747269680941929, 0.4383770081794123, 0.2633073142616442, 0.2865973698162777, 0.28839843067265225, 0.33400447691994073, 0.34700278414943286, 0.3347955809381713, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7297650225762788, 0.7561617519973067, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.38426161026094774, 0.24535000035044308, 0.24800361330648235, 0.23763682523015206, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.19511078252235525, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.24855831056807798, 0.29704267245385374, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.3997988032728754, 0.2810188732626324, 0.1871086922848072, 0.22953656870654815, 0.16661075332420883, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.19854812491053453, 0.20586226025814625, 0.29582302379680336, 0.26770806024948046, 0.23736041592654455, 0.1947554235796004, 0.21709915901892218, 0.4049723974639696, 0.7410778255344508, 0.7019200939543286, 0.7408375859403034, 0.7339585273479317, 0.7470571368484251, 0.7522746918712981, 0.7599372258581543, 0.7543863557113476, 0.7931949289363576, 0.10871048686870488, 0.12140494040781835, 0.12952436266753453, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29172004482012326, 0.28556281161824404, 0.28866064815316317, 0.27500938361466554, 0.2743880744475973, 0.3256195165782476, 0.2283876829989353, 0.2522777447743596, 0.2578196845059548, 0.30517159114755055, 0.24728937358852632, 0.2760348944342992, 0.2742732898287428, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.19710221681733398, 0.18441744236891255, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.20765822129570355, 0.22263819269341278, 0.23397549720840483, 0.2211925113173696, 0.21709361287932238, 0.19706895583311868, 0.20747598934988798, 0.21975840964791293, 0.2285587617954623, 0.23788357435136553, 0.2087047460111272, 0.1947686851194238, 0.6140263021886669, 0.8626155660294529, 0.6739956694352252, 0.8471085392867151, 0.8315730705834414, 0.8183191299465632, 0.7812865096669608, 0.6908040237457328, 0.5446963285582346, 0.6098687103057687, 0.6371344744199468, 0.5320317054046992, 0.5704714534811294, 0.6300103396906699, 0.5755019065673822, 0.7205013367967312, 0.6138522902257572, 0.5496396306017053, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19151208666586805, 0.2101968763155868, 0.20203963656843216, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "a0193592-e311-4280-8e7a-d9599b154a79", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.pso_inertia_weight = 0.7\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n            \n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing DynamicHarmonySearch by integrating Particle Swarm Optimization for improved global exploration and exploitation capabilities.", "configspace": "", "generation": 52, "fitness": 0.4020052115816193, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "5478d6eb-04a2-4be9-b755-b3f0494dde34", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.6292524893765881, 0.6235552089755864, 0.5819043617966315, 0.6594583968051069, 0.3906752781345856, 0.6422791440832551, 0.7457971949796383, 0.6837757653572007, 0.733531100970694, 0.1391949794266062, 0.12941973166101395, 0.15020807827308125, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.13861605040307767, 0.14532496554154872, 0.15971001100626803, 0.12572203767865087, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.16191182894949485, 0.14027251061266488, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.443748567142906, 0.4799823146404337, 0.562821999228035, 0.4747269680941929, 0.4383770081794123, 0.2633073142616442, 0.2865973698162777, 0.28839843067265225, 0.33400447691994073, 0.34700278414943286, 0.3347955809381713, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7297650225762788, 0.7561617519973067, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.38426161026094774, 0.24535000035044308, 0.24800361330648235, 0.23763682523015206, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.19511078252235525, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.24855831056807798, 0.29704267245385374, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.3997988032728754, 0.2810188732626324, 0.1871086922848072, 0.22953656870654815, 0.16661075332420883, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.19854812491053453, 0.20586226025814625, 0.29582302379680336, 0.26770806024948046, 0.23736041592654455, 0.1947554235796004, 0.21709915901892218, 0.4049723974639696, 0.7410778255344508, 0.7019200939543286, 0.7408375859403034, 0.7339585273479317, 0.7470571368484251, 0.7522746918712981, 0.7599372258581543, 0.7543863557113476, 0.7931949289363576, 0.10871048686870488, 0.12140494040781835, 0.12952436266753453, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29172004482012326, 0.28556281161824404, 0.28866064815316317, 0.27500938361466554, 0.2743880744475973, 0.3256195165782476, 0.2283876829989353, 0.2522777447743596, 0.2578196845059548, 0.30517159114755055, 0.24728937358852632, 0.2760348944342992, 0.2742732898287428, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.19710221681733398, 0.18441744236891255, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.20765822129570355, 0.22263819269341278, 0.23397549720840483, 0.2211925113173696, 0.21709361287932238, 0.19706895583311868, 0.20747598934988798, 0.21975840964791293, 0.2285587617954623, 0.23788357435136553, 0.2087047460111272, 0.1947686851194238, 0.6140263021886669, 0.8626155660294529, 0.6739956694352252, 0.8471085392867151, 0.8315730705834414, 0.8183191299465632, 0.7812865096669608, 0.6908040237457328, 0.5446963285582346, 0.6098687103057687, 0.6371344744199468, 0.5320317054046992, 0.5704714534811294, 0.6300103396906699, 0.5755019065673822, 0.7205013367967312, 0.6138522902257572, 0.5496396306017053, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19151208666586805, 0.2101968763155868, 0.20203963656843216, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "729928c1-5baf-4a00-976e-ef369e3a17c4", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by incorporating Particle Swarm Optimization for improved exploration and exploitation.", "configspace": "", "generation": 53, "fitness": 0.41024806630638627, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "5478d6eb-04a2-4be9-b755-b3f0494dde34", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919074356314576, 0.12941973166101395, 0.14955484325875423, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.16191182894949485, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.443748567142906, 0.4799823146404337, 0.562821999228035, 0.4738472515875516, 0.4379832214520818, 0.25411960716849646, 0.28480017788006495, 0.2879456972649407, 0.33400447691994073, 0.34583863545546756, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7262724593898207, 0.7499133806699783, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.3838062665580567, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.19511078252235525, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.24855831056807798, 0.29704267245385374, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.3997988032728754, 0.2810188732626324, 0.1871086922848072, 0.22953656870654815, 0.16661075332420883, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.19854812491053453, 0.20586226025814625, 0.29156088458180107, 0.2675236304170464, 0.23736041592654455, 0.27069251397504535, 0.21709915901892218, 0.4049723974639696, 0.7410778255344508, 0.691341323539272, 0.7408375859403034, 0.729243678238908, 0.746009337897666, 0.7522746918712981, 0.7472218156145862, 0.7515571081700281, 0.7920596214774898, 0.10605105998094277, 0.11556032159261265, 0.1295243626669379, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.28489870864395084, 0.28724423423018, 0.27321859334461585, 0.2743880744475973, 0.3256195165782476, 0.21352056176354695, 0.2490867522206227, 0.25613823139091996, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27391737624891865, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.19648658006608766, 0.18188571026843925, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19773880127984134, 0.21838544569528728, 0.22893422407082165, 0.21655927350310844, 0.2152617120963174, 0.19557251509031448, 0.20513309241475997, 0.21975840964791293, 0.22980363941420645, 0.23788357435136553, 0.21550415687234292, 0.20883567556193394, 0.6130169199133287, 0.8606268631940754, 0.8232676727953697, 0.8460663184948085, 0.8315730705834414, 0.8171188895639294, 0.7748004560704086, 0.6772412457101638, 0.5446963285582346, 0.593492744319313, 0.6311900550829377, 0.5003426852647934, 0.5704714534811294, 0.6173965538321642, 0.5712703909496721, 0.715843314917037, 0.58314368890394, 0.5300809494545988, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19151208666586805, 0.2101968763155868, 0.20203963656843216, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "c80aa33c-6665-421b-b261-679ea9d69bb2", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by incorporating Particle Swarm Optimization for improved exploration and exploitation.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "729928c1-5baf-4a00-976e-ef369e3a17c4", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919074356314576, 0.12941973166101395, 0.14955484325875423, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.16191182894949485, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.443748567142906, 0.4799823146404337, 0.562821999228035, 0.4738472515875516, 0.4379832214520818, 0.25411960716849646, 0.28480017788006495, 0.2879456972649407, 0.33400447691994073, 0.34583863545546756, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7262724593898207, 0.7499133806699783, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.3838062665580567, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.19511078252235525, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.24855831056807798, 0.29704267245385374, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.3997988032728754, 0.2810188732626324, 0.1871086922848072, 0.22953656870654815, 0.16661075332420883, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.19854812491053453, 0.20586226025814625, 0.29156088458180107, 0.2675236304170464, 0.23736041592654455, 0.27069251397504535, 0.21709915901892218, 0.4049723974639696, 0.7410778255344508, 0.691341323539272, 0.7408375859403034, 0.729243678238908, 0.746009337897666, 0.7522746918712981, 0.7472218156145862, 0.7515571081700281, 0.7920596214774898, 0.10605105998094277, 0.11556032159261265, 0.1295243626669379, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.28489870864395084, 0.28724423423018, 0.27321859334461585, 0.2743880744475973, 0.3256195165782476, 0.21352056176354695, 0.2490867522206227, 0.25613823139091996, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27391737624891865, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.19648658006608766, 0.18188571026843925, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19773880127984134, 0.21838544569528728, 0.22893422407082165, 0.21655927350310844, 0.2152617120963174, 0.19557251509031448, 0.20513309241475997, 0.21975840964791293, 0.22980363941420645, 0.23788357435136553, 0.21550415687234292, 0.20883567556193394, 0.6130169199133287, 0.8606268631940754, 0.8232676727953697, 0.8460663184948085, 0.8315730705834414, 0.8171188895639294, 0.7748004560704086, 0.6772412457101638, 0.5446963285582346, 0.593492744319313, 0.6311900550829377, 0.5003426852647934, 0.5704714534811294, 0.6173965538321642, 0.5712703909496721, 0.715843314917037, 0.58314368890394, 0.5300809494545988, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19151208666586805, 0.2101968763155868, 0.20203963656843216, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "da5d82d2-2381-4862-838c-049976d28d8a", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by incorporating Particle Swarm Optimization for improved exploration and exploitation.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "729928c1-5baf-4a00-976e-ef369e3a17c4", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919074356314576, 0.12941973166101395, 0.14955484325875423, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.16191182894949485, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.443748567142906, 0.4799823146404337, 0.562821999228035, 0.4738472515875516, 0.4379832214520818, 0.25411960716849646, 0.28480017788006495, 0.2879456972649407, 0.33400447691994073, 0.34583863545546756, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7262724593898207, 0.7499133806699783, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.3838062665580567, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.19511078252235525, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.24855831056807798, 0.29704267245385374, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.3997988032728754, 0.2810188732626324, 0.1871086922848072, 0.22953656870654815, 0.16661075332420883, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.19854812491053453, 0.20586226025814625, 0.29156088458180107, 0.2675236304170464, 0.23736041592654455, 0.27069251397504535, 0.21709915901892218, 0.4049723974639696, 0.7410778255344508, 0.691341323539272, 0.7408375859403034, 0.729243678238908, 0.746009337897666, 0.7522746918712981, 0.7472218156145862, 0.7515571081700281, 0.7920596214774898, 0.10605105998094277, 0.11556032159261265, 0.1295243626669379, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.28489870864395084, 0.28724423423018, 0.27321859334461585, 0.2743880744475973, 0.3256195165782476, 0.21352056176354695, 0.2490867522206227, 0.25613823139091996, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27391737624891865, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.19648658006608766, 0.18188571026843925, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19773880127984134, 0.21838544569528728, 0.22893422407082165, 0.21655927350310844, 0.2152617120963174, 0.19557251509031448, 0.20513309241475997, 0.21975840964791293, 0.22980363941420645, 0.23788357435136553, 0.21550415687234292, 0.20883567556193394, 0.6130169199133287, 0.8606268631940754, 0.8232676727953697, 0.8460663184948085, 0.8315730705834414, 0.8171188895639294, 0.7748004560704086, 0.6772412457101638, 0.5446963285582346, 0.593492744319313, 0.6311900550829377, 0.5003426852647934, 0.5704714534811294, 0.6173965538321642, 0.5712703909496721, 0.715843314917037, 0.58314368890394, 0.5300809494545988, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19151208666586805, 0.2101968763155868, 0.20203963656843216, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "af3649ef-b03f-447b-8c26-73566cd305d3", "solution": "class EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n\n    def __call__(self, func):\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def update_mutate(new_harmony, mutation_factor):\n            mutated_harmony = new_harmony + mutation_factor * np.random.normal(0, 1, self.dim)\n            mutated_harmony = np.clip(mutated_harmony, -5.0, 5.0)\n            return mutated_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            mutated_harmony = update_mutate(new_harmony, mutation_factor)\n\n            # Other parts of the algorithm remain unchanged\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Improving EnhancedDynamicHarmonySearchRefined by dynamically adjusting the mutation factor to balance exploration and exploitation.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'initialize_harmony_memory' is not defined\").", "error": "NameError(\"name 'initialize_harmony_memory' is not defined\")", "parent_id": "729928c1-5baf-4a00-976e-ef369e3a17c4", "metadata": {}, "mutation_prompt": null}
{"id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 57, "fitness": 0.4212865850440509, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "729928c1-5baf-4a00-976e-ef369e3a17c4", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "d105cb19-329f-4a69-b6c3-86fe2bb18799", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchDynamicSelection:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.optimizers = [differential_evolution, minimize, dual_annealing, basinhopping, shgo]\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            chosen_optimizer = np.random.choice(self.optimizers)\n            optimizer_result = chosen_optimizer(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            optimizer_fitness = func(optimizer_result)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if optimizer_fitness < best_fitness:\n                best_solution = optimizer_result\n                best_fitness = optimizer_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchDynamicSelection", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a dynamic selection mechanism to adaptively choose the most effective optimization strategy based on performance feedback during the optimization process.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"minimize() missing 1 required positional argument: 'x0'\").", "error": "TypeError(\"minimize() missing 1 required positional argument: 'x0'\")", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {}, "mutation_prompt": null}
{"id": "20218347-9a47-4209-bb1c-518f47959a7e", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "1cae1d87-937a-40fc-b289-8e3e5f8acc38", "solution": "class EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            # Incorporating Particle Swarm Optimization (PSO) to update harmony memory\n            for idx in range(self.harmony_memory_size):\n                pso_position = particles[idx]['position']\n                pso_best_position = particles[idx]['position']\n                pso_best_fitness = func(pso_best_position)\n                for _ in range(5):  # Run PSO for a few iterations\n                    pso_velocity = self.pso_w * particles[idx]['velocity'] + self.pso_c1 * np.random.rand() * (pso_best_position - pso_position) + self.pso_c2 * np.random.rand() * (best_solution - pso_position)\n                    pso_position = np.clip(pso_position + pso_velocity, -5.0, 5.0)\n                    if func(pso_position) < pso_best_fitness:\n                        pso_best_position = pso_position\n                        pso_best_fitness = func(pso_position)\n                harmony_memory[idx] = pso_best_position\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by incorporating Particle Swarm Optimization (PSO) to update the harmony memory and search for better solutions.", "configspace": "", "generation": 60, "fitness": 0.4212728262310557, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22560199915964307, 0.2724006296903132, 0.2840706062330344, 0.33400447691994073, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "293bddf4-4dd5-40c5-b1ea-e9f5387700e8", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "8a716657-f798-48b5-8ed7-b26d021f016d", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "07646957-73b6-4657-bcaf-c8c72dd81000", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "c59a50ac-d248-491c-9937-0bf59e1b3974", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "5bc7ad23-1bd9-4007-be63-0277b045a6a8", "solution": "import numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n            # Dynamically adjust population size based on diversity maintenance\n            diversity = np.mean([np.linalg.norm(h - np.mean(harmony_memory, axis=0)) for h in harmony_memory])\n            if diversity < 0.1:\n                harmony_memory = np.vstack((harmony_memory, np.random.uniform(-5.0, 5.0, self.dim)))\n                particles.append({'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim))\n                self.harmony_memory_size += 1\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Improving EnhancedDynamicHarmonySearchRefined by incorporating a dynamic population size adjustment mechanism based on diversity maintenance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError(\"closing parenthesis ')' does not match opening parenthesis '{'\", ('<string>', 144, 117, \"                particles.append({'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim))\")).", "error": "SyntaxError(\"closing parenthesis ')' does not match opening parenthesis '{'\", ('<string>', 144, 117, \"                particles.append({'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim))\"))", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {}, "mutation_prompt": null}
{"id": "fba42c79-52ac-41bc-bfe6-6ac64bb51146", "solution": "from scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by incorporating Particle Swarm Optimization (PSO) to improve exploration and exploitation.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'initialize_harmony_memory' is not defined\").", "error": "NameError(\"name 'initialize_harmony_memory' is not defined\")", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {}, "mutation_prompt": null}
{"id": "eee302dc-2b06-4319-9e85-4896acb15850", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.stats import logistic\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n            # Introducing logistic chaotic map for enhanced diversity\n            chaotic_values = logistic.rvs(size=self.dim)\n            new_harmony += chaotic_values\n            new_harmony = np.clip(new_harmony, -5.0, 5.0)\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Introducing a chaotic dynamical system to enhance diversity and exploration in the population.", "configspace": "", "generation": 67, "fitness": 0.421236340109773, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.2177209969625683, 0.2724006296903132, 0.2840706062330344, 0.33400447691994073, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "43459cf9-e5e7-4e12-9833-bb94f9def96e", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            # Integrate PSO component\n            pso = minimize(func, new_harmony, method='Powell').x\n            particles = [update_velocity_position(particle, particle_best=pso, global_best=pso) for particle in particles]\n            pso = min(particles, key=lambda x: func(x['position']))['position']\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            pso_fitness = func(pso)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if pso_fitness < best_fitness:\n                best_solution = pso\n                best_fitness = pso_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Refining EnhancedDynamicHarmonySearchRefined by incorporating a particle swarm optimization (PSO) component to enhance global exploration.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('tuple indices must be integers or slices, not str').", "error": "TypeError('tuple indices must be integers or slices, not str')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {}, "mutation_prompt": null}
{"id": "b3c407a5-ece5-483d-91bd-c10190b8171c", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import shgo\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import shgo\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import shgo\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            \n            pso = minimize(func, new_harmony, method='Powell').x  # Integrate Particle Swarm Optimization (PSO) for global search\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n            pso_fitness = func(pso)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            if pso_fitness < best_fitness:\n                best_solution = pso\n                best_fitness = pso_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Integrate Particle Swarm Optimization (PSO) for global search to enhance solution quality and convergence speed.", "configspace": "", "generation": 69, "fitness": 0.4212252619316108, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.21423218386226395, 0.2724006296903132, 0.2840706062330344, 0.3351004035372188, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "bce86948-49a5-41d6-b3c2-15d63f8dbca3", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "1787ff76-517b-4727-925f-986b60765dd3", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "4c7736cc-40f3-4042-83cd-b9e18d52b0a9", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "4e74f388-bf0e-432f-a3ee-62f09d82e8f7", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            # New PSO approach\n            pso = minimize(func, particles[0]['position'], method='Powell').x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            pso_fitness = func(pso)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if pso_fitness < best_fitness:\n                best_solution = pso\n                best_fitness = pso_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by introducing a novel Particle Swarm Optimization (PSO) approach for updating solution candidates dynamically.", "configspace": "", "generation": 73, "fitness": 0.4181139376757683, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.1391907721886655, 0.1458543534831821, 0.15618133395806633, 0.4272233475361771, 0.15749569047711798, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971003490338154, 0.5794575550019958, 0.15070364962064053, 0.14647339539340265, 0.15500858509313675, 0.1441820538642653, 0.16191182894949485, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.4402838456504452, 0.519853644180592, 0.4009383579401852, 0.45922588000795184, 0.4558067701119779, 0.4841992163125516, 0.562821999228035, 0.4976162280085902, 0.48830382559687835, 0.22504454216125225, 0.2724006296903132, 0.2840706062330344, 0.33400447691994073, 0.3337720059776885, 0.33965253377854765, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7442832126532433, 0.7818860814639079, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.5175304182261411, 0.25441523067871763, 0.24800361330648235, 0.2485130149336675, 0.22614831148715053, 0.1736055587255989, 0.14544156327230773, 0.2234698208327076, 0.3106170884474829, 0.15832454266203144, 0.38931429386520855, 0.3729511758506846, 0.434865517617399, 0.3130455455479102, 0.270847934639332, 0.3011353958054468, 0.3247302908138596, 0.4516140005491681, 0.3893086062846097, 0.34704831491472166, 0.22953656870654815, 0.204036614822517, 0.1768462078129407, 0.23382034477619928, 0.21705145346518429, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.24637772576311157, 0.2060879163396837, 0.32861918517354616, 0.2999681529690691, 0.267391311800245, 0.3401076832277554, 0.3041947632493772, 0.4049723974639696, 0.7706534511721681, 0.7192978584459293, 0.7450619887069346, 0.7761470712981762, 0.7602605724173636, 0.7594062838851223, 0.7408323529439047, 0.7913762902163497, 0.8080505523444201, 0.08485741612371078, 0.10236498536606853, 0.13083720039673885, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2767225139730586, 0.2589720691351932, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.1982448010020914, 0.19068635921568133, 0.24168856983321774, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17430615542098749, 0.19747313499567942, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.2097020192354604, 0.2096274982980887, 0.22554916786008317, 0.20393136362760933, 0.21489651368141993, 0.2012726435843869, 0.19646948305678114, 0.21975840964791293, 0.20352297315897117, 0.23788357435136553, 0.7421085236410789, 0.19322984509464436, 0.6447476756117783, 0.8602617703522764, 0.8232676727953697, 0.8589883289372653, 0.8315730705834414, 0.793327684030303, 0.7345552093988991, 0.6646376402751941, 0.5446963285582346, 0.7727012676105595, 0.6578657622920824, 0.7030601222871187, 0.7559094687037751, 0.2038090166916332, 0.557713219678714, 0.699722057044704, 0.6848246045463943, 0.16801321899535215, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19156228317934088, 0.2101968763155868, 0.20203963656843216, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "5e8fd3c1-f8e7-448b-b8e5-c64105cacd7a", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import rosen\nfrom scipy.optimize import shgo\nfrom scipy.optimize import dual_annealing\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Integrate Particle Swarm Optimization (PSO) for global search and Local Best Harmony Memory for local search to enhance exploration and exploitation capabilities.", "configspace": "", "generation": 74, "fitness": 0.4212865850440509, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "906eedd4-ef09-4a90-8c2e-bf6d6cec0fa3", "solution": "from scipy.optimize import differential_evolution, minimize, dual_annealing, basinhopping, shgo\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            pso = minimize(func, new_harmony, method='Powell').x  # Integrate PSO\n            pso_fitness = func(pso)\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Improving EnhancedDynamicHarmonySearchRefined by incorporating Particle Swarm Optimization (PSO) for better global exploration and exploitation.", "configspace": "", "generation": 75, "fitness": 0.4212252619316108, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.21423218386226395, 0.2724006296903132, 0.2840706062330344, 0.3351004035372188, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "f2e7ddfd-2f5c-4d7b-ae0f-f1ce5605e844", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "7b127d10-a184-4850-96ee-10cddecfd7d9", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "65730fb5-8310-4d18-b55f-b18d81237be0", "solution": "class EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_prob = 0.7  # Initial crossover probability\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            self.mutation_factor = 0.1 + 0.4 * (iteration / self.budget)  # Dynamic mutation factor adjustment\n            self.crossover_prob = 0.3 + 0.4 * (iteration / self.budget)  # Dynamic crossover probability adjustment\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhance the algorithm by incorporating a dynamic parameter adaptation mechanism to adjust the mutation factor and crossover probability based on the optimization progress.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'initialize_harmony_memory' is not defined\").", "error": "NameError(\"name 'initialize_harmony_memory' is not defined\")", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {}, "mutation_prompt": null}
{"id": "18ac4876-e5a8-46b8-99a5-1b77a2a14575", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefinedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position_pso(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.pso_c1 * np.random.rand() * (particle_best - particle['position']) + self.pso_c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position_pso(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedPSO", "description": "Improving EnhancedDynamicHarmonySearchRefined by incorporating a novel Particle Swarm Optimization (PSO) variant for enhanced global search capability.", "configspace": "", "generation": 79, "fitness": 0.4212865850440509, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefinedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "9a26043c-3c09-4257-a76f-b62796051cec", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import particle_swarm\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            pso = particle_swarm(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n            pso_fitness = func(pso)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            if pso_fitness < best_fitness:\n                best_solution = pso\n                best_fitness = pso_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by incorporating a novel local search strategy using Particle Swarm Optimization (PSO) to improve exploration and exploitation capabilities.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ImportError(\"cannot import name 'particle_swarm' from 'scipy.optimize' (/home/ian/.local/lib/python3.8/site-packages/scipy/optimize/__init__.py)\").", "error": "ImportError(\"cannot import name 'particle_swarm' from 'scipy.optimize' (/home/ian/.local/lib/python3.8/site-packages/scipy/optimize/__init__.py)\")", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {}, "mutation_prompt": null}
{"id": "afeccfcc-2c66-4b7d-914d-1f976e6716bd", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "da18c40d-f1f1-46d3-b291-52e1b2dcf298", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by integrating a novel hybrid optimization approach combining Genetic Algorithm and Simulated Annealing for enhanced exploration and exploitation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22136385923188617, 0.2724006296903132, 0.2840706062330344, 0.3412145204546646, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "48525e82-1b6f-4b8e-952f-65cb91112ee7", "solution": "from scipy.optimize import differential_evolution\nfrom scipy.optimize import minimize\nfrom scipy.optimize import dual_annealing\nfrom scipy.optimize import basinhopping\nfrom scipy.optimize import shgo\nfrom scipy.optimize import dual_annealing\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            pso = minimize(func, new_harmony, method='L-BFGS-B').x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n            pso_fitness = func(pso)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            if pso_fitness < best_fitness:\n                best_solution = pso\n                best_fitness = pso_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing EnhancedDynamicHarmonySearchRefined by incorporating Particle Swarm Optimization (PSO) to improve global exploration and leveraging Differential Evolution (DE) with adaptive mutation for local exploitation, enhancing solution quality and convergence speed.", "configspace": "", "generation": 83, "fitness": 0.4212861894902734, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9286928185817146, 0.9463765993018108, 0.9327766404149923, 0.9374752217483399, 0.949334207250983, 0.9495793781851343, 0.9453378146047274, 0.9498841607943384, 0.9490460088790944, 0.7490482354468238, 0.7406754262235633, 0.7483125831745046, 0.7486528067687452, 0.7356225847532987, 0.7157492247198391, 0.7489755710451663, 0.7382812355119108, 0.7418895728235175, 0.13919077493576792, 0.30775789103022344, 0.43744816729467095, 0.4272233475361771, 0.1574956904565361, 0.5642888091277782, 0.35238900068949297, 0.5446059727519343, 0.1385970723113833, 0.14532496554154872, 0.15971001100626803, 0.5794575550019958, 0.15070364962064053, 0.1380749577735052, 0.1550085795697803, 0.14418204949564084, 0.24814832603681447, 0.514685559343609, 0.5556774508586714, 0.5826489490512863, 0.6108646727775697, 0.9121005632661773, 0.9099025720790208, 0.8972105303602688, 0.7123795519586815, 0.7240629053753898, 0.7107052329479466, 0.43276915271503746, 0.5067530840632795, 0.4009383579401852, 0.45922588000795184, 0.4590680266964011, 0.4799823146404337, 0.562821999228035, 0.49142374244159603, 0.4866458132398461, 0.22130947826501546, 0.2724006296903132, 0.2840706062330344, 0.3411834618055919, 0.3337720059776885, 0.3309407179482171, 0.684621542608288, 0.7305106676729958, 0.7562364713241436, 0.7428309478588743, 0.7852656844975648, 0.7311394936878146, 0.8404362853175165, 0.7933607451447711, 0.850563540826265, 0.775782464770863, 0.7066590372841697, 0.7331824827481486, 0.775489535797752, 0.7820424478296283, 0.6981679892788409, 0.6419594475126602, 0.7023569218495422, 0.7232930246794105, 0.7052202149630713, 0.7058373015354071, 0.4776286194147369, 0.24535000035044308, 0.24800361330648235, 0.2485130149336675, 0.22047357963659264, 0.1736055587255989, 0.14544156327230773, 0.2213001745982256, 0.3106170884474829, 0.15832454266203144, 0.38063901331936323, 0.2518433057782179, 0.38122732919500424, 0.30650879932799, 0.24416524621348845, 0.25113641959751964, 0.29067104637880314, 0.43700863856688077, 0.2810188732626324, 0.31556102662309626, 0.22953656870654815, 0.19956125988747597, 0.1768462078129407, 0.23382034477619928, 0.21163217203801332, 0.12658917624666355, 0.17871533223329206, 0.20048143772488913, 0.21546705299997926, 0.3421568349272037, 0.20586226025814625, 0.31574777947085697, 0.2918682703065255, 0.29226874793406554, 0.3313128695797186, 0.2985798962167737, 0.422504167750113, 0.7486528605417282, 0.7222810196705984, 0.7880557182560107, 0.7620687973249551, 0.8458590861255105, 0.777385876008674, 0.7904821398331318, 0.7761613621801826, 0.7787052757855244, 0.10558399654268524, 0.0952153929203643, 0.12952436266631973, 0.13655612131522632, 0.09872260123440024, 0.10438920359232284, 0.08280638422388675, 0.10201381708599788, 0.16080744045218798, 0.17023106796834286, 0.17269893888010468, 0.140738666473197, 0.15224799188825255, 0.15412470319108829, 0.16734024496642708, 0.13156458864927567, 0.12314211195486935, 0.1420070055757796, 0.29151485059942506, 0.2785089467722949, 0.26260416328817915, 0.25712748452370526, 0.2743880744475973, 0.3256195165782476, 0.20316007997418173, 0.20562095656959922, 0.22646818304692462, 0.30517159114755055, 0.2469040950810274, 0.2760348944342992, 0.27145064527123597, 0.2690499413372105, 0.2779540392812909, 0.23672159614579646, 0.17503258404972, 0.17024526471782153, 0.20605589523903767, 0.2201807978719208, 0.2032352224233347, 0.20365501356798987, 0.20147053889225608, 0.1853642921836719, 0.19173860238489437, 0.21019281378347, 0.2173326904210675, 0.21476241367044036, 0.21489651368141993, 0.22131840742125342, 0.19646948305678114, 0.21975840964791293, 0.21359715443117988, 0.23788357435136553, 0.21642628401850827, 0.21399040930858704, 0.6130169199133287, 0.8602617703522764, 0.8232676727953697, 0.8556097529197711, 0.8315730705834414, 0.8406017472068079, 0.8122671730973405, 0.7606800303064425, 0.5446963285582346, 0.7559269214764849, 0.685007252541287, 0.677768392489225, 0.7453747624184499, 0.2038090166916332, 0.7365344200737117, 0.7928505643353396, 0.7024285590980857, 0.7056888444971476, 0.20669258243570499, 0.19210976659226287, 0.181094779087711, 0.18652011309144134, 0.1905453723324566, 0.17967248536737002, 0.19408246576035337, 0.2103916622768034, 0.20301008281055466, 0.0764000564622298, 0.0815103207541581, 0.08059777630080112, 0.08626606263884629, 0.08104718196310134, 0.09377270879010191, 0.07827977397822139, 0.08257841825248957, 0.07880567373423308]}, "mutation_prompt": null}
{"id": "7b8a2d7a-e330-4d20-8314-425f3c577798", "solution": "class EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.mutation_factor, recombination=self.crossover_prob).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Improving the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a dynamic adaptation mechanism for the mutation factor and crossover probability.", "configspace": "", "generation": 84, "fitness": 0.4803982757255093, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "b8f4dede-711e-461a-a4c1-f73e878c2b3b", "metadata": {"aucs": [0.9450799127495932, 0.9574724833232292, 0.9572856496709006, 0.9624584039182045, 0.9614399628371662, 0.9530450994312158, 0.9688733272223004, 0.956521620068335, 0.9628189852551321, 0.8564721620668878, 0.8655534929112887, 0.8323907380021975, 0.8564776178392365, 0.8399900645168372, 0.849133386026298, 0.8522472094740494, 0.8501717217939393, 0.8457895840327878, 0.6560811684161452, 0.1836765606255253, 0.16955652315977188, 0.18632930501177858, 0.5009431858555495, 0.4827485791692677, 0.1634393250085865, 0.16978725810672568, 0.18123950654069898, 0.1564517411619023, 0.18079900130735693, 0.7573161990344972, 0.12244178717796383, 0.15022598932821696, 0.1549245732075305, 0.1207136128026165, 0.43550885026087804, 0.7379239215513164, 0.697808368246523, 0.7365370384129734, 0.6713332651720807, 0.9317197381659708, 0.9126563557613281, 0.936932329478838, 0.8204100268448029, 0.82367548703125, 0.7645430339015526, 0.6368924361134084, 0.5336573617031086, 0.5915180171007716, 0.5315684935746925, 0.6182521054271151, 0.53914335377039, 0.6723977132679346, 0.689992835376563, 0.5473409692182873, 0.30402976644201285, 0.36307655202063294, 0.2817759735475446, 0.3751746762716103, 0.3842155050879471, 0.35233223438336914, 0.8985386821381323, 0.8590621789932883, 0.37769682717953657, 0.7377330569391518, 0.8314926027680292, 0.7266693310243093, 0.8991032414261471, 0.8945024732168809, 0.8675100930677431, 0.8867242383653772, 0.8534391457523167, 0.7100790468031919, 0.8748327010286847, 0.8781973777531478, 0.8556628972874172, 0.814343186525829, 0.8746450467441493, 0.8782707533082131, 0.8222005838258248, 0.8576703998045924, 0.8408806999478302, 0.3156637396056996, 0.3461052349580924, 0.3724806053827293, 0.40765418826777666, 0.3335395873396143, 0.37599919077535626, 0.3893715783437711, 0.37766500314738627, 0.3460931789337228, 0.3762353536930666, 0.55327965835113, 0.47197239286330994, 0.34140734030379627, 0.3505770885048032, 0.4858598247480216, 0.4946622824941517, 0.4826813453080404, 0.4243054352386598, 0.5153063842311909, 0.5174855363707296, 0.48624362057290094, 0.4808671702962273, 0.660277482544342, 0.6080165241063538, 0.5022357105796484, 0.528395670677589, 0.40076828618270055, 0.5450586339888149, 0.3677927023126294, 0.3602260513150338, 0.33506156900251916, 0.34603949175310045, 0.39570526195120825, 0.44931822707576496, 0.3499183125216725, 0.3699847177755893, 0.7555556342476253, 0.8707848708789954, 0.7784657315868073, 0.7727451624364856, 0.7606227051630806, 0.7909055910567755, 0.8156040039515959, 0.7868347159146137, 0.7899373695293972, 0.14528779610018305, 0.09721850806434051, 0.11983162676351544, 0.11069103844097239, 0.1466556008443114, 0.11963483173894895, 0.1261231268350541, 0.18172868710563495, 0.11435446604722654, 0.2105051126382823, 0.27663022478729515, 0.18028351631331574, 0.23764989819839633, 0.2670187199008417, 0.291095828920242, 0.16065651992502172, 0.2938561726832415, 0.24598157570990797, 0.30569849528855253, 0.3191033908807589, 0.3315601160179501, 0.3329829826117928, 0.3247690381785775, 0.2925770321002481, 0.236201113426031, 0.2721644763158142, 0.23138925093423646, 0.25668210949688197, 0.2772925903788047, 0.2908339240379968, 0.30168737315222083, 0.3331397843254216, 0.2541415647621881, 0.20075695552800066, 0.16124117081978384, 0.22460711748102546, 0.26448332763385807, 0.20412313179351116, 0.19296329262145773, 0.2620385792994149, 0.22638197456710796, 0.2332882552741976, 0.21650222770419836, 0.24923314557580356, 0.25716561774905855, 0.2063189811457099, 0.22973534185803912, 0.2342874177067641, 0.22369598491663967, 0.209062939304963, 0.2186495509043388, 0.20331927191455912, 0.20798820274980168, 0.2535634035000427, 0.8747387316613271, 0.7153471659099082, 0.8743849509569968, 0.903456848901183, 0.19797474953426264, 0.7384203397125553, 0.7055047448818142, 0.7782672600818852, 0.7901921617082648, 0.9035021282964748, 0.797557485885241, 0.8053245749190227, 0.8231727967558408, 0.23913249760207378, 0.6616318227836079, 0.7886421242845894, 0.7116254037499938, 0.1688185520846759, 0.1815394917544345, 0.18324668946392253, 0.18726532084972025, 0.18141675865557705, 0.18071914682440016, 0.1951626199335761, 0.20971150851045295, 0.21909017658328944, 0.21837279665824594, 0.10349037613147705, 0.08867039113671693, 0.09740677599251557, 0.10173236631075833, 0.08255082190268836, 0.09545475046770713, 0.09430400305973996, 0.08741136856963727, 0.09067859585400406]}, "mutation_prompt": null}
{"id": "71aee675-18b8-49a6-92e9-38da4a2d41bb", "solution": "class EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob_min = 0.5\n        self.crossover_prob_max = 0.9\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            crossover_prob = self.crossover_prob_min + (self.crossover_prob_max - self.crossover_prob_min) * (iteration / self.budget)\n            return par, mutation_factor, crossover_prob\n\n        def update_velocity_position(particle, particle_best, global_best, mutation_factor, crossover_prob):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + mutation_factor * np.random.rand() * (particle_best - particle['position']) + crossover_prob * np.random.rand() * (global_best - particle['position'])\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, mutation_factor, crossover_prob = update_parameters(iteration)\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution, mutation_factor, crossover_prob)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Enhancing the algorithm by incorporating a novel adaptive parameter control mechanism to dynamically adjust mutation factor and crossover probability for improved convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'initialize_harmony_memory' is not defined\").", "error": "NameError(\"name 'initialize_harmony_memory' is not defined\")", "parent_id": "7b8a2d7a-e330-4d20-8314-425f3c577798", "metadata": {}, "mutation_prompt": null}
{"id": "32960f2f-0e94-4b2c-b9b2-4871adbc1d02", "solution": "class EnhancedDynamicHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            return par, bandwidth\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.mutation_factor, recombination=self.crossover_prob).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefined", "description": "Improving the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a dynamic adaptation mechanism for the mutation factor and crossover probability.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b8a2d7a-e330-4d20-8314-425f3c577798", "metadata": {"aucs": [0.9450799127495932, 0.9574724833232292, 0.9572856496709006, 0.9624584039182045, 0.9614399628371662, 0.9530450994312158, 0.9688733272223004, 0.956521620068335, 0.9628189852551321, 0.8564721620668878, 0.8655534929112887, 0.8323907380021975, 0.8564776178392365, 0.8399900645168372, 0.849133386026298, 0.8522472094740494, 0.8501717217939393, 0.8457895840327878, 0.6560811684161452, 0.1836765606255253, 0.16955652315977188, 0.18632930501177858, 0.5009431858555495, 0.4827485791692677, 0.1634393250085865, 0.16978725810672568, 0.18123950654069898, 0.1564517411619023, 0.18079900130735693, 0.7573161990344972, 0.12244178717796383, 0.15022598932821696, 0.1549245732075305, 0.1207136128026165, 0.43550885026087804, 0.7379239215513164, 0.697808368246523, 0.7365370384129734, 0.6713332651720807, 0.9317197381659708, 0.9126563557613281, 0.936932329478838, 0.8204100268448029, 0.82367548703125, 0.7645430339015526, 0.6368924361134084, 0.5336573617031086, 0.5915180171007716, 0.5315684935746925, 0.6182521054271151, 0.53914335377039, 0.6723977132679346, 0.689992835376563, 0.5473409692182873, 0.30402976644201285, 0.36307655202063294, 0.2817759735475446, 0.3751746762716103, 0.3842155050879471, 0.35233223438336914, 0.8985386821381323, 0.8590621789932883, 0.37769682717953657, 0.7377330569391518, 0.8314926027680292, 0.7266693310243093, 0.8991032414261471, 0.8945024732168809, 0.8675100930677431, 0.8867242383653772, 0.8534391457523167, 0.7100790468031919, 0.8748327010286847, 0.8781973777531478, 0.8556628972874172, 0.814343186525829, 0.8746450467441493, 0.8782707533082131, 0.8222005838258248, 0.8576703998045924, 0.8408806999478302, 0.3156637396056996, 0.3461052349580924, 0.3724806053827293, 0.40765418826777666, 0.3335395873396143, 0.37599919077535626, 0.3893715783437711, 0.37766500314738627, 0.3460931789337228, 0.3762353536930666, 0.55327965835113, 0.47197239286330994, 0.34140734030379627, 0.3505770885048032, 0.4858598247480216, 0.4946622824941517, 0.4826813453080404, 0.4243054352386598, 0.5153063842311909, 0.5174855363707296, 0.48624362057290094, 0.4808671702962273, 0.660277482544342, 0.6080165241063538, 0.5022357105796484, 0.528395670677589, 0.40076828618270055, 0.5450586339888149, 0.3677927023126294, 0.3602260513150338, 0.33506156900251916, 0.34603949175310045, 0.39570526195120825, 0.44931822707576496, 0.3499183125216725, 0.3699847177755893, 0.7555556342476253, 0.8707848708789954, 0.7784657315868073, 0.7727451624364856, 0.7606227051630806, 0.7909055910567755, 0.8156040039515959, 0.7868347159146137, 0.7899373695293972, 0.14528779610018305, 0.09721850806434051, 0.11983162676351544, 0.11069103844097239, 0.1466556008443114, 0.11963483173894895, 0.1261231268350541, 0.18172868710563495, 0.11435446604722654, 0.2105051126382823, 0.27663022478729515, 0.18028351631331574, 0.23764989819839633, 0.2670187199008417, 0.291095828920242, 0.16065651992502172, 0.2938561726832415, 0.24598157570990797, 0.30569849528855253, 0.3191033908807589, 0.3315601160179501, 0.3329829826117928, 0.3247690381785775, 0.2925770321002481, 0.236201113426031, 0.2721644763158142, 0.23138925093423646, 0.25668210949688197, 0.2772925903788047, 0.2908339240379968, 0.30168737315222083, 0.3331397843254216, 0.2541415647621881, 0.20075695552800066, 0.16124117081978384, 0.22460711748102546, 0.26448332763385807, 0.20412313179351116, 0.19296329262145773, 0.2620385792994149, 0.22638197456710796, 0.2332882552741976, 0.21650222770419836, 0.24923314557580356, 0.25716561774905855, 0.2063189811457099, 0.22973534185803912, 0.2342874177067641, 0.22369598491663967, 0.209062939304963, 0.2186495509043388, 0.20331927191455912, 0.20798820274980168, 0.2535634035000427, 0.8747387316613271, 0.7153471659099082, 0.8743849509569968, 0.903456848901183, 0.19797474953426264, 0.7384203397125553, 0.7055047448818142, 0.7782672600818852, 0.7901921617082648, 0.9035021282964748, 0.797557485885241, 0.8053245749190227, 0.8231727967558408, 0.23913249760207378, 0.6616318227836079, 0.7886421242845894, 0.7116254037499938, 0.1688185520846759, 0.1815394917544345, 0.18324668946392253, 0.18726532084972025, 0.18141675865557705, 0.18071914682440016, 0.1951626199335761, 0.20971150851045295, 0.21909017658328944, 0.21837279665824594, 0.10349037613147705, 0.08867039113671693, 0.09740677599251557, 0.10173236631075833, 0.08255082190268836, 0.09545475046770713, 0.09430400305973996, 0.08741136856963727, 0.09067859585400406]}, "mutation_prompt": null}
{"id": "b10afde7-4be1-45fc-98ab-9d1d5a5ee9ea", "solution": "class EnhancedDynamicHarmonySearchRefinedAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedAdaptiveMutation", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a novel adaptive mutation mechanism based on particle swarm optimization.", "configspace": "", "generation": 87, "fitness": 0.4925972378682903, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefinedAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.32.", "error": "", "parent_id": "7b8a2d7a-e330-4d20-8314-425f3c577798", "metadata": {"aucs": [0.9711286858400736, 0.9708205395198826, 0.9712662957504874, 0.9722103832559792, 0.9766922604503864, 0.9685236949678653, 0.9705026243198032, 0.9711408435396481, 0.9762566628177733, 0.9254023111366384, 0.9104152436069589, 0.9063927064324393, 0.9022329049918167, 0.9249750600334049, 0.9358998024350248, 0.918944416918825, 0.9261419231094032, 0.9340265451125982, 0.12036449246111713, 0.18167654358839802, 0.15800656811865943, 0.15531846954311623, 0.15751879231550048, 0.18936785477154416, 0.14209402742593524, 0.1547680197553596, 0.18465071007185307, 0.18625422941564562, 0.1813879103309568, 0.9248182710270768, 0.14605976090843198, 0.16209912987606656, 0.16357639088898035, 0.15158766883260744, 0.17800523637808563, 0.9022002470825622, 0.910614581206135, 0.8874759533056218, 0.894114286210905, 0.9608337788093285, 0.9540604185071728, 0.9533733762817465, 0.9239834966154555, 0.9160202461856208, 0.9015561186791416, 0.7071497930804616, 0.5995468210066568, 0.7161195528624681, 0.6285176637884471, 0.5240017448517609, 0.7485089826673297, 0.6713742581510007, 0.6624033126667361, 0.5834513285275591, 0.21261712160929114, 0.32613638865606354, 0.23761621548339196, 0.2635871847177699, 0.2642044297982755, 0.2091231278593666, 0.16416469255797328, 0.16204403517678878, 0.22130640706446825, 0.8522963375378017, 0.8317946157432569, 0.9384505136394455, 0.9298823723708635, 0.8030126615364868, 0.9283316785416378, 0.8060426174227145, 0.9318008197767824, 0.8620034185228355, 0.9317651158988973, 0.9421068606924996, 0.9388770968146537, 0.9220130362537678, 0.9441630115470834, 0.8386015080346945, 0.9345304055484855, 0.8924802560698497, 0.8906259519625437, 0.3050937716160057, 0.13465943108864553, 0.38123205076773625, 0.42896425237646507, 0.4971573586535264, 0.6479851063866555, 0.6044483460301375, 0.4480146023513818, 0.5858190277374753, 0.46657867871662617, 0.6363790269162442, 0.6200116809853939, 0.5670511097006523, 0.597589619666123, 0.21912480044949123, 0.44909879032880995, 0.33497705702365355, 0.5015694226808521, 0.7060823478068137, 0.6856840621609639, 0.6578343005333818, 0.714875261339109, 0.7838930357083644, 0.7000503841921213, 0.6878497295307351, 0.6993761613027701, 0.7247120086268358, 0.36545306377233544, 0.33041452848748454, 0.3227193827780105, 0.3488625344367188, 0.37415970577548874, 0.3583936781886128, 0.5479424234171519, 0.4596381061373078, 0.45771295180017313, 0.8121375086722789, 0.7953834141798956, 0.7945581078521706, 0.8039277481265299, 0.7783915732604618, 0.7787902921815546, 0.8120471677214202, 0.8505339197853945, 0.807799632110217, 0.10181847565568536, 0.09778079810067464, 0.17819226964893387, 0.12020376696272839, 0.09139361388548861, 0.09106021533147901, 0.13662227863430365, 0.10887431646110457, 0.08432262788043532, 0.20492742897951344, 0.23791711753260703, 0.1933136820560275, 0.3204596144331253, 0.2280106903994571, 0.21104152486625172, 0.22565953180411036, 0.31425794615112623, 0.20355514000112884, 0.3121744357907601, 0.21601834817556087, 0.1663218127781736, 0.22496524356685954, 0.20974056333087987, 0.28329705272780925, 0.2737186791653655, 0.27720326192361533, 0.3118729426237963, 0.1998523658478677, 0.14557574718565525, 0.20847830565032555, 0.12478752737569154, 0.23035400865938804, 0.22570077460759752, 0.18100356509112336, 0.2447530948267015, 0.3227357659314811, 0.2410469462496403, 0.2513207748603, 0.2091843307433101, 0.2459599958941454, 0.21094053706157478, 0.18448234062435942, 0.2791512027930325, 0.23358786284108324, 0.2574869343681716, 0.20692376717550165, 0.23059829047899916, 0.20083909482500817, 0.7600491552412206, 0.21241696054316328, 0.21531665538275235, 0.20263620826698603, 0.22782008432088885, 0.203353755342234, 0.16506531573089467, 0.8209351119874244, 0.9344683426609067, 0.8332468603041709, 0.9114725428509638, 0.8498808269091196, 0.17060437449348687, 0.8295749878929415, 0.8835976891792294, 0.8088813528052679, 0.1572317108395922, 0.764608840315705, 0.8715237664064025, 0.2386823529381169, 0.2130143503716624, 0.8857912521715687, 0.9428874890978405, 0.9244163301136238, 0.2309292773975532, 0.20798916302085912, 0.20260326686543162, 0.2546480346582429, 0.2432711883873221, 0.22332181422643227, 0.21790263030637802, 0.25077793896503375, 0.2328501732822854, 0.10220910129614569, 0.09091915120118743, 0.08650354700748508, 0.09816879786285859, 0.08050988236788448, 0.12311459052101759, 0.11547693902882128, 0.09453533390446989, 0.07792163649484285]}, "mutation_prompt": null}
{"id": "ccd6768a-8268-4e07-8d17-ee6328011411", "solution": "class EnhancedDynamicHarmonySearchRefinedAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedAdaptiveMutation", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a novel adaptive mutation mechanism based on particle swarm optimization.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b10afde7-4be1-45fc-98ab-9d1d5a5ee9ea", "metadata": {"aucs": [0.9711286858400736, 0.9708205395198826, 0.9712662957504874, 0.9722103832559792, 0.9766922604503864, 0.9685236949678653, 0.9705026243198032, 0.9711408435396481, 0.9762566628177733, 0.9254023111366384, 0.9104152436069589, 0.9063927064324393, 0.9022329049918167, 0.9249750600334049, 0.9358998024350248, 0.918944416918825, 0.9261419231094032, 0.9340265451125982, 0.12036449246111713, 0.18167654358839802, 0.15800656811865943, 0.15531846954311623, 0.15751879231550048, 0.18936785477154416, 0.14209402742593524, 0.1547680197553596, 0.18465071007185307, 0.18625422941564562, 0.1813879103309568, 0.9248182710270768, 0.14605976090843198, 0.16209912987606656, 0.16357639088898035, 0.15158766883260744, 0.17800523637808563, 0.9022002470825622, 0.910614581206135, 0.8874759533056218, 0.894114286210905, 0.9608337788093285, 0.9540604185071728, 0.9533733762817465, 0.9239834966154555, 0.9160202461856208, 0.9015561186791416, 0.7071497930804616, 0.5995468210066568, 0.7161195528624681, 0.6285176637884471, 0.5240017448517609, 0.7485089826673297, 0.6713742581510007, 0.6624033126667361, 0.5834513285275591, 0.21261712160929114, 0.32613638865606354, 0.23761621548339196, 0.2635871847177699, 0.2642044297982755, 0.2091231278593666, 0.16416469255797328, 0.16204403517678878, 0.22130640706446825, 0.8522963375378017, 0.8317946157432569, 0.9384505136394455, 0.9298823723708635, 0.8030126615364868, 0.9283316785416378, 0.8060426174227145, 0.9318008197767824, 0.8620034185228355, 0.9317651158988973, 0.9421068606924996, 0.9388770968146537, 0.9220130362537678, 0.9441630115470834, 0.8386015080346945, 0.9345304055484855, 0.8924802560698497, 0.8906259519625437, 0.3050937716160057, 0.13465943108864553, 0.38123205076773625, 0.42896425237646507, 0.4971573586535264, 0.6479851063866555, 0.6044483460301375, 0.4480146023513818, 0.5858190277374753, 0.46657867871662617, 0.6363790269162442, 0.6200116809853939, 0.5670511097006523, 0.597589619666123, 0.21912480044949123, 0.44909879032880995, 0.33497705702365355, 0.5015694226808521, 0.7060823478068137, 0.6856840621609639, 0.6578343005333818, 0.714875261339109, 0.7838930357083644, 0.7000503841921213, 0.6878497295307351, 0.6993761613027701, 0.7247120086268358, 0.36545306377233544, 0.33041452848748454, 0.3227193827780105, 0.3488625344367188, 0.37415970577548874, 0.3583936781886128, 0.5479424234171519, 0.4596381061373078, 0.45771295180017313, 0.8121375086722789, 0.7953834141798956, 0.7945581078521706, 0.8039277481265299, 0.7783915732604618, 0.7787902921815546, 0.8120471677214202, 0.8505339197853945, 0.807799632110217, 0.10181847565568536, 0.09778079810067464, 0.17819226964893387, 0.12020376696272839, 0.09139361388548861, 0.09106021533147901, 0.13662227863430365, 0.10887431646110457, 0.08432262788043532, 0.20492742897951344, 0.23791711753260703, 0.1933136820560275, 0.3204596144331253, 0.2280106903994571, 0.21104152486625172, 0.22565953180411036, 0.31425794615112623, 0.20355514000112884, 0.3121744357907601, 0.21601834817556087, 0.1663218127781736, 0.22496524356685954, 0.20974056333087987, 0.28329705272780925, 0.2737186791653655, 0.27720326192361533, 0.3118729426237963, 0.1998523658478677, 0.14557574718565525, 0.20847830565032555, 0.12478752737569154, 0.23035400865938804, 0.22570077460759752, 0.18100356509112336, 0.2447530948267015, 0.3227357659314811, 0.2410469462496403, 0.2513207748603, 0.2091843307433101, 0.2459599958941454, 0.21094053706157478, 0.18448234062435942, 0.2791512027930325, 0.23358786284108324, 0.2574869343681716, 0.20692376717550165, 0.23059829047899916, 0.20083909482500817, 0.7600491552412206, 0.21241696054316328, 0.21531665538275235, 0.20263620826698603, 0.22782008432088885, 0.203353755342234, 0.16506531573089467, 0.8209351119874244, 0.9344683426609067, 0.8332468603041709, 0.9114725428509638, 0.8498808269091196, 0.17060437449348687, 0.8295749878929415, 0.8835976891792294, 0.8088813528052679, 0.1572317108395922, 0.764608840315705, 0.8715237664064025, 0.2386823529381169, 0.2130143503716624, 0.8857912521715687, 0.9428874890978405, 0.9244163301136238, 0.2309292773975532, 0.20798916302085912, 0.20260326686543162, 0.2546480346582429, 0.2432711883873221, 0.22332181422643227, 0.21790263030637802, 0.25077793896503375, 0.2328501732822854, 0.10220910129614569, 0.09091915120118743, 0.08650354700748508, 0.09816879786285859, 0.08050988236788448, 0.12311459052101759, 0.11547693902882128, 0.09453533390446989, 0.07792163649484285]}, "mutation_prompt": null}
{"id": "caeeab65-d0f3-4e39-836b-f08a3d916bd1", "solution": "class EnhancedDynamicHarmonySearchRefinedAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedAdaptiveMutation", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a novel adaptive mutation mechanism based on particle swarm optimization.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b10afde7-4be1-45fc-98ab-9d1d5a5ee9ea", "metadata": {"aucs": [0.9711286858400736, 0.9708205395198826, 0.9712662957504874, 0.9722103832559792, 0.9766922604503864, 0.9685236949678653, 0.9705026243198032, 0.9711408435396481, 0.9762566628177733, 0.9254023111366384, 0.9104152436069589, 0.9063927064324393, 0.9022329049918167, 0.9249750600334049, 0.9358998024350248, 0.918944416918825, 0.9261419231094032, 0.9340265451125982, 0.12036449246111713, 0.18167654358839802, 0.15800656811865943, 0.15531846954311623, 0.15751879231550048, 0.18936785477154416, 0.14209402742593524, 0.1547680197553596, 0.18465071007185307, 0.18625422941564562, 0.1813879103309568, 0.9248182710270768, 0.14605976090843198, 0.16209912987606656, 0.16357639088898035, 0.15158766883260744, 0.17800523637808563, 0.9022002470825622, 0.910614581206135, 0.8874759533056218, 0.894114286210905, 0.9608337788093285, 0.9540604185071728, 0.9533733762817465, 0.9239834966154555, 0.9160202461856208, 0.9015561186791416, 0.7071497930804616, 0.5995468210066568, 0.7161195528624681, 0.6285176637884471, 0.5240017448517609, 0.7485089826673297, 0.6713742581510007, 0.6624033126667361, 0.5834513285275591, 0.21261712160929114, 0.32613638865606354, 0.23761621548339196, 0.2635871847177699, 0.2642044297982755, 0.2091231278593666, 0.16416469255797328, 0.16204403517678878, 0.22130640706446825, 0.8522963375378017, 0.8317946157432569, 0.9384505136394455, 0.9298823723708635, 0.8030126615364868, 0.9283316785416378, 0.8060426174227145, 0.9318008197767824, 0.8620034185228355, 0.9317651158988973, 0.9421068606924996, 0.9388770968146537, 0.9220130362537678, 0.9441630115470834, 0.8386015080346945, 0.9345304055484855, 0.8924802560698497, 0.8906259519625437, 0.3050937716160057, 0.13465943108864553, 0.38123205076773625, 0.42896425237646507, 0.4971573586535264, 0.6479851063866555, 0.6044483460301375, 0.4480146023513818, 0.5858190277374753, 0.46657867871662617, 0.6363790269162442, 0.6200116809853939, 0.5670511097006523, 0.597589619666123, 0.21912480044949123, 0.44909879032880995, 0.33497705702365355, 0.5015694226808521, 0.7060823478068137, 0.6856840621609639, 0.6578343005333818, 0.714875261339109, 0.7838930357083644, 0.7000503841921213, 0.6878497295307351, 0.6993761613027701, 0.7247120086268358, 0.36545306377233544, 0.33041452848748454, 0.3227193827780105, 0.3488625344367188, 0.37415970577548874, 0.3583936781886128, 0.5479424234171519, 0.4596381061373078, 0.45771295180017313, 0.8121375086722789, 0.7953834141798956, 0.7945581078521706, 0.8039277481265299, 0.7783915732604618, 0.7787902921815546, 0.8120471677214202, 0.8505339197853945, 0.807799632110217, 0.10181847565568536, 0.09778079810067464, 0.17819226964893387, 0.12020376696272839, 0.09139361388548861, 0.09106021533147901, 0.13662227863430365, 0.10887431646110457, 0.08432262788043532, 0.20492742897951344, 0.23791711753260703, 0.1933136820560275, 0.3204596144331253, 0.2280106903994571, 0.21104152486625172, 0.22565953180411036, 0.31425794615112623, 0.20355514000112884, 0.3121744357907601, 0.21601834817556087, 0.1663218127781736, 0.22496524356685954, 0.20974056333087987, 0.28329705272780925, 0.2737186791653655, 0.27720326192361533, 0.3118729426237963, 0.1998523658478677, 0.14557574718565525, 0.20847830565032555, 0.12478752737569154, 0.23035400865938804, 0.22570077460759752, 0.18100356509112336, 0.2447530948267015, 0.3227357659314811, 0.2410469462496403, 0.2513207748603, 0.2091843307433101, 0.2459599958941454, 0.21094053706157478, 0.18448234062435942, 0.2791512027930325, 0.23358786284108324, 0.2574869343681716, 0.20692376717550165, 0.23059829047899916, 0.20083909482500817, 0.7600491552412206, 0.21241696054316328, 0.21531665538275235, 0.20263620826698603, 0.22782008432088885, 0.203353755342234, 0.16506531573089467, 0.8209351119874244, 0.9344683426609067, 0.8332468603041709, 0.9114725428509638, 0.8498808269091196, 0.17060437449348687, 0.8295749878929415, 0.8835976891792294, 0.8088813528052679, 0.1572317108395922, 0.764608840315705, 0.8715237664064025, 0.2386823529381169, 0.2130143503716624, 0.8857912521715687, 0.9428874890978405, 0.9244163301136238, 0.2309292773975532, 0.20798916302085912, 0.20260326686543162, 0.2546480346582429, 0.2432711883873221, 0.22332181422643227, 0.21790263030637802, 0.25077793896503375, 0.2328501732822854, 0.10220910129614569, 0.09091915120118743, 0.08650354700748508, 0.09816879786285859, 0.08050988236788448, 0.12311459052101759, 0.11547693902882128, 0.09453533390446989, 0.07792163649484285]}, "mutation_prompt": null}
{"id": "e9e9dc9a-96b2-4a5a-9572-bd4ddcad2109", "solution": "class EnhancedDynamicHarmonySearchRefinedAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def apply_opposition(new_harmony):\n            return 2.0 * np.mean(new_harmony) - new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            new_harmony_opposite = apply_opposition(new_harmony)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            de_harmony_opposite = apply_opposition(de_harmony)\n\n            ps = minimize(func, new_harmony, method='Powell').x\n            ps_opposite = apply_opposition(ps)\n\n            ga = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=self.ga_mut_prob).x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            shg = shgo(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            new_fitness_opposite = func(new_harmony_opposite)\n            de_fitness = func(de_harmony)\n            de_fitness_opposite = func(de_harmony_opposite)\n            ps_fitness = func(ps)\n            ps_fitness_opposite = func(ps_opposite)\n            ga_fitness = func(ga)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n            shg_fitness = func(shg)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if new_fitness_opposite < best_fitness:\n                best_solution = new_harmony_opposite\n                best_fitness = new_fitness_opposite\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if de_fitness_opposite < best_fitness:\n                best_solution = de_harmony_opposite\n                best_fitness = de_fitness_opposite\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if ps_fitness_opposite < best_fitness:\n                best_solution = ps_opposite\n                best_fitness = ps_fitness_opposite\n\n            if ga_fitness < best_fitness:\n                best_solution = ga\n                best_fitness = ga_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            if shg_fitness < best_fitness:\n                best_solution = shg\n                best_fitness = shg_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedAdaptiveMutation", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by incorporating a novel adaptive mutation mechanism based on particle swarm optimization.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b10afde7-4be1-45fc-98ab-9d1d5a5ee9ea", "metadata": {"aucs": [0.9711286858400736, 0.9708205395198826, 0.9712662957504874, 0.9722103832559792, 0.9766922604503864, 0.9685236949678653, 0.9705026243198032, 0.9711408435396481, 0.9762566628177733, 0.9254023111366384, 0.9104152436069589, 0.9063927064324393, 0.9022329049918167, 0.9249750600334049, 0.9358998024350248, 0.918944416918825, 0.9261419231094032, 0.9340265451125982, 0.12036449246111713, 0.18167654358839802, 0.15800656811865943, 0.15531846954311623, 0.15751879231550048, 0.18936785477154416, 0.14209402742593524, 0.1547680197553596, 0.18465071007185307, 0.18625422941564562, 0.1813879103309568, 0.9248182710270768, 0.14605976090843198, 0.16209912987606656, 0.16357639088898035, 0.15158766883260744, 0.17800523637808563, 0.9022002470825622, 0.910614581206135, 0.8874759533056218, 0.894114286210905, 0.9608337788093285, 0.9540604185071728, 0.9533733762817465, 0.9239834966154555, 0.9160202461856208, 0.9015561186791416, 0.7071497930804616, 0.5995468210066568, 0.7161195528624681, 0.6285176637884471, 0.5240017448517609, 0.7485089826673297, 0.6713742581510007, 0.6624033126667361, 0.5834513285275591, 0.21261712160929114, 0.32613638865606354, 0.23761621548339196, 0.2635871847177699, 0.2642044297982755, 0.2091231278593666, 0.16416469255797328, 0.16204403517678878, 0.22130640706446825, 0.8522963375378017, 0.8317946157432569, 0.9384505136394455, 0.9298823723708635, 0.8030126615364868, 0.9283316785416378, 0.8060426174227145, 0.9318008197767824, 0.8620034185228355, 0.9317651158988973, 0.9421068606924996, 0.9388770968146537, 0.9220130362537678, 0.9441630115470834, 0.8386015080346945, 0.9345304055484855, 0.8924802560698497, 0.8906259519625437, 0.3050937716160057, 0.13465943108864553, 0.38123205076773625, 0.42896425237646507, 0.4971573586535264, 0.6479851063866555, 0.6044483460301375, 0.4480146023513818, 0.5858190277374753, 0.46657867871662617, 0.6363790269162442, 0.6200116809853939, 0.5670511097006523, 0.597589619666123, 0.21912480044949123, 0.44909879032880995, 0.33497705702365355, 0.5015694226808521, 0.7060823478068137, 0.6856840621609639, 0.6578343005333818, 0.714875261339109, 0.7838930357083644, 0.7000503841921213, 0.6878497295307351, 0.6993761613027701, 0.7247120086268358, 0.36545306377233544, 0.33041452848748454, 0.3227193827780105, 0.3488625344367188, 0.37415970577548874, 0.3583936781886128, 0.5479424234171519, 0.4596381061373078, 0.45771295180017313, 0.8121375086722789, 0.7953834141798956, 0.7945581078521706, 0.8039277481265299, 0.7783915732604618, 0.7787902921815546, 0.8120471677214202, 0.8505339197853945, 0.807799632110217, 0.10181847565568536, 0.09778079810067464, 0.17819226964893387, 0.12020376696272839, 0.09139361388548861, 0.09106021533147901, 0.13662227863430365, 0.10887431646110457, 0.08432262788043532, 0.20492742897951344, 0.23791711753260703, 0.1933136820560275, 0.3204596144331253, 0.2280106903994571, 0.21104152486625172, 0.22565953180411036, 0.31425794615112623, 0.20355514000112884, 0.3121744357907601, 0.21601834817556087, 0.1663218127781736, 0.22496524356685954, 0.20974056333087987, 0.28329705272780925, 0.2737186791653655, 0.27720326192361533, 0.3118729426237963, 0.1998523658478677, 0.14557574718565525, 0.20847830565032555, 0.12478752737569154, 0.23035400865938804, 0.22570077460759752, 0.18100356509112336, 0.2447530948267015, 0.3227357659314811, 0.2410469462496403, 0.2513207748603, 0.2091843307433101, 0.2459599958941454, 0.21094053706157478, 0.18448234062435942, 0.2791512027930325, 0.23358786284108324, 0.2574869343681716, 0.20692376717550165, 0.23059829047899916, 0.20083909482500817, 0.7600491552412206, 0.21241696054316328, 0.21531665538275235, 0.20263620826698603, 0.22782008432088885, 0.203353755342234, 0.16506531573089467, 0.8209351119874244, 0.9344683426609067, 0.8332468603041709, 0.9114725428509638, 0.8498808269091196, 0.17060437449348687, 0.8295749878929415, 0.8835976891792294, 0.8088813528052679, 0.1572317108395922, 0.764608840315705, 0.8715237664064025, 0.2386823529381169, 0.2130143503716624, 0.8857912521715687, 0.9428874890978405, 0.9244163301136238, 0.2309292773975532, 0.20798916302085912, 0.20260326686543162, 0.2546480346582429, 0.2432711883873221, 0.22332181422643227, 0.21790263030637802, 0.25077793896503375, 0.2328501732822854, 0.10220910129614569, 0.09091915120118743, 0.08650354700748508, 0.09816879786285859, 0.08050988236788448, 0.12311459052101759, 0.11547693902882128, 0.09453533390446989, 0.07792163649484285]}, "mutation_prompt": null}
{"id": "e774078b-2eca-4b87-8a07-2779bd0d953a", "solution": "class EnhancedDynamicHarmonySearchRefinedAdaptiveMutationImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n        self.sa_iter = 100\n        self.sa_T0 = 100\n        self.sa_Tf = 0.001\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, mutation_factor\n\n        def improvise_harmony(harmony_memory, par):\n            new_harmony = np.copy(harmony_memory[np.random.choice(range(self.harmony_memory_size))])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-0.1, 0.1)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def update_velocity_position(particle, particle_best, global_best):\n            velocity = self.inertia_weight * particle['velocity'] + self.c1 * np.random.rand() * (particle_best - particle['position']) + self.c2 * np.random.rand() * (global_best - particle['position'])\n            position = particle['position'] + velocity\n            position = np.clip(position, -5.0, 5.0)\n            return position, velocity\n\n        harmony_memory = initialize_harmony_memory()\n        particles = [{'position': np.random.uniform(-5.0, 5.0, self.dim), 'velocity': np.zeros(self.dim)} for _ in range(self.harmony_memory_size)]\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n\n            ps = minimize(func, new_harmony, method='Powell').x\n\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim, maxiter=self.sa_iter, initial_temp=self.sa_T0, restart_temp_ratio=self.sa_Tf).x\n\n            basinhop = basinhopping(func, new_harmony, stepsize=0.5).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            ps_fitness = func(ps)\n            sa_fitness = func(sa)\n            basinhop_fitness = func(basinhop)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if ps_fitness < best_fitness:\n                best_solution = ps\n                best_fitness = ps_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            if basinhop_fitness < best_fitness:\n                best_solution = basinhop\n                best_fitness = basinhop_fitness\n\n            for idx, particle in enumerate(particles):\n                new_position, new_velocity = update_velocity_position(particle, best_solution, best_solution)\n                particles[idx]['position'] = new_position\n                particles[idx]['velocity'] = new_velocity\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedAdaptiveMutationImproved", "description": "Enhancing meta-learning adaptive mechanisms for parameter tuning and solution selection to improve convergence and exploration in the algorithm.", "configspace": "", "generation": 91, "fitness": 0.48837294360928074, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefinedAdaptiveMutationImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.32.", "error": "", "parent_id": "b10afde7-4be1-45fc-98ab-9d1d5a5ee9ea", "metadata": {"aucs": [0.9683204029233557, 0.9772825883086984, 0.971714411767363, 0.9726222020749873, 0.9725978811194589, 0.9723368560956291, 0.9739739912331667, 0.9736612793607883, 0.9774123769009017, 0.9062955641930118, 0.9181066581768549, 0.9189590491320206, 0.9131574038484465, 0.9012343001593254, 0.9094747725257243, 0.9292454824776974, 0.9129011003378924, 0.8965736734413924, 0.1839082845614417, 0.19674144963671547, 0.162034825438521, 0.1599549359105269, 0.18325146236707035, 0.7364487474904782, 0.16287103586893192, 0.14282135192671808, 0.8550443895152242, 0.17699899066307756, 0.14895988210484046, 0.19102152785154236, 0.16432415396851263, 0.16051339944295906, 0.18723880301225804, 0.18416502335689122, 0.8325592291116538, 0.1882774218403085, 0.8885648238546604, 0.8994246900810997, 0.8940065393798406, 0.9580621913005857, 0.9537406732374375, 0.9583688607312766, 0.919184086809371, 0.9417246332499511, 0.9341457738435365, 0.7693377610905308, 0.7670409285448554, 0.68763909394796, 0.8114624558894239, 0.5857852925077726, 0.701941724578552, 0.7022307069209647, 0.5959895188336188, 0.621693045092673, 0.18637056003020602, 0.1767463096489511, 0.14519378627327095, 0.2536253492252154, 0.2664139954067051, 0.2622928421753663, 0.2212121466837339, 0.17745554761509996, 0.17640695692846198, 0.8842527567346031, 0.8914412328969343, 0.8567675280860514, 0.8571298113639682, 0.9015437877237461, 0.8619832417236076, 0.84185967927949, 0.9370998302339564, 0.8405667720529018, 0.7697285289331857, 0.9324672722685441, 0.9092567171825371, 0.8740460752301522, 0.9288746367772003, 0.8483820383305231, 0.9132687905421635, 0.8172901899314492, 0.7934883326967831, 0.1755758801870776, 0.12578235425370965, 0.5709884963362861, 0.586546825200387, 0.2764872720831629, 0.6494609595899834, 0.41390018217953173, 0.6409446872655081, 0.5894271262646621, 0.5323408600305339, 0.6013447159815658, 0.3976028413800142, 0.5232602049253633, 0.39097627058931517, 0.42622631996652727, 0.5453426818456347, 0.4348240638868971, 0.5668257377932836, 0.6752793173565129, 0.8042066748349193, 0.759880770655279, 0.7548591244262239, 0.741040525259175, 0.7801860570939456, 0.7489933553677555, 0.8102016708243562, 0.6531351404980037, 0.39229247597598704, 0.4737589923691695, 0.3764625088979431, 0.5444693275846908, 0.396240428710281, 0.4038963961304626, 0.49725937140413845, 0.4835549426015118, 0.5067725703548622, 0.7842370997318209, 0.893012867148487, 0.7517003868448301, 0.824381162213954, 0.7587796975160335, 0.7908307160139959, 0.8003773149611398, 0.8121044546281847, 0.8053743617333633, 0.14979442477796256, 0.12326453659868764, 0.11113369006550111, 0.07865755439258915, 0.11905207100551618, 0.11502783710236741, 0.14256752053001798, 0.1950254921068416, 0.1080944128543817, 0.1750522617546414, 0.22496333363949383, 0.1598323311670714, 0.2623314408589599, 0.19332891446738076, 0.2245144894260862, 0.4193488737374288, 0.22720187127537594, 0.19834663865747593, 0.419139073727835, 0.2145823758071057, 0.20418629593169502, 0.21421815192818894, 0.2327377668369861, 0.14860423149799573, 0.1995488541681163, 0.24334365762129384, 0.35129654512695874, 0.15934581449332852, 0.16724085068254047, 0.11076429879194116, 0.16107784038323203, 0.15975233647306375, 0.24564840790869713, 0.1836979515848417, 0.1389888165739882, 0.21224302514098148, 0.22430774057038805, 0.22999647876497697, 0.23098581584889621, 0.22578745070391704, 0.16996331766415018, 0.24851195881737098, 0.2575688980411319, 0.29332249147292355, 0.20651338628795934, 0.22497371561406088, 0.20274469950471863, 0.22993264782476508, 0.2291616348896599, 0.23631533607567767, 0.20171060341441927, 0.2337268451005753, 0.20014294721423198, 0.22940656960672923, 0.1933961196487698, 0.20814840793484657, 0.9319010337250748, 0.8866747849118122, 0.8644694871336913, 0.17054580053746216, 0.6947935962700995, 0.8326766933337365, 0.733345145950097, 0.895071842903356, 0.791311541991087, 0.8997545435514744, 0.20016586230712996, 0.6668933844120808, 0.21383185613139688, 0.6807544885765612, 0.1693359734689881, 0.9037020990471338, 0.25627460982457584, 0.2280671244437924, 0.2142393289130422, 0.2386255911090448, 0.1996342937541985, 0.22794805079066804, 0.2670636329124866, 0.26567477014990215, 0.25493139845639357, 0.08380048954449126, 0.08170608234839472, 0.06168161677642059, 0.09891583575605023, 0.0833911327174175, 0.09228815888025077, 0.07713745502758906, 0.09426915394119273, 0.0874502910010364]}, "mutation_prompt": null}
{"id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "solution": "from scipy.optimize import differential_evolution, dual_annealing\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefinedHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybrid", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by introducing a novel hybridization with Differential Evolution and Simulated Annealing techniques for improved exploration and exploitation.", "configspace": "", "generation": 92, "fitness": 0.49324637765975876, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefinedHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "b10afde7-4be1-45fc-98ab-9d1d5a5ee9ea", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
{"id": "c01df86a-278b-4ec7-bf6e-90fc7a3869c3", "solution": "from scipy.optimize import differential_evolution, dual_annealing\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefinedHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybrid", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by introducing a novel hybridization with Differential Evolution and Simulated Annealing techniques for improved exploration and exploitation.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
{"id": "0532f95f-c1a8-42d3-97cb-f1ce32371564", "solution": "class EnhancedDynamicHarmonySearchRefinedHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7  # Add dynamic inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            inertia_weight = self.inertia_weight - (self.inertia_weight / self.budget) * iteration  # Update inertia weight dynamically\n            return par, bandwidth, mutation_factor, inertia_weight\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor, inertia_weight = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybrid", "description": "Introducing a dynamic inertia weight update mechanism based on objective function evaluations to enhance exploration and exploitation capabilities.", "configspace": "", "generation": 94, "fitness": 0.49324637765975876, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefinedHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
{"id": "c7a914c5-8eac-4c6a-b244-200aecb97db1", "solution": "from scipy.optimize import differential_evolution, dual_annealing\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefinedHybridImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        def chaotic_mutation(harmony, mutation_factor):\n            chaotic_map = lambda x: 3.9 * x * (1 - x)\n            mutated_harmony = np.copy(harmony)\n            for i in range(self.dim):\n                mutated_harmony[i] += chaotic_map(mutated_harmony[i]) * mutation_factor\n                mutated_harmony[i] = np.clip(mutated_harmony[i], -5.0, 5.0)\n            return mutated_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n            mutated_harmony = chaotic_mutation(new_harmony, mutation_factor)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(mutated_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = mutated_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybridImproved", "description": "Improving the exploration capability by incorporating a chaotic map-based mutation strategy.", "configspace": "", "generation": 95, "fitness": 0.49324637765975876, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefinedHybridImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
{"id": "a9ad3962-00d0-46fc-96e3-cee0c571237f", "solution": "from scipy.optimize import minimize\n\nclass EnhancedDynamicHarmonySearchRefinedHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n            # Integrate gradient-based local search\n            local_best = minimize(func, new_harmony, bounds=[(-5.0, 5.0)]*self.dim).x\n            local_fitness = func(local_best)\n\n            if local_fitness < best_fitness:\n                best_solution = local_best\n                best_fitness = local_fitness\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybrid", "description": "Utilizing a gradient-based local search after each evolution step to refine the obtained solutions for enhanced exploitation.", "configspace": "", "generation": 96, "fitness": 0.49324637765975876, "feedback": "The algorithm EnhancedDynamicHarmonySearchRefinedHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
{"id": "1cc5adbf-9851-4591-9b87-aa13169b1523", "solution": "from scipy.optimize import differential_evolution, dual_annealing\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefinedHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybrid", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by introducing a novel hybridization with Differential Evolution and Simulated Annealing techniques for improved exploration and exploitation.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
{"id": "22066551-fc39-45e9-83a9-d9db76b3c474", "solution": "from scipy.optimize import differential_evolution, dual_annealing\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefinedHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybrid", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by introducing a novel hybridization with Differential Evolution and Simulated Annealing techniques for improved exploration and exploitation.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
{"id": "9f55af5f-ea9c-49bd-9b4b-06cc71f9ad42", "solution": "from scipy.optimize import differential_evolution, dual_annealing\nimport numpy as np\n\nclass EnhancedDynamicHarmonySearchRefinedHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.par_min = 0.1\n        self.par_max = 0.9\n        self.bandwidth_min = 0.01\n        self.bandwidth_max = 0.1\n        self.mutation_factor_min = 0.1\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.ga_mut_prob = 0.1\n\n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(-5.0, 5.0, size=(self.harmony_memory_size, self.dim))\n\n        def update_parameters(iteration):\n            par = self.par_min + (self.par_max - self.par_min) * (iteration / self.budget)\n            bandwidth = self.bandwidth_min + (self.bandwidth_max - self.bandwidth_min) * (iteration / self.budget)\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (iteration / self.budget)\n            return par, bandwidth, mutation_factor\n\n        def improvise_harmony(harmony_memory, par, bandwidth):\n            new_harmony = np.copy(harmony_memory[np.random.randint(0, self.harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.uniform() < par:\n                    new_harmony[i] += np.random.uniform(-bandwidth, bandwidth)\n                    new_harmony[i] = np.clip(new_harmony[i], -5.0, 5.0)\n            return new_harmony\n\n        harmony_memory = initialize_harmony_memory()\n        best_solution = None\n        best_fitness = np.inf\n\n        for iteration in range(self.budget):\n            par, bandwidth, mutation_factor = update_parameters(iteration)\n            new_harmony = improvise_harmony(harmony_memory, par, bandwidth)\n\n            de_harmony = differential_evolution(func, bounds=[(-5.0, 5.0)]*self.dim, mutation=mutation_factor, recombination=self.crossover_prob).x\n            sa = dual_annealing(func, bounds=[(-5.0, 5.0)]*self.dim).x\n\n            new_fitness = func(new_harmony)\n            de_fitness = func(de_harmony)\n            sa_fitness = func(sa)\n\n            if new_fitness < best_fitness:\n                best_solution = new_harmony\n                best_fitness = new_fitness\n\n            if de_fitness < best_fitness:\n                best_solution = de_harmony\n                best_fitness = de_fitness\n\n            if sa_fitness < best_fitness:\n                best_solution = sa\n                best_fitness = sa_fitness\n\n            idx = np.argmax([func(h) for h in harmony_memory])\n            if new_fitness < func(harmony_memory[idx]):\n                harmony_memory[idx] = new_harmony\n\n        return best_solution", "name": "EnhancedDynamicHarmonySearchRefinedHybrid", "description": "Enhancing the EnhancedDynamicHarmonySearchRefined algorithm by introducing a novel hybridization with Differential Evolution and Simulated Annealing techniques for improved exploration and exploitation.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "6e0dc72b-a9b2-4401-9781-d2dc2fd6ef2b", "metadata": {"aucs": [0.9669634956491259, 0.9739838781094029, 0.9714421782264784, 0.9628487303551675, 0.9701134949982206, 0.972553637574371, 0.9693689869233514, 0.971984749601686, 0.9696383466637251, 0.9015870439832043, 0.7749252638085776, 0.7778901812834086, 0.8521303163012222, 0.8965034134592341, 0.7764030374010573, 0.8733887941641274, 0.8874358011909144, 0.8238537738221635, 0.674795592500234, 0.5121231287235075, 0.5694974850206436, 0.7859992834916825, 0.4593208252337716, 0.8040106122043351, 0.7290584490940669, 0.6659804131016103, 0.6839342075379885, 0.5476903042666136, 0.5829455356978551, 0.23101251484381313, 0.30410195297144504, 0.550007329504483, 0.6079701714437709, 0.5666794768374784, 0.5421819302817487, 0.6792864452610867, 0.9170100822106209, 0.894296708601155, 0.8669350227151442, 0.9525796820518103, 0.9549097690498412, 0.9598517843652954, 0.9258619959545771, 0.9093441500485485, 0.913351541059818, 0.6038966728597177, 0.5904562145272693, 0.6968566297239095, 0.6421512734669235, 0.8153143203356676, 0.648697601471006, 0.4353332173745379, 0.6382548054225781, 0.5818389556578627, 0.2058750871454348, 0.2058560326028016, 0.20542012155551925, 0.34142279198344994, 0.17745156687846864, 0.30565193149159575, 0.2878908496721798, 0.19482897632037355, 0.27786868214135185, 0.9247440869903316, 0.9268399612609703, 0.8418906661653289, 0.8880957769063155, 0.9262920528353048, 0.7707759316128593, 0.8331620628618817, 0.801758366832541, 0.934211498812538, 0.8996075718779111, 0.9309631769851993, 0.9312502273572734, 0.9261420371515073, 0.9483860089238172, 0.9291667021128611, 0.8164257847716209, 0.79035023678395, 0.9199483287729501, 0.5689346048667846, 0.5371401173175763, 0.4056708311600934, 0.6199332689436168, 0.5672877029184664, 0.6522972205031303, 0.5741684975073293, 0.5559435518347449, 0.5851986044593348, 0.5767371560515884, 0.4381036446460308, 0.4354494728561168, 0.4048035725400104, 0.3678783411296406, 0.30116962060552177, 0.5520379020190239, 0.44694499083079975, 0.4791698462852383, 0.6284394982746606, 0.6616913093141985, 0.4423227199318005, 0.747661575128827, 0.7837667286138891, 0.7314470180039867, 0.6791832507291873, 0.6967669317807312, 0.6759036834726942, 0.43321694311301817, 0.21790774069026642, 0.16601111897911947, 0.11676714365853491, 0.14268195826035812, 0.3049196033449233, 0.25225564678757506, 0.21788217250981545, 0.2161816431605854, 0.7044712375629694, 0.7293712991638268, 0.7340997183358011, 0.6368071420645878, 0.7757509959746641, 0.7478060456963356, 0.7730957172904936, 0.6525129749288452, 0.787294505554582, 0.14341386789265997, 0.06807971011292502, 0.188033943334469, 0.08761560187626694, 0.09433987597845095, 0.08213168495858758, 0.1138366209763817, 0.10225214971128516, 0.1624837529639439, 0.2146413740112174, 0.14937849204108533, 0.1967799244247883, 0.2777913053857475, 0.36053292713933327, 0.20087481322047718, 0.15874749834404556, 0.18430051126091407, 0.1794741749532417, 0.2332486426702134, 0.18697198440606333, 0.2061802945026584, 0.19152469580508658, 0.2250614868461932, 0.3265238779696761, 0.24698660015105334, 0.2897069017514401, 0.21054287023055884, 0.2143399783492731, 0.1723928564028474, 0.19286229440086522, 0.23212303019156644, 0.19186225593736494, 0.17827438328832945, 0.1347663538883055, 0.15448210920938887, 0.19208686274070697, 0.16823253958412387, 0.24562794619414086, 0.30331302950564454, 0.17371996481091667, 0.1893062831003277, 0.22933635152757292, 0.2262390725465937, 0.2353379616908543, 0.23461316719633418, 0.3266293567890771, 0.23429453094726138, 0.25800029703122584, 0.21172436812213435, 0.1937467605597729, 0.23077540139217723, 0.18793834494058193, 0.22383194764388292, 0.1998335147619943, 0.1996489593685662, 0.21128738328708851, 0.162419800164176, 0.8276526646000896, 0.9702936919198523, 0.9669393546395819, 0.8286819011016895, 0.569556619298616, 0.8584068340590592, 0.7884169640221733, 0.21413263007378702, 0.650667084063908, 0.2113188658779661, 0.7418227119689623, 0.6357130317205129, 0.16475020839031895, 0.20539227742694, 0.9028593558814904, 0.20987967500230975, 0.22959068611099442, 0.23364813324959266, 0.22694260701874003, 0.23440383408223975, 0.2287119369710544, 0.26009216179731065, 0.25029471392862057, 0.3113475899209954, 0.08457982575549927, 0.117317171531515, 0.09716937317586494, 0.079359944210178, 0.07784315953260734, 0.08978748860832186, 0.09601471265155981, 0.08127972813037254, 0.10193495325778745]}, "mutation_prompt": null}
