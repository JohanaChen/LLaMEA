{"role": "LLaMEA", "time": "2025-01-05 03:23:57.638176", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:07.838766", "content": "# Description: The algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:07.840945", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:14.429077", "content": "# Description: The algorithm improves on Adaptive Lévy Differential Evolution by introducing elitism and dynamic population resizing for better convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            elite_index = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if i == elite_index:\n                    continue\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Elitism: keep the best solution found so far\n            self.population[elite_index] = self.x_opt\n            self.fitness[elite_index] = self.f_opt\n\n            # Dynamically resize population\n            self.population_size = int(self.initial_population_size * (1 - evaluations / self.budget))\n            self.population_size = max(self.population_size, 5)\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:14.438048", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:19.552040", "content": "# Description: The algorithm is refined by introducing a more adaptive mutation strategy with a self-adaptive Lévy flight parameter and employing a dynamic population resizing mechanism for a balance of exploration and exploitation.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            if evaluations > 0.75 * self.budget:\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.15:\n                    L = 1 + np.random.rand()  # Adaptive Lévy flight parameter\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.2 + 0.8 * np.random.rand()  # More adaptive mutation factor\n            self.crossover_rate = 0.5 + 0.5 * (evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:19.560109", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:26.024171", "content": "# Description: The strategy refines the adaptation by implementing a fitness diversity mechanism and a dynamic mutation factor that responds to stagnation regions, enhancing the exploration-exploitation balance.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.stagnation_counter = 0\n        self.prev_best_fitness = np.inf\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def diversity_metric(self):\n        return np.std(self.fitness)\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            diversity = self.diversity_metric()\n            if self.prev_best_fitness <= self.f_opt:\n                self.stagnation_counter += 1\n                if self.stagnation_counter > self.population_size // 2:\n                    self.mutation_factor += 0.1\n                    self.stagnation_counter = 0\n            else:\n                self.stagnation_counter = 0\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * diversity / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            self.prev_best_fitness = self.f_opt\n        \n        return self.f_opt, self.x_opt\n```\n"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:26.031698", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:31.924254", "content": "# Description: Incorporate a dynamic adaptation scheme for mutation factor and crossover rate based on individual fitness improvements, while introducing a diversity preservation mechanism to avoid premature convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                else:\n                    if np.random.rand() < 0.1:\n                        self.population[i] = np.random.uniform(-5, 5, self.dim)\n                        self.fitness[i] = func(self.population[i])\n                        evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.6 + (0.4 * np.mean(self.fitness) / np.max(self.fitness))\n            self.crossover_rate = 0.6 + (0.4 * (1 - np.std(self.fitness) / np.mean(self.fitness)))\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:31.931070", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:38.564464", "content": "# Description: Enhanced DE with adaptive mutation/crossover rates and dynamic population resizing driven by convergence and diversity analysis.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            diversity = np.var(self.population, axis=0).mean()\n            dynamic_size = max(4, int(self.population_size * (1 - diversity)))\n            \n            for i in range(dynamic_size):  # Adjust loop for dynamic population\n                indices = list(range(dynamic_size))\n                if i in indices:\n                    indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:38.571018", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:44.509284", "content": "# Description: The algorithm is refined to use an adaptive Lévy flight step size, adjusted using cosine annealing, to improve convergence on multimodal landscapes, while retaining the dynamic DE mutation and crossover strategies.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.initial_step_size = 0.01\n\n    def adaptive_levy_flight(self, L, evaluations):\n        step_size = self.initial_step_size * 0.5 * (1 + np.cos(np.pi * evaluations / self.budget))\n        return step_size * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = self.compute_fitness(self.population[i])\n\n    def compute_fitness(self, x):\n        f = func(x)\n        if f < self.f_opt:\n            self.f_opt = f\n            self.x_opt = x.copy()\n        return f\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.adaptive_levy_flight(L, evaluations)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = self.compute_fitness(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:44.520196", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:50.294724", "content": "# Description: Enhancing search diversity by introducing an adaptive hybridization of Lévy flights and Gaussian perturbations, with dynamic mutation and crossover adjustments based on convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L, scale=0.01):\n        return scale * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def gaussian_perturbation(self, scale=0.01):\n        return scale * np.random.normal(size=self.dim)\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                adaptive_scale = (self.budget - evaluations) / self.budget\n                if np.random.rand() < 0.2:  # Increased probability of perturbation\n                    if np.random.rand() < 0.5:\n                        trial_vector += self.levy_flight(L, adaptive_scale)\n                    else:\n                        trial_vector += self.gaussian_perturbation(adaptive_scale)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.6 + (0.4 * evaluations / self.budget)  # Adjusted crossover rate\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:50.308574", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:24:58.269676", "content": "# Description: Incorporate adaptive control of Lévy flight variance and individual dynamic adaptation of mutation factor and crossover rate based on success history to enhance exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = np.full(self.population_size, 0.8)\n        self.crossover_rate = np.full(self.population_size, 0.9)\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.success_count = np.zeros(self.population_size)\n        self.failure_count = np.zeros(self.population_size)\n\n    def levy_flight(self, L, scale=0.01):\n        return scale * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor[i] * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    scale = 0.01 + 0.09 * (self.budget - evaluations) / self.budget\n                    trial_vector += self.levy_flight(L, scale)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    self.success_count[i] += 1\n                    self.failure_count[i] = 0\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                else:\n                    self.failure_count[i] += 1\n                \n                if self.failure_count[i] > 2:\n                    self.mutation_factor[i] *= 0.95\n                    self.crossover_rate[i] *= 0.95\n                elif self.success_count[i] > 2:\n                    self.mutation_factor[i] *= 1.05\n                    self.crossover_rate[i] *= 1.05\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:24:58.283692", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:03.554814", "content": "# Description: Enhanced Adaptive Lévy Differential Evolution with dynamic population and adaptive control parameter scaling using cosine similarity for improved global convergence.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        u = np.random.normal(size=self.dim) * 0.01\n        v = np.random.normal(size=self.dim)\n        step = u / np.power(np.abs(v), 1/L)\n        return step\n    \n    def evaluate_population(self):\n        for i in range(self.initial_population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def dynamic_population_size(self, evaluations):\n        return max(5, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))\n    \n    def __call__(self, func):\n        evaluations = self.initial_population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(evaluations)\n            for i in range(current_population_size):\n                indices = list(range(current_population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + 0.8 * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < 0.9, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:03.570321", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:09.880271", "content": "# Description: The refined strategy enhances diversity by incorporating a self-adaptive mechanism for mutation factor and crossover rates, dynamically adjusting based on individual and global fitness improvements.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.mutation_factors = np.random.uniform(0.5, 1.0, self.population_size)\n        self.crossover_rates = np.random.uniform(0.4, 0.9, self.population_size)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factors[i] * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rates[i], mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                else:\n                    self.mutation_factors[i] = np.random.uniform(0.5, 1.0)\n                    self.crossover_rates[i] = np.random.uniform(0.4, 0.9)\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:09.891199", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:15.552288", "content": "# Description: This refined algorithm improves the balance between exploration and exploitation by introducing adaptive population size and dynamic Lévy flight parameters based on the search progress.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.population_size = self.population.shape[0]\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            if evaluations > self.budget * 0.7:\n                self.population = self.population[:self.population_size//2]\n                self.fitness = self.fitness[:self.population_size//2]\n                self.population_size //= 2\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:15.561964", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:22.342806", "content": "# Description: This algorithm enhances exploration by using an adaptive Lévy flight based on iteration progress and incorporates dynamic population scaling for better convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.L = 1.5  # Initial Lévy flight exponent\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def update_levy_exponent(self, evaluations):\n        progress = evaluations / self.budget\n        self.L = 1.5 + (0.5 * progress)\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(self.L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            self.update_levy_exponent(evaluations)\n            self.population_size = self.initial_population_size - int(0.5 * self.initial_population_size * evaluations / self.budget)\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:22.352477", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:28.925904", "content": "# Description: The algorithm incorporates a self-adaptive strategy for mutation and crossover rates, and dynamically tunes the Lévy flight scale based on diversity to improve performance.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L, scale):\n        return scale * (np.random.normal(size=self.dim) /\n                        np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            diversity = np.std(self.population, axis=0).mean()\n            scale = 0.01 + 0.1 * (diversity / 5.0)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L, scale)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:28.932787", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:36.531034", "content": "# Description: This improved algorithm enhances exploration by incorporating a dynamic Lévy flight step size and adaptive population refresh, maintaining balance between exploration and exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L, step_size):\n        return step_size * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  \n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:  # Increased chance of Lévy flight\n                    step_size = 0.1 * (1 - evaluations / self.budget)  # Dynamic step size\n                    trial_vector += self.levy_flight(L, step_size)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            if evaluations % (self.budget // 5) == 0:  # Adaptive population refresh\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.evaluate_population()\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:36.544351", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:42.306665", "content": "# Description: The strategy enhances the algorithm by incorporating an adaptive mutation factor, varying the Lévy flight exponent over iterations, and using tournament selection to improve robustness and convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def tournament_selection(self):\n        candidates = np.random.choice(self.population_size, 3, replace=False)\n        return min(candidates, key=lambda idx: self.fitness[idx])\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L_initial, L_final = 1.5, 3.0  # Adaptive Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                a = self.tournament_selection()\n                b = self.tournament_selection()\n                c = self.tournament_selection()\n                \n                mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                dynamic_L = L_initial + (L_final - L_initial) * (evaluations / self.budget)\n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(dynamic_L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.mutation_factor = 0.5 + (0.5 * np.sin(np.pi * evaluations / self.budget))\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:42.314732", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:48.430192", "content": "# Description: The algorithm enhances exploration by varying the Lévy flight factor based on the success rate of recent iterations and integrates a dynamic population resizing strategy to concentrate resources effectively.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def adjust_population_size(self, evaluations):\n        self.population_size = max(4, int(self.initial_population_size * (1 - evaluations / self.budget)))\n        self.population = self.population[:self.population_size]\n        self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        success_rate = 0.0\n        \n        while evaluations < self.budget:\n            successful_updates = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    successful_updates += 1\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            success_rate = successful_updates / self.population_size\n            L = 1.5 + 0.5 * success_rate  # Adjust Lévy factor based on success rate\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            self.adjust_population_size(evaluations)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:48.440345", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:25:57.229914", "content": "# Description: The algorithm enhances the adaptability of mutation and crossover rates using a dynamic strategy based on population diversity and includes a restart mechanism to escape premature convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def population_diversity(self):\n        return np.std(self.population, axis=0).mean()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        restart_threshold = 1e-5\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            diversity = self.population_diversity()\n            self.mutation_factor = 0.5 + (0.5 * diversity)\n            self.crossover_rate = 0.5 + (0.5 * (1.0 - diversity))\n\n            if diversity < restart_threshold:\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.evaluate_population()\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:25:57.237242", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:04.987961", "content": "# Description: The enhanced Adaptive Lévy Differential Evolution algorithm employs dynamic population resizing and adaptive mutation strategies to improve convergence speed and solution accuracy across diverse optimization landscapes.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def resize_population(self, evals):\n        factor = 1.5\n        new_size = max(int(self.population_size / (factor * (evals/self.budget + 0.1))), 4)\n        if new_size < self.population_size:\n            self.population = self.population[:new_size]\n            self.fitness = self.fitness[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            self.resize_population(evaluations)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.3 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:04.996105", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:11.902877", "content": "# Description: The algorithm now incorporates an adaptive population size and uses a periodic reinitialization strategy to enhance diversity and escape local optima, while maintaining balance between exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.base_pop_size = 5 * dim  # Changed\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.base_pop_size, dim))  # Changed\n        self.fitness = np.full(self.base_pop_size, np.inf)  # Changed\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population.shape[0]):  # Changed\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population.shape[0]  # Changed\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            # Adaptive population size\n            current_pop_size = int(self.base_pop_size * (1 + 0.5 * np.sin(evaluations / self.budget * np.pi)))  # Changed\n            self.population = np.resize(self.population, (current_pop_size, self.dim))  # Changed\n            self.fitness = np.resize(self.fitness, current_pop_size)  # Changed\n\n            for i in range(current_pop_size):  # Changed\n                indices = list(range(current_pop_size))  # Changed\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Periodic re-initialization\n            if evaluations % (self.budget // 10) == 0:  # Changed\n                self.population = np.random.uniform(-5, 5, (current_pop_size, self.dim))  # Changed\n                self.evaluate_population()  # Changed\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:11.914693", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:18.253333", "content": "# Description: Enhanced DE with adaptive mutation/crossover and elitism for robust exploration-exploitation using Lévy flights.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        elite = self.population[np.argmin(self.fitness)]\n        \n        while evaluations < self.budget:\n            new_population = self.population.copy()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.population = new_population\n            self.population[np.argmax(self.fitness)] = elite  # Elitism\n            self.mutation_factor = 0.5 + (0.3 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.4 * evaluations / self.budget)  # Adjusted rates\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:18.261149", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:23.668783", "content": "# Description: Improve adaptive strategy by incorporating dynamic population size, adaptive scaling factor, and dynamic Lévy exponent for enhanced exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.initial_population_size = self.population_size\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        dynamic_population_size = self.initial_population_size\n        L = 1.5  # Initial Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(dynamic_population_size):\n                indices = list(range(dynamic_population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                dynamic_mutation_factor = self.mutation_factor * (1 - (evaluations / self.budget))\n                mutant_vector = a + dynamic_mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            dynamic_population_size = max(5, int(self.population_size * (1 - evaluations / self.budget)))\n            L = 1.5 + 0.5 * (evaluations / self.budget)\n\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:23.677642", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:30.754299", "content": "# Description: Enhanced the strategy by incorporating elitism and adaptive population resizing to improve convergence and prevent premature convergence.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            next_population = []\n            next_fitness = []\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    next_population.append(trial_vector)\n                    next_fitness.append(trial_fitness)\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                else:\n                    next_population.append(self.population[i])\n                    next_fitness.append(self.fitness[i])\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.population = np.array(next_population)\n            self.fitness = np.array(next_fitness)\n\n            if evaluations < self.budget // 2:\n                self.population_size = min(len(self.fitness) + 1, self.initial_population_size)\n            else:\n                self.population_size = max(len(self.fitness) - 1, 4)  # Maintain minimum size\n        \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:30.763656", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:38.111749", "content": "# Description: This refined algorithm enhances exploration by incorporating a dynamic Lévy exponent and adaptive mutation factor adjustment, allowing more flexibility and diversity in the search process.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n    \n    def levy_flight(self, L):\n        step = 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n        return step * np.random.uniform(0.5, 1.5, size=self.dim)\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        initial_L = 1.5\n        min_L, max_L = 1.2, 2.0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    L = min_L + (max_L - min_L) * (evaluations / self.budget)\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.6 + (0.4 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.4 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:38.118814", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:45.735696", "content": "# Description: Enhanced the algorithm by incorporating an adaptive population size based on solution diversity and convergence rate, while leveraging chaos theory to introduce controlled randomness for boosting exploration capabilities.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def chaos_perturbation(self, size):\n        return 0.05 * (np.random.rand(size) * 2 - 1)\n\n    def evaluate_population(self):\n        for i in range(len(self.population)):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = len(self.population)\n        L = 1.5\n\n        while evaluations < self.budget:\n            diversity = np.std(self.fitness)\n            self.population_size = int(self.initial_population_size * (1 + 0.1 * np.log(1 + diversity)))\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                mutant_vector = a + self.mutation_factor * (b - c) + self.chaos_perturbation(self.dim)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n\n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:45.749694", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:51.933780", "content": "# Description: Enhanced Adaptive Lévy Differential Evolution with dynamic population resizing and stagnation-based parameter adaptation for improved convergence performance.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.stagnation_threshold = 50  # New attribute for stagnation detection\n        self.no_improvement_count = 0   # Counter for stagnation\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                        self.no_improvement_count = 0  # Reset stagnation counter\n                    else:\n                        self.no_improvement_count += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            \n            # Dynamic population resizing\n            if self.no_improvement_count > self.stagnation_threshold:\n                self.population_size = max(5, self.population_size // 2)\n                self.no_improvement_count = 0\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:51.941125", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:26:59.384344", "content": "# Description: This refined algorithm enhances Differential Evolution with Lévy flights by introducing dynamic population resizing and a feedback-driven control of mutation and crossover to adaptively balance exploration and exploitation during optimization.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            \n            if evaluations % (self.budget // 5) == 0:\n                self.population_size = max(4, int(self.initial_population_size * (self.budget - evaluations) / self.budget))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:26:59.393215", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:08.849261", "content": "# Description: The refined algorithm improves Differential Evolution by incorporating dynamic scaling of population size and utilizing adaptive parameters for enhanced convergence and diversity.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 5 * dim\n        self.max_population_size = 15 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(len(self.population)):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = len(self.population)\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(len(self.population)):\n                indices = list(range(len(self.population)))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n                self.crossover_rate = 0.6 + (0.4 * evaluations / self.budget)\n                if evaluations % (self.budget // 10) == 0:\n                    new_population_size = min(self.max_population_size, len(self.population) + dim)\n                    if new_population_size > len(self.population):\n                        new_candidates = np.random.uniform(-5, 5, (new_population_size - len(self.population), self.dim))\n                        self.population = np.vstack([self.population, new_candidates])\n                        self.fitness = np.concatenate([self.fitness, np.full(new_candidates.shape[0], np.inf)])\n            self.evaluate_population()\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:08.860763", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:14.200929", "content": "# Description: This refined algorithm combines Differential Evolution with adaptive step sizes and Lévy flights, incorporating dynamic mutation and crossover adjustments based on population diversity to enhance convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def population_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            diversity = self.population_diversity()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * diversity / 10.0)\n            self.crossover_rate = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:14.207550", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:24.488035", "content": "# Description: The algorithm refines the synergy of Differential Evolution with Lévy flights by integrating adaptive scaling of mutation factors, improved population diversity through tournament selection, and periodic reinitialization to prevent premature convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def tournament_selection(self, k=3):\n        indices = np.random.choice(self.population_size, k, replace=False)\n        best = indices[np.argmin(self.fitness[indices])]\n        return best\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations % 250 == 0:\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.evaluate_population()\n                \n                a = self.tournament_selection()\n                b = self.tournament_selection()\n                c = self.tournament_selection()\n                while b == a: b = self.tournament_selection()\n                while c == a or c == b: c = self.tournament_selection()\n\n                mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:24.496966", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:31.707051", "content": "# Description: Enhances exploration and exploitation by incorporating a population diversity check and adaptive mutation strategies based on distance between solutions.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def check_diversity(self):\n        distances = np.linalg.norm(self.population - np.mean(self.population, axis=0), axis=1)\n        return np.mean(distances)\n\n    def adapt_mutation_factor(self, diversity):\n        if diversity > 3:\n            self.mutation_factor = 0.9\n        else:\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            diversity = self.check_diversity()\n            self.adapt_mutation_factor(diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:  # Increased chance of Levy flight\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:31.714459", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:38.672542", "content": "Certainly! Here's the refined version of the code:\n\n# Description: The solution integrates a dynamic population size adjustment strategy with enhanced Lévy flights to improve convergence speed and quality.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(0, 1, self.dim) / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            if evaluations % (self.budget // 5) == 0 and self.population_size > self.dim * 5:\n                self.population_size = max(self.dim * 5, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.15:  # Slight increase in probability\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```\n"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:38.682122", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:43.747450", "content": "# Description: Improved Differential Evolution with Lévy flights and dynamic adaptation of key parameters based on success rates of mutations.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        success_rate = 0.2\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                    success_rate += 0.1\n                else:\n                    success_rate -= 0.1\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.mutation_factor = 0.5 + 0.5 * success_rate\n            self.crossover_rate = 0.3 + 0.7 * success_rate\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:43.754149", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:50.050912", "content": "# Description: The algorithm integrates a dynamic step size control for Lévy flights and employs an elitism strategy, maintaining the best solutions in each generation to enhance convergence speed and robustness.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 12 * dim  # Modified\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L, scale=0.01):  # Modified\n        return scale * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = self.func(self.population[i])  # Modified\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.func = func  # Modified\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            elites = np.argsort(self.fitness)[:self.population_size // 5]  # New\n            step_scale = 1.0 - evaluations / self.budget  # New\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L, step_scale)  # Modified\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = self.func(trial_vector)  # Modified\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.population[elites] = self.population[elites]  # New\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:50.063816", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:27:56.002848", "content": "# Description: We refine the algorithm by introducing an adaptive population size reduction mechanism, incorporating a learning component to dynamically adjust the Lévy flight exponent based on search progress, and improving parameter adaptation for better convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.min_population_size = 4\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L_base = 1.5\n        L = L_base\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.population_size = max(self.min_population_size, int(self.initial_population_size * (1 - evaluations / self.budget)))\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            L = L_base + 0.1 * np.sin(3.14 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:27:56.013398", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:02.240403", "content": "# Description: Enhancing Differential Evolution with adaptive Lévy flights by integrating local search and dynamic population resizing for improved balance between exploration and exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.evaluate_population()\n        self.dynamic_population_size = self.initial_population_size\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim) + 1e-8), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.dynamic_population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def local_search(self, vector):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(vector + perturbation, -5, 5)\n\n    def __call__(self, func):\n        evaluations = self.dynamic_population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.dynamic_population_size):\n                indices = list(range(self.dynamic_population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = self.local_search(trial_vector)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            self.dynamic_population_size = self.initial_population_size - int(evaluations / self.budget * self.initial_population_size) + 1\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:02.253617", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:08.460033", "content": "# Description: This refined algorithm incorporates adaptive scaling for mutation factors and dynamically tuned Lévy flight parameters, enhancing the balance between exploration and exploitation throughout the search process.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n    \n    def levy_flight(self, L, step_size=0.01):\n        return step_size * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                adaptive_mutation_factor = self.mutation_factor * (1 - evaluations / self.budget)\n                mutant_vector = a + adaptive_mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.1:\n                    adaptive_L = 1.5 + 0.5 * (evaluations / self.budget)\n                    trial_vector += self.levy_flight(adaptive_L, step_size=0.05)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n                \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.4 + (0.6 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.6 + (0.4 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:08.474169", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:15.033191", "content": "# Description: Enhanced the adaptive Differential Evolution with an exploration-exploitation balance by utilizing dynamic population size adjustment and elite preservation to improve convergence speed and solution quality.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.elite = None\n        self.elite_fitness = np.inf\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(len(self.population)):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n            if self.fitness[i] < self.elite_fitness:\n                self.elite_fitness = self.fitness[i]\n                self.elite = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.initial_population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(len(self.population)):\n                indices = list(range(len(self.population)))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                    if trial_fitness < self.elite_fitness:\n                        self.elite_fitness = trial_fitness\n                        self.elite = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            if evaluations % (self.budget // 10) == 0:\n                self.population = np.concatenate((self.population, self.elite[np.newaxis, :]), axis=0)\n                self.fitness = np.append(self.fitness, self.elite_fitness)\n        \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:15.045672", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:20.781884", "content": "# Description: Improved Adaptive Lévy Differential Evolution with dynamic population size adjustment and stochastic ranking for better exploration-exploitation balance.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.initial_population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def update_population_size(self, evaluations):\n        scaled_factor = evaluations / self.budget\n        return int(self.initial_population_size * (1 - 0.5 * scaled_factor))\n    \n    def __call__(self, func):\n        evaluations = self.initial_population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            current_population_size = self.update_population_size(evaluations)\n            for i in range(current_population_size):\n                indices = list(range(current_population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + 0.8 * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < 0.9, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:20.794385", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:26.672771", "content": "# Description: The algorithm enhances adaptive mutation and crossover strategies by incorporating population diversity metrics and improving the Lévy flight mechanism for better balancing of exploration and exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.power(np.abs(v), 1/L)\n        return 0.01 * step * np.random.choice([-1, 1], size=self.dim)\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            diversity = np.std(self.population, axis=0).mean()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2 * diversity:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.3 + (0.7 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:26.680959", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:31.911303", "content": "# Description: The algorithm now integrates adaptive mutation factors using a Gaussian distribution for diversity and incorporates a hybrid population strategy that mixes individuals from the current generation with newly generated random solutions for improved exploration.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            new_population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                adaptive_factor = np.random.normal(self.mutation_factor, 0.1)\n                mutant_vector = a + adaptive_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.population = (self.population + new_population) / 2\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:31.918607", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:37.965848", "content": "# Description: Enhanced the Adaptive Lévy Differential Evolution by introducing an adaptive population resizing mechanism and improving the Lévy flight scaling to further balance exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def levy_flight(self, L):\n        return 0.01 * np.random.standard_cauchy(size=self.dim) / np.abs(np.random.normal(size=self.dim)) ** (1/L)\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def adapt_population_size(self, evaluations):\n        new_size = int(self.initial_population_size * (1 - evaluations / self.budget))\n        return max(4, new_size)\n    \n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            new_population_size = self.adapt_population_size(evaluations)\n            if new_population_size < self.population_size:\n                self.population = self.population[:new_population_size]\n                self.fitness = self.fitness[:new_population_size]\n                self.population_size = new_population_size\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:37.978268", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:43.816839", "content": "# Description: The algorithm enhances exploration and exploitation by integrating an adaptive control mechanism for mutation and crossover rates, and utilizing a restart mechanism if convergence stalls for better global search capability.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        no_improve_count = 0  # Track improvements\n        max_no_improve = 100  # Threshold to restart\n        \n        while evaluations < self.budget:\n            improved = False\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                        improved = True\n                \n                if evaluations >= self.budget:\n                    break\n\n            if improved:\n                no_improve_count = 0\n            else:\n                no_improve_count += 1\n            \n            if no_improve_count >= max_no_improve:\n                # Restart strategy\n                self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n                self.evaluate_population()\n                no_improve_count = 0\n            \n            self.mutation_factor = 0.3 + 0.7 * (self.budget - evaluations) / self.budget\n            self.crossover_rate = 0.4 + 0.6 * evaluations / self.budget\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:43.825381", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:50.604723", "content": "# Description: This refined algorithm uses an adaptive Lévy Differential Evolution with time-varying mutation and crossover parameters alongside an elitism strategy to maintain the best solutions across generations.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:  # Increased chance of Levy flight\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                    \n                if evaluations >= self.budget:\n                    break\n            \n            # Enhanced adaptation strategy\n            self.mutation_factor = 0.5 + 0.3 * np.cos((np.pi * evaluations) / self.budget)\n            self.crossover_rate = 0.5 + 0.3 * np.sin((np.pi * evaluations) / self.budget)\n        \n        return self.f_opt, self.x_opt\n```\n"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:50.615072", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:28:56.611974", "content": "# Description: An improved algorithm that combines Differential Evolution with adaptive Lévy flights and an elitist strategy to enhance convergence using adaptive parameters and elite retention.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def elitism_update(self):\n        elite_indices = np.argsort(self.fitness)[:self.population_size // 5]\n        self.population[:len(elite_indices)] = self.population[elite_indices]\n    \n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            self.elitism_update()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.3 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.4 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:28:56.620533", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:02.371621", "content": "# Description: Enhance the algorithm by introducing a temperature-based simulated annealing component to control the exploration and exploitation balance more effectively.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevySADE:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.temperature = 1.0  # Initial temperature for simulated annealing\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n                \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i] or np.exp((self.fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.temperature *= 0.95  # Cooling schedule for simulated annealing\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:02.380332", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:12.239171", "content": "# Description: The algorithm refines Adaptive Lévy Differential Evolution by incorporating an adaptive restart mechanism and improving diversity with chaos-based perturbation.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.evaluations = 0\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaos\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def restart_population(self):\n        self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.evaluate_population()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        chaos_param = np.random.rand()\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                chaos_param = self.chaotic_map(chaos_param)\n                trial_vector += chaos_param * (self.x_opt - trial_vector)\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            if evaluations % (self.budget // 5) == 0:\n                self.restart_population()\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:12.257182", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:20.178822", "content": "# Description: The algorithm enhances exploration by introducing an adaptive population size and dynamically adjusting the Lévy flight exponent during the search process.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.init_population_size = 10 * dim\n        self.population = np.random.uniform(-5, 5, (self.init_population_size, dim))\n        self.fitness = np.full(self.init_population_size, np.inf)\n        \n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population.shape[0]\n        L = 1.5  # Lévy flight exponent\n        while evaluations < self.budget:\n            current_population_size = int(self.init_population_size * (1 - evaluations / self.budget)) + 5\n            self.population = self.population[:current_population_size]\n            self.fitness = self.fitness[:current_population_size]\n            \n            for i in range(current_population_size):\n                indices = list(range(current_population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L + 0.2 * (evaluations / self.budget))\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:20.189535", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:28.713656", "content": "# Description: The optimization algorithm enhances exploration via Lévy flights and introduces a self-adaptive control parameter strategy for the mutation factor and crossover rate to improve convergence efficiency.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = np.random.uniform(0.5, 1.0)\n        self.crossover_rate = np.random.uniform(0.1, 0.9)\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        u = np.random.normal(size=self.dim)\n        v = np.random.normal(size=self.dim)\n        step = u / np.power(np.abs(v), 1/L)\n        return 0.01 * step\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.15:  # Increase chance of Lévy flight for exploration\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            # Self-adaptive strategy for mutation factor and crossover rate\n            self.mutation_factor = np.random.normal(0.5, 0.1)\n            self.crossover_rate = np.random.normal(0.75, 0.05)\n\n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:28.724904", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:34.762178", "content": "# Description: The algorithm enhances adaptive mutation and crossover strategies with Chaotic Maps for better convergence and exploration.\n\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveChaoticLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.logistic_r = 3.9  # Parameter for logistic map\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def chaotic_map(self, x):\n        return self.logistic_r * x * (1 - x)\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        chaos_variable = np.random.rand()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n                    \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            chaos_variable = self.chaotic_map(chaos_variable)\n            self.mutation_factor = 0.5 + (0.5 * chaos_variable)\n            self.crossover_rate = 0.5 + (0.5 * (evaluations / self.budget))\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:34.770962", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:40.944343", "content": "# Description: Enhanced algorithm by incorporating a dynamic population size adjustment and a tournament selection mechanism for better balance between exploration and exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def tournament_selection(self, k=3):\n        participants = np.random.choice(self.population_size, k, replace=False)\n        best_index = participants[np.argmin(self.fitness[participants])]\n        return self.population[best_index]\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                a = self.tournament_selection()\n                b, c = np.random.choice(self.population_size, 2, replace=False)\n                \n                mutant_vector = a + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = int(self.population_size * 0.9)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:40.952219", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:47.173236", "content": "# Description: Incorporate self-adaptive parameters and opposition-based learning to enhance convergence and diversity in the adaptive Levy Differential Evolution algorithm.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Self-adaptive mutation factor and crossover rate\n                F = np.random.uniform(0.5, 1.5)\n                CR = np.random.uniform(0.1, 0.9)\n                \n                mutant_vector = a + F * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < CR, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Opposition-based learning\n            opposite_population = -self.population + 5\n            opposite_population = np.clip(opposite_population, -5, 5)\n            for i in range(self.population_size):\n                opposite_fitness = func(opposite_population[i])\n                evaluations += 1\n                if opposite_fitness < self.fitness[i]:\n                    self.population[i] = opposite_population[i]\n                    self.fitness[i] = opposite_fitness\n                    if opposite_fitness < self.f_opt:\n                        self.f_opt = opposite_fitness\n                        self.x_opt = opposite_population[i].copy()\n                if evaluations >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:47.181544", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:29:54.872779", "content": "# Description: Enhanced Adaptive Lévy Differential Evolution by introducing feedback-based parameter adaptation and elite local search to boost convergence speed and solution quality.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.elite = 0.1 * self.population_size  # Elite percentage\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            if evaluations < 0.5 * self.budget:\n                self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n                self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            \n            elite_indices = np.argsort(self.fitness)[:int(self.elite)]\n            for elite_idx in elite_indices:\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                self.population[elite_idx] = np.clip(self.population[elite_idx] + perturbation, -5, 5)\n                fitness_with_perturbation = func(self.population[elite_idx])\n                if fitness_with_perturbation < self.fitness[elite_idx]:\n                    self.fitness[elite_idx] = fitness_with_perturbation\n                    if fitness_with_perturbation < self.f_opt:\n                        self.f_opt = fitness_with_perturbation\n                        self.x_opt = self.population[elite_idx].copy()\n\n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:29:54.880077", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:00.154882", "content": "# Description: The strategy is refined by incorporating an adaptive population size and a dynamic Lévy exponent to enhance global exploration and convergence capabilities.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L_initial = 1.5  # Initial Lévy flight exponent\n        L_final = 1.1    # Final Lévy flight exponent\n        \n        self.evaluate_population(func)  # Initial evaluation\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    L_dynamic = L_initial + (L_final - L_initial) * (evaluations / self.budget)\n                    trial_vector += self.levy_flight(L_dynamic)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.population_size = max(2, int(self.initial_population_size * (1 - evaluations / self.budget)))\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:00.167574", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:07.633767", "content": "# Description: Enhancing the Adaptive Lévy Differential Evolution by incorporating a dynamic population resizing strategy based on convergence and periodically injecting diversity to escape local optima.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def resize_population(self, factor=0.5):\n        self.population_size = int(self.population_size * factor)\n        self.population = self.population[:self.population_size]\n        self.fitness = self.fitness[:self.population_size]\n\n    def inject_diversity(self, rate=0.1):\n        num_diverse = int(self.population_size * rate)\n        new_individuals = np.random.uniform(-5, 5, (num_diverse, self.dim))\n        self.population[:num_diverse] = new_individuals\n        for i in range(num_diverse):\n            self.fitness[i] = func(self.population[i])\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        resize_trigger = self.budget // 3\n        \n        while evaluations < self.budget:\n            if evaluations % resize_trigger == 0:\n                self.resize_population()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            if evaluations % (resize_trigger * 2) == 0:\n                self.inject_diversity()\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```\n"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:07.644110", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:13.813047", "content": "# Description: Enhances adaptive exploration-exploitation balance by introducing variable population size and dynamic Lévy flight adjustments based on fitness diversity.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.base_population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.base_population_size, dim))\n        self.fitness = np.full(self.base_population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population.shape[0]):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population.shape[0]\n        L = 1.5\n        \n        while evaluations < self.budget:\n            fitness_variation = np.std(self.fitness)\n            population_size = max(int(self.base_population_size * (1 + 0.5 * fitness_variation / np.mean(self.fitness))), 4)\n            L = 1.2 + 0.6 * fitness_variation\n\n            for i in range(self.population.shape[0]):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population.shape[0]))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:13.825071", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:19.733676", "content": "# Description: The algorithm enhances exploration by introducing chaotic maps for parameter adaptation and a dynamic population size strategy for improved convergence across diverse optimization landscapes.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def chaotic_map(self, param):\n        # Using a logistic map for chaos-based parameter adaptation\n        return 4 * param * (1 - param)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Dynamic adjustment of mutation and crossover using chaotic maps\n            self.mutation_factor = self.chaotic_map(self.mutation_factor)\n            self.crossover_rate = self.chaotic_map(self.crossover_rate)\n            \n            # Dynamically adjust population size\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = max(5, int(self.population_size * 0.9))\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:19.743492", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:26.524524", "content": "# Description: The strategy refines DE by introducing adaptive parameters based on population diversity and incorporates both Lévy flights and Gaussian perturbations to enhance convergence and escape local optima.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def gaussian_perturbation(self):\n        return np.random.normal(0, 0.1, self.dim)\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                indices = [idx for idx in indices if idx != i]\n                a, b, c = self.population[indices[:3]]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L) + self.gaussian_perturbation()\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            diversity = np.mean(np.std(self.population, axis=0))\n            self.mutation_factor = 0.5 + (0.3 * (1 - diversity))\n            self.crossover_rate = 0.6 + (0.2 * diversity)\n        \n        return self.f_opt, self.x_opt\n```\n"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:26.539546", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:34.858619", "content": "# Description: Improved AdaptiveLevyDifferentialEvolution by introducing a dynamic population resizing strategy and using the best individual to guide Lévy flights, enhancing convergence speed and solution accuracy.\n# Code:\n```python\nimport numpy as np\n\nclass ImprovedAdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_pop_size = 10 * dim\n        self.population_size = self.initial_pop_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L, best):\n        step = 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n        return best + step\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.1:\n                    best = self.population[np.argmin(self.fitness)]\n                    trial_vector += self.levy_flight(L, best)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            if evaluations % (self.budget / 10) == 0:\n                self.population_size = max(4, int(self.initial_pop_size * (1 - evaluations / self.budget)))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:34.868233", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:40.379311", "content": "# Description: Improved adaptive strategy by introducing fitness-based scaling for mutation factor, dynamic Lévy exponent, and enhanced initialization with chaotic maps for better exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = self.initialize_population()\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def initialize_population(self):\n        # Use chaotic map for initialization\n        return 5 * np.sin(np.random.uniform(-5, 5, (self.population_size, self.dim)))\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1 / L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation with fitness-based scaling\n                mutant_vector = a + (self.mutation_factor * (b - c) * (1 - self.fitness[i] / np.max(self.fitness)))\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.15:  # Increased Lévy flight probability\n                    L = 1 + (2 * (self.fitness[i] / np.max(self.fitness)))  # Dynamic Lévy exponent\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.6 + (0.4 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:40.391004", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:46.647786", "content": "# Description: The refined algorithm introduces adaptive population sizing and fitness-based differential evolution parameters to enhance convergence, while maintaining exploration with Lévy flights.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            # Adjust population size adaptively based on evaluations remaining\n            self.population_size = int(self.initial_population_size * (1 - evaluations / self.budget))\n            self.population_size = max(self.population_size, 4)  # Ensure a minimum size\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Adjust mutation factor based on fitness\n                current_mutation = self.mutation_factor * (1 + (self.f_opt - self.fitness[i]) / (1 + self.f_opt))\n                mutant_vector = a + current_mutation * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:46.654700", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:30:53.906156", "content": "# Description: Enhancing adaptive DE with Lévy flights by introducing dynamic population size and elitism for improved exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.init_population_size = 10 * dim\n        self.population_size = self.init_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.standard_cauchy(size=self.dim) / np.power(np.abs(np.random.standard_cauchy(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        elitism_rate = 0.02\n        \n        while evaluations < self.budget:\n            elite_count = max(1, int(elitism_rate * self.population_size))\n            elites = np.argsort(self.fitness)[:elite_count]\n            \n            for i in range(self.population_size):\n                if i in elites:\n                    continue\n                \n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            self.population_size = self.init_population_size + int(0.1 * self.init_population_size * np.cos(np.pi * evaluations / self.budget))\n            self.population = np.clip(self.population[:self.population_size], -5, 5)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:30:53.914696", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:00.636105", "content": "# Description: This refined strategy incorporates adaptive step sizes for the Lévy flights based on budget consumption and introduces a convergence-based mutation factor adjustment to enhance robustness and convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L, factor):\n        return factor * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    step_factor = 0.01 * (1 + 0.5 * (self.budget - evaluations) / self.budget)\n                    trial_vector += self.levy_flight(L, step_factor)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            convergence_rate = np.std(self.fitness) / self.f_opt if self.f_opt != 0 else 1\n            self.mutation_factor = 0.5 + (0.5 * (1 - convergence_rate))\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:00.644199", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:07.317295", "content": "# Description: Enhancing convergence by integrating a dynamic weighting mechanism and chaos-based initialization to enrich diversity and adaptability in the search process.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = self.chaotic_initialization(dim)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def chaotic_initialization(self, dim):\n        population = np.zeros((self.population_size, dim))\n        x = np.random.rand(dim)\n        for i in range(self.population_size):\n            x = 4 * x * (1 - x)  # logistic map for chaos\n            population[i] = -5 + 10 * x\n        return population\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                weight_factor = np.random.uniform(0.5, 1.5)\n                mutant_vector = a + weight_factor * self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:07.325504", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:16.670508", "content": "# Description: The algorithm enhances Differential Evolution with Lévy flights by dynamically adjusting population size and mutation strategies based on performance feedback and adding elite retention.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                np.random.shuffle(indices)\n                a, b, c = self.population[indices[:3]]\n                if i in indices[:3]:\n                    continue\n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            elite_individuals = np.argpartition(self.fitness, 3)[:3]\n            self.population = np.concatenate((self.population[elite_individuals], self.population))\n            self.fitness = np.concatenate((self.fitness[elite_individuals], self.fitness))\n            self.population_size = min(self.initial_population_size, self.population_size + 1)\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:16.679582", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:23.095606", "content": "# Description: This algorithm enhances exploration by using adaptive strategy parameters and self-adaptive Lévy flights, improving convergence speed and solution accuracy.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 20 + int(3 * np.log(dim))  # Adapt population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * np.random.standard_cauchy(size=self.dim) * np.exp(-np.random.rand(self.dim) / L)\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                # Add adaptive Lévy flight\n                if np.random.rand() < (0.1 + 0.4 * (self.budget - evaluations) / self.budget):\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:23.104075", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:29.700686", "content": "# Description: Enhancing the adaptive DE with Lévy flights by including dynamic population resizing and a novel mutation adaptation strategy based on fitness diversity to improve convergence speed and solution quality.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            diversity = np.std(self.fitness) / (abs(np.mean(self.fitness)) + 1e-8)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                adaptive_mutation = self.mutation_factor * (1 + diversity)\n                mutant_vector = a + adaptive_mutation * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            if diversity < 0.1 and self.population_size > 5:\n                self.population_size -= 1\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:29.707845", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:37.096524", "content": "# Description: Enhancing the algorithm by incorporating self-adaptive parameter control for mutation and crossover rates to improve convergence and exploration balance.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        success_count = np.zeros(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    success_count[i] += 1\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            success_rate = success_count / evaluations\n            self.mutation_factor = 0.5 + 0.5 * np.mean(success_rate)\n            self.crossover_rate = 0.5 + 0.3 * np.var(success_rate)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:37.102594", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:42.733106", "content": "# Description: The algorithm integrates adaptive strategies in mutation and crossover with a more sophisticated Lévy flight approach, utilizing dynamic scaling based on fitness improvement rates.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1 / L)\n        return 0.01 * step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.delete(np.arange(self.population_size), i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:  # Increasing Lévy flight probability\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.3 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.6 + (0.4 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:42.742756", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:48.827523", "content": "# Description: The algorithm enhances the adaptive Lévy Differential Evolution by introducing a self-adaptive mechanism for mutation and crossover rates based on population diversity, improving convergence and robustness.\n\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.diversity_threshold = 1e-5\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def population_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            diversity = self.population_diversity()\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            if diversity < self.diversity_threshold:\n                self.mutation_factor = np.random.uniform(0.5, 0.9)\n                self.crossover_rate = np.random.uniform(0.4, 0.9)\n            else:\n                self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n                self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:48.835313", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:31:55.581314", "content": "# Description: The refined strategy adds dynamic adaptation of population size and mutation factor based on convergence and fitness variance, introducing an elite preservation mechanism to maintain diversity and improve convergence.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n\n        while evaluations < self.budget:\n            fitness_variance = np.var(self.fitness)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            self.mutation_factor = 0.5 + (0.5 * fitness_variance / (fitness_variance + 1e-8))\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            self.population_size = min(self.initial_population_size, max(4, int(self.population_size * 0.95)))\n\n            elite_index = np.argmin(self.fitness)\n            if elite_index != i:\n                self.population[i] = self.population[elite_index].copy()\n                self.fitness[i] = self.fitness[elite_index]\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:31:55.588934", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:00.893011", "content": "# Description: The improved algorithm refines the balance between exploration and exploitation by adjusting the Lévy flight mechanism, mutation factor, and crossover rate based on fitness variances, enhancing adaptation to the landscape.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.fitness_variance = np.var(self.fitness)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def adapt_parameters(self):\n        self.fitness_variance = np.var(self.fitness)\n        if self.fitness_variance < 0.1:\n            self.mutation_factor = 0.6\n            self.crossover_rate = 0.95\n        else:\n            self.mutation_factor = 0.9\n            self.crossover_rate = 0.85\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:00.902546", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:06.851019", "content": "# Description: Improved strategy combines Differential Evolution with adaptive Lévy flights while dynamically adjusting parameters and incorporating elitism for enhanced convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n    \n    def levy_flight(self, L):\n        return 0.01 * (np.random.standard_cauchy(self.dim) / np.power(np.abs(np.random.standard_cauchy(self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Include elitism to retain the best solution in the population\n            worst_index = np.argmax(self.fitness)\n            self.population[worst_index] = self.x_opt\n            self.fitness[worst_index] = self.f_opt\n\n            self.mutation_factor = 0.5 + (0.3 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.3 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:06.860301", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:14.155768", "content": "# Description: This refined algorithm introduces a dynamic population size adjustment and adaptive Lévy flight variance to enhance convergence speed and solution quality.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        scale = 0.01 * (self.budget - self.evaluations) / self.budget  # Dynamic scale\n        return scale * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def adjust_population_size(self):\n        # Dynamic adjustment of population size\n        self.population_size = self.initial_population_size // 2 + (self.initial_population_size * self.evaluations) // (2 * self.budget)\n\n    def __call__(self, func):\n        self.evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if self.evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - self.evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * self.evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:14.167316", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:20.637598", "content": "# Description: Enhance the existing Adaptive Lévy Differential Evolution by introducing an adaptive population size and elitism to improve convergence speed and solution quality.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_pop_size = 10 * dim\n        self.population_size = self.initial_pop_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def __call__(self, func):\n        evaluations = 0\n        L = 1.5\n        \n        self.evaluate_population(func)\n        evaluations += self.population_size\n\n        while evaluations < self.budget:\n            elite_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive population size\n            self.population_size = max(4, int(self.initial_pop_size * (self.budget - evaluations) / self.budget))\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n            # Maintain elite\n            self.population[0] = self.x_opt\n            self.fitness[0] = self.f_opt\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:20.649312", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:26.890786", "content": "# Description: The algorithm refines Adaptive Lévy Differential Evolution by incorporating dynamic search space reduction and adaptive mutation strategies to enhance convergence efficiency and precision.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def dynamic_space_reduction(self, evaluations):\n        return 5 * (1 - evaluations / self.budget)\n\n    def adaptive_mutation(self, evaluations):\n        return 0.5 + (0.3 * np.sin(3.14 * evaluations / self.budget))\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                self.mutation_factor = self.adaptive_mutation(evaluations)\n                mutant_vector = a + self.mutation_factor * (b - c)\n                search_range = self.dynamic_space_reduction(evaluations)\n                mutant_vector = np.clip(mutant_vector, -search_range, search_range)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -search_range, search_range)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:26.900957", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:32.826780", "content": "# Description: The refined algorithm introduces self-adaptive control parameters and a dynamic population resizing strategy to enhance convergence efficiency and robustness across diverse problems.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n    \n    def levy_flight(self, L):\n        return 0.01 * (np.random.randn(self.dim) / np.power(np.abs(np.random.randn(self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < (evaluations / self.budget):  # Adaptive mutation factor\n                    self.mutation_factor = 0.4 + 0.6 * np.random.rand()\n                else:\n                    self.mutation_factor = 0.6 + 0.4 * np.random.rand()\n\n                self.crossover_rate = 0.6 + 0.4 * (evaluations / self.budget)\n                \n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:  # Increased probability for Lévy flight\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            if evaluations % (self.budget / 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.9))  # Dynamic population resizing\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:32.839691", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:39.629900", "content": "# Description: Enhanced the algorithm by incorporating dynamic population resizing and a stochastic selection strategy to improve convergence and exploration efficiency.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(list(range(self.population_size)), 3, replace=False)\n                a, b, c = self.population[indices]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            \n            # Dynamically resize population based on progress\n            if evaluations > self.budget / 2:\n                new_population_size = max(4, int(self.initial_population_size * (self.budget - evaluations) / self.budget))\n                self.population = self.population[:new_population_size]\n                self.fitness = self.fitness[:new_population_size]\n                self.population_size = new_population_size\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:39.638792", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:45.769810", "content": "# Description: The algorithm enhances exploration by introducing a self-adaptive Lévy flight parameter and dynamic population resizing based on search stagnation, thus improving exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.initial_population_size = self.population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        no_improvement_generations = 0\n        \n        while evaluations < self.budget:\n            improved = False\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    improved = True\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            if not improved:\n                no_improvement_generations += 1\n            else:\n                no_improvement_generations = 0\n\n            if no_improvement_generations > 5:\n                L = np.clip(L * 1.1, 1.5, 2.0)\n                self.population = np.random.uniform(-5, 5, (self.initial_population_size, self.dim))\n                self.evaluate_population()\n                evaluations += self.initial_population_size\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:45.780744", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:51.862078", "content": "# Description: The algorithm incorporates a dynamic Lévy exponent and adaptive population scaling based on fitness diversity to enhance exploration and convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.init_population(dim)\n        self.evaluate_population()\n\n    def init_population(self, dim):\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = self.objective_function(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.objective_function = func\n        evaluations = self.population_size\n        while evaluations < self.budget:\n            diversity = np.std(self.fitness)\n            L = 1.5 + 0.5 * (1 - diversity / 5)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                \n                trial_vector = np.clip(trial_vector, -5, 5)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:51.872347", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:32:57.616900", "content": "# Description: The algorithm now integrates an elite preservation strategy and dynamically updates the Lévy flight parameter, enhancing exploration and convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.elite_threshold = 0.02  # Percentage of elites\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.elite_threshold:  # Elite preservation\n                    continue\n                \n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget / 2:  # Dynamic L adjustment for early exploration\n                L = 1.4 + 0.1 * (2 * evaluations / self.budget)\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:32:57.624392", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:03.888380", "content": "# Description: Refined DE with adaptive Lévy flights by enhancing parameter adaptivity and incorporating local best selection for improved exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.initial_mutation_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.initial_mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.initial_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.05:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            local_best = self.population[np.argmin(self.fitness)]\n            self.initial_mutation_factor = 0.5 + (0.5 * np.linalg.norm(local_best - self.x_opt) / 10)\n            self.initial_crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:03.902276", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:12.176854", "content": "# Description: The improved strategy introduces an adaptive mutation factor and crossover rate based on population diversity and adds a mechanism to restart population when stagnation is detected, maintaining a balance between exploration and exploitation while avoiding local optima.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def population_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        stagnation_counter = 0\n        max_stagnation = 50\n        \n        while evaluations < self.budget:\n            diversity = self.population_diversity()\n            self.mutation_factor = 0.5 + 0.5 * diversity\n            self.crossover_rate = 0.5 + 0.5 * (1 - diversity)\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    stagnation_counter = 0\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                else:\n                    stagnation_counter += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            if stagnation_counter > max_stagnation:\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.evaluate_population()\n                stagnation_counter = 0\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:12.185040", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:18.341036", "content": "# Description: Improved by incorporating an adaptive population size strategy and dynamic Lévy flight exponent adjustment to enhance search efficiency and convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Initial Lévy flight exponent\n        \n        while evaluations < self.budget:\n            self.population_size = int(self.initial_population_size * (1 - evaluations / self.budget))\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    dynamic_L = 1.5 + 0.5 * (evaluations / self.budget)\n                    trial_vector += self.levy_flight(dynamic_L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:18.348607", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:27.742731", "content": "# Description: Enhanced the AdaptiveLevyDifferentialEvolution algorithm by integrating adaptive control for mutation factor and crossover rate based on fitness diversity, and optimized the Lévy flight mechanism for better exploration.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self):\n        sigma = (np.gamma(1 + 1.5) * np.sin(np.pi * 1.5 / 2) / \n                 (np.gamma((1 + 1.5) / 2) * 1.5 * 2 ** ((1.5 - 1) / 2))) ** (1 / 1.5)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        return u / np.abs(v) ** (1 / 1.5)\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight()\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            fitness_diversity = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n            self.mutation_factor = 0.5 + 0.3 * fitness_diversity\n            self.crossover_rate = 0.5 + 0.4 * (1 - fitness_diversity)\n        \n        return self.f_opt, self.x_opt\n```\n"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:27.752220", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:34.705981", "content": "# Description: Improved the balance between exploration and exploitation by introducing dynamic population adjustments and a more adaptive Lévy flight mechanism in the Differential Evolution framework.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.power(np.abs(v), 1/L)\n        scale_factor = 0.01 * np.sqrt((self.budget - self.evaluations) / self.budget)\n        return scale_factor * step\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.2:  # Increased probability for Lévy flights\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if self.evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + 0.5 * np.exp(-2 * (self.evaluations / self.budget))\n            self.crossover_rate = 0.4 + 0.6 * (self.evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:34.717402", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:41.198744", "content": "# Description: This enhanced algorithm introduces an adaptive scaling factor for Lévy flights, a dynamic population resizing mechanism based on fitness variance, and a restart mechanism upon stagnation to improve exploration and exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.initial_budget = budget\n\n    def levy_flight(self, L, scale):\n        return scale * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        stagnation_threshold = 0.01\n        scale_factor = 0.01\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    scale_factor = 0.01 + 0.05 * (evaluations / self.budget)\n                    trial_vector += self.levy_flight(L, scale_factor)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n                \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                    if evaluations >= self.budget:\n                        break\n                \n            fitness_variance = np.var(self.fitness)\n            if fitness_variance < stagnation_threshold:\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.evaluate_population()\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.initial_budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.initial_budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:41.227249", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:48.370803", "content": "# Description: The refined strategy incorporates adaptive mutation factor tuning based on fitness diversity and dynamic population resizing to enhance convergence and exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.base_population_size = 10 * dim\n        self.population_size = self.base_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()  # Evaluate initial population\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def adjust_mutation_factor(self):\n        diversity = np.std(self.fitness) / np.mean(self.fitness)\n        self.mutation_factor = 0.5 + 0.3 * (1 - diversity)\n\n    def dynamic_population_resize(self, evaluations):\n        if evaluations > self.budget / 2:\n            self.population_size = int(self.base_population_size * 0.8)\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            self.adjust_mutation_factor()\n            self.dynamic_population_resize(evaluations)\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:48.381073", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:33:55.533600", "content": "# Description: Improve exploration and exploitation balance by introducing dynamic Levy exponent adjustment and a local search component, enhancing adaptability and convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = self.evaluate_func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def evaluate_func(self, x):\n        return func(x)\n    \n    def local_search(self, individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_individual = np.clip(individual + perturbation, -5, 5)\n        return new_individual\n    \n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                if np.random.rand() < 0.2:\n                    trial_vector = self.local_search(trial_vector)\n\n                trial_fitness = self.evaluate_func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            L = 1.2 + 0.3 * (self.budget - evaluations) / self.budget\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:33:55.545069", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:01.302057", "content": "# Description: The algorithm enhances adaptive Lévy Differential Evolution by refining population initialization using Sobol sequences, adding non-linear scaling to the mutation factor and crossover rate, and integrating a dynamic boundary reflection mechanism for better exploration and exploitation.\n# Code:\n```python\nimport numpy as np\nfrom scipy.stats.qmc import Sobol\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = self.initialize_population()\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def initialize_population(self):\n        sobol = Sobol(d=self.dim, scramble=True)\n        return -5 + 10 * sobol.random(self.population_size)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = np.inf\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_vector = np.where(trial_vector < -5, -5 + np.abs(trial_vector + 5), trial_vector)\n                trial_vector = np.where(trial_vector > 5, 5 - np.abs(trial_vector - 5), trial_vector)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n            self.crossover_rate = 0.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:01.312213", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:06.803184", "content": "# Description: Enhances exploration by incorporating self-adaptation for both mutation factor and crossover rate, while using a more dynamic Lévy flight strategy.  \n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1/L)\n        return 0.01 * step\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                dynamic_mutation = self.mutation_factor + np.random.uniform(-0.1, 0.1)\n                mutant_vector = a + dynamic_mutation * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                dynamic_crossover = np.random.rand()\n                trial_vector = np.where(np.random.rand(self.dim) < dynamic_crossover, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.3:  # Increased probability to adjust\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)       \n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:06.814930", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:13.634019", "content": "# Description: An enhanced Adaptive Lévy Differential Evolution that introduces elitism and dynamic population resizing for improved convergence. \n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        elite_size = max(1, self.population_size // 10)\n\n        while evaluations < self.budget:\n            # Introduce elitism\n            elite_indices = np.argsort(self.fitness)[:elite_size]\n            elite_population = self.population[elite_indices]\n            for i in range(self.population_size):\n                if i not in elite_indices:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    \n                    mutant_vector = a + self.mutation_factor * (b - c)\n                    mutant_vector = np.clip(mutant_vector, -5, 5)\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                    \n                    if np.random.rand() < 0.1:\n                        trial_vector += self.levy_flight(L)\n                        trial_vector = np.clip(trial_vector, -5, 5)\n\n                    trial_fitness = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial_vector\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.f_opt:\n                            self.f_opt = trial_fitness\n                            self.x_opt = trial_vector.copy()\n                    \n                    if evaluations >= self.budget:\n                        break\n                \n            # Dynamic resizing (reduce population size for exploitation)\n            if evaluations > self.budget // 2:\n                self.population_size = max(elite_size, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n            \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:13.643710", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:21.872902", "content": "# Description: The strategy is refined by using an adaptive population size based on convergence, implementing opposition-based learning to enhance diversity and ensuring balanced exploration and exploitation through adaptive Lévy parameters.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def adjust_population_size(self):\n        if self.budget - evaluations < 0.3 * self.budget:\n            self.population_size = max(5 * self.dim, int(0.5 * self.initial_population_size))\n\n    def opposition_based_learning(self, x):\n        return -x + np.random.uniform(-5, 5, x.shape)\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                else:\n                    opposition = self.opposition_based_learning(self.population[i])\n                    op_fitness = func(opposition)\n                    evaluations += 1\n                    if op_fitness < trial_fitness:\n                        self.population[i] = opposition\n                        self.fitness[i] = op_fitness\n                        if op_fitness < self.f_opt:\n                            self.f_opt = op_fitness\n                            self.x_opt = opposition.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            L = 1.5 + 0.5 * (evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:21.883261", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:30.301233", "content": "# Description: Enhanced Adaptive Lévy DE by introducing dynamic population size and chaotic maps to improve diversification and convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLevyDE:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic behavior\n\n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            self.population_size = int(self.initial_population_size * (1 - evaluations / self.budget))\n            self.population_size = max(self.population_size, 4)  # Keep a minimum size\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            x = np.random.rand()\n            self.mutation_factor = self.chaotic_map(x)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:30.310279", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:36.389068", "content": "# Description: Enhanced Adaptive Lévy DE with local search improvements for intensification by integrating a local optimizer and adaptive population dynamics.\n# Code:\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def local_search(self, candidate, func):\n        result = minimize(func, candidate, method='L-BFGS-B', bounds=[(-5, 5)] * self.dim)\n        return result.x, result.fun\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    local_x, local_f = self.local_search(trial_vector, func)\n                    if local_f < trial_fitness:\n                        trial_vector, trial_fitness = local_x, local_f\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            if evaluations < self.budget // 2:\n                self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            else:\n                self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:36.403000", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:42.349269", "content": "# Description: The refined approach incorporates an adaptive population size and local search with quadratic interpolation to enhance convergence speed and solution quality.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 5 * dim\n        self.population = np.random.uniform(-5, 5, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def local_search(self, point):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(point + perturbation, -5, 5)\n        return candidate\n    \n    def __call__(self, func):\n        L = 1.5\n        evaluations = self.initial_population_size\n        \n        while evaluations < self.budget:\n            population_size = self.initial_population_size + int((self.budget - evaluations) / self.budget * self.initial_population_size)\n            self.population = np.random.uniform(-5, 5, (population_size, self.dim))\n            for i in range(population_size):\n                indices = list(range(population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + 0.8 * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < 0.9, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                if np.random.rand() < 0.05:\n                    trial_vector = self.local_search(trial_vector)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:42.373283", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:49.629337", "content": "# Description: The algorithm enhances exploration and convergence by dynamically adjusting the Lévy flight exponent and incorporating a restart mechanism when improvements stagnate.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.stagnation_counter = 0\n        self.restart_threshold = budget // 4\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Initial Lévy flight exponent\n        \n        while evaluations < self.budget:\n            improvement_flag = False\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                        improvement_flag = True\n                \n                if evaluations >= self.budget:\n                    break\n            \n            if not improvement_flag:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n\n            if self.stagnation_counter >= self.restart_threshold:\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.evaluate_population()\n                self.stagnation_counter = 0\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n            L = 1.5 + 0.5 * (evaluations / self.budget)  # Adjust Lévy exponent\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:49.636723", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:34:55.853075", "content": "# Description: The algorithm enhances adaptive exploration-exploitation by introducing fitness-based mutation scaling and adaptive Lévy flights, improving convergence speed and accuracy.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n        self.alpha = 0.1  # Scaling factor for mutation\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.standard_normal(self.dim) / np.power(np.abs(np.random.standard_normal(self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Fitness-based mutation scaling\n                fitness_scaling = (self.fitness[i] - np.min(self.fitness)) / np.ptp(self.fitness) if np.ptp(self.fitness) != 0 else 0.5\n                scaled_mutation_factor = self.mutation_factor * (1 + self.alpha * fitness_scaling)\n                \n                mutant_vector = a + scaled_mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                # Adaptive Lévy flights\n                if np.random.rand() < 0.15:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n                \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:34:55.864573", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:35:02.134195", "content": "# Description: Enhancing the DE and Lévy flight strategy with dynamic population size adjustment and a restart mechanism for improved exploration.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = 0\n        L = 1.5  # Lévy flight exponent\n        self.evaluate_population(func)\n        evaluations += self.population_size\n        unsuccessful_iterations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                    unsuccessful_iterations = 0\n                else:\n                    unsuccessful_iterations += 1\n\n                if evaluations >= self.budget:\n                    break\n\n            if unsuccessful_iterations >= self.population_size:\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.evaluate_population(func)\n                evaluations += self.population_size\n                unsuccessful_iterations = 0\n\n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:35:02.145769", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:35:08.488874", "content": "# Description: The algorithm is refined by introducing dynamic population resizing based on convergence, improving exploration in early stages and exploiting in later stages, while maintaining adaptive Lévy flights and DE's core mechanisms.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        L = 1.5\n        \n        while evaluations < self.budget:\n            if evaluations % (self.budget // 5) == 0:\n                self.population_size = max(10, int(self.initial_population_size * (1 - evaluations / self.budget)))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
{"role": "LLaMEA", "time": "2025-01-05 03:35:08.499352", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code to minimize the function value. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nAn example of such code (a simple random search), is as follows:\n```\nimport numpy as np\n\nclass RandomSearch:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            x = np.random.uniform(func.bounds.lb, func.bounds.ub)\n            \n            f = func(x)\n            if f < self.f_opt:\n                self.f_opt = f\n                self.x_opt = x\n            \n        return self.f_opt, self.x_opt\n```\nGive an excellent and novel heuristic algorithm to solve this task.\n\nThe selected solution to update is:\nThe algorithm combines Differential Evolution (DE) with adaptive Lévy flights to balance exploration and exploitation, dynamically adjusting mutation and crossover rates based on search progression.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        return 0.01 * (np.random.normal(size=self.dim) / np.power(np.abs(np.random.normal(size=self.dim)), 1/L))\n    \n    def evaluate_population(self):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n\n\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 40.0% of the code, which means if the code has 100 lines, you \ncan only change 40.0 lines, and the rest lines should remain the same. For \nthis code, it has 61 lines, so you can only change 24\nlines, the rest 37 lines should remain the same. \nThis changing rate 40.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-01-05 03:35:15.848850", "content": "# Description: Enhanced Adaptive Lévy Differential Evolution by introducing dynamic population resizing and adaptive mutation strategies based on convergence rate to improve search performance and convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluate_population()\n\n    def levy_flight(self, L):\n        u = np.random.normal(size=self.dim)\n        v = np.random.normal(size=self.dim)\n        return 0.01 * (u / np.power(np.abs(v), 1/L))\n    \n    def evaluate_population(self, func=None):\n        if func is not None:\n            for i in range(self.population_size):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.f_opt:\n                    self.f_opt = self.fitness[i]\n                    self.x_opt = self.population[i].copy()\n\n    def __call__(self, func):\n        evaluations = self.population_size\n        L = 1.5  # Lévy flight exponent\n        \n        while evaluations < self.budget:\n            conv_rate = np.std(self.fitness) / np.abs(np.mean(self.fitness))\n            if conv_rate < 0.01 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant_vector = a + self.mutation_factor * (b - c)\n                mutant_vector = np.clip(mutant_vector, -5, 5)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    trial_vector += self.levy_flight(L)\n                    trial_vector = np.clip(trial_vector, -5, 5)\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.f_opt:\n                        self.f_opt = trial_fitness\n                        self.x_opt = trial_vector.copy()\n                \n                if evaluations >= self.budget:\n                    break\n                \n            self.mutation_factor = 0.5 + (0.5 * (self.budget - evaluations) / self.budget)\n            self.crossover_rate = 0.5 + (0.5 * evaluations / self.budget)\n        \n        return self.f_opt, self.x_opt\n```"}
