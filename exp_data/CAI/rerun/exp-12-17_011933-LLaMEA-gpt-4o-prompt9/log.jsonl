{"id": "5c7f1dc5-b18a-469c-b7ef-f7dab59a3f67", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.CR = 0.5  # Crossover probability\n        self.F = 0.8  # Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Dynamic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.cos(2 * np.pi * gen_counter / (self.budget / self.pop_size))\n            self.F = 0.5 + 0.3 * np.cos(2 * np.pi * gen_counter / (self.budget / self.pop_size))\n\n            # Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness.fill(np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Restarts and Dynamic Crossover for enhanced exploration and exploitation in varying dimensions.", "configspace": "", "generation": 0, "fitness": 0.2877374364831176, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7481219174802779, 0.766383141827114, 0.7563874627357557, 0.7879964495690908, 0.8219890694358972, 0.7990748933217491, 0.7957011265523961, 0.7403643753711353, 0.8336572459023566, 0.48567795837121475, 0.4687616678187756, 0.4517120019296942, 0.46918381370889517, 0.5044315980899057, 0.4187646500167249, 0.5045087288638553, 0.4455575724430938, 0.5113839409027574, 0.1817383844315893, 0.18826957963580138, 0.15410245489511598, 0.16909808041728813, 0.14288336575061056, 0.19711211761145064, 0.16236698155085905, 0.1630588710433234, 0.1335251853271615, 0.13461494139325036, 0.14533511521151854, 0.1325169485364448, 0.14285881801419742, 0.12478606587542107, 0.1602422729086337, 0.14008810466456856, 0.15435005958011794, 0.14563125603131322, 0.9940555948469646, 0.9528060390884039, 0.9601070909182822, 0.9725084176773244, 0.9873727814674381, 0.9811729370631284, 0.9291199853918152, 0.9354691095152474, 0.9298523244699511, 0.2786919262901294, 0.2784684851645809, 0.2809632020605606, 0.27748963974307117, 0.2285615372185814, 0.38515703414305613, 0.17132887354921045, 0.31480218310217334, 0.2690808255064209, 0.8475399081846052, 0.38368040910072254, 0.8551839188071653, 0.8945122901275144, 0.3833730027135567, 0.29301206584223005, 0.3931824511902182, 0.8589321695753942, 0.33519254284656086, 0.18634819301793137, 0.187624752795728, 0.15053552666590808, 0.17706775114788487, 0.25727919226914087, 0.17242345521447844, 0.16476914442539514, 0.17794042309166358, 0.15330371819382294, 0.08001605897930075, 0.17650836418971738, 0.13523271179501573, 0.17017053016227068, 0.16037145821830312, 0.19904654398707977, 0.17034937091925606, 0.15756213310189415, 0.2002400391179071, 0.01718102590958792, 0.15039902525465, 0.1951159491299128, 0.16760221398676844, 0.1397738505803212, 0.09649176706953277, 0.10433100288403507, 0.13030432615327248, 0.09858827696174044, 0.30327813437175777, 0.3027605010723129, 0.24468352451881237, 0.2767366197130423, 0.05163231016847625, 0.2302389383095006, 0.35000976348968293, 0.3656352514176475, 0.2829039638342551, 0.016671279070759937, 0.0, 0.006277076513626856, 0.025886906780564822, 0.0017989002888878503, 0.0024565534246918652, 0.005119532292491957, 0.024150417907954802, 0.027348233813822453, 0.18931542116439892, 0.16349490304744718, 0.05941323295125911, 0.124354228232461, 0.17230884829037552, 0.16628147122578485, 0.1704361732512245, 0.08063567628320034, 0.14852324859948585, 0.4734668120189003, 0.44983420212552994, 0.5069812889049562, 0.4606367419541294, 0.4838699365293079, 0.5376486067685453, 0.5125841011659429, 0.507331935877852, 0.449540924216127, 0.1068976488230643, 0.08687361803479565, 0.10509293138247267, 0.1120269482971844, 0.11037362123238204, 0.10180054067914623, 0.07675607789137406, 0.0822987332120978, 0.07936752310886042, 0.2185190067090158, 0.14123507469762642, 0.14619463660441, 0.25483354805967795, 0.14462152651096405, 0.1954489548060807, 0.2285513952460133, 0.19794181455121085, 0.1329318470622355, 0.3244300218747077, 0.3166660001607663, 0.2989857102362634, 0.2649786908357411, 0.2748822681267815, 0.27718230293240187, 0.2940353369451525, 0.30886913905463376, 0.3079376827430069, 0.2409448519324181, 0.21030207818031488, 0.2306211532088427, 0.21058726713338272, 0.19603680546478075, 0.21468415914048256, 0.25229888067543427, 0.181516656022358, 0.2373577187872321, 0.20071610677369722, 0.18020972084143527, 0.18271860777109394, 0.17689577517194321, 0.1802959350476887, 0.18437955398186323, 0.19191391278991532, 0.19363694882384996, 0.20175569882931954, 0.20097549263394643, 0.21605702536139304, 0.19801339754906055, 0.21591988836035148, 0.1899994039594376, 0.19439463597379614, 0.1971574168993061, 0.20983877226736414, 0.1905890438597131, 0.2121003076515524, 0.22553535276402714, 0.171787312845329, 0.24061508422807576, 0.2688688834281606, 0.8943912043337451, 0.1560854271438924, 0.2013608094435353, 0.18193916206294036, 0.18274950339747342, 0.24469399905356481, 0.794822955598548, 0.7420226766454086, 0.1654804245130661, 0.21134805311289062, 0.18935948009024473, 0.6545014301598644, 0.6272914284280597, 0.1797645913657523, 0.19237189998842152, 0.17674893175844641, 0.1795663092116203, 0.18296468462500148, 0.186056536673195, 0.17076262662779773, 0.18113388167027555, 0.1800914414164606, 0.07660889594439635, 0.0775911611558282, 0.06593116234438001, 0.07306492760620054, 0.07637491664854223, 0.07566430167677973, 0.07479292652160496, 0.08308463151025935, 0.07953402380817864]}, "mutation_prompt": null}
{"id": "5db9bfea-06ea-4c1d-8b61-cb5ee523951f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.CR = 0.5  # Crossover probability\n        self.F = 0.8  # Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n                # Crossover with enhanced diversity preservation\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Dynamic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.cos(2 * np.pi * gen_counter / (self.budget / self.pop_size))\n            self.F = 0.5 + 0.3 * np.cos(2 * np.pi * gen_counter / (self.budget / self.pop_size))\n\n            # Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness.fill(np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Enhanced Diversity Preservation for faster convergence and robustness across diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": 0.31186608367512525, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "5c7f1dc5-b18a-469c-b7ef-f7dab59a3f67", "metadata": {"aucs": [0.8374883418936968, 0.8222989998417811, 0.7992784576841714, 0.8628095018356965, 0.8316359398930868, 0.8491399385405682, 0.7966627828288759, 0.8460804560817442, 0.831120421753325, 0.5338864314748744, 0.52668355085175, 0.5278207932804839, 0.43870602500088585, 0.48632304656568115, 0.5798900142422259, 0.5688051563179818, 0.5837129236412097, 0.5255657797540363, 0.26103027839722426, 0.14715391971391634, 0.21997801121408633, 0.14334628067237476, 0.16930314798167934, 0.16513711786966356, 0.15311537955719667, 0.1608216936278244, 0.1395870746014709, 0.15398107383106852, 0.14040415511134907, 0.17564095417912828, 0.13681100869388496, 0.1315598670308218, 0.1491918191138959, 0.1336433856234811, 0.12888285144742495, 0.15536126141021034, 0.9717141267316953, 0.9882104614348776, 0.7772978800715266, 0.9030824220927328, 0.8934751796722804, 0.9058987984259963, 0.9346732012944823, 0.874072365431211, 0.9415112042006837, 0.3016658127223233, 0.30202114578486317, 0.2514476205733618, 0.23706435181859664, 0.27069755804722384, 0.34275998967602095, 0.16444567540375643, 0.30606286789425297, 0.30707831236443617, 0.8783133972239078, 0.8610209021273764, 0.3841343747924083, 0.8795996070329102, 0.871030099865143, 0.3994698666554918, 0.8777983206441118, 0.36245800285898655, 0.3868786815548243, 0.16602551404916754, 0.17661624509178964, 0.23985262749866765, 0.2341386637853904, 0.16225428372804074, 0.19126046911815686, 0.19751005942828292, 0.18963761610323282, 0.24920192302570765, 0.19542782173209516, 0.19670744294821818, 0.23941578163960087, 0.1375375883517278, 0.1866766312438748, 0.21917562393712298, 0.16752188923139733, 0.17501933366610534, 0.17144949700756884, 0.3104593966385435, 0.19801436340229717, 0.2684121360928262, 0.2060706505252572, 0.27365657045490066, 0.11344865662453685, 0.18741329803752482, 0.13675724778934506, 0.2614949182200498, 0.35233285778277146, 0.49146912219564143, 0.2983140319754497, 0.29904923461813215, 0.3780647911461832, 0.3640656953431892, 0.3932325966816971, 0.42969921426439006, 0.34734155597725724, 0.0022607953662169278, 0.08063115775014507, 0.027888729196952067, 0.026890455564728688, 0.07585785967678749, 0.11428064497059387, 0.07733736558833293, 0.06824759408919745, 0.03932316532281965, 0.14197905910312425, 0.1389341552815293, 0.16817457239554057, 0.1984562929934871, 0.15242912467631808, 0.1818206943892947, 0.23431732675418737, 0.19051286708529458, 0.16712783060068181, 0.470036811570936, 0.507819110827141, 0.5148553853334208, 0.5364349556792496, 0.47431119378655484, 0.48017032254577274, 0.5214151726577492, 0.5198184637566694, 0.5189175173542759, 0.09668917453568959, 0.1167584643331202, 0.0828489300457077, 0.1042889672756222, 0.1379798621287538, 0.09263485602079724, 0.12270437896644804, 0.09635747448166199, 0.08316735116471552, 0.15265080742991466, 0.17014072506750655, 0.13223321494489215, 0.13278628039030593, 0.19196104801052583, 0.13539006366963802, 0.15450714857007897, 0.1303193912904037, 0.11385464231187503, 0.2765593780275255, 0.31013322092475004, 0.31113090907372576, 0.2909486784981147, 0.31138225713351175, 0.25575915196449284, 0.33860893786372404, 0.32441505009358507, 0.2917819076243173, 0.2295845096197946, 0.2044699218127075, 0.22509956628149075, 0.2850626354556879, 0.2343908111931532, 0.237077382721264, 0.25428918056338157, 0.2681398524309496, 0.25747011608943615, 0.21297702419733477, 0.1921646776268079, 0.18008272803591552, 0.1911683167784034, 0.22684111893391523, 0.21424179760014395, 0.20896911431008636, 0.17696158658019723, 0.18366247231997612, 0.21638788538484544, 0.24879969528237655, 0.19702430326827924, 0.21641494121089822, 0.19981014940407704, 0.20343980776934167, 0.21394488203305917, 0.21949675289603765, 0.19003303154739792, 0.9213443566271476, 0.7110835918799336, 0.16103717760573433, 0.24022951304143403, 0.8647108638600403, 0.21677178163146416, 0.5960124209531922, 0.20022604983354975, 0.21412464352369132, 0.18962717732966838, 0.843853627390735, 0.21303820021062303, 0.269166194809765, 0.20714539666878595, 0.2063035330252414, 0.260899003472869, 0.14845213442107652, 0.5790072395508974, 0.1847680334395635, 0.20648248191023733, 0.1948375223949741, 0.1686324417973829, 0.18985066634636372, 0.17846704198234276, 0.18411203123675335, 0.1896669006337789, 0.18321193359258992, 0.06903886534754455, 0.06848278307094335, 0.07426785889371168, 0.07408544835207553, 0.0745327384916673, 0.08706451803492765, 0.07152284555617827, 0.08259166135073914, 0.07071482074366864]}, "mutation_prompt": null}
{"id": "2074c75c-688f-4851-b6b8-c908b2aab386", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n                # Crossover with enhanced diversity preservation\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness.fill(np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Stochastic CR and F Adjustments for increased exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.32104904624128955, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "5db9bfea-06ea-4c1d-8b61-cb5ee523951f", "metadata": {"aucs": [0.9062422759925874, 0.8670751243976698, 0.8680247004433228, 0.9153041433708661, 0.8624252209999937, 0.9108474930182588, 0.8102054414691152, 0.8691051152334763, 0.8756527096473916, 0.5672926555296429, 0.553411280498933, 0.5071404587937087, 0.5938431319156285, 0.5272314329524717, 0.5345332371556069, 0.6107003454871123, 0.5788935528229698, 0.5287950014173466, 0.12399289907084932, 0.13062948886907544, 0.14837441855654165, 0.11908390540165403, 0.10916074693268785, 0.11900134846646493, 0.1354671901475829, 0.11733013487152388, 0.11818760059942612, 0.13157322129945348, 0.12343712271069307, 0.11808729763023729, 0.10596090548953485, 0.11815069455526717, 0.1205369478293955, 0.10600734015546898, 0.10661568710492852, 0.12485167055583368, 0.9775687062142634, 0.9712008637474747, 0.9561779519652307, 0.9800602638981293, 0.9553723477987909, 0.9432105901948873, 0.9786626886722243, 0.9689686466271373, 0.9618285998381946, 0.3342182214669489, 0.31019041087858046, 0.33596684529274223, 0.33116185811325816, 0.32390746458629693, 0.3689274841603948, 0.334166640501694, 0.3578621589676134, 0.365077830076161, 0.4949574668460197, 0.5960139710162862, 0.8738529939271917, 0.6006397750108561, 0.8536200788768827, 0.442150649434114, 0.8642672080118442, 0.7649605961760756, 0.7024110254177771, 0.27294540835208103, 0.19390922513046893, 0.17470152508498815, 0.26312502520779224, 0.18336428613272582, 0.1894916998739984, 0.1869784599449622, 0.24605938394434357, 0.22175344054698554, 0.2038731885755829, 0.19577270729284635, 0.21704274303040716, 0.2304791060453354, 0.18202765565746293, 0.20115338462316235, 0.19362801311253497, 0.21064257146090992, 0.2156830412556443, 0.13376589503495884, 0.14835968206958294, 0.12380890689696045, 0.16161817356217212, 0.15106886013604104, 0.1492695926579516, 0.10988877393090557, 0.14876637375124246, 0.13501903141973248, 0.3031977126625427, 0.24761274422575186, 0.24899720995409824, 0.22662697757556616, 0.26661444881393204, 0.24130981251265438, 0.2884334255658225, 0.29739589806670197, 0.36309591483044723, 0.10690024462979486, 0.06772865115667392, 0.06702905979047968, 0.0828919751808016, 0.07831710818915305, 0.05971566277649121, 0.07909282218976676, 0.07619910200780888, 0.08557084082879496, 0.19382330741668785, 0.18633790336066836, 0.18442985825183977, 0.20585172302217425, 0.20694550407560475, 0.19790636001256767, 0.20452741063551627, 0.19955247976929635, 0.1809263580609103, 0.5685846679920259, 0.5954266536255766, 0.5806045987889359, 0.5969780697741889, 0.6183199461454076, 0.5659253970872193, 0.5665687183702667, 0.5165772554812489, 0.602282496720663, 0.10355607095317587, 0.12078494320652466, 0.1086214077790486, 0.09865216557706957, 0.08999700745253703, 0.09190663207011307, 0.09360567698342259, 0.09946826842759326, 0.09380262010484564, 0.15169413400602283, 0.1441196647752142, 0.19161221827620634, 0.1544261458078845, 0.19546608234280938, 0.17263978026262938, 0.22887620224339955, 0.13936303166238995, 0.167520877238178, 0.315597961881774, 0.2965875753308018, 0.31529257666506394, 0.3086069793568089, 0.30977969476410594, 0.31670031981092883, 0.33436278596299585, 0.34002796830539883, 0.36493061554429973, 0.24370893860562293, 0.22684607216715236, 0.2686897903395148, 0.25516695659989463, 0.24573159581322257, 0.2327163064095017, 0.25898343910281896, 0.25011262936691736, 0.28204246554350043, 0.20268314629881412, 0.17278360690783845, 0.1898327774493479, 0.2061399552631311, 0.20327430240090538, 0.2060148461004384, 0.19975314605887073, 0.19972829743748166, 0.1796332335496329, 0.2056559518106461, 0.2058523782943149, 0.2411270230385567, 0.19390835602338286, 0.18320672235923452, 0.22160833565819738, 0.2472355124839999, 0.2089492851027781, 0.19999272856164807, 0.1733529224428747, 0.7366733088875556, 0.7110653851154856, 0.6802351630291494, 0.3458308995316395, 0.18056375442236783, 0.5208037170659333, 0.3977509554276434, 0.42536565987110186, 0.6683802777466201, 0.6005357576849377, 0.2088772014956608, 0.17968997465002812, 0.18255609236869874, 0.20572772910512171, 0.20804893415439496, 0.6928370601591769, 0.3373520331822807, 0.18910078768981098, 0.17988948261260762, 0.17489234265334852, 0.1829577155354437, 0.17605527538824772, 0.18544716130628536, 0.19860949440158437, 0.1975334899512785, 0.19440372052440757, 0.08266589356960719, 0.07489648043078545, 0.0812181693540539, 0.08754542450029934, 0.0746396754180525, 0.07598844445394282, 0.08096647401598733, 0.08368665038557033, 0.0780035206582923]}, "mutation_prompt": null}
{"id": "7d17837b-2ed4-453b-8499-22d446da099a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 20  # Initial population size\n        self.pop_size = self.initial_pop_size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n                # Crossover with enhanced diversity preservation\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Dynamic population resizing\n            if gen_counter % 50 == 0 and self.evaluations + self.pop_size < self.budget:\n                if np.var(self.population_fitness) < 0.01:\n                    self.pop_size = max(10, self.pop_size // 2)\n                    self.population = self.population[:self.pop_size]\n                    self.population_fitness = self.population_fitness[:self.pop_size]\n\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.initial_pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness.fill(np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                self.pop_size = self.initial_pop_size\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic population resizing for enhanced convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "2074c75c-688f-4851-b6b8-c908b2aab386", "metadata": {}, "mutation_prompt": null}
{"id": "4f33dbce-e9b3-4fa5-a5f3-c7e0022e4177", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n                # Crossover with enhanced diversity preservation\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Dynamic Population Size Adjustment\n            if gen_counter % 50 == 0 and self.pop_size < 40:\n                new_individuals = np.random.uniform(self.lb, self.ub, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                self.population = np.vstack((self.population, new_individuals))\n                self.population_fitness = np.append(self.population_fitness, new_fitness)\n                self.pop_size += 2\n                self.evaluations += 2\n\n            # Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness.fill(np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Size Adjustment for improved convergence speed.", "configspace": "", "generation": 4, "fitness": 0.2986670229019555, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "2074c75c-688f-4851-b6b8-c908b2aab386", "metadata": {"aucs": [0.8079094158652256, 0.8063624904038803, 0.8779704220407694, 0.7741373240996379, 0.8032781701060012, 0.8518967406799782, 0.8700583203706885, 0.8004151023730036, 0.807257629047997, 0.5311379003418502, 0.5088984467602273, 0.5667269649253162, 0.5472926679021992, 0.5034303693141944, 0.5311728680769157, 0.5374265762102042, 0.5350083073418506, 0.6155524791488081, 0.10991622507654664, 0.12326532950179392, 0.11374217799465147, 0.10527286420384374, 0.11200098424224325, 0.11017356208174245, 0.13263827229640535, 0.12311742166043183, 0.12218463290740689, 0.11564403014424296, 0.1215856682660984, 0.11175899124328514, 0.1083400723994713, 0.12095020545668722, 0.10324380721644488, 0.09978069596141281, 0.11377993864920533, 0.11446974601345317, 0.9611055652200987, 0.9652176090019293, 0.991070928971378, 0.9629854444431745, 0.9720053634792623, 0.9656888033299138, 0.9597420002632427, 0.9509698587393097, 0.9378296699726744, 0.36539795718210166, 0.34861283634603923, 0.3475429190180125, 0.32238413662347043, 0.3262078390259743, 0.331025374860374, 0.29451017692289516, 0.31147815389511524, 0.3192236112671408, 0.6539729925988202, 0.31412656056523924, 0.6867225587188324, 0.6329065338052481, 0.4976477035477873, 0.8599277313403033, 0.35933569269547616, 0.6509207904959613, 0.8333584722404681, 0.19102604417170377, 0.18541867935510392, 0.21194804377199639, 0.18435031276568692, 0.17603272401252834, 0.18115012339323278, 0.20592020174502446, 0.2090160853664791, 0.19998918769805318, 0.14577315887438147, 0.1526046500665923, 0.16233064072187586, 0.19705184539196563, 0.1978250179998532, 0.2159963901222718, 0.17030431160220083, 0.17814732001359002, 0.20341931388046686, 0.11379065344623307, 0.11958432823319765, 0.18154785429981424, 0.12755291689484005, 0.11311890260893775, 0.159834284616874, 0.10660728003653863, 0.13782118804818178, 0.18005027676889074, 0.292889329072347, 0.2611138280208114, 0.3247233074579392, 0.23851388661752093, 0.24979591328897188, 0.23409964715590315, 0.28476829562873873, 0.3004067951577898, 0.33880536044810683, 0.04434081320985894, 0.06218803757597924, 0.06817831135209873, 0.022097000313589743, 0.05920958040602997, 0.043586212490892784, 0.01776232114081855, 0.009604656056353078, 0.0719934565076128, 0.17812658849802088, 0.16691011094269492, 0.20098583869073972, 0.20436880092571952, 0.1787861917832153, 0.20993735079735443, 0.19300468930617287, 0.17490590380705984, 0.17038147785326696, 0.5378192728915886, 0.5115996485343062, 0.558749498472404, 0.5655571621104065, 0.595551413362988, 0.5623732348582231, 0.5448574816187535, 0.5276612199803846, 0.558505514260465, 0.11195499596375813, 0.09398752476383487, 0.1514146565014306, 0.0890507936805558, 0.09979454004168742, 0.11502081824591626, 0.0801928170599906, 0.08098214802994153, 0.12218070708974649, 0.16898610276217574, 0.14001416061013894, 0.15729536893892748, 0.13766990437825277, 0.13707020324774655, 0.15473544047680077, 0.12853518730379854, 0.14701139105642524, 0.16548072136015513, 0.3402231697082938, 0.3103854605898767, 0.28878188548530703, 0.32121632764172026, 0.33688994355269386, 0.29074777233143867, 0.33486473304257947, 0.35676022326013157, 0.31952093967542705, 0.2436888034556598, 0.2328482100651833, 0.23180324107870476, 0.20884934966654123, 0.2134028355380605, 0.24763154848094437, 0.22855837939657309, 0.24405213069617981, 0.23571179998429592, 0.1802566906943197, 0.18984153899153478, 0.18385010610054764, 0.18278121311447193, 0.18608202945501473, 0.1814918170247094, 0.18458464685935783, 0.18142403916999295, 0.1947475296447344, 0.18918552368631225, 0.21178504448168656, 0.19631880707496696, 0.19777531665383308, 0.18595851667169638, 0.19108190526388802, 0.1862653703437347, 0.18905907860222948, 0.19390313688032323, 0.26419714071348444, 0.6415825388822369, 0.1778675830484211, 0.42263023918206155, 0.19321718512146724, 0.2503579522732693, 0.4466834384374747, 0.1720521183838135, 0.2478488794541991, 0.2615931435432999, 0.7268793226059792, 0.19205206874971614, 0.20074934387805954, 0.1812658322837355, 0.41007892064184626, 0.2121274062630608, 0.6301722351873418, 0.20565278031337952, 0.18254191614198945, 0.1922383503900741, 0.17617651228965203, 0.18299252572312985, 0.18451104685580422, 0.18316708930164827, 0.17771125064982207, 0.20138371239000807, 0.18919858336785378, 0.07799076784642345, 0.07503392901470762, 0.07817135620216353, 0.08355470934834319, 0.07799284333320067, 0.07702091191957383, 0.07619348652640279, 0.07182427546404235, 0.08157501382446375]}, "mutation_prompt": null}
{"id": "c34fd898-02c8-4b8c-8f2f-26676a821fb9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            ranked_idx = np.argsort(self.population_fitness)\n            self.CR = 0.5 + 0.2 * (1 - np.arange(self.pop_size) / self.pop_size)  # Dynamic CR based on rank\n            for i in range(self.pop_size):\n                # Mutation with best individual influence\n                a, b, c = self.population[np.random.choice(ranked_idx[:self.pop_size//2], 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR[i]\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Dynamic F adjustment based on performance\n            f_diff = np.max(self.population_fitness) - np.min(self.population_fitness)\n            self.F = 0.5 + 0.3 * (f_diff / (f_diff + 1e-9))\n\n            # Restart mechanism with elitism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 50 == 0:  # Increased restart frequency\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness.fill(np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic parameter adjustment and improved crossover based on fitness ranking for enhanced convergence.", "configspace": "", "generation": 5, "fitness": 0.23025416448067237, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "2074c75c-688f-4851-b6b8-c908b2aab386", "metadata": {"aucs": [0.5918229209187763, 0.639679780143541, 0.6573561719065332, 0.5938522584759478, 0.6203729610228765, 0.6599895179035711, 0.6775393122052462, 0.6274068167235674, 0.6633946209952275, 0.30899085146607663, 0.34806909853732104, 0.33041555666967304, 0.3469657239032742, 0.39117218790280717, 0.34451002898949723, 0.32694161437264924, 0.35485008684871555, 0.3642612135357345, 0.12370938136611731, 0.11199193440064115, 0.11889173832083855, 0.12494935858777245, 0.12372471538442409, 0.14544268756169165, 0.1404672165927695, 0.10965016204799538, 0.13941109552583275, 0.09860524658564807, 0.12470938943745291, 0.12341473424904148, 0.12198961843201728, 0.11426373662681966, 0.11648394738282164, 0.1234922253635028, 0.11991937255304908, 0.10712925602427181, 0.9687700041868114, 0.9727093252984274, 0.9806410302698642, 0.9698253016181023, 0.967338482135203, 0.980464483043637, 0.9754598809260369, 0.9797923603215127, 0.9810189962183613, 0.2310773256437041, 0.2126868586910473, 0.2189175865315207, 0.2028277108975115, 0.24352294665008822, 0.22221239485753252, 0.1919331235928433, 0.1903791437401513, 0.24235457484699574, 0.22161874472641874, 0.29341495891458547, 0.23379057147297388, 0.2939069086968541, 0.2888164673271294, 0.2828068184441169, 0.2395437236506749, 0.2517651964127706, 0.26389433101009674, 0.14850411487370696, 0.16347089486350064, 0.14581251046500143, 0.17695663889773072, 0.17192200719595785, 0.1581050331396947, 0.16410705822389193, 0.15955826950829488, 0.17663865889660824, 0.12928006142972703, 0.1354428003579038, 0.13782556273790647, 0.1479463029300001, 0.15934449276441742, 0.16571753083713736, 0.13977183374202962, 0.1485226972893161, 0.14273519712263028, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.010368097207360871, 0.0, 0.0, 0.08101768345987181, 0.07612834708208815, 0.06891362845296678, 0.08514968682222357, 0.10720192265785189, 0.08469942041351441, 0.13061460397804237, 0.10463347638663378, 0.09786039183830653, 0.04264709485552243, 0.028151823770701467, 0.0, 0.0, 0.00629240484011484, 0.015838492048106723, 0.02132075668936273, 0.0, 0.0, 0.09293571317304328, 0.08877311845137115, 0.097327519052402, 0.11263684031785981, 0.10005222804865099, 0.099485802916644, 0.09290594405243024, 0.10396736497078707, 0.10899395553037217, 0.4631620881618864, 0.47712169342041677, 0.4228030639069751, 0.4617641669223397, 0.4531036244735829, 0.448722568963153, 0.45380727130372867, 0.46710289832363816, 0.451595770559883, 0.08883952433528297, 0.08795150830690368, 0.08367143581073833, 0.11298514461527542, 0.08817912795575922, 0.08136748572512609, 0.08238599011155001, 0.08898431728438516, 0.08664959381614479, 0.1574025397593346, 0.14876701533336223, 0.13078675824746966, 0.16614800234501526, 0.13637839833377763, 0.1462624796715003, 0.1538092521592176, 0.14798743629697708, 0.18429572026874286, 0.24482621537830018, 0.2540315743725371, 0.25980334212940503, 0.26026164069259217, 0.2673969304059993, 0.2654681813471741, 0.31148760628268146, 0.27738572718971877, 0.2662859445687763, 0.19923057323793358, 0.1735794080839287, 0.17902852216168963, 0.16676354539083293, 0.18385561444322873, 0.16258223494717017, 0.18918679933323523, 0.18780502221690765, 0.18768308205506867, 0.18125226270498906, 0.1948349861174523, 0.2032277826672625, 0.16886460781308832, 0.17485176476957243, 0.19460604949752147, 0.19613991453452062, 0.18177883173052578, 0.16873520119026875, 0.19021676004704757, 0.19471099110672496, 0.18395993357040097, 0.1888153731293245, 0.19907126594037494, 0.20894441283484033, 0.18897945631210644, 0.19115669799223078, 0.18734030356571507, 0.25370659653216676, 0.2821130973773066, 0.4195579806648704, 0.37834481832212985, 0.3026038283619842, 0.23611603369875866, 0.24304206727581457, 0.2515350107249018, 0.2567295530793442, 0.20957847008321429, 0.1990105370255757, 0.18371192270916714, 0.21545101165400882, 0.21131883954147923, 0.31376344102815423, 0.2808557047442305, 0.25056187789157225, 0.3828979505095247, 0.18130123478107074, 0.18668637244916486, 0.19427710087279415, 0.18910509714230406, 0.19533173619729194, 0.18663021392568602, 0.193709181085861, 0.19409017718617783, 0.18735990684286585, 0.06905490439316142, 0.0710408927364784, 0.07277515744389351, 0.07627022347021539, 0.0804209944909875, 0.09633749831952698, 0.07039662683924763, 0.07386107087013893, 0.07226519000045006]}, "mutation_prompt": null}
{"id": "1d2f74e6-bfe6-40c2-8051-0a5518a51287", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness.fill(np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Improved Crossover Strategy and Adaptive Population Sizing for Better Convergence.", "configspace": "", "generation": 6, "fitness": 0.3358734150777298, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "2074c75c-688f-4851-b6b8-c908b2aab386", "metadata": {"aucs": [0.8614911874093778, 0.8926423667523506, 0.8523713328518983, 0.908205834178016, 0.9017968844601475, 0.8210386746381265, 0.9148001620331139, 0.8153267230730035, 0.854356944378644, 0.6162810055049665, 0.5681572291890635, 0.5513227489701346, 0.5230596349616569, 0.6123047335445047, 0.6068742372416703, 0.5610852282659391, 0.5341348683333311, 0.5575393278116625, 0.11196520707587732, 0.12243812968126244, 0.13628208936381725, 0.11527621751006467, 0.12019329721374072, 0.11040762451768404, 0.11165924720704679, 0.1450426423722403, 0.11747788388849645, 0.10283054838010097, 0.10332422085634496, 0.12270979076982236, 0.10603456978142822, 0.11841556781117013, 0.10759285752331649, 0.10654960236342814, 0.1262364438402528, 0.11113798872899971, 0.9760458182194623, 0.9478059141838413, 0.9544205881594394, 0.949054150306778, 0.9644682932183533, 0.9733793659711192, 0.9618029721867076, 0.9752735058777043, 0.9542942862966098, 0.38632439622190107, 0.3410394915132404, 0.3660439362758884, 0.3122579069895107, 0.32946184578434135, 0.38487869483292425, 0.3682400248459796, 0.339867264904939, 0.3151114247304512, 0.8524652657940486, 0.8752676647331772, 0.722389197818591, 0.8812318777951434, 0.8875252804731295, 0.7469261561919722, 0.8671768150760286, 0.8703094852033781, 0.8724549025332362, 0.20393982938595911, 0.18295438946569487, 0.24028402055306497, 0.20610983710983632, 0.16934419161084002, 0.21844469352629625, 0.22694907833107836, 0.24674228262211428, 0.17164378752834242, 0.18154502867476807, 0.16329870224936327, 0.21869211359952978, 0.24123622782448872, 0.21598541326353593, 0.22967840366167647, 0.18033770347602784, 0.2650848381382619, 0.23848548067700925, 0.2273029211975507, 0.14707590504728918, 0.16356315750532835, 0.14617268867521793, 0.21305460946817167, 0.22501337860665027, 0.1740388476766781, 0.1354680996158637, 0.12850663037171894, 0.338000433682081, 0.24016609833880376, 0.3109717626120212, 0.3744586517879719, 0.29579482897728226, 0.2291209731868884, 0.31334779730464746, 0.37621335805815925, 0.31249473008128004, 0.07556128471481083, 0.09304024200256067, 0.08556884376899743, 0.07071196533855051, 0.07648590515883957, 0.09328854107326601, 0.14090872649276787, 0.09438045439964649, 0.13921127765753716, 0.21192417589129897, 0.20394767145248505, 0.2195529385069125, 0.2236259134775591, 0.22116221616163845, 0.22002046387502427, 0.20914115885233076, 0.18937350217041193, 0.23451530072475713, 0.5977095129260541, 0.6328976181407943, 0.6123498031230136, 0.6088154777761771, 0.5919364562076332, 0.5802699790235282, 0.6845928156064157, 0.5499676375382341, 0.6563780189524397, 0.09710971754714459, 0.090123930900609, 0.0893631407108032, 0.10739337623658807, 0.09725529828996882, 0.0958559968224898, 0.11201068666011016, 0.12634657467995514, 0.10420391292995645, 0.15694563326999067, 0.12095914310030298, 0.1514204180336508, 0.12035128638636783, 0.16144112413721845, 0.14664629943681284, 0.15553413986415376, 0.1310597318492963, 0.13187684568914082, 0.35517119561220933, 0.30110422053736263, 0.3390312497492306, 0.32399767413435554, 0.31805258873485864, 0.3629587532172166, 0.33274158747564697, 0.35419329191173077, 0.36714643501005384, 0.29213049787795, 0.2243032988737177, 0.24724457307522552, 0.2427192857808107, 0.2292397597061968, 0.2376425361851079, 0.23483844030789225, 0.2673315347237113, 0.26743093085626246, 0.19184988521994362, 0.19723871831749928, 0.21456769620753324, 0.20959662324426176, 0.1921166248255043, 0.1932059444441837, 0.19614355578869902, 0.2143454572315393, 0.23882581414717552, 0.1932574732742417, 0.2049215852164481, 0.22370675553987007, 0.19219783398558143, 0.20635850738393025, 0.20004029878678464, 0.22922667153003728, 0.1925757883768926, 0.2209308190127275, 0.6044191132044926, 0.20737302405965308, 0.5786328095138633, 0.8966030212932887, 0.31685550187870837, 0.33888982086488695, 0.5355807125228399, 0.5781922484641058, 0.7349324357321381, 0.2570116022329222, 0.49993257812328995, 0.7268010991119485, 0.20177078201534038, 0.22982331870992356, 0.4044514619566827, 0.27241967182474014, 0.45195850902592005, 0.20885790844146135, 0.17744558838977786, 0.1887105036333092, 0.18121241816829492, 0.20969426009363612, 0.18711889986464303, 0.18648541782674233, 0.1904359292549862, 0.19864361198303127, 0.1770871336068207, 0.08396836267043384, 0.07521659803514336, 0.08480002763367267, 0.07217367584358014, 0.07517176113945612, 0.0796069445050871, 0.06941592306611744, 0.09689336791850178, 0.07305207780746348]}, "mutation_prompt": null}
{"id": "6b00f04b-f36a-46eb-8c3b-55c8c835cda5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (1 - (self.evaluations / self.budget))  # Dynamic mutation factor\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Enhanced Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 120 == 0:  # Changed from 100 to 120 for better exploration\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Modified Adaptive Differential Evolution with Dynamic Mutation Factor and Enhanced Restart Strategy for Faster Convergence.", "configspace": "", "generation": 7, "fitness": 0.3611700753366136, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "1d2f74e6-bfe6-40c2-8051-0a5518a51287", "metadata": {"aucs": [0.9072796044210775, 0.8952227703317915, 0.9060750369117059, 0.9225627966087628, 0.9088402886066054, 0.907499314567752, 0.9078389418483458, 0.9133002814924156, 0.9009124298026193, 0.8482462007974632, 0.8421597303226476, 0.8269057075875319, 0.784236676309156, 0.7899038687830213, 0.8027565228520905, 0.8125221997156926, 0.7703201696487025, 0.7884444936274759, 0.15231109430774048, 0.1482389021179028, 0.15179378403467925, 0.15859453769300236, 0.14114790174240965, 0.1913939335631848, 0.14586966772830345, 0.1397201754633718, 0.17495770571366143, 0.1557910688113523, 0.1526808307368268, 0.13849939613317752, 0.137567066010168, 0.12819262314298563, 0.12238973590510283, 0.13823163093519997, 0.12394973962437394, 0.14279042328815972, 0.9532189253560248, 0.9801826274259591, 0.9519064729204008, 0.9473615517891417, 0.9300267542040472, 0.9642215019711136, 0.9670259993414753, 0.9724315751810001, 0.9459838648387622, 0.3300164790882977, 0.3112750689878184, 0.2695570038877412, 0.46765750243589477, 0.3684933686521724, 0.4325410950136963, 0.3825858054155514, 0.42027418353279633, 0.1516049674568858, 0.8632567230759357, 0.6891798364209321, 0.8645320564223693, 0.372279781327043, 0.27800245310036964, 0.7692894206753038, 0.8825128504572245, 0.8819976528982288, 0.8783445431701077, 0.26382347216012014, 0.24119602703985454, 0.1801466186433952, 0.22229689402503294, 0.30305062105519986, 0.18628185022482469, 0.18055587624240832, 0.3003015861833973, 0.16870989337984788, 0.15892058343204118, 0.20237617549440245, 0.15862588739118766, 0.20848975487513044, 0.17493865448983248, 0.21046835475207004, 0.18417192586004327, 0.1981765135593948, 0.19804395267477093, 0.22252291745331632, 0.04338353596301181, 0.0882306890111666, 0.1725099375275586, 0.2219389898973655, 0.11525939161711574, 0.1015834031572187, 0.26957560548147863, 0.14609706181429116, 0.34565797256993047, 0.2882014598475222, 0.434629757394163, 0.392285872437909, 0.18782766527134165, 0.15898261085532106, 0.17338576321136057, 0.42721694211495065, 0.34713835687175876, 0.245418020105865, 0.16708566328096874, 0.14294945157932926, 0.20709206072536634, 0.11923123761880483, 0.21941703810275293, 0.19937687229680756, 0.22700285536314913, 0.1460637991790682, 0.13891910647513528, 0.24062608083157921, 0.29403724553503097, 0.2989824748507385, 0.2745863623341849, 0.3052546182325214, 0.22915416773992825, 0.23208357462829998, 0.290313615390407, 0.646139186175554, 0.5930655582776161, 0.5810832251997309, 0.7396033786754981, 0.6457961575066573, 0.6835484667269671, 0.6102645487540628, 0.5125621678548589, 0.5726859095482247, 0.11662685344272483, 0.10401004851502671, 0.1515718193641694, 0.1191219760312, 0.10634219020902524, 0.10519918595956101, 0.12648451198773003, 0.12310979585365256, 0.12857763792577503, 0.20221149165912533, 0.16222616352063268, 0.17914733012376238, 0.2351736984305517, 0.1647843657097412, 0.1676543247041098, 0.16071651652440466, 0.186102208363488, 0.19827381756412987, 0.47150668010850016, 0.44208961627434173, 0.42532878259936646, 0.4065030026029415, 0.40430649247142514, 0.42662372142505356, 0.49172957829536545, 0.44039158755119145, 0.4289539152212679, 0.28735037410765396, 0.29861675693920253, 0.3669500959194191, 0.3005253195325026, 0.3225080003188696, 0.31099211627844037, 0.3181043922520933, 0.313079036501668, 0.3463880189374595, 0.20461510018333218, 0.2015453137859754, 0.19254709613873633, 0.22513816569929634, 0.23712278458365044, 0.19946402090964443, 0.20439637826305557, 0.198544478139974, 0.2013812279298629, 0.2227015253630903, 0.23512131392065672, 0.37748132181870997, 0.40715975118612113, 0.2474411320305303, 0.20905213787232058, 0.3695827976389706, 0.20209216192787316, 0.23853436206264977, 0.8916435531344825, 0.5088109232951277, 0.20600733250837588, 0.8875563063486158, 0.19527848503408518, 0.44979663378317414, 0.24246508856949045, 0.19792871468636564, 0.7212468644589716, 0.6828471132167593, 0.5500564795577606, 0.20462248146385298, 0.22535842237686488, 0.1948846975066153, 0.2898000702783322, 0.2084720260272046, 0.8678623201438409, 0.39131445915978225, 0.18069806972849056, 0.20276492502002363, 0.17375736304660583, 0.17738127785685887, 0.18206209437981358, 0.17659378523816127, 0.18501174459741376, 0.18924845704002147, 0.23089999152696838, 0.08331891660665858, 0.09182879841890013, 0.08267048514089437, 0.0773348371022543, 0.08395269239788417, 0.07420277879268833, 0.08320895671492257, 0.08720313021366832, 0.07719077145499453]}, "mutation_prompt": null}
{"id": "2fb26e32-a143-47a8-ae68-e79fc8d1ce7f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (1 - (self.evaluations / self.budget)) + 0.1 * np.random.rand()  # Adaptive mutation scaling\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Enhanced Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 115 == 0:  # Adjusted frequency for tuning exploration\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Integrates Adaptive Mutation Scaling and Restart Mechanism Tuning to enhance Differential Evolution's convergence speed.", "configspace": "", "generation": 8, "fitness": 0.3656277839761029, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "6b00f04b-f36a-46eb-8c3b-55c8c835cda5", "metadata": {"aucs": [0.9027349945819305, 0.8811095882824411, 0.8976176194871471, 0.9074706048855302, 0.9061376213734453, 0.895313277153789, 0.8917266207600146, 0.8973959289432152, 0.8633860967168449, 0.7972908918908186, 0.7959504857785953, 0.8115485996751893, 0.8065515197592358, 0.8057936891870364, 0.683989516254272, 0.6459050869437769, 0.7236046613521804, 0.5947764516467277, 0.15568640659553934, 0.13025361798979596, 0.1756619920342709, 0.17159494896008687, 0.1176465554419649, 0.1266553345951985, 0.12569424045190658, 0.1687033336280752, 0.12500810310972554, 0.10316419788865938, 0.12079025293025225, 0.12904165918040966, 0.13491699923812517, 0.14194436016484813, 0.10089822087674949, 0.12367036580055024, 0.1363786380643729, 0.18220154165960967, 0.9750888866728668, 0.9515950078104738, 0.9396329715548847, 0.9913270346142251, 0.9773253831936644, 0.982273545919092, 0.9803541290324818, 0.9899551476698671, 0.9534874152259714, 0.3815709663063801, 0.4196280805075905, 0.40572457361108705, 0.3500142617321783, 0.31571312880116986, 0.37281579959147915, 0.4011882764090786, 0.30422140979936374, 0.38144391950339485, 0.8338721122986186, 0.8556548400289516, 0.859434962962357, 0.8514043239553216, 0.8777392199989715, 0.8682869993714042, 0.8683023909503294, 0.8817336247351782, 0.8505673922039917, 0.23169436867310123, 0.1914501652100441, 0.23851968841367732, 0.1693209021315415, 0.2949386685365806, 0.2163236610859255, 0.3495618938345634, 0.23929648837426143, 0.2394748962884119, 0.19536918698101458, 0.31337282361315355, 0.21007131760526132, 0.22910596537823835, 0.19240981740316754, 0.22881576628630385, 0.2391339999689176, 0.17427972894265253, 0.1895307061049768, 0.22615284137479708, 0.2843366429789774, 0.08200619936744646, 0.15195055292023185, 0.2640450239703115, 0.2745601289003481, 0.1890347157091269, 0.3079066455357643, 0.10187226663211846, 0.3716430080098453, 0.376323843254747, 0.40876810431623645, 0.41123884436668146, 0.34693928908651794, 0.39241978113605147, 0.3177364731475, 0.30205761192840264, 0.35235516200219674, 0.16623383909969403, 0.09663262113568416, 0.2352702126586561, 0.13923933881771222, 0.18113819533973996, 0.21564944676527642, 0.21129509333246688, 0.22252105069094053, 0.15082252738219704, 0.21708279932037244, 0.25438320860903363, 0.3070388059994631, 0.2609117785174173, 0.27563205326282947, 0.28943630148875243, 0.2517623633889743, 0.21578200467567288, 0.2393272332355313, 0.6565365224391622, 0.6245649602012457, 0.6030472416537456, 0.5444980256372647, 0.6412487687214092, 0.571710253718536, 0.6515906058173623, 0.6880151531531506, 0.5701319783581128, 0.11066947559006834, 0.11612357878911139, 0.0959330131318098, 0.11038694578516062, 0.10614686367861481, 0.11563889188219112, 0.13720772469916342, 0.11151704651566174, 0.10511858358961057, 0.24542487299958238, 0.1790545212956588, 0.20137835045109187, 0.14799730096540864, 0.18151402598601019, 0.21555192442718918, 0.1701885041992548, 0.19505516063378459, 0.1956623722078339, 0.3831223738274584, 0.4145514478206809, 0.35890668591088437, 0.4350548316129502, 0.39972478468796224, 0.37618031520418294, 0.4358783495704345, 0.45276750103628793, 0.4269381487620383, 0.283073217673928, 0.29988523850080184, 0.3204060087239994, 0.32233579626143105, 0.2639318428932438, 0.28783734246620707, 0.3139885204391649, 0.34322677294372106, 0.3475652341316632, 0.21738222170457333, 0.2046856263630864, 0.20088196106957645, 0.20139944419591504, 0.20693139042149378, 0.18010952338852781, 0.22784807941691576, 0.1998131134603376, 0.17729365354040982, 0.22547027239996142, 0.2473642590689531, 0.2626070821262013, 0.22710433560204923, 0.22245738016149075, 0.2062279585038167, 0.20708889464265856, 0.22447957498795845, 0.2107452322530129, 0.7195822910279421, 0.2016264348379203, 0.18170171594845042, 0.6827489515963268, 0.7743028871836974, 0.8685535708796168, 0.21279140920654716, 0.18576268064328882, 0.32197631948270733, 0.21565927255799155, 0.7060004845884025, 0.7507572600402441, 0.5733376159673935, 0.2959917794596866, 0.3422339219688464, 0.1997484595079435, 0.2094459134551152, 0.21234926735969728, 0.18709718408320708, 0.18831307381482842, 0.2099478356167993, 0.18891038549215766, 0.2008867401526988, 0.19496142247462211, 0.18238053806073118, 0.1850774578794394, 0.17970306389135127, 0.08067040540739412, 0.09449812917074507, 0.08396728819760535, 0.07896263041492346, 0.07972544173047869, 0.08229909131489077, 0.09609451131477675, 0.07910687269941086, 0.08850606817696482]}, "mutation_prompt": null}
{"id": "5fbf2bce-3a84-4ac3-b2b3-8f188df61982", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))  # More flexible mutation\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())  # Increased variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Enhanced Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 115 == 0:  # Adjusted frequency for tuning exploration\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces dynamic mutation adaptation and enhanced crossover variability to accelerate convergence in Differential Evolution.", "configspace": "", "generation": 9, "fitness": 0.38363367111795954, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "2fb26e32-a143-47a8-ae68-e79fc8d1ce7f", "metadata": {"aucs": [0.8989661374613823, 0.895549956270113, 0.9080424939138703, 0.9198986150764232, 0.903646826349867, 0.9102730010335274, 0.8997096079053006, 0.9039199815797635, 0.9079263912889807, 0.8227436981988328, 0.7605689567935918, 0.6110453302339021, 0.8105679666537893, 0.8092238452831163, 0.8123330073791963, 0.7919254411039398, 0.744801528900807, 0.7629800451407526, 0.1364089157482946, 0.1371662120436251, 0.13908286644708756, 0.17136765861565506, 0.1268093180764086, 0.13561858186225983, 0.14942643101696207, 0.11325229221448918, 0.13765724327669426, 0.11083988542954981, 0.1457126468879918, 0.12042084562788291, 0.1289799341716794, 0.12035693720097629, 0.12348527523989017, 0.1297757313661183, 0.140197405919252, 0.11406575673722286, 0.9367160278851691, 0.964810213213055, 0.9506066728601366, 0.9825968192280919, 0.9394354611217858, 0.9326394949994363, 0.9708631912252748, 0.9641714147897147, 0.9584189085899315, 0.3515951435020438, 0.3842660745466314, 0.38287340949304227, 0.4211581993626128, 0.3986015554587998, 0.3693772595838808, 0.3981335176915639, 0.3736917764123332, 0.2526565234989029, 0.8469106560202747, 0.8650461067005379, 0.8884725525592694, 0.8894700588941038, 0.8814287134170208, 0.7228794902019153, 0.9025479718615264, 0.8863577652357537, 0.8530483193144152, 0.34076956544424086, 0.23353043357253334, 0.16851372627858086, 0.231775754499983, 0.3426103205233696, 0.2980440442626864, 0.214261532674082, 0.21628899363960707, 0.23989713711808192, 0.4977459784896614, 0.1685337548765521, 0.16749943286942726, 0.17995042077974444, 0.22244986898612729, 0.2957338659084038, 0.3154986107864316, 0.19944677947897582, 0.19775857069152236, 0.07956469108763797, 0.040630853717709026, 0.13092086034227157, 0.24495873877447694, 0.15122231736681602, 0.3016075862212011, 0.04884590334778127, 0.22584706711506197, 0.12178271599072199, 0.267207270336298, 0.2802589061452212, 0.2734591464217233, 0.5054524524757552, 0.4294768345150919, 0.1536748522156569, 0.5226737750103294, 0.4438448840643331, 0.4213014990315872, 0.11135109671677434, 0.11802387364916722, 0.19200485565983916, 0.16598801917332062, 0.1848019640381865, 0.1890069316991404, 0.18742015755645025, 0.195354062067305, 0.22703954978132523, 0.2989951595208187, 0.3272703281126066, 0.2526236275107373, 0.3250031496192062, 0.2852777760644092, 0.30282218529004434, 0.28846781015597434, 0.26744925627963356, 0.27474758853458026, 0.7412410275578043, 0.6204776858020001, 0.7251137301848964, 0.7922925627612435, 0.7344183574732098, 0.6858291462426618, 0.7352340195709556, 0.6765605500669778, 0.5930228244301761, 0.1086020576267841, 0.09683066419661568, 0.1172895147795402, 0.10023318348446542, 0.12313496758701492, 0.10937223083110892, 0.11838330466499536, 0.09624560416893602, 0.10339853505192276, 0.30571174981399085, 0.15247109634497336, 0.17106458166557514, 0.2426536203862334, 0.17418459752831827, 0.17797173452674653, 0.17687984735522821, 0.2540947350328654, 0.1774900446072144, 0.44090676103116355, 0.408495279620953, 0.3967718482945315, 0.43401379586942845, 0.3833322656860976, 0.40835499876775416, 0.40256472393110176, 0.43063560118726274, 0.42986610950691406, 0.31871898668226273, 0.2832452049440283, 0.32351890287278295, 0.2880587812863997, 0.34363186578861926, 0.29181374912104385, 0.3412824100364257, 0.3249327788619538, 0.32978754885861084, 0.197463821836676, 0.19002873678349874, 0.20367442608813935, 0.2130766045727439, 0.2222071836481947, 0.19427572358682643, 0.24024923705478407, 0.2170903125268805, 0.21101379846614177, 0.23127922729078265, 0.22610100012994894, 0.20555336992657702, 0.48191258613778054, 0.21732482027210254, 0.32162048079898176, 0.5084876399405669, 0.23720222469648045, 0.3970776151115025, 0.9246660251688618, 0.18714367520179453, 0.2885675969536724, 0.8793409352358517, 0.7106329461440818, 0.19701403490353642, 0.7425324868092158, 0.8683190167572408, 0.8811849074971607, 0.537371848701854, 0.86884864089108, 0.8909086431182272, 0.31986524337529076, 0.2836841189751519, 0.2651673643312351, 0.18823362251327613, 0.34088585409091465, 0.21536566773562493, 0.18055533097041265, 0.17570850576241992, 0.18525303475742627, 0.19506478416861028, 0.18653204117759414, 0.1862456699487277, 0.17613372641713831, 0.18074429331334463, 0.17417050489661745, 0.07384368551095266, 0.07666919419104812, 0.10249838602284267, 0.08614629068084978, 0.08577568182030793, 0.08101091900049939, 0.07850494605936997, 0.07834342412983675, 0.07596091668316873]}, "mutation_prompt": null}
{"id": "62621c10-f101-48cb-a6f8-b63b3aaa600d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Adjusted initial population size\n        self.CR = 0.7  # Modified Crossover probability\n        self.F = 0.9  # Modified Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid Mutation with adaptive scaling\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                scale_factor = 0.6 + (0.4 * (1 - self.evaluations / self.budget))  # Adaptive scaling based on progress\n                mutant = np.clip(a + scale_factor * (b - c), self.lb, self.ub)\n\n                # Dynamic Crossover with exploration-exploitation balance\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Adaptive population size and diversity strategy\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                selected_indices = np.random.choice(range(self.pop_size), self.pop_size, replace=False)\n                self.population = self.population[selected_indices]\n                self.population_fitness = self.population_fitness[selected_indices]\n\n            # Restart and diversity enhancement\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  \n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporates adaptive population dynamics and alternate hybridization strategies to enhance global exploration and convergence speed.", "configspace": "", "generation": 10, "fitness": 0.21230674307638656, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "5fbf2bce-3a84-4ac3-b2b3-8f188df61982", "metadata": {"aucs": [0.5443471480117559, 0.5365698109880779, 0.5438277979501296, 0.6471541927532967, 0.5967587510139458, 0.616085569276031, 0.6052427713098125, 0.5846844455657734, 0.5994474290093721, 0.31563486843945154, 0.3180201584702862, 0.3152592795702246, 0.3126988213445311, 0.2900292763879775, 0.32551388235077483, 0.3098071866097568, 0.28773631269074595, 0.30874303691300775, 0.1273824852974269, 0.10285599455453942, 0.1233574881329923, 0.11869708671131307, 0.11899401551260835, 0.12721650156892517, 0.15613357686628515, 0.12490980042841604, 0.13528468119631398, 0.0996123368316223, 0.09222946324523729, 0.09496911573940159, 0.10285399351234936, 0.11611769231081548, 0.10656540681258064, 0.0916422865596942, 0.10083722612178647, 0.11196251187512318, 0.9711138581785483, 0.9834476373931357, 0.9747823532491029, 0.9720873196112172, 0.9709641387369288, 0.968885647520827, 0.9750720969734623, 0.9773702846305989, 0.978047669088875, 0.20592611628175883, 0.18215767798147764, 0.205234704860628, 0.20824888078841108, 0.20630037806693025, 0.20989011169866356, 0.21677805753492763, 0.20236397224179803, 0.2224382134865016, 0.22970028502794548, 0.21418142383247551, 0.19237432690495826, 0.27150860524915643, 0.23463749943882872, 0.22031218830904054, 0.25041903585739, 0.24298305844077217, 0.24330365714454028, 0.1379476117699462, 0.13404100497187732, 0.1120562311004929, 0.16736763171139502, 0.12471895380790865, 0.1417576514587141, 0.14404712052916624, 0.13187535774812764, 0.14184069512396946, 0.11037112814628525, 0.09364910823644146, 0.11002832643435889, 0.12368089210051714, 0.1350227257981822, 0.11988301381789679, 0.10234454944156679, 0.08866406349958811, 0.10790439563254406, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01427590793749256, 9.999999999998899e-05, 0.032073976563893436, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08063032637705003, 0.08685170018455846, 0.07971101944573566, 0.0744084930724297, 0.09856922050674843, 0.061741618452277214, 0.08671021330639017, 0.07646284755785326, 0.07963200644196644, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09784533516530969, 0.07234524089503247, 0.08925028137021052, 0.07488541470857835, 0.07945963706142933, 0.08442692910716121, 0.07782325564208181, 0.07546097841906463, 0.08161880159816426, 0.4147359270864812, 0.4359654807048441, 0.41608975844435336, 0.4410634310254663, 0.4192404020540289, 0.43882403687841576, 0.42122714032299513, 0.43342938434505074, 0.402866730699483, 0.07748954174850387, 0.0844804731715807, 0.09146688144107318, 0.07927655494196406, 0.0867697808991259, 0.0834605345711611, 0.08345000699585203, 0.07324450486253575, 0.09019197616799579, 0.21465277671526062, 0.18025359198043223, 0.13844505675743457, 0.32875961248368857, 0.14718738466621928, 0.16330406761183136, 0.18349629373837484, 0.15023873218634165, 0.1468754721172807, 0.23075108255362864, 0.2203237697708097, 0.24198866451238155, 0.22709886124505585, 0.22250334167264185, 0.22549825511046695, 0.273001113536505, 0.24833738681942308, 0.2472944244648927, 0.16453980833973292, 0.1886426937542095, 0.16021413646370752, 0.15600633455079083, 0.1493797730604488, 0.15430078532851788, 0.1836854945260673, 0.1786316379052445, 0.19753536722065257, 0.17741361618199136, 0.17334724164606263, 0.1869509869296676, 0.18837041607299332, 0.1765707766259602, 0.1821146315164689, 0.18200653792987265, 0.1805069262129526, 0.18592366216699907, 0.17818561997583415, 0.19172122959116256, 0.1800102004588121, 0.16919202862134985, 0.18399899562945388, 0.1764281420379803, 0.17269313916778406, 0.18354107220270532, 0.18477241420232704, 0.1897168517628851, 0.2407042972521709, 0.17498467651183036, 0.1584321227683788, 0.16386418943192071, 0.30660615425293725, 0.1978353130324757, 0.1516384829693792, 0.16385090874369468, 0.3561205862576746, 0.1825209681212191, 0.1948473660835368, 0.1604635186814548, 0.1637045520824244, 0.16395486933475312, 0.2031244991680028, 0.36845847937400555, 0.2696517030788792, 0.20402328864542152, 0.1765271009138929, 0.19548561466787207, 0.16912380058467646, 0.19513228621253442, 0.1764324696277254, 0.1804966254909337, 0.18238643140754462, 0.201758493066447, 0.06788494466130235, 0.0647383966556272, 0.07491542003363283, 0.085232871807982, 0.06712197284284394, 0.07130556345968198, 0.06836926681804412, 0.07036286594660923, 0.07381818452208189]}, "mutation_prompt": null}
{"id": "0c9ccf42-0f60-4106-943e-4b73f2f7f236", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Enhanced Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand() * (self.evaluations / self.budget))\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Adaptive adjustments\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9 + 0.1 * (self.population_fitness < np.mean(self.population_fitness)).sum()))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Enhanced Restart mechanism\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n            if gen_counter % 115 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx] \n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive population scaling and dynamic crossover enhancement strategies for improved convergence in Differential Evolution.", "configspace": "", "generation": 11, "fitness": 0.3582350693484067, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "5fbf2bce-3a84-4ac3-b2b3-8f188df61982", "metadata": {"aucs": [0.9064776407451667, 0.9048554140117538, 0.8935011139702689, 0.9072766354466947, 0.8974904100135452, 0.9100103384687293, 0.8974869145479811, 0.908049746351083, 0.900910053859197, 0.7875279528028243, 0.7515124522030607, 0.7698214139913383, 0.7597438481590519, 0.7928377570925921, 0.7529108472658814, 0.792500234919125, 0.7528294820107172, 0.7616365839742989, 0.1580286405502891, 0.15785585958325632, 0.13143915093417124, 0.14518875718891344, 0.1389146220688755, 0.1380925502059599, 0.14143184533383957, 0.12342629314641795, 0.18442392532109309, 0.12787560307576384, 0.13972116939512857, 0.14419328038113743, 0.14798943968712686, 0.12857193384453236, 0.12745492319376994, 0.12317072196594525, 0.12654537528914278, 0.1270991486267503, 0.9599965275583474, 0.9527707356911563, 0.9618827200806409, 0.9814772440284075, 0.9700932584671872, 0.9775272372529046, 0.9837857667583392, 0.9667300531117862, 0.9517442233564368, 0.39087758558204255, 0.35971932355303293, 0.36964270466176286, 0.34368356119093435, 0.4111329959968786, 0.43260590168857926, 0.3218054496960441, 0.3818904414584421, 0.3054088607217369, 0.8319100239794393, 0.7061931309708325, 0.834307975711035, 0.7118002015640119, 0.7359411259296578, 0.8579400523358302, 0.8750737135463205, 0.7017166953766456, 0.8374406577659097, 0.32825259048574185, 0.2716829844189049, 0.21966134185202257, 0.18612048849496, 0.20695321220665308, 0.16035503104383042, 0.18515898640541206, 0.259162698741235, 0.22531005438705531, 0.3799018284476974, 0.20721490587444358, 0.18855979364309505, 0.20017152391920057, 0.18722022383417913, 0.24718789228221782, 0.15224268208489977, 0.16859250694390815, 0.1758097339216429, 0.21971273321444207, 0.12306292454436718, 0.1548712656241109, 0.13875384670837432, 0.1318887611252434, 0.2206518758298034, 0.28584707435176726, 0.0867879486862565, 0.15108685240254505, 0.32826136776464165, 0.27335983225484883, 0.32130251500556584, 0.2635209368403645, 0.30323758162742187, 0.20726817042527734, 0.23531699566400877, 0.37939414361792523, 0.38570128597691933, 0.12336947992630953, 0.13057172158290287, 0.10413705008060514, 0.15347040405525458, 0.11794982550808253, 0.10826531597789124, 0.14438783793796373, 0.13904582220722117, 0.1636944662216947, 0.2364903444728762, 0.21314410817307294, 0.27540929671668424, 0.23483949705949358, 0.2843847424067103, 0.27796916542958594, 0.2102791794771025, 0.27459593682275485, 0.22913945531285862, 0.6235901991601399, 0.6295205234852435, 0.5669971395970681, 0.6232330601441629, 0.5981509405278308, 0.5828700018255482, 0.5788358723427545, 0.5824726660911403, 0.6244169764991736, 0.09753159057850536, 0.10633255728828206, 0.09223254558269656, 0.11283727256098997, 0.10723976960606141, 0.10945187521500721, 0.11081820310228918, 0.10785989293465281, 0.10492606698678719, 0.15159422027408131, 0.3002194295540015, 0.17503669610110717, 0.14708638196985324, 0.16084749125550624, 0.13934804375862841, 0.23164870937327797, 0.16900697441287027, 0.31372060543165625, 0.4083097624230986, 0.3831572657903549, 0.4001142103441774, 0.35936352333880184, 0.3997242961951373, 0.38918074293665383, 0.4800565529875904, 0.4380258867083545, 0.41946599608336066, 0.31340197846886886, 0.29350399257462445, 0.29280195148334465, 0.2877902030327941, 0.2629403734502812, 0.2968590695693172, 0.27707587380897125, 0.3159149213313319, 0.30675616049384613, 0.19954058588391999, 0.19197100435655967, 0.24831938943445508, 0.18407630758855165, 0.18633984288184868, 0.2093077020683869, 0.19888907940449485, 0.19303477839094307, 0.209963514039735, 0.208579318557349, 0.2182061275194498, 0.19113041918740759, 0.19957565550643308, 0.22295928747876004, 0.20568228319521376, 0.2021527880486199, 0.23054550546705166, 0.3153475222698434, 0.8814339013924916, 0.6752492151628311, 0.7217909616394446, 0.2695042016761877, 0.6743578958024623, 0.34490312149953395, 0.7305954656592413, 0.6285210934742529, 0.6781004522333299, 0.3132910810568612, 0.43411352062249, 0.1892999582984577, 0.19983346868415153, 0.20400144477362392, 0.4164645744607929, 0.3024708016202967, 0.5839732504078052, 0.19286183708028237, 0.18465377168374486, 0.1735410574994759, 0.18903894000186305, 0.19103052438901336, 0.18077390903077306, 0.191089093810052, 0.18475154204924993, 0.1721935112773033, 0.18419102650126085, 0.09542927693345404, 0.08523643323505681, 0.0913246233273387, 0.08434756612093786, 0.0739740611990164, 0.07684023009920127, 0.08292035425563515, 0.07820964455130275, 0.07594510210757577]}, "mutation_prompt": null}
{"id": "e9b7cb77-d4a2-411d-92e6-b4c55360f610", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.5\n        self.F = 0.8\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        learning_rate = 0.1\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            if self.evaluations + self.pop_size >= self.budget:\n                break\n\n            if gen_counter % 100 == 0:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n\n            if gen_counter % 50 == 0 and np.random.rand() < 0.3:\n                for i in range(self.pop_size):\n                    noise = np.random.normal(0, learning_rate, self.dim)\n                    new_solution = np.clip(self.population[i] + noise, self.lb, self.ub)\n                    new_fitness = func(new_solution)\n                    self.evaluations += 1\n                    if new_fitness < self.population_fitness[i]:\n                        self.population[i] = new_solution\n                        self.population_fitness[i] = new_fitness\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Integrates adaptive learning rates with stochastic local search strategies to enhance convergence and solution quality in Differential Evolution.", "configspace": "", "generation": 12, "fitness": 0.3669504456372706, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "5fbf2bce-3a84-4ac3-b2b3-8f188df61982", "metadata": {"aucs": [0.8942300447994049, 0.8982754928213511, 0.8865544566146304, 0.9033751040422469, 0.8802284397549769, 0.8947775139276772, 0.9071728765883991, 0.9057892706630954, 0.8903907187151422, 0.7707878302468982, 0.7181718048269878, 0.7094641728767652, 0.7188090560432339, 0.7108137584000962, 0.749187349023914, 0.655750781874324, 0.6813696706146449, 0.7382676403828297, 0.13861177519678203, 0.14093715668734008, 0.12850904308613553, 0.14619817700429083, 0.12351305869835283, 0.11297241980441286, 0.13838496969618042, 0.13785958337880289, 0.11346556436593669, 0.11690724224093574, 0.14749833109424693, 0.09908930180610154, 0.12369052430355154, 0.11814461639080054, 0.10880105922334793, 0.11214355923929287, 0.10658155179921747, 0.11377227389859257, 0.954552623439026, 0.964810213213055, 0.9776045272053281, 0.9341007461310307, 0.9497116634433331, 0.9461125923588669, 0.9323770487081933, 0.9589578106638628, 0.949229742949073, 0.36477580697223744, 0.306688618196686, 0.3621442971614215, 0.33040231897159233, 0.3864551010859172, 0.4361685714202427, 0.2327595094029451, 0.3737044654493351, 0.45461852386775636, 0.8856790339906193, 0.8555949331947698, 0.8781955779253237, 0.8997401657779693, 0.8814287134170208, 0.8687844672451284, 0.9098914180521872, 0.8700897523514514, 0.7576379942302532, 0.37093059096785896, 0.21584536918061492, 0.24113109017152057, 0.1905302300298256, 0.2002468471411758, 0.20072895769622423, 0.25436752374217264, 0.2516961679812756, 0.2069539907064809, 0.19401537332010976, 0.1995599614687219, 0.18511115728290584, 0.23301561118107095, 0.18195643318274302, 0.3114546949386672, 0.3234759821511499, 0.20375878447870666, 0.16222740798125412, 0.23239903013736074, 0.29491999025537197, 0.2793227643371594, 0.27865798477787207, 0.17725406801676946, 0.15274562362540345, 0.3050716711217659, 0.12306858173660473, 0.28880109415652966, 0.30991876926588524, 0.2984560613189412, 0.25790808186270164, 0.4407553950474332, 0.14831395236047684, 0.4247200471897724, 0.253810716758205, 0.3066918775009141, 0.3740024292851487, 0.19547370415368293, 0.1480445847181483, 0.15973113860982158, 0.1874078934334069, 0.174546119296755, 0.11903473436168532, 0.2596167678633633, 0.1300090363537023, 0.1463295231873335, 0.22897892527227792, 0.24347266634768694, 0.27349555068888953, 0.26390595646053716, 0.28480986347908177, 0.2912776413987268, 0.24685324202627612, 0.2774240328281652, 0.24950498890345785, 0.6260778965778373, 0.6670198604773568, 0.7094029521405917, 0.6744773320685593, 0.6749612703572594, 0.6554595536448063, 0.6794965664157826, 0.6447327069118456, 0.6865196237845695, 0.10050404338156438, 0.09610555701278611, 0.10734983662049757, 0.10561899654804363, 0.10160540171461585, 0.12371092817582574, 0.10400425741725772, 0.09571872621706845, 0.11093957497734774, 0.16099102331019988, 0.15046867051866375, 0.19358898755215903, 0.13044354218998266, 0.1915216596485677, 0.16763329292614348, 0.1340698998710923, 0.17385455788235782, 0.15968734963376485, 0.40012967430930335, 0.38964508437692646, 0.40554290586801667, 0.3565938149117177, 0.3872329853292916, 0.4160947478032685, 0.43409379968898565, 0.39370878016213806, 0.3892830749078292, 0.3201497178208502, 0.2789305349720347, 0.3069065587868528, 0.2641521151967602, 0.28670089542183563, 0.27596789725506965, 0.3090359990975322, 0.3225531183147642, 0.32075086108512985, 0.19532486191105813, 0.1996160371652259, 0.19444098225074136, 0.2044912591610435, 0.21012058257296695, 0.18862011372533594, 0.19561964643220375, 0.22158208516134514, 0.19652654445204343, 0.21322581098997828, 0.21336656987525304, 0.20132949605670813, 0.26393974015307364, 0.19318175810577365, 0.24817688533301185, 0.20076404762546307, 0.23054593481658725, 0.19302970661305463, 0.9051247772150605, 0.3421412465450363, 0.8787521971211055, 0.6823363501960614, 0.27041022802943127, 0.2942015049620489, 0.89815150607368, 0.8069659389074497, 0.7336085674429751, 0.20413661781444348, 0.8747851382123959, 0.7441423440843626, 0.2132515726257418, 0.18659567131299093, 0.28413845748480704, 0.21593756192284463, 0.3325400171577301, 0.20711333819925737, 0.21224152144426678, 0.18720307457308405, 0.19361792576141523, 0.17671429738842526, 0.1828954626686471, 0.17864060285850536, 0.18462703318165063, 0.18579063499942583, 0.18538908952353472, 0.07586041492123263, 0.08154910566748108, 0.07983595239033492, 0.09235684982745807, 0.08242374165389699, 0.08028945680492738, 0.08323131442287268, 0.08132170342252854, 0.07918323645225278]}, "mutation_prompt": null}
{"id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0  # Counter for restarts\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))  # More flexible mutation\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())  # Increased variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Controlled random restart mechanism\n            if gen_counter % 115 == 0 and restart_counter < 3:  # Adjusted restart limit\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1  # Increment restart counter\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces a controlled random restart mechanism to maintain diversity and avoid premature convergence in Adaptive Differential Evolution.", "configspace": "", "generation": 13, "fitness": 0.3866143419780379, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "5fbf2bce-3a84-4ac3-b2b3-8f188df61982", "metadata": {"aucs": [0.8989661374613823, 0.895549956270113, 0.9080424939138703, 0.9198986150764232, 0.903646826349867, 0.9102730010335274, 0.8997096079053006, 0.9039199815797635, 0.9079263912889807, 0.8227436981988328, 0.7575001334933922, 0.6110736500669453, 0.8105690193873165, 0.8092238452831163, 0.8054407697778515, 0.7919254411039398, 0.7448088265526185, 0.7629800451407526, 0.16796942260631753, 0.13652113723397874, 0.15272476815359626, 0.171448648583849, 0.14924113697404995, 0.14197785680120856, 0.18930534370915608, 0.13665626635912453, 0.13722910535080735, 0.11092757756153426, 0.1379539570737044, 0.12050648970288547, 0.15882411056334422, 0.12542634645582562, 0.12209737175658997, 0.1298614842578556, 0.1393300885223825, 0.11415258616894008, 0.9367160278851691, 0.964810213213055, 0.9506066728601366, 0.9825968192280919, 0.9394354611217858, 0.9326394949994363, 0.9708631912252748, 0.9641714147897147, 0.9584189085899315, 0.3516546298108355, 0.3843225217307772, 0.3829300245986579, 0.42120966493198675, 0.39865528896129465, 0.36943557506195135, 0.39818838465628126, 0.37374923096219503, 0.2527288152912933, 0.8469106560202747, 0.8650461067005379, 0.8884725525592694, 0.8894700588941038, 0.8814287134170208, 0.7228794902019153, 0.9025479718615264, 0.8863577652357537, 0.8530483193144152, 0.340825852640382, 0.23360393143051594, 0.16859557223894794, 0.2318913779158217, 0.3426638014080794, 0.29811082104585307, 0.2143382385099083, 0.2163651853809062, 0.23740767742640723, 0.4977885451699775, 0.16861512421968783, 0.1675814723457575, 0.18008946993076802, 0.1890220444515348, 0.29580076198712546, 0.3157345241355385, 0.1995235102939712, 0.1978363167808641, 0.07975503288660324, 0.040725937470871054, 0.12239207020122012, 0.24502965359954876, 0.15129970228141942, 0.30166245681742443, 0.04893964615918445, 0.2269604827382269, 0.12223266845029046, 0.26727780649382094, 0.28032795076263695, 0.2740270645671391, 0.5054944522789915, 0.42951383547633304, 0.1536621321056587, 0.5227132967913142, 0.44389450195914637, 0.4213533595356639, 0.11185425712647412, 0.11829758303568272, 0.1920745548784769, 0.16606715585956533, 0.2017811129844823, 0.18907748529004575, 0.24032232940084008, 0.19550082170395222, 0.2271044368983598, 0.2990591391229849, 0.3477544649625587, 0.25269440354646133, 0.3250661115356268, 0.2853451319764204, 0.30288308894178917, 0.2885318163617171, 0.2675172278055805, 0.28140742630506743, 0.7412595882183325, 0.6205107684125244, 0.7251324259473122, 0.7923052741320004, 0.7344328890920881, 0.6858550825695817, 0.74363051176914, 0.6765849645528513, 0.5930583388129986, 0.10675791919557287, 0.09769635615140593, 0.117375574456964, 0.10929392888113687, 0.12606615957370526, 0.10750889799481322, 0.11465312761422775, 0.1063275431444628, 0.11446057485514338, 0.30577698502488604, 0.15066442146292214, 0.16770137146986164, 0.2020450396401624, 0.18029339333003258, 0.1787461015377355, 0.15941174034926975, 0.25416567253552247, 0.1858189895704525, 0.4893081513833989, 0.4439340058376626, 0.44458010651314617, 0.43406588680572844, 0.4718696627369442, 0.447121240512663, 0.4462009175696541, 0.5188316766155776, 0.47397329361347906, 0.3057719775856166, 0.29444840513801496, 0.3579117565082387, 0.31139982426198165, 0.39760657992767645, 0.28564781343801704, 0.38680567408490263, 0.3471238214482719, 0.37394870588782647, 0.197541164006941, 0.18142594573175697, 0.2038614510206922, 0.21348392938582783, 0.22228189832516032, 0.18769672252540492, 0.24032365070996753, 0.21716815301764802, 0.211091611803518, 0.20443519181890224, 0.22536690118407876, 0.20336665965887113, 0.4999879684609232, 0.2166127758999863, 0.32168446241446413, 0.5085149576733581, 0.23727597347676666, 0.4610076819963367, 0.9246660251688618, 0.1872246277866183, 0.28863212632691815, 0.8793409352358517, 0.7106329461440818, 0.19709243954848954, 0.7425324868092158, 0.8683190167572408, 0.8811849074971607, 0.537399787473888, 0.86884864089108, 0.8909086431182272, 0.3199256257794404, 0.2837488590904337, 0.2104412289984502, 0.18770653901185563, 0.14898954087732785, 0.2154423274352133, 0.180636110978597, 0.16964224829603625, 0.1853337582756026, 0.19515701664685137, 0.1866123759792485, 0.1843498621016364, 0.17621590097712847, 0.18554176135178846, 0.17425262643196948, 0.07446386212821943, 0.07895112884446809, 0.10697668694503648, 0.08624589024958473, 0.08685911700759585, 0.08026963431445477, 0.07859584707241452, 0.07843495633691622, 0.0748712026283207]}, "mutation_prompt": null}
{"id": "235b4ce3-18f4-4996-801e-0b03836c95d3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.5\n        self.F = 0.8\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Dynamic adjustment of CR and F\n            self.CR = 0.5 + 0.3 * np.random.rand()\n            self.F = 0.4 + 0.4 * np.random.rand()  # Adjusted range\n\n            # Dynamic population resizing and elite retention\n            if self.evaluations % (self.budget // 15) == 0:\n                elite_size = max(2, int(self.pop_size * 0.1))\n                best_indices = np.argsort(self.population_fitness)[:elite_size]\n                elite_individuals = self.population[best_indices]\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[:elite_size] = elite_individuals\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                for j in range(elite_size):\n                    self.population_fitness[j] = func(self.population[j])\n                    self.evaluations += 1\n\n            # Controlled random restart mechanism\n            if gen_counter % 110 == 0 and restart_counter < 3:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhances Adaptive Differential Evolution by incorporating a dynamic population resizing and elite retention mechanism for faster convergence.", "configspace": "", "generation": 14, "fitness": 0.35356576599714384, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.9041268755397729, 0.9017928688945346, 0.9089017547604518, 0.9205856500962674, 0.9055974748225939, 0.9160467352363899, 0.9060337235000774, 0.8994093388711457, 0.9124510285768312, 0.8052928924668379, 0.7625040495446558, 0.7616568920217002, 0.8143754909024078, 0.7555904354266227, 0.7952346658360905, 0.8349847219719058, 0.7838064832352322, 0.8129011222619846, 0.35101324802606837, 0.34056876472831865, 0.1845318513985893, 0.16333526650718466, 0.20323112791765596, 0.3301370947969644, 0.162254020592574, 0.1381702329007849, 0.15507922255969242, 0.14430432758507572, 0.1423662257496099, 0.13451693415387567, 0.16347757725390732, 0.12729552737283045, 0.13978502189040265, 0.132983795987618, 0.12849855615468586, 0.13430859778653326, 0.9700827678271573, 0.9623947372746873, 0.9549879545683532, 0.959008155284536, 0.9862411838575517, 0.9795921408135596, 0.976576727778883, 0.9743862037609141, 0.9500676305846872, 0.3804968942249103, 0.48121919377875977, 0.37752970476319714, 0.3040331056281237, 0.39548124801991924, 0.3558608876241661, 0.3663017455176396, 0.30345778374715815, 0.31870724591073596, 0.8671309208377581, 0.7478627477811312, 0.37533318631356183, 0.8501391352490566, 0.708827050195991, 0.6936356285666385, 0.8679188043968304, 0.8747856604385558, 0.8772346497008999, 0.21197430061869327, 0.1777081302529967, 0.1870029219428, 0.18526931574632133, 0.21512956075394174, 0.2273449504617302, 0.21913641283983742, 0.22540518634421136, 0.20721314607364683, 0.13831845087463102, 0.19745337982564504, 0.2099124385668969, 0.2452271235788891, 0.2865883684836662, 0.1842502565241212, 0.18091237145079753, 0.260647069418771, 0.19630703431403485, 0.16539708308470324, 0.17136704068855246, 0.23951960329178656, 0.10781269002140559, 0.028772043553268456, 0.034742208897157956, 0.14314222850064195, 0.08443750170277509, 0.20783819617201071, 0.22270730382319404, 0.13560275550356382, 0.20105349988593912, 0.1374912792383426, 0.24980398475200483, 0.1150508075834572, 0.26395041037815825, 0.2755895950586269, 0.2599501424995233, 0.15309216424765382, 0.14845386707527963, 0.06800020643557492, 0.16770238661064563, 0.1115073459477327, 0.1367555202376961, 0.05624016658117148, 0.06309255005341696, 0.17839795592733865, 0.18212664872786755, 0.23580183102035412, 0.2475560307106106, 0.19538374984965312, 0.2502706207459041, 0.21603683655934258, 0.179605185130025, 0.21988720596911504, 0.2320912091923053, 0.6169448563756625, 0.6043749207843149, 0.6362612330342747, 0.5634246601869838, 0.6114749581124737, 0.5445209426944864, 0.6761246223216071, 0.6140719208075205, 0.602544575189234, 0.12294516505812358, 0.12537436681980707, 0.10718841869554108, 0.11498455745614522, 0.11145691031781901, 0.11344034737146558, 0.09448235695302754, 0.10865841568102153, 0.11393528379581008, 0.18834007898013316, 0.20958925685685814, 0.17109598139535043, 0.16372005942210943, 0.13638901837149064, 0.16127541698156167, 0.15567542165744874, 0.1803162407729425, 0.1847725008810609, 0.42379791964211766, 0.3746707306307049, 0.3713102482843248, 0.4405851770395063, 0.46413501995144335, 0.45070070556047825, 0.5464987490358644, 0.39509429165298615, 0.45728178532737074, 0.31198521150170067, 0.29248815672507067, 0.3265893715372238, 0.366350349010266, 0.2982044215336207, 0.3351871172519112, 0.32046979047029656, 0.31579705180730966, 0.3048356675600905, 0.216609575001676, 0.18733642862073485, 0.20591073119017145, 0.1968070089730426, 0.19725192954144533, 0.1868611693165636, 0.19134997070520043, 0.21243635312572928, 0.19031700594792333, 0.3412190507594678, 0.24219825871487133, 0.36319637726829346, 0.4173469542833659, 0.23785357680632757, 0.2262529641584099, 0.5357345024242806, 0.2125698310529519, 0.22840938213569406, 0.8589324517798558, 0.17749424985188111, 0.2164176915875422, 0.8747605476326399, 0.19653428338288825, 0.5599273447466646, 0.17854999646507352, 0.5544857873077198, 0.5760820508112695, 0.2796370264186101, 0.300171487118458, 0.4400815031672992, 0.25569093415114397, 0.20890902383309273, 0.45713067909296523, 0.23319218523588325, 0.21257131865302303, 0.6365353237184825, 0.20343873549024794, 0.18299502106186705, 0.193091757719562, 0.1957598957395693, 0.17256535066110223, 0.18820824837014194, 0.18234138036698355, 0.17856882194654322, 0.205710640247033, 0.08391862531787753, 0.07626158999718569, 0.08564167684675561, 0.08100189113157574, 0.08618817360190878, 0.09727533230259888, 0.07571929586971604, 0.08580324189558419, 0.08111360483795071]}, "mutation_prompt": null}
{"id": "2090eee8-c655-4358-84f7-260afd8078e9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.5\n        self.F = 0.8\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget))) * (0.9 + 0.1 * abs(np.sin(self.evaluations)))  # Sinusoidal adjustment\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            if gen_counter % 115 == 0 and restart_counter < 3:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhances mutation diversity by slightly varying the differential weight F based on a sinusoidal pattern to improve convergence speed.", "configspace": "", "generation": 15, "fitness": 0.3722225318210312, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.9054003401217379, 0.9104894891867409, 0.8927788111087855, 0.9195230715034652, 0.9129606025855832, 0.9126997706246714, 0.90191947240019, 0.9105518502676773, 0.9041911671082703, 0.7978862317767021, 0.8002970538496065, 0.6635087158468819, 0.808987149108928, 0.7831935987848851, 0.8245224995795606, 0.8350730760610967, 0.8222231639727786, 0.8072330300687889, 0.13156212497790654, 0.22766215907392895, 0.23952823991957883, 0.17472083576129738, 0.16728602507332213, 0.1403253450315648, 0.13952121003815388, 0.23889839104255473, 0.20995501362567726, 0.12567117842671105, 0.12617687881891593, 0.136338414534928, 0.13105261008265412, 0.18644753761247013, 0.1210053037809472, 0.16668125172923898, 0.1577266670344123, 0.11926985133387402, 0.940031488395701, 0.9522074229145641, 0.9717770626803566, 0.9430791597819613, 0.9556044152882424, 0.9584600507041682, 0.9604228268613395, 0.9655301809651421, 0.9368001923245697, 0.37115424651896833, 0.3558738859681595, 0.3092642148085908, 0.37613406300948304, 0.3177172749824929, 0.3483572893533077, 0.34089747418019056, 0.4590554426663408, 0.32252767563673235, 0.885589800601857, 0.8563944408202675, 0.8378997347114829, 0.8607665975966147, 0.8638177796196896, 0.9017296937619567, 0.8648395981965104, 0.8878621827587876, 0.8967530224558009, 0.21153747651554833, 0.1945863925746295, 0.27771150172499515, 0.3252281842096103, 0.15151353208331397, 0.19098342148806247, 0.23076845820534608, 0.25852368289897676, 0.191684247732413, 0.1676873176221565, 0.15970505404309443, 0.22517760051892632, 0.40255088657754556, 0.19072910063570114, 0.20865228625301058, 0.16999964127950973, 0.1926334222001035, 0.24664872325368392, 0.21847864819480167, 0.22973320247158902, 0.12800489274049542, 0.07252300017623092, 0.15521997944930377, 0.2173121281497793, 0.13944315874154123, 0.13770667412360416, 0.19935808081562412, 0.5519102459570379, 0.303990815820124, 0.32465644280226347, 0.30422540285114896, 0.3170641270247041, 0.11976438401497635, 0.24834455053892157, 0.49982364938270973, 0.4308986434046971, 0.1529710804226594, 0.26527667709839176, 0.17508812797404716, 0.12558705747333265, 0.24188380046400804, 0.11531515969412032, 0.17190678935767922, 0.11813119196706179, 0.2867845194440388, 0.31059610696402407, 0.3072998900250239, 0.26124550087647025, 0.3358290322184877, 0.2819576742031047, 0.2841214256346427, 0.20232451808318075, 0.2639548744587503, 0.26239678432523905, 0.6416075942046247, 0.7213369224224777, 0.681461237869494, 0.6666476486899318, 0.6645163537010743, 0.737002093098627, 0.5518916847059149, 0.6864928700206477, 0.6461525107379913, 0.09012568888206585, 0.10524401296203556, 0.09026286033967079, 0.10538960320508506, 0.10772518063790981, 0.10411376864573763, 0.09834297255463476, 0.10717335948254492, 0.1294667281465196, 0.17000254393501346, 0.20140902379482994, 0.2344980210815485, 0.22660194847048576, 0.1935632710361168, 0.18928453440272197, 0.19071872993071515, 0.1440159156625488, 0.19166318053007203, 0.48861395928263573, 0.42493163154296076, 0.4218259439013605, 0.48492464855619755, 0.4382172429310508, 0.4135607195894183, 0.506252716973299, 0.4136426680275952, 0.4899068015364212, 0.3734588515067542, 0.35161615973484195, 0.3089293207285775, 0.37689874021921865, 0.36194033240367285, 0.28010242495540694, 0.4288743736033107, 0.41010182965157493, 0.40172487729682094, 0.19600472914590605, 0.19398911217946269, 0.22155832719706903, 0.20595936863394992, 0.1874050796242307, 0.22291264515030984, 0.20266274999932765, 0.20370839453845535, 0.20223809413899974, 0.21774818050305156, 0.1990260011785514, 0.24427086361653705, 0.20114142269163982, 0.20857658045515914, 0.2568621384607783, 0.2042785938962628, 0.22083362711647547, 0.22880854150021168, 0.5192490966094037, 0.18605672160206344, 0.866748029101949, 0.23633404293995297, 0.6981567852467077, 0.1898276539271877, 0.7220074877120422, 0.7065043374937805, 0.16502003358940087, 0.6272936579916317, 0.24756231689514063, 0.891350413435945, 0.19822719914813425, 0.3329699004507738, 0.21002494599355792, 0.2858872686851741, 0.1487127360496142, 0.2111322475918298, 0.1793225871150349, 0.1787031605077447, 0.1871919701375775, 0.1771249651287471, 0.19136427341858997, 0.1897242592854511, 0.19269195889176383, 0.19423585908391694, 0.1802673370292679, 0.08337346593816897, 0.08471723919292506, 0.08299144663427582, 0.08415511214011118, 0.08629613767417665, 0.0813880081320616, 0.09202730465230247, 0.0862126917617756, 0.08373175395781385]}, "mutation_prompt": null}
{"id": "f8de3fa4-cef4-41a2-8cc6-46a9029ecca9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.4 + 0.6 * (1 - (self.evaluations / self.budget)))  # Slightly more flexible mutation\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())  # Tweaked variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            self.CR = 0.4 + 0.6 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            if gen_counter % 110 == 0 and restart_counter < 4:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Combines adaptive mutation and crossover strategies with a dynamic population resizing mechanism to enhance convergence speed in Differential Evolution.", "configspace": "", "generation": 16, "fitness": 0.3437695606512021, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.8911744435389076, 0.8880572950517898, 0.8751585177176446, 0.8978170118289817, 0.8926694930233541, 0.8911828267060414, 0.8868099304508593, 0.8735826334052897, 0.9031992383500649, 0.6952432063998553, 0.7262085104165312, 0.7115672825598043, 0.7642121231489913, 0.6904698479362928, 0.7348487350490001, 0.7711294959299809, 0.7400807054702474, 0.7169121813043199, 0.15504727172712196, 0.11984100323107882, 0.13171369000689936, 0.1499107255083162, 0.14094837666792448, 0.1586411533014236, 0.15046067564560273, 0.13626077619774535, 0.13247677944420788, 0.12405818621050224, 0.11851839442341339, 0.1478660398613576, 0.11759184853686744, 0.12172257347501358, 0.12119306089370896, 0.133536034775945, 0.1408028309507532, 0.13000353395048747, 0.9829212722954233, 0.9712695025195677, 0.9733609094826509, 0.9775322233856781, 0.9756828432462238, 0.9702311287387094, 0.9777890395276151, 0.9717544626463965, 0.9569826776353412, 0.33007507656188784, 0.4030847288858086, 0.3344196421928911, 0.4267610514717828, 0.33136594392731944, 0.3785536731972766, 0.350413942273341, 0.40455634481621905, 0.35910363568925363, 0.8301190410375234, 0.8335220236189135, 0.8394796778813791, 0.8502714218314069, 0.8474794688469739, 0.8426910822106946, 0.6102827621040412, 0.8290213453627623, 0.6102479219172205, 0.3074811335906047, 0.19942023816138066, 0.17191026148833266, 0.19971835616042555, 0.23370693469404447, 0.2358646723945329, 0.2134003282468736, 0.24499215334291535, 0.17223692734277007, 0.17519151271852296, 0.19358571391707258, 0.15345410319793695, 0.36082196006252343, 0.22670209595782764, 0.1833630472854888, 0.17319101678794635, 0.20175820867279126, 0.20164316722181197, 0.18660898761723088, 0.09381173778414431, 0.08435532783673494, 0.09022584412803358, 0.14202864979885654, 0.12639623064593708, 0.13923443164754734, 0.15013897660578535, 0.08258557939596844, 0.2133443802252739, 0.3006402462315735, 0.34445859941840606, 0.2876362821647921, 0.2547748327652576, 0.20990854200832954, 0.3562210862626395, 0.3492620968368493, 0.3400188513461535, 0.12282697914899943, 0.05663954001995719, 0.07379876618880532, 0.10363539930271404, 0.13881305435332014, 0.07977965814337384, 0.10077204009423546, 0.0822242505173717, 0.09143772087859836, 0.2261362574280782, 0.2144146193334413, 0.1832950002703535, 0.2359820946158837, 0.23877060321123966, 0.23418356304812493, 0.22745302208482931, 0.22161789458003023, 0.1880963218609082, 0.6090349497455081, 0.6589860464885645, 0.6362763256033195, 0.5895020655276442, 0.6218975905890337, 0.6056497321328298, 0.5518738055505756, 0.5896034293039933, 0.6315269701249617, 0.09838037406779043, 0.102632023546958, 0.11257643716714594, 0.1054399359349798, 0.09538098682815221, 0.11770993192977453, 0.09966108655736716, 0.09698086215661972, 0.0968346315591383, 0.23834668004240134, 0.1495112120315667, 0.16322343343528578, 0.17720970361541988, 0.18098873628500411, 0.26106988905815187, 0.15166257694831242, 0.16967293774639913, 0.1325278569398337, 0.3653918347365669, 0.3568191053790726, 0.39444476835802733, 0.34490905410205597, 0.36014726808720243, 0.3914619193330662, 0.3713829145458102, 0.40039543013091927, 0.40637490919067454, 0.28477618060666454, 0.30144452682835887, 0.2840691739561009, 0.2639099736020304, 0.22957228826604037, 0.27053244018751543, 0.3325307081028015, 0.277950773471039, 0.2963558422979541, 0.19748697471523624, 0.18157057946384336, 0.1880756688691284, 0.22276542531371157, 0.20057211173364942, 0.18871217332796364, 0.18197098499873865, 0.21746512038494392, 0.19004456855774043, 0.20265348936040462, 0.22408500537391585, 0.25164531758474085, 0.21897698179420388, 0.21269734643274385, 0.2092963658034639, 0.23943109133070373, 0.19841308411681624, 0.20591058087575165, 0.20577567923879692, 0.6674886302019019, 0.6912472438943693, 0.4600151633579731, 0.397352594494625, 0.7161447617481189, 0.39749786831099, 0.6731053654679664, 0.46576315560708725, 0.3901384440412444, 0.6707857522211695, 0.24397343678006078, 0.2638441475754957, 0.2013453373666001, 0.2084690920697322, 0.20364116910799535, 0.2308244269836076, 0.5218768984137114, 0.17602326027394377, 0.18095888094699253, 0.1828080348100115, 0.19103117598720964, 0.18506336375529164, 0.1984323841150969, 0.18024814633756847, 0.17431442061944324, 0.18169988828809192, 0.08157056468912993, 0.08885350682611715, 0.07908278886410136, 0.0720675447465765, 0.08648419674475949, 0.07658760494331496, 0.07587044706101642, 0.07128172209113948, 0.08429723509786269]}, "mutation_prompt": null}
{"id": "b86c34f2-6520-4b01-b942-8d54f9856c07", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.5\n        self.F = 0.8\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0\n\n        while self.evaluations < self.budget:\n            adaptive_inertia = 0.5 + 0.3 * np.sin(gen_counter * np.pi / 50)  # New inertia mechanism\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))\n                mutant = np.clip(a + dynamic_F * (b - c) * adaptive_inertia, self.lb, self.ub)  # Apply inertia\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            if gen_counter % 115 == 0 and restart_counter < 3:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive inertia weight mechanism in the mutation strategy to enhance convergence speed by dynamically balancing exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.2772090871752951, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.7735757003300614, 0.8749679492678862, 0.8843674796068208, 0.8694721611805993, 0.8118555846104806, 0.7384902894930413, 0.4897168532679689, 0.5656212083047617, 0.6765347880630617, 0.5058085442547787, 0.23387615928315342, 9.999999999998899e-05, 0.5303734163821756, 0.30086699816061047, 0.5717081846584705, 0.5101669994063285, 0.09816928447715201, 0.4564171243975206, 0.1693801559717948, 0.18154132202086015, 0.17679935472242414, 0.40144174070486693, 0.1295795863904654, 0.17713243590166272, 0.13240869853285764, 0.2682501798724042, 0.1877928508639891, 0.15086679734495123, 0.14509367386853878, 0.1794578404970515, 0.15910486472268515, 0.1467265106128678, 0.14666201470329632, 0.13855738109943871, 0.15105250114678326, 0.16216543914509052, 0.9403944805184655, 0.9377943556923036, 0.909963852468202, 0.9788261142891729, 0.7451521025655679, 0.4536319013720438, 0.9880139387598694, 0.9523294676783502, 0.6139937245355751, 0.18544610376501391, 0.10097834013248463, 0.1199447430083066, 0.15241922318056655, 0.1375577575079513, 0.10022410394866166, 0.21606950923609192, 0.23127549731370411, 0.22365000434929028, 0.2428396682882843, 0.3946859974832143, 0.3300481002365544, 0.3189630261448708, 0.3150960450237621, 0.9037886467104992, 0.2801214349260033, 0.9501702395160503, 0.39840063922690894, 0.12000168440822268, 0.12292012358071736, 0.12737401512101643, 0.12932655971466933, 0.10757798685622477, 0.23993577750141892, 0.2210068127947583, 0.13737040497509712, 0.1384533474045636, 0.5603323856346606, 0.33363650271418344, 0.14756722385520793, 0.2760596397389994, 0.17699370261808944, 0.18059720382138966, 0.20437448148296555, 0.1416233402739424, 0.16010508113463162, 0.007380050521030301, 0.06595641086536941, 9.999999999998899e-05, 0.004972116070007915, 0.06475682787524462, 0.12782314680456952, 0.09835025544295217, 0.06521381325488196, 0.04236608793980945, 0.15473843894537564, 0.12844094400970807, 0.1507033451010813, 0.09728605828336767, 0.11712716369159648, 0.19775649680939045, 0.23235607412350678, 0.17084804949041354, 0.07485672617041961, 0.06110091711110799, 0.03558824015197204, 0.1672781059939482, 0.08279589286701705, 0.25466401140923745, 0.17253210788943785, 0.09386119632880163, 0.08850373789667976, 0.14287728994692295, 0.23440848360090782, 0.264967087616479, 0.19063444735167812, 0.11126412532691099, 0.15164932705708267, 0.20322831857339885, 0.1742312652094522, 0.23343655280709263, 0.20801039153574086, 0.5395139812754701, 0.5327640673075218, 0.42638756925802634, 0.5273628841626028, 0.4184838020298919, 0.4785460456720806, 0.4937261663473128, 0.35790513151111514, 0.45061097080360335, 0.13584555612311466, 0.11549003880394526, 0.13063519478472407, 0.12640082840511258, 0.17231998397116843, 0.11525545846283736, 0.13836987024118175, 0.13170861380192656, 0.13521673773760445, 0.22893974379295678, 0.16628115260444065, 0.17962216084483462, 0.23693381629346077, 0.26748986552328724, 0.2871603539422003, 0.29726665211364567, 0.2156415420794957, 0.22874036539294262, 0.33839658611415047, 0.3306068473812781, 0.4012872002125709, 0.34954122715810076, 0.3747102127263646, 0.34126497818069723, 0.2486786251226567, 0.467894724330326, 0.45624443805744885, 0.34242654596313526, 0.3325316938705729, 0.2598065289496595, 0.2895634953899656, 0.2969774521165507, 0.2733959726101155, 0.3311044732133668, 0.3190066404025814, 0.3007472449793126, 0.19541497841593003, 0.21457664269670207, 0.2268979518160208, 0.203546747360963, 0.19344818579237988, 0.25490526773125144, 0.1976902104555336, 0.1977126374346745, 0.22877782658113544, 0.20612548673673758, 0.38778247585879355, 0.24837605328369583, 0.3245376129023405, 0.22509342024679835, 0.2117857436826751, 0.24054369892034777, 0.2191474374582979, 0.16591921197200443, 0.1649704120766613, 0.18841128660746775, 0.6296336274517079, 0.36825216654967674, 0.4228503564577629, 0.16827250594334686, 0.4452986593142215, 0.17663445923502719, 0.16362962948670667, 0.5251956701806079, 0.18132342395246193, 0.44991385733520617, 0.26480994793183854, 0.17717744166770788, 0.2120447336253629, 0.31118564332574217, 0.1493926095002729, 0.19262387293455607, 0.19075158651773272, 0.18284082938137391, 0.1778834574964132, 0.17875840781569674, 0.179978128254625, 0.17440402879043726, 0.18678591143227308, 0.19036842533096676, 0.19912019171422912, 0.08793374812031851, 0.1018598686802179, 0.10312733256482132, 0.10340456985169078, 0.0861222970168698, 0.10616758118911107, 0.09214390962720265, 0.10306867001870601, 0.09453768422506292]}, "mutation_prompt": null}
{"id": "64daa837-c408-4e6b-a845-d611e2fe5641", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 20  # Initial population size\n        self.pop_size = self.initial_pop_size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0  # Counter for restarts\n        prev_best_fitness = np.inf  # Track previous best fitness\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size based on progress\n            improvement = prev_best_fitness - np.min(self.population_fitness)\n            if self.evaluations % (self.budget // 10) == 0 and improvement < 1e-5:\n                self.pop_size = max(5, int(self.pop_size * 0.8))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n            prev_best_fitness = np.min(self.population_fitness)\n\n            best_idx = np.argmin(self.population_fitness)\n            best_fitness = self.population_fitness[best_idx]\n            if gen_counter % 115 == 0 and restart_counter < 3:\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  \n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1\n\n            # Early stopping condition if no significant improvement\n            if np.abs(prev_best_fitness - best_fitness) < 1e-6:\n                break\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhances Adaptive Differential Evolution with dynamic scaling of population size and early stopping based on convergence criteria.", "configspace": "", "generation": 18, "fitness": 0.04139043012570042, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.07557948780358437, 0.13729208426254114, 0.0916041897440597, 0.08943128444456927, 0.11468581712951453, 0.07700439226565303, 0.07786194868253349, 0.0781735070500621, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03758998554048598, 0.014572254733962064, 0.0, 0.010544468052148481, 0.009561452692529171, 0.016175612266720374, 0.018150078853237606, 0.007262677624934266, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847073, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03554994628669261, 0.07941271529838445, 0.05324558914821231, 0.06117848908101475, 0.061468409850551686, 0.06379241875032016, 0.08399389834645832, 0.05913169983241717, 0.0, 0.0, 0.0, 0.0, 0.008621304045280165, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870674, 0.006388112346703334, 0.04021173600191419, 0.027157688250799894, 0.0, 0.04305442389768099, 0.05921649636366433, 0.02756980551378929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249119, 0.14829537673711235, 0.0979678182016569, 0.09699835892693354, 0.09931814592991228, 0.1239692985348404, 0.14178241063223307, 0.12096781838999704, 0.007578940382387711, 0.025632811019799973, 0.0, 0.006002370323321182, 0.0, 0.033721826319668025, 0.0, 0.002095734332218435, 0.0266683362656992, 0.07028246122684645, 0.0672636612780867, 0.09075190288804857, 0.09846289938816155, 0.10844057434014054, 0.12484737732431295, 0.08799080449358876, 0.05855194112748141, 0.07717165476235766, 0.13073742094371077, 0.09878892749577062, 0.1035081378150462, 0.10838250165484586, 0.10410820891032213, 0.1255763116241425, 0.15045703777616615, 0.17369512487615557, 0.09170887849681608, 0.08295775139156103, 0.05012863859643235, 0.04633832437959895, 0.04686272416635662, 0.06397588396999376, 0.04621487005142011, 0.08841948501172059, 0.09376969834432347, 0.057960038071565245, 0.09154377975027184, 0.11877674417915873, 0.13336421106438556, 0.1028008393912958, 0.08830654432808804, 0.11855493981510279, 0.12237199858757519, 0.1111737128845407, 0.12610897469223914, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07935244344406911, 0.07457348599177205, 0.08157840845421893, 0.07041910276054164, 0.1207035396655618, 0.08135552840883231, 0.0723629269250583, 0.09634568763971818, 0.053579659675793145, 0.038145025866380466, 0.06524162289785873, 0.0284604828031797, 0.0505908534635271, 0.03728632333816151, 0.06146798994749514, 0.04680845216491614, 0.05285525100531263, 0.04133833534605058, 0.13471522306136396, 0.1282849674499068, 0.1475449842687161, 0.1159064692416708, 0.11587994885436581, 0.12456358843521431, 0.1297136600334463, 0.11091267478310074, 0.14680476350940785, 0.0013499860183363577, 0.01337948491849783, 0.03129662407793532, 0.02691798931623468, 0.01901361700996329, 0.01747985959787568, 0.013223057063992738, 0.021348718921610943, 0.021357208370090475]}, "mutation_prompt": null}
{"id": "1a379fad-48ae-4f87-b96e-501c692c307d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0  # Counter for restarts\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))  # More flexible mutation\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())  # Increased variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Feedback-based stochastic adjustment of CR and F\n            if np.mean(self.population_fitness) < 0.9 * np.median(self.population_fitness):\n                self.CR = max(0.4, 0.5 + 0.5 * np.random.rand())\n                self.F = max(0.4, 0.5 + 0.3 * np.random.rand())\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Controlled random restart mechanism\n            if gen_counter % 115 == 0 and restart_counter < 3:  # Adjusted restart limit\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1  # Increment restart counter\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Integrates a feedback mechanism for dynamic parameter tuning in Adaptive Differential Evolution.", "configspace": "", "generation": 19, "fitness": 0.31958599318767644, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.8372688677388793, 0.8083445403079164, 0.8391303893332269, 0.8336170568388614, 0.8466731604416956, 0.8495106522548048, 0.8997096079053006, 0.9039199815797635, 0.9079263912889807, 0.7391239533917944, 0.7457790614948734, 0.7522015309992196, 0.7066281639302106, 0.6887809368726165, 0.7074443534744199, 0.7361766417365574, 0.7286532316772221, 0.7609715276427084, 0.15299377402006176, 0.1345848914510942, 0.11817708120785098, 0.26724602631675576, 0.2678817373236211, 0.29777322699777, 0.265709928003766, 0.34167493145327776, 0.29992536191565733, 0.1441707734773563, 0.142088576120182, 0.1214233984550972, 0.15019689695975735, 0.13696614322025558, 0.13686785214785047, 0.2707751665713818, 0.12969683166088375, 0.14440772921827372, 0.9704547868833532, 0.9773440010211065, 0.9781157368208993, 0.9788104419371281, 0.974725690263892, 0.9902561597324625, 0.9739686101281652, 0.983349722348465, 0.973954745152706, 0.27549129233455416, 0.32085049706292956, 0.3766709419517814, 0.31763955878607386, 0.3442214062712903, 0.3713410518339675, 0.37197748315940427, 0.34449642445060336, 0.38173512598551296, 0.41490542037769074, 0.39916404454336507, 0.362614917310086, 0.4479935249055206, 0.46806774350709135, 0.41200414899458715, 0.44726887674132976, 0.33492671927935613, 0.4734137020564261, 0.23365029411452665, 0.1774317581604279, 0.17301647722004532, 0.2139359735737435, 0.1497469477976101, 0.17967396623752407, 0.17976317889744153, 0.18356727492883584, 0.17873608227777982, 0.16699323556109225, 0.12983603099989427, 0.1618306852491389, 0.15108075801795784, 0.14768098539644248, 0.17258862674145725, 0.16389253555995054, 0.13002628604505295, 0.14608524009401447, 0.019960026427818023, 0.12785717590910373, 0.006677598022722497, 0.00046868925708754006, 0.015807405790044915, 0.08189286022395303, 0.05154194886188834, 0.019345538237584115, 0.09230670238853633, 0.1250842606483018, 0.11630950178086119, 0.07931474733229915, 0.12034537314318272, 0.2462305130981577, 0.119606358428207, 0.12132354151351632, 0.13489441226083132, 0.12335729555581287, 0.06531753406695484, 0.06157547651501083, 0.11172124204380562, 0.03707703648497296, 0.04111794357012655, 0.09184655669412278, 9.999999999998899e-05, 0.17260811782348506, 0.08006828538146271, 0.11990631019599618, 0.11739787209923469, 0.1397884290966378, 0.29648969447959383, 0.22324911077355714, 0.2819547774252137, 0.29248247128211124, 0.28967672680748235, 0.2933911860345204, 0.6828175922108277, 0.6623440182904325, 0.7560630126364126, 0.601476956287814, 0.6664001052136685, 0.6216528754617894, 0.49710548551792355, 0.5171880505994154, 0.5049134954439054, 0.09732754721298642, 0.09625961517435189, 0.09538291295311896, 0.09454986871206861, 0.09313419644714682, 0.08110641638912963, 0.09960320330543859, 0.11662448409538706, 0.07876171746586147, 0.14143941696415163, 0.13587650853258515, 0.14557503798600613, 0.2020450396401624, 0.18029339333003258, 0.1787461015377355, 0.13340089751520623, 0.14762624849816952, 0.15324324361942288, 0.46319621100340647, 0.4399939104785896, 0.4229854046502842, 0.3248219393144589, 0.30588762710854034, 0.2786350807087733, 0.3544911562320202, 0.37184189837695536, 0.36509950398227076, 0.3039551553308887, 0.33320060661032647, 0.2958151329877228, 0.19728426149143674, 0.1908660037141623, 0.21718185178413374, 0.2339054220496498, 0.21896122383463634, 0.21962754067242762, 0.18320465176544887, 0.21127693629009914, 0.21038468469606586, 0.18851968617977932, 0.19621641153200575, 0.19086054403152952, 0.1949223959766122, 0.1803383265451357, 0.1839798374745767, 0.19878579583590772, 0.29176465510158034, 0.22625240093181342, 0.20195297700849824, 0.26400795469282456, 0.32324328795847246, 0.26398717050098297, 0.3575513451356047, 0.19635488112391053, 0.3742541164388907, 0.5048059497665872, 0.20640449464205046, 0.16505861320708193, 0.6044920723986209, 0.18223243303172232, 0.7425324868092158, 0.8683190167572408, 0.8811849074971607, 0.537399787473888, 0.86884864089108, 0.8909086431182272, 0.1518490633065489, 0.18297773999689393, 0.21562020311242436, 0.7113071332330518, 0.1496442265429494, 0.21187929296267816, 0.19691175650422776, 0.18726944748741103, 0.1770269676750138, 0.18707761690808855, 0.17782561522948492, 0.1873483912569628, 0.17621590097712847, 0.18554176135178846, 0.17425262643196948, 0.07551647962081642, 0.08252958950721845, 0.08659164984106049, 0.0821694494669799, 0.07337946940116924, 0.07515344947812375, 0.07381931944646314, 0.08489157859288532, 0.0772111182254992]}, "mutation_prompt": null}
{"id": "e1eaf31d-b279-446b-b868-e5395b266eb1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Adjusted population size for increased diversity\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0  # Counter for restarts\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation with adaptive learning rates\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_CR = self.CR * (1 + 0.3 * np.random.rand())  # Adaptive crossover rate\n                dynamic_F = self.F * (0.6 + 0.4 * (1 - (self.evaluations / self.budget)))  # Adaptive mutation weight\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Enhanced Crossover\n                crossover_mask = np.random.rand(self.dim) < dynamic_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.4 + 0.6 * np.random.rand()\n            self.F = 0.4 + 0.4 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 12) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Controlled random restart mechanism\n            if gen_counter % 100 == 0 and restart_counter < 4:  # Adjusted restart parameters\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1  # Increment restart counter\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive learning rates and diversity enhancement for broader exploration in Adaptive Differential Evolution.", "configspace": "", "generation": 20, "fitness": 0.3596934243148763, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.8881395886899409, 0.893698278668536, 0.8773441596682984, 0.8822128925001936, 0.8869186630628662, 0.8818386879508265, 0.8929964045310032, 0.8773348973307282, 0.8939908577963132, 0.672302460996074, 0.7079754245184049, 0.6687346750148258, 0.6707979819945993, 0.6934910422500116, 0.7248278573854451, 0.6566113981386215, 0.6836678994424099, 0.6869630505996973, 0.1488157780744177, 0.12286634984092304, 0.14586175511089716, 0.1607830793365398, 0.1436906037832819, 0.13169110749063861, 0.1205426798283441, 0.13727691589418733, 0.11870297052202428, 0.12163331028578284, 0.12277858913696893, 0.13853062058743704, 0.11597283707621842, 0.10924543883616056, 0.1187284704577436, 0.12972833408108508, 0.12646168605409636, 0.11879911397875387, 0.9313307051754482, 0.9834041337996748, 0.9632113450524133, 0.9378305822429094, 0.9483125048371301, 0.9434991061782123, 0.9683954074139578, 0.9360879460851441, 0.9668765477431798, 0.39458144744851764, 0.3567612617734738, 0.3242689296274214, 0.3919579974412364, 0.4239381220701317, 0.3552482006113521, 0.37758067474467827, 0.3635999163810456, 0.33858778821030233, 0.8320108984149255, 0.8760656845493358, 0.8299568758463933, 0.8860534914110421, 0.8611753663594558, 0.8391814905195185, 0.8470334029260813, 0.8629146164038004, 0.8284350870919492, 0.28367148161651246, 0.21435961590306662, 0.20596813195591523, 0.21604780565394865, 0.2423687652438482, 0.22266783115077793, 0.2011075846367003, 0.25423283476035785, 0.18878129604939875, 0.1682485535546181, 0.2483127589009234, 0.20034749444189515, 0.18154423357891902, 0.20428952454656069, 0.2456270591514823, 0.1652295577806686, 0.25435071903683537, 0.17647380466951124, 0.19870194285641296, 0.19578402555292618, 0.2661897594680761, 0.16318804098344697, 0.09742850172008044, 0.14266073348783648, 0.2576782920737133, 0.13007633119180373, 0.3327305219010632, 0.3611260686847524, 0.36775795226429686, 0.3895948778710764, 0.32099439476626257, 0.416192951257222, 0.3695212674427517, 0.34002274158938806, 0.4025712936203637, 0.43478736482780334, 0.09865892868725457, 0.10384547596832983, 0.0841008290546491, 0.11821902740027634, 0.1580740639113528, 0.15405584691610197, 0.15847574366694228, 0.07735417953150048, 0.14691196144952123, 0.23600494081883527, 0.2342587712594758, 0.25285934300730106, 0.2537337830432429, 0.2673499626057865, 0.27544085960939635, 0.2678634289367787, 0.2598246123760757, 0.24997016580950482, 0.6648567456150715, 0.6296030229307152, 0.6296011423974605, 0.6676305246389564, 0.5708561992146428, 0.6288602909175794, 0.629945497688635, 0.648798315989242, 0.6251691016500316, 0.09296475895828082, 0.09744719416673364, 0.11287173563509767, 0.09908199964175923, 0.0970049664829381, 0.1069915827686373, 0.13030187592492837, 0.1001909359804376, 0.09303721128185405, 0.2607552339342587, 0.13597486766931455, 0.16399312760333906, 0.14624585587704586, 0.14831637715910406, 0.15299130269376637, 0.18908901234562003, 0.14484718761230708, 0.15333801436901484, 0.38945190366623283, 0.38129247249978093, 0.36172039305467774, 0.37559139947718556, 0.37739545156923826, 0.38870747616811574, 0.40259517816282975, 0.4131199594277968, 0.397527874746616, 0.2664181197029928, 0.28970499630311275, 0.29326153867007043, 0.2775986005596124, 0.28474105453136356, 0.2619018412729397, 0.28501553750065756, 0.3375465030551347, 0.2977057458876292, 0.1880405273686735, 0.20328941016806257, 0.19287430896849844, 0.18910425565077948, 0.20063570056132973, 0.20804977591990814, 0.19966708295693614, 0.20202872772169467, 0.25297885350103766, 0.22567247874542495, 0.18914875478469928, 0.21859499492499046, 0.19216257847222418, 0.27516365985634594, 0.20949353751543154, 0.22370969286625564, 0.20094965014250454, 0.22569089290797295, 0.16385968875586332, 0.1991826263753037, 0.8744878612917226, 0.27636990076172996, 0.7062617730744661, 0.18861526745229873, 0.6297961152578491, 0.7866161825837986, 0.8608664365062646, 0.4346224381934364, 0.8325273313002558, 0.7540091958838709, 0.53778464371812, 0.19266222549391465, 0.45831700815873955, 0.21076503985976802, 0.21280176859152744, 0.3620207658183765, 0.17821315099073964, 0.1764871834805508, 0.1776497909221587, 0.19022269587252394, 0.2034013935494653, 0.2154069494065618, 0.20019574648489347, 0.183115982524941, 0.22986179878671265, 0.0748200650980334, 0.09518883155534863, 0.08252664633193507, 0.0834032982969447, 0.07506509035740783, 0.08899076783047077, 0.07857377161100687, 0.10375507127008332, 0.07812670861408932]}, "mutation_prompt": null}
{"id": "5d575fbb-7d9c-4cd7-8a1e-2c2abaf0427b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.CR = 0.55  # Adjusted Crossover probability to enhance exploration\n        self.F = 0.8\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            if gen_counter % 115 == 0 and restart_counter < 3:\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1\n\n            # Periodic re-evaluation of the best solution to ensure accuracy\n            if gen_counter % 50 == 0:  \n                best_idx = np.argmin(self.population_fitness)\n                self.population_fitness[best_idx] = func(self.population[best_idx])\n                self.evaluations += 1\n\n            gen_counter += 1\n\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces a minor increase in exploration by adjusting the crossover rate and incorporates periodic re-evaluation of the best solution to enhance convergence speed.", "configspace": "", "generation": 21, "fitness": 0.38495765640979557, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.9066563259485274, 0.8984637376062404, 0.9070558545700036, 0.914477943788635, 0.9047029525732677, 0.9136244438748182, 0.9072938281324133, 0.8944111624816852, 0.906693616175428, 0.8436005797956964, 0.7414287021176882, 0.7263575682375789, 0.8027533495035802, 0.7770225895673011, 0.7853094996400304, 0.8152919282867738, 0.7796439379237106, 0.8096153596945272, 0.16682240699963746, 0.14876733684202248, 0.34915707319992195, 0.12277725167930398, 0.15200466063552687, 0.13743211235410568, 0.20905091565311618, 0.12864909696284632, 0.17830588151859228, 0.1278573654120746, 0.13515395317389756, 0.1216048415708314, 0.12239833267460531, 0.12230793920519223, 0.1386579646639169, 0.13647654918234986, 0.15234464161569228, 0.1328949786230933, 0.9728995283129845, 0.950167491040347, 0.954255049587384, 0.9825021246672105, 0.9319551202827394, 0.9327457169768683, 0.970769649867186, 0.9587837034315603, 0.9583110106350339, 0.48224838525500224, 0.357837598713713, 0.33901250068200084, 0.38604189053858184, 0.4061393822924185, 0.3488931599464251, 0.48060382763361464, 0.36335183587660447, 0.29969309449928916, 0.8517592014448734, 0.8504286685425508, 0.8765250839805179, 0.7257583531811366, 0.8975838899272504, 0.7130437669094916, 0.8885882583297766, 0.8671869553410756, 0.8750345344272956, 0.2419640552219876, 0.1798548852991978, 0.16629638699013471, 0.2542343744351392, 0.20920528663148075, 0.1915669955088637, 0.24869968404346243, 0.18451272927734308, 0.2175148783244325, 0.3331911920574042, 0.1528841429957205, 0.20192696913175623, 0.2411015267757306, 0.16144380852987394, 0.28710483108813645, 0.191876718589996, 0.3637072908914917, 0.17448237610197503, 0.10157431085479907, 0.2099145964753727, 0.15574754238989175, 0.1470344663989781, 0.1330627763249882, 0.24161006617759606, 0.3113649710933717, 0.23793699570370896, 0.13009282339953965, 0.47382612525263224, 0.46855710209381873, 0.1900775098386014, 0.2474938185806651, 0.27300004875031214, 0.3640200682489376, 0.3699420146859329, 0.42755494793123305, 0.46811645513149003, 0.1067780135109937, 0.195947134551129, 0.0905743775884259, 0.23688018448971615, 0.16943812751925857, 0.11807741267611327, 0.15597645208915323, 0.2106543308952531, 0.26653897126969717, 0.28338667106750315, 0.21435691847664962, 0.27300932792592203, 0.28085117897386114, 0.2614458791305695, 0.27878515979508633, 0.31736938494914346, 0.25313368082510745, 0.2895026042525882, 0.6193725552721308, 0.6641495914460261, 0.7018905556022502, 0.6803314332950041, 0.72909618730983, 0.7198299966605888, 0.7492616282565294, 0.6194048830661012, 0.6329833044167004, 0.09872464760097466, 0.10910425157130321, 0.10123717994663861, 0.10489124040152908, 0.10106560961317756, 0.11444586709841864, 0.09767125477186933, 0.1039239728591268, 0.09426296769736686, 0.20360513306409045, 0.1569591328077955, 0.13220808288494534, 0.1653780518129908, 0.1514267954935331, 0.19166443030917313, 0.19490148027474763, 0.13670833160398688, 0.21031589453874133, 0.4455326582689577, 0.4516041404262907, 0.4137143835793614, 0.4388318159629899, 0.4897265844490173, 0.3821387732889916, 0.4134537536107056, 0.5087724945178433, 0.4853959913156288, 0.3559388209662431, 0.31572257283704075, 0.36713096646316246, 0.33044134116048585, 0.3329788519511713, 0.29354393346863694, 0.4172059216713082, 0.34903490420263095, 0.40760901083187484, 0.22181745097056882, 0.1925954893320183, 0.19663820729169001, 0.2178829938429082, 0.18676570593106856, 0.19824414531817014, 0.22145592618083387, 0.19134092288000415, 0.1966592053778985, 0.44702977897341567, 0.21236055300418932, 0.20953639192664664, 0.44859379830732615, 0.2557940207150855, 0.36027970882236127, 0.23079863869138195, 0.21084139034093563, 0.33122990240181827, 0.920795172106001, 0.187214692311091, 0.719431953820877, 0.8771151593101286, 0.7045662939489865, 0.7045023983233956, 0.619628257049905, 0.8647056919392355, 0.8809770525451098, 0.6970801356844387, 0.8690788141644608, 0.18817597627061022, 0.2810500951076095, 0.2957686102546643, 0.2104255701011889, 0.38314464481690425, 0.14897384100823308, 0.212094882899878, 0.17741557591627932, 0.1975734876134696, 0.18597406632830515, 0.17988172192355, 0.20308092474092954, 0.21680327119143394, 0.19176152281404824, 0.1756472118607495, 0.19475600011200722, 0.08326909099744662, 0.08444539558999953, 0.09001077694739412, 0.08559679198808445, 0.08768362853344791, 0.07516435793960441, 0.08365252836878423, 0.08421183256681852, 0.08135370304482459]}, "mutation_prompt": null}
{"id": "1f76e06c-1482-480f-9700-25fa65a10985", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0  # Counter for restarts\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                diversity = np.std(self.population, axis=0).mean()  # Calculate diversity\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget))) * (1 + 0.1 * diversity)  # Adjust mutation by diversity\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())  # Increased variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Controlled random restart mechanism\n            if gen_counter % 100 == 0 and restart_counter < 5:  # More frequent restarts\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1  # Increment restart counter\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhances convergence speed by dynamically adjusting mutation factor based on population diversity and increases restart frequency, while maintaining tightly controlled adjustments to balance exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.34314889934514636, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.8782391939021247, 0.9069104363983309, 0.8710449336439251, 0.8943482046928113, 0.894192986789351, 0.9045615803197669, 0.8911603233563958, 0.900518765204618, 0.8858074945382283, 0.6758183518252918, 0.7202227181593817, 0.5884039689943339, 0.5250712121934887, 0.6783900716280739, 0.6956107487332798, 0.7169343113850086, 0.6514860221765516, 0.5692385740066344, 0.12120543541692008, 0.12886735579347353, 0.11931523803110289, 0.12998971424699868, 0.11957794978903036, 0.11527938199681176, 0.13170848647740752, 0.1255871976315932, 0.12152034202844841, 0.1099007731104813, 0.12028508820837647, 0.12012152739199411, 0.11827288624717536, 0.11072855192172448, 0.12886896314792373, 0.11120994559236064, 0.12172720889992561, 0.10766534984720877, 0.920282095939456, 0.9802704834146573, 0.9581873668870496, 0.9701826384090255, 0.9654552705579775, 0.977367608890155, 0.9781259249929147, 0.9702350415855544, 0.9863142460215841, 0.3851553910936204, 0.3295936424549072, 0.29548842829751953, 0.29639329124377745, 0.3157407859930703, 0.3479688424893589, 0.38727341162343765, 0.32587513106109645, 0.4076897116285614, 0.36830888810933426, 0.7287675335925892, 0.8453016054908895, 0.8776436044684013, 0.7520764161399724, 0.8794154415376197, 0.8708681890868114, 0.7747569832065879, 0.8922131367728863, 0.20379571499144666, 0.16667812809351767, 0.1867853279242292, 0.1752524090323685, 0.182342182457907, 0.1719351581159031, 0.22251204026033988, 0.21346408781369441, 0.1724648974477646, 0.1182517732128403, 0.17605437705872318, 0.18061963009847637, 0.1913735771666717, 0.19213846450222893, 0.19156980251064282, 0.18903789147660433, 0.2243544316331073, 0.20653590421313883, 0.21463736435552772, 0.24155728529234943, 0.09903380840274623, 0.14205543109552177, 0.0939742148580468, 0.10514837752449036, 0.20435181157618676, 0.14778413296240267, 0.18177522931239665, 0.3142201871422713, 0.33669953834695865, 0.30256475381779935, 0.2190110282618637, 0.279056499621411, 0.3196917112455918, 0.34868150417863053, 0.30933899258675646, 0.4393690202787567, 0.12814890162735115, 0.14161109364546265, 0.10475865257622685, 0.14073433354088027, 0.1389237537370096, 0.14923753786568072, 0.1945367847779378, 0.16310623831272808, 0.1885847996446417, 0.24795887306435138, 0.2251030250378543, 0.22995352928546897, 0.3296739152996666, 0.23051581527703813, 0.29306774717364314, 0.23371319469722596, 0.20183336296245158, 0.2624204452924518, 0.683342029770843, 0.6420960584283848, 0.6178265409324191, 0.6468409950837013, 0.6017317972673945, 0.6742164412194447, 0.6136235473563105, 0.5957729277069395, 0.5865655212831797, 0.0963038923088343, 0.09700932001030926, 0.09979986245138994, 0.09610761111245958, 0.09095788549057338, 0.09615600206214003, 0.09677834057643064, 0.0888633350537561, 0.09748413018061541, 0.14357857898458748, 0.14537474521846083, 0.15084418617843676, 0.1506174634960249, 0.15606642056060882, 0.1440138040641865, 0.14476395893614824, 0.1611537590147245, 0.15670002488285684, 0.3700888706736035, 0.39689011694073817, 0.3687407002175399, 0.353833257709973, 0.32521401461251676, 0.35323769802959915, 0.44237233443012824, 0.4061521919326836, 0.36733990238540115, 0.26234163529583177, 0.2544413303985048, 0.2963800222634695, 0.28172238751067125, 0.2496510430116975, 0.3018371070425572, 0.2878567045439058, 0.2756983938422559, 0.27955230499911876, 0.18083558393510357, 0.19794125055162293, 0.18956350362239371, 0.1960305247798595, 0.18345428952143505, 0.19540151574295972, 0.17606067875210374, 0.18651414556176382, 0.1894887522955887, 0.20023842083855936, 0.19982072258974726, 0.21751936706342445, 0.19992469771345034, 0.1969518575612691, 0.21411881453002501, 0.22862063276407807, 0.27120098923261204, 0.19995675224623655, 0.8930045309781681, 0.8608932265326715, 0.8461561809303306, 0.23039709048839085, 0.23399621335137766, 0.5296746624536044, 0.19110759211679473, 0.34041558773388736, 0.7384508677161791, 0.19390040339498538, 0.5311615995204553, 0.5163997383484615, 0.5599929146152094, 0.19016086506181995, 0.22303334682158527, 0.7358514273286547, 0.24240680146332672, 0.24057723941667075, 0.177651466931546, 0.1795533010714384, 0.18177818599062845, 0.20334907162371052, 0.18137234682427994, 0.1853049151416276, 0.18343572278429876, 0.17228234215098548, 0.1893497553523682, 0.0760622091990103, 0.08391595570747123, 0.10031761720650556, 0.08253073339642814, 0.07989841874362724, 0.07399842853556549, 0.07474160350239922, 0.07691339795247809, 0.08380370598832343]}, "mutation_prompt": null}
{"id": "c7a2f212-f7ca-4320-bf1f-1efcc199b9c1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0  # Counter for restarts\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.6 + 0.4 * (1 - (self.evaluations / self.budget)))  # More flexible mutation\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())  # Increased variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.55 + 0.45 * np.random.rand()\n            self.F = 0.55 + 0.25 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 8) == 0:  # Adjustment for more frequent population size change\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Controlled random restart mechanism\n            if gen_counter % 110 == 0 and restart_counter < 3:  # Adjusted restart frequency\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = self.population[best_idx]  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1  # Increment restart counter\n\n            gen_counter += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.population_fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced diversification through dynamic parameter adjustment and adaptive restart conditions for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.375328090528394, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.891695720591362, 0.8985122712147897, 0.892889574673417, 0.912930080122865, 0.8997142233629748, 0.8873376535321622, 0.9089051878116452, 0.8924556969746282, 0.8957757695600194, 0.7144770222822969, 0.7494836624926288, 0.7354402678868172, 0.7301953185229253, 0.7186114855161709, 0.7687321912052112, 0.7493212961894116, 0.7502303160596935, 0.7186145600160152, 0.24800326521389215, 0.14245600320848095, 0.22382594895045282, 0.28091662201163237, 0.1397105107613026, 0.11712879453929437, 0.136782624178739, 0.11379479764207645, 0.14810411558242542, 0.13224809811771798, 0.12219157804371295, 0.13916706697963, 0.14251700438996306, 0.14062517295947496, 0.13057145180111407, 0.13432647061125758, 0.14163591358277483, 0.11936617715208209, 0.9844567964704963, 0.9586557157275761, 0.9502025665445356, 0.9777134663202315, 0.9528584488239609, 0.9130390616162951, 0.969025785258844, 0.9175668895842767, 0.9688086019956171, 0.32285524387046394, 0.4576314897215167, 0.3489554496833652, 0.39796074259313874, 0.3785118203380329, 0.40060251838833405, 0.43361101119938017, 0.38365686491334716, 0.39594010212720543, 0.8687632650941988, 0.8698634895221918, 0.8380006061515153, 0.8868596865939754, 0.8983484304232725, 0.882221388577995, 0.8655433776945944, 0.861938489479783, 0.8329231530694455, 0.23113931516798347, 0.1548473823350096, 0.19902686766141564, 0.21221983222734286, 0.1663537733958207, 0.2462522314326121, 0.18328909989584852, 0.1755437402002341, 0.20852259789599925, 0.2665249633630077, 0.33146889597663043, 0.2770230922655018, 0.18245197043143258, 0.27254362919702957, 0.20412903169035224, 0.27791656761483297, 0.20906997476902278, 0.2703131791562343, 0.1281947350518733, 0.2352770589470582, 0.3166821277124654, 0.4028737777657323, 0.2586609269792328, 0.19138914025861198, 0.24897612867698393, 0.2352173010158689, 0.23103334941541476, 0.27145982658486234, 0.40509908477009693, 0.3527649067090748, 0.20102180423892646, 0.37049237475101404, 0.2518110123875352, 0.3525056248946331, 0.3876733463902887, 0.33487317680686457, 0.08957459559258674, 0.17625465460387402, 0.1967819538550144, 0.12308648899775032, 0.28531790761103437, 0.14221053955876173, 0.22238502214364286, 0.11944502087924103, 0.1063773278428416, 0.3214779196221049, 0.2045545663341246, 0.2966424416010792, 0.27811342634619285, 0.2646813528185954, 0.25909085089927253, 0.2870078302936463, 0.2457791090632504, 0.1812744444977903, 0.6364605611529268, 0.5925782574570146, 0.7414678998234978, 0.7013013955866967, 0.6305158292698041, 0.6427703124285913, 0.7448789982766657, 0.6848641709044228, 0.636412781342393, 0.1079243472835909, 0.09663489294088379, 0.10052201354442636, 0.10458333009234089, 0.10203109706115954, 0.09602317199520172, 0.09206814974964184, 0.10763187681662145, 0.09876605191693366, 0.14794654926477124, 0.47126761468330236, 0.15170154742474784, 0.16690946737095347, 0.20597980347559175, 0.1845864910988243, 0.16838339101973687, 0.32152410853992974, 0.2240484484307924, 0.40672920519402633, 0.41075403825436585, 0.48216117394377966, 0.4236428280169523, 0.44288554413894077, 0.4698376998291718, 0.5073808930299007, 0.48239542595197804, 0.4971047090894165, 0.34640458736075874, 0.3463865469744405, 0.3034614458203245, 0.32833625841317904, 0.3154431677505215, 0.32088493559994646, 0.39739676147282754, 0.25675684987012193, 0.3406820744626018, 0.20922441396574298, 0.20179096557769716, 0.22663930059914472, 0.19408630179795128, 0.18618793012184875, 0.19341186394033683, 0.1915246399298679, 0.19696284201812608, 0.18860126354376716, 0.21986107900632446, 0.2132724749385546, 0.3244454705789581, 0.21498048276500192, 0.20506753099720643, 0.1977052005007196, 0.3962676708678565, 0.20023780024873872, 0.19608478912667804, 0.911984675353852, 0.18558218474503696, 0.17144275982213653, 0.18067564371913236, 0.3902669757857008, 0.8299464894736986, 0.5347922488095977, 0.5467660767663325, 0.16715700504247233, 0.8267911246353039, 0.7489813538263326, 0.5253559311428138, 0.6408443373707198, 0.2021616848872807, 0.27252346172007325, 0.7092231201660473, 0.18360467880984377, 0.21095016130675348, 0.17132840124068005, 0.1852705832984266, 0.18389223370357777, 0.19192250124645016, 0.18220049666620441, 0.193681049323012, 0.18032673182754055, 0.1933280111617821, 0.17527223736898156, 0.08035497509368106, 0.0839860720869714, 0.08936951711705676, 0.07884034507772553, 0.07922848697603346, 0.07608043788327667, 0.10146679846446482, 0.07956810598416797, 0.08101625546240798]}, "mutation_prompt": null}
{"id": "b55c4fb3-ccd6-4f91-894e-e8c0168ac8ea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.CR = 0.5  # Initial Crossover probability\n        self.F = 0.8  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n        restart_counter = 0  # Counter for restarts\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))  # More flexible mutation\n                mutant = np.clip(a + dynamic_F * (b - c), self.lb, self.ub)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.2 * np.random.rand())  # Increased variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Track best solution\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.5 + 0.5 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Controlled random restart mechanism\n            if gen_counter % 115 == 0 and restart_counter < 3:  # Adjusted restart limit\n                best_idx = np.argmin(self.population_fitness)\n                self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n                self.population[0] = best_solution  # Keep the best solution\n                self.population_fitness = np.full(self.pop_size, np.inf)\n                self.population_fitness[0] = func(self.population[0])\n                self.evaluations += 1\n                restart_counter += 1  # Increment restart counter\n\n            gen_counter += 1\n\n        # Return the best solution found\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhances Adaptive Differential Evolution by introducing an additional elitism mechanism to retain the best solutions across generations for improved convergence.", "configspace": "", "generation": 24, "fitness": 0.41530616782084384, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "746d6bfb-63e7-4b15-8d1b-abfe3b7a0335", "metadata": {"aucs": [0.9225118965837362, 0.9138503078467544, 0.9076401644101783, 0.9131148615152772, 0.9081326882393692, 0.9178365975133543, 0.9097482426088315, 0.897303676302502, 0.9096084244293472, 0.8454925976196932, 0.7595587054264377, 0.820521423470281, 0.7742523530305878, 0.8448626515341637, 0.8052843049517867, 0.8093312119008972, 0.7160537325684697, 0.8198877722921736, 0.1409923047530821, 0.3124072571902531, 0.26070851345794, 0.24472896204221584, 0.16516697765881294, 0.13514060823728868, 0.3305570796711076, 0.3084004819308558, 0.36892565638315367, 0.1420057028484638, 0.14303511282466463, 0.18247128189434303, 0.21629661308612524, 0.15280081940194234, 0.1478642838416181, 0.17686026806909727, 0.11928126380048998, 0.11519291503372042, 0.9630595040122648, 0.9461281563177446, 0.9716744489890246, 0.9664778556065392, 0.949610060186946, 0.9723971199942966, 0.9744458186394845, 0.9710404892506372, 0.9819083779071198, 0.5738731234259915, 0.5202453132053642, 0.49525163774124525, 0.5290357184128638, 0.49156680339199055, 0.5362457930632425, 0.5420141885639804, 0.5095736853390416, 0.23415876157886384, 0.7432493386258359, 0.8784993577471641, 0.8751681773084876, 0.8876782595763846, 0.8722157013258314, 0.843907565564266, 0.9026746214000165, 0.736821860505726, 0.8680210166519724, 0.19820050495612362, 0.3441773402197258, 0.5448452257833291, 0.1938587768629798, 0.2576510272628172, 0.13217360503952658, 0.49646573739133215, 0.6522819844447072, 0.1974885179442777, 0.1256697354199552, 0.40040583146510733, 0.2434731892770997, 0.22535378025454644, 0.2034967027986393, 0.28608543162355204, 0.19569233293661592, 0.3973272320224184, 0.21296489503777993, 0.46143438986414664, 0.292869244228258, 0.5078981167987904, 0.23725787573805246, 0.3388189213271394, 0.12369762195603051, 0.47690366979890253, 0.36074142813257837, 0.37809533684883123, 0.48499150222401943, 0.5816925277681291, 0.6064949219218712, 0.44633588028148796, 0.5297039546677254, 0.321544310463702, 0.5175814755261148, 0.6752578276372998, 0.5699061775610088, 0.24014868726296068, 0.11217292577825977, 0.19446780248342987, 0.3414676219395759, 0.16455382761107817, 0.1621438501260586, 0.1870677551167027, 0.12528929019995927, 0.15066989454667346, 0.275665764418046, 0.3193185928405583, 0.3552782367650723, 0.31991559588438023, 0.3562263776110426, 0.3550446395958712, 0.3536638889839967, 0.23063220256775352, 0.19925780994774378, 0.7986157405107025, 0.7920044795683424, 0.7039017813864643, 0.8265770902976968, 0.7096256120991495, 0.7714491910461314, 0.8308950296628517, 0.8044501506917268, 0.8130920155125764, 0.11923128145522732, 0.11202573841845842, 0.09718634583745511, 0.1544397009854378, 0.1128977965113036, 0.11880978109609075, 0.13227662878727664, 0.11649468188253542, 0.12037542887486252, 0.20665343526647018, 0.23503159526648032, 0.1897664563187993, 0.14840202872067443, 0.14166812562844988, 0.2181528533486613, 0.14929858924466588, 0.16733544041553328, 0.15165428361868638, 0.5432929196734173, 0.5110878481667986, 0.5230984968411184, 0.4687250754146758, 0.4815570211228728, 0.4762016352052154, 0.5336032821441103, 0.49670647908729404, 0.5542026883362414, 0.38625203992452994, 0.37906685851382016, 0.4444453637413126, 0.3887320386594153, 0.43838136378520365, 0.4076065133340798, 0.386248205555492, 0.4634773192985785, 0.4079246270848774, 0.1983756206122853, 0.19041424905251492, 0.19752761339123337, 0.18610429142381946, 0.2062665895903666, 0.18789812803032113, 0.2042903521828766, 0.21634678528558993, 0.19609878452264917, 0.4345002237521053, 0.5016715772686928, 0.2266007708144402, 0.22905483349139766, 0.341908558114973, 0.23992483706869694, 0.21110508407904716, 0.24121226539236518, 0.6608213053750941, 0.8203834479426804, 0.18159771773782774, 0.17334065433549073, 0.1946319041327229, 0.3324406460508368, 0.8751119646116121, 0.8688733993211488, 0.529054631647837, 0.5265510574487039, 0.16657650602822283, 0.25809733237226573, 0.8948273684670016, 0.20692841298040154, 0.1688811375763728, 0.21106057438674564, 0.11215418033158042, 0.20728231054703483, 0.1535897601494164, 0.17820652847177643, 0.18963679450247584, 0.2186650860674202, 0.18409696528746355, 0.1973659556078683, 0.18663069777153551, 0.19067117665280686, 0.179941725395802, 0.20478479787005344, 0.08243768074172153, 0.0824173734011181, 0.08858411891036444, 0.0878617069448937, 0.08098779098638298, 0.08342871751322978, 0.07322658900597234, 0.0806872403553287, 0.07548310409279801]}, "mutation_prompt": null}
{"id": "dd5a6b34-8080-40b2-8445-326006fa8fe9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Slightly increased initial population size\n        self.CR = 0.7  # Initial Crossover probability\n        self.F = 0.9  # Initial Differential weight\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0  # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.6 + 0.4 * (1 - (self.evaluations / self.budget)))  # More flexible mutation\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)  # Boundary reflection\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                # Improved Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())  # Increased variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            # Track best solution\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            # Stochastic adjustment of CR and F\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            # Adaptive population size\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        # Return the best solution found\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive learning rates for crossover and mutation, dynamic population resizing, and a boundary reflection strategy for enhanced convergence.", "configspace": "", "generation": 25, "fitness": 0.4554209575610837, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "b55c4fb3-ccd6-4f91-894e-e8c0168ac8ea", "metadata": {"aucs": [0.8616175680498059, 0.8849801980366058, 0.8682547654871317, 0.8841784212767242, 0.8795431131151068, 0.8816044373141507, 0.8818420436529572, 0.8763579540228591, 0.8755125568816542, 0.7915054944924189, 0.8041590103933254, 0.7987671362099861, 0.7904775405154931, 0.7811415051591802, 0.8022408653434637, 0.7995010180448333, 0.8113825500476253, 0.7918242668854848, 0.3766911879391881, 0.4270747857668523, 0.5987691725206548, 0.49397606084069956, 0.16431491113118823, 0.486832743502854, 0.4353197132291663, 0.5179621814302122, 0.15141098087967386, 0.13183985620404415, 0.1309860246869281, 0.14335250313591552, 0.12964466788633633, 0.37091366953253624, 0.15465653197140905, 0.15795767421205642, 0.33657526766920587, 0.15858138581392522, 0.8243759673603072, 0.8040547660504093, 0.7980720248305109, 0.8190805447842663, 0.8002539838898155, 0.8110301786786441, 0.814305109446547, 0.8057116353054995, 0.8229783047198207, 0.6735545940662583, 0.700579214105429, 0.6306467122646272, 0.6516084930445215, 0.7090318299214886, 0.6947250297590268, 0.7280514982005732, 0.6655720606540801, 0.7355588844943473, 0.8421577752404918, 0.832019734627406, 0.8383009660593067, 0.8180592579194271, 0.8553887148306747, 0.8365963841404708, 0.8257213412177393, 0.8467819542113398, 0.8384294682646772, 0.24858973420158859, 0.3032313495276394, 0.21574624835422263, 0.27019274387070014, 0.16351602198288728, 0.22632135731050707, 0.5672013685015715, 0.26014603068316333, 0.2358923768441077, 0.17270848486139223, 0.12438815047407914, 0.20565797799243324, 0.4258704106701968, 0.4008842263632556, 0.2075054342106596, 0.2488912218741931, 0.1893777548208646, 0.19643776962932158, 0.5263714465114412, 0.28069073595268523, 0.20400823540072954, 0.6519818569632907, 0.6924383161090728, 0.41232114469451997, 0.6653681196585898, 0.6877537711353723, 0.6671036321459533, 0.7056265250367777, 0.3055323870071859, 0.7130143889014489, 0.4314266998218689, 0.670197609251518, 0.7090179043287144, 0.7533582005328792, 0.6889460912760773, 0.37110552042751865, 0.1290140248926538, 0.19991472447707093, 0.2549637568438988, 0.2031920228041748, 0.2133953706517352, 0.23703234707022025, 0.1896414854694708, 0.2529253463928406, 0.32670942990674323, 0.47835758865877365, 0.3455583568715159, 0.3641197377877152, 0.4640922241186779, 0.46669364409295633, 0.5522979607742713, 0.3449162017786269, 0.38057218974813767, 0.3575449969450428, 0.8145175597595407, 0.7315059975978968, 0.7204747748324347, 0.6848976612353519, 0.8252970611025752, 0.726600388178376, 0.7707331335956461, 0.7060122830297177, 0.8136887786452345, 0.11816043036990209, 0.36011611825056655, 0.12593075126377296, 0.11625084150316312, 0.10597644633638081, 0.11351394897550726, 0.13197123949824308, 0.18826020904432395, 0.12843861864847184, 0.16006535634637853, 0.13806305209477943, 0.1759204342111409, 0.21622177930051678, 0.15353369325926247, 0.16272603302426192, 0.1422646545352816, 0.15387365150403365, 0.1601907936215543, 0.5901681494917801, 0.5404199129032587, 0.5893078383784491, 0.595472543886522, 0.5540583261215529, 0.6004062801240132, 0.659740672193119, 0.5762198244187124, 0.6658443285102584, 0.41475966089102045, 0.45500543681263694, 0.4389877074943167, 0.4787148755013767, 0.39083004606963934, 0.47181727877786483, 0.5958747240272666, 0.4784257640719053, 0.48895008265394035, 0.19954777645609656, 0.19025246015478392, 0.19793444798684068, 0.22222628675109313, 0.1962145798448951, 0.1978194280967509, 0.2011920096255435, 0.187407396633116, 0.2351810499734156, 0.7370701296580231, 0.5775972289008484, 0.22110296067760904, 0.22214788747122816, 0.5266147897960809, 0.2871023186320455, 0.6483204690320183, 0.5044349061768512, 0.5149633709613795, 0.8828524365622025, 0.8984576293456298, 0.1700750371803339, 0.7990126960153567, 0.19634963651081982, 0.8073843506543921, 0.7842132754155706, 0.8391218912916177, 0.15901453869777504, 0.20974960674509258, 0.21021299734021637, 0.20491107050943946, 0.8633645797228447, 0.16448403076160156, 0.20907021277784832, 0.8519337485369831, 0.155507285284194, 0.20308646767281724, 0.17991462362218502, 0.1821158732901732, 0.2084434921842141, 0.19695543387214376, 0.20523121430411007, 0.17520501800797394, 0.185584763075908, 0.17597108160549324, 0.19603847684683784, 0.07908861808274725, 0.0801637184431524, 0.08715760542329531, 0.08349432837437831, 0.08218046058070272, 0.08843741693710327, 0.07886879463549645, 0.07517957316957968, 0.09059736281097286]}, "mutation_prompt": null}
{"id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))  # Adjusted mutation scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())  # Enhanced variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced crossover variability and mutation scaling to improve convergence.", "configspace": "", "generation": 26, "fitness": 0.47867218638261627, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.27.", "error": "", "parent_id": "dd5a6b34-8080-40b2-8445-326006fa8fe9", "metadata": {"aucs": [0.8810221499453622, 0.8761957455712175, 0.8651602090504003, 0.8731619023673198, 0.8862480148990971, 0.883256002119552, 0.8709392108317866, 0.8886852225063526, 0.8824605565173262, 0.8045651861809117, 0.8086098410918574, 0.7863671713221994, 0.7881646147961111, 0.8200972356400965, 0.8102462908485784, 0.7962729667923106, 0.803714510531037, 0.7938559296653833, 0.46491203836211126, 0.43896719199993184, 0.386862772393069, 0.15684918956669758, 0.40924247082796217, 0.16846646142097665, 0.14715155734095786, 0.15844220179031931, 0.3709317919678594, 0.13835415860260414, 0.11576134248203163, 0.13526099521419255, 0.15264339527972892, 0.1232793504041878, 0.3169558296415276, 0.378651181448596, 0.3875843891497921, 0.2567400757128917, 0.8070756981906158, 0.7903011205514303, 0.8074723179050769, 0.8029056928806229, 0.7918866628233466, 0.8023208554192971, 0.8147543662139626, 0.7981072049453635, 0.8202088067035825, 0.6872333768600504, 0.73066202307556, 0.6805563823738283, 0.7472849258120178, 0.7075648682437077, 0.6911406545681393, 0.7319384729439434, 0.7066820820533883, 0.7356081080306258, 0.8632888972757257, 0.8559263638674957, 0.8095375019944997, 0.8816693321601309, 0.8552846148934599, 0.8461421028484832, 0.8258374011539105, 0.23268819514511885, 0.8607679653406454, 0.3287928893928178, 0.18690184535752663, 0.5846845824587121, 0.24190649990222002, 0.2596017930404052, 0.5614112353865355, 0.24719741964400133, 0.2013251639059901, 0.24904255461195146, 0.2649525712001758, 0.19885124213887018, 0.2652651092150631, 0.274442454351117, 0.5960583106609636, 0.6598644098002617, 0.1679344817971885, 0.2011669948228162, 0.2959291854640389, 0.34204305185130024, 0.6753197291999689, 0.36933237069824454, 0.6734647633740108, 0.596725144742546, 0.42265891811275247, 0.6017593669849912, 0.6020118283133565, 0.6692017401447654, 0.7466792973351031, 0.28893479479981765, 0.7490742780183763, 0.7384852710220798, 0.425969597683169, 0.7101480147770272, 0.7571773200629761, 0.7673484909502575, 0.7648382317379306, 0.17252895347084818, 0.10350767408946482, 0.202348540951096, 0.3770350347065532, 0.3810691353731548, 0.18081980584976798, 0.34959069686059907, 0.19230973827012876, 0.17096033974599445, 0.38259468061377766, 0.5783653243768578, 0.48219522955288385, 0.5011624992514628, 0.5517499967606816, 0.5308407547066747, 0.37421613999765724, 0.6057095566312769, 0.5498711223777757, 0.7400803875954067, 0.7258401995405677, 0.8108936038037593, 0.8218641201906699, 0.8360485410746838, 0.7401163809261617, 0.6418039989024694, 0.8489501767885598, 0.637895629918623, 0.13280187009300193, 0.12002485667948581, 0.13031418455752442, 0.14721759459606887, 0.1062668450655625, 0.11308446050613985, 0.10771674015640853, 0.2923185194449387, 0.1045609465906222, 0.12361222258920201, 0.21416572590705862, 0.14446494714276903, 0.18891760731766594, 0.2431219779612166, 0.14580202472116466, 0.1509680192898879, 0.2039457264433352, 0.45215441618002294, 0.620207644315558, 0.6377307658871676, 0.6157658342780554, 0.64422602721412, 0.5875920697022259, 0.43252073431905935, 0.6755822578324113, 0.6540362340401238, 0.6531310429424464, 0.4539617248029544, 0.46599026709194036, 0.4756410221184463, 0.5336208891557566, 0.4368947103967079, 0.5126845310375812, 0.5147017628375439, 0.5058629637920693, 0.5033002827980287, 0.19179706107247807, 0.20352789138590743, 0.18618290129506998, 0.19503720254289791, 0.21124126290745093, 0.1789049966060393, 0.21486363778454365, 0.19382865081240153, 0.19333209695623166, 0.593135486011423, 0.21905472264189052, 0.6498535721840548, 0.6701840840764449, 0.6143504956768202, 0.5479127108540978, 0.6596584519097994, 0.6742552635416823, 0.2308596759683278, 0.8874575984480584, 0.8930556637870563, 0.8059048231758742, 0.8518356073455862, 0.19820947029672364, 0.853277299633688, 0.192168181239045, 0.7954899923822188, 0.8375980195676556, 0.8407044913576781, 0.21075565742910607, 0.20549393314633202, 0.8290661964420709, 0.2075319719021118, 0.7274427916092412, 0.15238308672728695, 0.21214197990596617, 0.8430511137109712, 0.18906384119414932, 0.19905440547153208, 0.1741526577834147, 0.21310328217483943, 0.20027423528422128, 0.18962347926025025, 0.18528360627411944, 0.19482174293438725, 0.19457903285148337, 0.08492469879740783, 0.08659063342866136, 0.07934196961588202, 0.09143580979243393, 0.08605010050211126, 0.07805452437891436, 0.08092417268338725, 0.08368719358904797, 0.07797501664710593]}, "mutation_prompt": null}
{"id": "27c4ff9d-f73a-4bfb-9fa2-233be196039b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))  # Adjusted mutation scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())  # Enhanced variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    improvement_ratio = (self.population_fitness[i] - trial_fitness) / self.population_fitness[i]\n                    self.CR = min(1.0, self.CR + improvement_ratio * 0.05)  # Dynamic CR adjustment\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic crossover probability adjustment based on fitness improvement to enhance convergence.", "configspace": "", "generation": 27, "fitness": 0.3268697943658187, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.7718338293383766, 0.8290365818583526, 0.8820340338048634, 0.8774275145489123, 0.7069287628158125, 0.8625747789329217, 0.8420434203583904, 0.7928408867885672, 0.8342263839885891, 0.0614353272016418, 0.01690607735735561, 0.10221824363455012, 0.08077575911430501, 0.7661744974927901, 0.10007741261159042, 0.08582508236589204, 0.21653358892004593, 0.13226144382156213, 0.02313136461695864, 0.08388373189761988, 0.005375109906600173, 0.09572900867752143, 0.1074742388004617, 0.09287897390656086, 0.10916971897802719, 0.09908417143969295, 0.09963624954886785, 0.5813297147193232, 0.6141697893557014, 0.02597005300984878, 0.10434225379097573, 0.08891692569227638, 0.09104670913914781, 0.1021792156709107, 0.10915718139421338, 0.12901717177678107, 0.10643764958698665, 0.16822650942960404, 0.15566036377171055, 0.7754434644256667, 0.776109672894643, 0.7835854657576296, 0.234473870279862, 0.19712270659537567, 0.20390541206964685, 0.2794976867666722, 0.5780381246557671, 0.2360188445181527, 0.21688999155093247, 0.3331134003763523, 0.3619216801553278, 0.5335714881304732, 0.7139419727578749, 0.4638578513196786, 0.8599923262542926, 0.8818271614838364, 0.8794031378276914, 0.8917981475168438, 0.9042523964148996, 0.8695001917169736, 0.8793888960184291, 0.9002982853048092, 0.8778372221375541, 0.16171080569579266, 0.1939953090635933, 0.31986395582047933, 0.04847449937195847, 9.999999999998899e-05, 9.999999999998899e-05, 0.2720335444390577, 0.15997938685602953, 0.24656236544511934, 0.21244734818400057, 0.1577110958976553, 0.771131862560257, 0.14751149161531263, 0.48719017753165983, 0.2364686157582978, 0.13023162773123387, 0.17064361310755682, 0.1642833806917482, 0.10996591442018722, 0.1314208821917855, 0.10480318834266233, 0.7573174867586674, 0.7991232486831681, 0.7755182338522606, 0.06405569142222844, 0.013840849255573828, 0.04086875377281285, 0.8371436054374484, 0.8312329577944564, 0.8088036870958604, 0.25819056365777193, 0.09811274576586893, 0.1207860079110662, 0.8337812440711708, 0.8429466360976824, 0.8557670815966228, 0.01988616994094139, 9.999999999998899e-05, 0.04905216579988825, 0.11352717313185734, 0.0438457608896633, 0.07621339153276241, 0.22970964975581087, 0.29720255018899755, 0.23432117038864597, 0.23488451067488936, 0.3096428757093682, 0.4411234846852664, 0.09325186763679083, 0.07710277151549139, 0.04883150364319733, 0.056113564170770736, 0.0491112589431727, 0.0328991711544091, 0.54434922395725, 0.1337250632471727, 0.14838054695461433, 0.8367246937596353, 0.09708865527373767, 0.11245591969153246, 0.7929328146781678, 0.8671674023102153, 0.8669318639590262, 0.11304424165232851, 0.11522217328292117, 0.13021762193886932, 0.13802695466760329, 0.1321573833676577, 0.10556227824350795, 0.06669874979754187, 0.11301481710189054, 0.068304274469566, 0.17813337689046982, 0.16940543597453928, 0.2205829837535077, 0.17082483717472352, 0.14729218197938676, 0.15828668999379403, 0.19798915743685785, 0.14894911860422377, 0.20334276473849666, 0.10644843653178937, 0.15498740266924416, 0.14352810184653642, 0.574994872755746, 0.5444965631176948, 0.6974545657369722, 0.5686291051570405, 0.6575772455441127, 0.6536271019529567, 0.20640192711000205, 0.11163852550352582, 0.11529705386730293, 0.4201703530064851, 0.4679443527029691, 0.3524071614604113, 0.40156115566383355, 0.49467741893065265, 0.5317483623847252, 0.23926622712824597, 0.10526324160725165, 0.13345086981233123, 0.1926917500932297, 0.18874204949278894, 0.18941142161135627, 0.2417666564111055, 0.20036413095597616, 0.20516031785589672, 0.14488020110253397, 0.38400713405624687, 0.15385724259514733, 0.23134114615316714, 0.22236328809729378, 0.22149428042253838, 0.2147113989989703, 0.2046253512245707, 0.21068970992906055, 0.8776116978541132, 0.8137000848722856, 0.18522238453085715, 0.17929401330338401, 0.18408417426754187, 0.8350288197102438, 0.6835505270077205, 0.6821285492553226, 0.6297688974011966, 0.7046428318479534, 0.6153781102744604, 0.5714209895109355, 0.16459110851530656, 0.8299829507827241, 0.8006085452617578, 0.11936748669318753, 0.18103895067495068, 0.08419325527841282, 0.17581172454352878, 0.18675818151551848, 0.1734455231984603, 0.18546167490204757, 0.18575368498474532, 0.19162760792595313, 0.19337214711928385, 0.19880617547497992, 0.20723689019676284, 0.08513887880443183, 0.0814804674414985, 0.07431703835106984, 0.07986219983725329, 0.08178564868326355, 0.08315578560082182, 0.09246463770544056, 0.08139911446225045, 0.08320145218557395]}, "mutation_prompt": null}
{"id": "d24fbef4-fa60-48d9-ac79-2cc752a6f68a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.7 + 0.3 * (1 - (self.evaluations / self.budget)))  # Slightly adjusted mutation scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)  # Use numpy's clip for boundary handling\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())  # Enhanced variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.3 * np.random.rand()  # Slightly adjusted crossover rate\n            self.F = 0.5 + 0.25 * np.random.rand()  # Slightly adjusted mutation factor\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive exploration with dynamic scaling and crossover to enhance convergence speed.", "configspace": "", "generation": 28, "fitness": 0.4347590902731775, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8819811611093903, 0.8903799839011354, 0.8820045085838066, 0.893317689076171, 0.8916490561141149, 0.8803140447300076, 0.8897263881112334, 0.8901420095639089, 0.8844876280114129, 0.8059654744749748, 0.8208431581923947, 0.8203610071894387, 0.7995254807206476, 0.8081515798980613, 0.8061478065498708, 0.8228151727804409, 0.815596074536666, 0.818532453815191, 0.5338320179566063, 0.39252209607125177, 0.16434988345580803, 0.5162664754120483, 0.41629049257490414, 0.1546794406926425, 0.49478196224056403, 0.5613605854480552, 0.1563242984021892, 0.1635206684286471, 0.14660702764809508, 0.15735756736493745, 0.14126245841009477, 0.15026733342691345, 0.14688711952717426, 0.14323108794590989, 0.17037414776567805, 0.11728986620728699, 0.9473926041807695, 0.9460807519819066, 0.9756512959392366, 0.9778298378388248, 0.9702356700111227, 0.9655058937252394, 0.9653719631782702, 0.965555253784149, 0.9729700053433067, 0.6326947786250112, 0.709115483683566, 0.7330365697565477, 0.619274022995334, 0.7195698005258397, 0.7520505421272211, 0.5284088661424182, 0.6412842143999291, 0.4782866008646809, 0.820788166437511, 0.824157765809435, 0.7984860679974812, 0.8568628297109, 0.8545073869062858, 0.8455281051792136, 0.8607287386033292, 0.3533073656414275, 0.3521892944400933, 0.15620209113226846, 0.20870208077890973, 0.5985137122757315, 0.19108574200829043, 0.13809675737901694, 0.21242080444120515, 0.19126319899229938, 0.1836455503248069, 0.27344244491985803, 0.24334132941402498, 0.18886868271997836, 0.20195019749889065, 0.15476519741164574, 0.2105298089059836, 0.3082249822629286, 0.19908086073082476, 0.17411422717466862, 0.18313709832045255, 0.6041749680004007, 0.36176307047463097, 0.17513682302080957, 0.4881497681789462, 0.2019991490819253, 0.18691017655067477, 0.5365023271473084, 0.10333372664494722, 0.32239649308389573, 0.48266798590589566, 0.6522546058921179, 0.34218037926081524, 0.4735299683982952, 0.46818472704755043, 0.4442115515949495, 0.7192440849564474, 0.5200449072496884, 0.6763058462053846, 0.14192365823442088, 0.20157150448744476, 0.13794130882364097, 0.2236104760544544, 0.1790408886095285, 0.10068527245762693, 0.1303208018804176, 0.329199979300007, 0.16397392957566226, 0.45030833257989566, 0.3517447299480029, 0.34799810690392674, 0.5104257317920438, 0.43403424496554865, 0.4313050544528444, 0.37026656289701876, 0.44006067322227627, 0.49276835243691064, 0.7067136526213259, 0.8203901727031766, 0.8047345352054699, 0.6541067935833569, 0.8286473342477259, 0.6389796125920986, 0.7505790732168157, 0.778059976805456, 0.74318753795582, 0.09465717327336953, 0.10692770895542947, 0.1398373748147047, 0.09943516367098959, 0.11097103773387662, 0.1551078663663339, 0.12162900192621073, 0.10171989541374371, 0.102978985263386, 0.15340669391185546, 0.20191850584042514, 0.18962349657385213, 0.1464171218384357, 0.1724075498975488, 0.2108489942736015, 0.26985338527582636, 0.17245384116674778, 0.12357193121484655, 0.6304956374916904, 0.6207393337642622, 0.6135721496764744, 0.6535510473862906, 0.5992367075690106, 0.5304453552475857, 0.7104695198563669, 0.712606289379394, 0.6893250351610491, 0.4492442858162975, 0.46417368836168293, 0.4698719488884905, 0.4943913402623812, 0.5099857792725232, 0.5014113206456086, 0.4786116800927349, 0.4451139217499318, 0.5039840190232328, 0.20066531593045844, 0.18679546661067403, 0.20829718361252203, 0.21096455583813067, 0.19880999296465662, 0.20677258909566587, 0.19530687990247164, 0.18380808162965023, 0.2157639916022558, 0.6738158044811806, 0.2146267453057068, 0.2374978965260195, 0.5955317198136729, 0.6493627463276064, 0.22193989398522806, 0.5435365535612491, 0.1862528655736262, 0.6740266202439386, 0.8576073456150471, 0.18309417436222652, 0.4445647606926665, 0.8582483703876259, 0.1818373693646883, 0.7542283795841309, 0.17587649618431445, 0.1608680477180653, 0.7832949670379687, 0.7587719434321747, 0.818962369251871, 0.16736498630601837, 0.20132839556304694, 0.1575136481480125, 0.20773435979301158, 0.2061393324463947, 0.21393920673186562, 0.7634915636590986, 0.1788045904543316, 0.18682585886206193, 0.18813146063093933, 0.18585299704635982, 0.17818014347924493, 0.187339476767602, 0.19109463162686502, 0.191429595630638, 0.18935903518058017, 0.08043618555344823, 0.08512279909245812, 0.08568803339797193, 0.07450079786444608, 0.09117736197205317, 0.0789316684456417, 0.08432518178504356, 0.08682256650893305, 0.07933700326247783]}, "mutation_prompt": null}
{"id": "4ec300d7-1751-46de-92fe-b078aff3547c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.66 + 0.34 * (1 - (self.evaluations / self.budget)))  # Adjusted mutation scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())  # Enhanced variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:  # Elitism applied\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved trial vector selection by incorporating elitism and adaptive mutation adjustments.", "configspace": "", "generation": 29, "fitness": 0.47148578271748676, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8858818264288757, 0.8761446439854638, 0.8711872422291, 0.8717574379593013, 0.8871532321445336, 0.8806599251377951, 0.8871361069161177, 0.8897013663901997, 0.8821624318579838, 0.7987627620591371, 0.79924642334758, 0.7916819220512015, 0.795048682984931, 0.8100051141803657, 0.8116585983771057, 0.8050878675480102, 0.8056851405981906, 0.7858062603805184, 0.37971484370571307, 0.324435502838582, 0.3116375474147971, 0.46520325617592817, 0.14391044552735133, 0.26497431184565345, 0.22866461356966583, 0.39557173889063035, 0.14572031004614694, 0.14020296429836432, 0.13501592611099145, 0.18582596676733187, 0.1436330723786463, 0.1601072652637544, 0.154587142703286, 0.1289447227882352, 0.14295878132470297, 0.13371456695854467, 0.8210138170461605, 0.7905537192619969, 0.7929735226084482, 0.7764941123957876, 0.7990513997908231, 0.7951962874627778, 0.8079824068775483, 0.7994570604907687, 0.8069210384282165, 0.7038940862897582, 0.7011757651269539, 0.7116916083628073, 0.7184441129571428, 0.690344391976393, 0.6979121088922235, 0.7441588148246385, 0.7356521478024085, 0.6580887374574265, 0.8319908688872482, 0.8207771396393464, 0.35951998294398624, 0.8862541097559974, 0.8698679553430805, 0.8860473331084847, 0.8336999753958468, 0.8493819170054808, 0.8499220345794056, 0.31905088024963923, 0.22483535791760445, 0.1965449074368304, 0.25199238235718635, 0.3265294614260329, 0.6398590081368329, 0.24159738219932758, 0.7459443146909888, 0.3694494399272632, 0.16202848985398288, 0.2313084602951222, 0.23276511306894787, 0.2908099344639492, 0.28802591138867895, 0.20175148990640412, 0.18595053905703396, 0.28388304213106996, 0.30950589744728374, 0.5866033864544345, 0.727517147034447, 0.4683530494792264, 0.677172059400747, 0.6080069940332643, 0.5553028157432482, 0.44862019032765743, 0.6574753137195931, 0.6394702426529966, 0.7340631307989801, 0.7023547301370217, 0.7208075203907338, 0.7466252134490832, 0.6136520390305207, 0.65943153383974, 0.7462146899551081, 0.7819974161485085, 0.7590300845435017, 0.14303123436766707, 0.17528167139528028, 0.15428204155111236, 0.3166632233491887, 0.3166833833216455, 0.2547231824632695, 0.20870912482853687, 0.1628515764721684, 0.17126537886827953, 0.408620820598805, 0.4418489645295728, 0.4557418864641579, 0.5791450291989524, 0.5674653648281616, 0.39083710110441683, 0.5510834621294718, 0.4689228798892061, 0.3002053379654358, 0.8093545940482927, 0.8422406928633182, 0.6846622790459784, 0.8440743210362679, 0.8505320310633352, 0.6120292830441836, 0.8103655424799615, 0.8321147514905576, 0.6347143217252558, 0.1002110358555468, 0.3028051344110462, 0.11639146865910066, 0.11995096840633468, 0.11806090258922086, 0.12068488407433198, 0.11592768578429313, 0.10356301807324453, 0.10947039998006824, 0.12730782694419573, 0.13304751351077826, 0.21358350595275444, 0.14898278588751523, 0.14945112822830975, 0.17577491559145764, 0.1249465511243466, 0.14282330824938128, 0.18607536338141395, 0.5912390364295385, 0.5964194440420734, 0.6202520095004487, 0.5939172377586697, 0.620016579037393, 0.6140287494842136, 0.6514210648417688, 0.6295241110516689, 0.6514705326571821, 0.5346592350412329, 0.3518601590089816, 0.4710335974113653, 0.5352526433137219, 0.5106735458826199, 0.3830233430706479, 0.5485979518904193, 0.5120131053579895, 0.5389524584488747, 0.18428695178514132, 0.20295664143581849, 0.20751683003512134, 0.1945847953642581, 0.18690584021285772, 0.19625991391278041, 0.22717123144336715, 0.19912511610228845, 0.2515740157301064, 0.3922371088867841, 0.24188811426051182, 0.2007248167908574, 0.6464492992746163, 0.5949664458427506, 0.5357046093336713, 0.5727853768843564, 0.612582728437163, 0.39873277331352586, 0.8817051539076624, 0.8869812042285352, 0.8069916018462291, 0.8531143258397625, 0.19826238532823048, 0.8476440493712748, 0.1740035954143122, 0.8073196057018343, 0.8384479481241727, 0.8431583272699771, 0.2107536186958857, 0.2055208966408174, 0.8303549819750846, 0.20752827316218292, 0.7786301157382708, 0.15224889264364083, 0.2123561661785267, 0.8424487390031401, 0.18603323035359465, 0.184516270230355, 0.17991135687265214, 0.20825902733882673, 0.19421707348288786, 0.17745044105937813, 0.21813394315922807, 0.17232418275789585, 0.18847391256416024, 0.10179702547985103, 0.07651672879865978, 0.08312521068327894, 0.08090369894109828, 0.08211839830518475, 0.08551686019113769, 0.08736126762429774, 0.0831726351592933, 0.08372664581633238]}, "mutation_prompt": null}
{"id": "0af11b04-babc-41d9-84c0-8325f1879c9d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.10 * np.random.rand())  # Reduced variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.3 * np.random.rand()   # Adjusted crossover probability range\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved diversity management and convergence by dynamic adjustment of crossover probability and mutation factor.", "configspace": "", "generation": 30, "fitness": 0.44533645537273625, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8770661123882054, 0.8798056820641451, 0.8709221351990913, 0.8813810975752895, 0.8814702036556886, 0.8883633477208731, 0.8617080830514244, 0.8875829274723296, 0.8733460108952273, 0.7943950523114548, 0.7782841716054231, 0.787294326928543, 0.7854743380430917, 0.7951346594878922, 0.7849215329642911, 0.7906845339278291, 0.8002514560063951, 0.7960975682721524, 0.38427037221273197, 0.482873699760038, 0.3367441055710487, 0.541304640742122, 0.4639884271062138, 0.4934002478587083, 0.16606659243262623, 0.3725234722920312, 0.3368065266855458, 0.1472842915213579, 0.1494046574188045, 0.14959518294062435, 0.46845620866943527, 0.1595704797308517, 0.15629187457876048, 0.13033442524212402, 0.14159243979215352, 0.1262229048965502, 0.8217923412410101, 0.8031390720636513, 0.8041651126780216, 0.8137555608037879, 0.8196642797027361, 0.8035516475717943, 0.8125368434844457, 0.8008541911741147, 0.8232529487199112, 0.6894768248042866, 0.6756001409489623, 0.7138023439652734, 0.6630519210221895, 0.6747263041893177, 0.7012719415663979, 0.668313309063458, 0.7228636243385613, 0.6542200550918802, 0.7869594035127395, 0.7913459456931271, 0.7593881217815424, 0.8168765728329727, 0.8320909731288674, 0.8018126256131785, 0.8060039042266921, 0.8567291192458082, 0.8289981120903326, 0.2132508149658091, 0.18071131320873524, 0.2878301034129618, 0.5868104574961621, 0.2699961316054412, 0.25401024744554523, 0.2783487169223261, 0.2770279637829052, 0.22173748539923976, 0.3253883288742848, 0.20640020337474818, 0.24710814173981777, 0.30411865143201144, 0.3550188942804865, 0.5511696455309085, 0.28932279754633805, 0.2768513133064031, 0.47265866728125816, 0.375184493023215, 0.24706110155403582, 0.5277980489026621, 0.49917315243809657, 0.3904787734866013, 0.27151214389653777, 0.45188363028830103, 0.3959153482814324, 0.2878716145144099, 0.6066100310041296, 0.386731544777303, 0.4333839911945039, 0.286125160974518, 0.6037601409161575, 0.579299677309925, 0.652813319094875, 0.682235339482167, 0.6397760814468199, 0.15943379717784845, 0.258052009558308, 0.28151220786599396, 0.16384214151749255, 0.20413786424414493, 0.16625451209257558, 0.28861812588739333, 0.2771210494340881, 0.17919186118361463, 0.33746952865797875, 0.4585906849162703, 0.4331409429048618, 0.40066940177949384, 0.4179612481091187, 0.494836568740452, 0.36859646275399627, 0.40479169266572235, 0.4192276067166858, 0.8009238407661381, 0.6640401623524049, 0.8049866361575313, 0.7530908889849859, 0.8123281373382121, 0.8048304227594033, 0.6344547940168783, 0.7313046019161509, 0.74082042650431, 0.09611189176377066, 0.11939666145605499, 0.11479676507004422, 0.11934104906310894, 0.09386060891590664, 0.1043121680334147, 0.14764113208305085, 0.16674093331729067, 0.1294821147306231, 0.15638813380731065, 0.15219602685568878, 0.13547368487276412, 0.1646291927407466, 0.13542319570098205, 0.15711167978060947, 0.1421695352104222, 0.43281131438932474, 0.3529145098836126, 0.5478270281280606, 0.5859936679882265, 0.6062022853978568, 0.5307959340328816, 0.484343023412099, 0.5478674539840296, 0.6635223117788143, 0.6021737820397279, 0.6243198782396719, 0.38348615722833124, 0.4175932568689703, 0.43338704680836737, 0.3633761965821479, 0.441613184316621, 0.3969327736424795, 0.4165166174247388, 0.4233183021371675, 0.5135494109342091, 0.2135922067356667, 0.19083433700083619, 0.1743430348513897, 0.18340496297516573, 0.19330305605721454, 0.2379159249539815, 0.20071215805900733, 0.21940694616087997, 0.19084213185189203, 0.6436966157357514, 0.6552535771429793, 0.23009160389040761, 0.39869282249872373, 0.2257528259628928, 0.5058580559364627, 0.45342943563735294, 0.5178059448474018, 0.2098713599313543, 0.8761353327935109, 0.8518329793746847, 0.15166775638696506, 0.857655862894227, 0.7775523378821176, 0.7943349723464681, 0.17226104174832357, 0.7190360461201415, 0.7025436895333179, 0.20507087490613451, 0.20534059683700967, 0.20086924583206855, 0.8217323696796992, 0.21111008458010017, 0.21052843893591633, 0.1558223983359529, 0.15242260316350909, 0.7859843575750709, 0.20193423735211324, 0.17748927997950814, 0.18357896382342487, 0.18069063703892718, 0.18933459573391076, 0.20154283286372943, 0.18691503877875082, 0.19776800377352388, 0.18912979469536317, 0.08549645997084354, 0.07405405794250042, 0.08289905864414226, 0.08110432170720883, 0.09269994083987954, 0.07904924069094854, 0.07982376159001159, 0.07894849968492257, 0.08713062085836465]}, "mutation_prompt": null}
{"id": "cae19eac-22a5-4706-bb82-e79bc7b10e8e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                current_best_idx = np.argmin(self.population_fitness)\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = self.population[i] + dynamic_F * (self.population[current_best_idx] - self.population[i]) + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Implement \"current-to-best\" mutation strategy for enhanced convergence speed.", "configspace": "", "generation": 31, "fitness": 0.47422287280393316, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.32.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.9437394171119796, 0.9348656177259291, 0.9387729508156226, 0.9455587794975499, 0.9445603293447917, 0.9462827185878985, 0.938306796252626, 0.9411695969606093, 0.9341155222934098, 0.8969888552911328, 0.8950268390465534, 0.8865907040312004, 0.8729865627245623, 0.8873483484891406, 0.878007267201741, 0.868363369921766, 0.8779837037420747, 0.8897472541847936, 0.4065935375614915, 0.12755429074364943, 0.14641170311097718, 0.13766635822464646, 0.25636835584638085, 0.15187699013403777, 0.14738168984993227, 0.17369836871280786, 0.15559204112310365, 0.2305157794635202, 0.1266118264723416, 0.1289002608257197, 0.1330255730069534, 0.11441042315038319, 0.12939139513162956, 0.15559688037156572, 0.1388961830230664, 0.12240592527143002, 0.9105085079660991, 0.8806493006571111, 0.8955185524724724, 0.9028308611390012, 0.9040874414880888, 0.9115339512963685, 0.8918924649180389, 0.8955978586549678, 0.911717658100903, 0.8343245346688453, 0.8548226996114874, 0.8601043728077751, 0.8607675168357164, 0.87160121418282, 0.8784680353802987, 0.8696586229902235, 0.8852537197597787, 0.881885695728281, 0.9381498193324684, 0.9270346891849028, 0.228332283026907, 0.9383973563310362, 0.21275616275023312, 0.9347249892249808, 0.9215189215652484, 0.9338035990528054, 0.9382995064402367, 0.4630476351660231, 0.7165347205995218, 0.7741608111447335, 0.7683222556719376, 0.3205308867899913, 0.19833705009044167, 0.703845719378723, 0.22718109062958947, 0.13638981100367586, 0.7531971646212847, 0.22885127313386167, 0.8607049204811993, 0.6775646352073429, 0.7612630792943744, 0.849895211260976, 0.8303262268685241, 0.1914303270677652, 0.6971649486485385, 0.5102131446515431, 0.4375722551942799, 0.31995395640235214, 0.8265386888295501, 0.17957298838954716, 0.46904009486594656, 0.1905832436139182, 0.18330342114800113, 0.30069996547282785, 0.8542047690883084, 0.3083568651417471, 0.4873069002273245, 0.8857595045758594, 0.8628320863454388, 0.15633203853553457, 0.2786721136843714, 0.19621157618019602, 0.8756472058099137, 0.09749816399854827, 0.11283950198040948, 0.3783944653624781, 0.45033288662200877, 0.23499036193088374, 0.19388459036707706, 0.48976534742409805, 0.20066721136107657, 0.511098214878414, 0.4272791742297466, 0.3822431551224089, 0.4467236611836991, 0.8122814402393662, 0.3960453470027997, 0.6442165583654222, 0.6880138247726986, 0.37879765159834855, 0.61630572581798, 0.9078954171405891, 0.7642195526145434, 0.8469005563310857, 0.9050872468585787, 0.9165286779172247, 0.8044345034816006, 0.7627378175020352, 0.9141004819734052, 0.9116576426461169, 0.12998167323135035, 0.13924626207159452, 0.13267102664878205, 0.14606942669099832, 0.11562876171762326, 0.17576504934655335, 0.1367813746212383, 0.13354619340004248, 0.12386966529119348, 0.20358003953675774, 0.3578862408003214, 0.2143502386539371, 0.1838680271240215, 0.1672779984422954, 0.17353330577716242, 0.18307978948845272, 0.14352964922273292, 0.19465380828707934, 0.5111316675449773, 0.45702598693582963, 0.6412960198469451, 0.5961541717626305, 0.6777794335050118, 0.6725222516331404, 0.7878434579541956, 0.6726811509512118, 0.8138522257852487, 0.43707134768432465, 0.5784998230446456, 0.3071774421649146, 0.4059855509567444, 0.24841942875779988, 0.620009584590391, 0.3690598913626183, 0.40149877537931933, 0.5190563414761818, 0.20630038138313678, 0.19607565014908745, 0.19594195655493785, 0.20723283430354067, 0.2120125827471735, 0.20077715080109426, 0.2134674169138876, 0.207421991013636, 0.21139583282773222, 0.2477940918210142, 0.18674952028887049, 0.20502866912487028, 0.823703513757158, 0.2478747454118132, 0.2510141827843745, 0.21275439094254267, 0.2463941495958486, 0.20752630716176435, 0.9023671345102621, 0.17944345072683443, 0.18519429808313803, 0.9054043372829466, 0.19931767381427423, 0.8911728964313044, 0.15347259504455868, 0.16872987491976454, 0.1594643344467187, 0.15661938633045536, 0.853116468958967, 0.1693551618185185, 0.16840153728353258, 0.21087388297419285, 0.8993703738324933, 0.16840452097897562, 0.1613643328666069, 0.15664392596321464, 0.1852991212819609, 0.1839798863967692, 0.1968101111952485, 0.17730955807652482, 0.1826877780166979, 0.20296782260327273, 0.19663825387214928, 0.17674676640528764, 0.1975482265982963, 0.09881533254698371, 0.09641730738540732, 0.08548265376399145, 0.09382474031868371, 0.08434861569407825, 0.08263804190842272, 0.12640981725382483, 0.08834558124397696, 0.08126596079855064]}, "mutation_prompt": null}
{"id": "ea1e6698-f831-4bdd-8621-25ca65aa6aa9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.7 + 0.3 * (1 - (self.evaluations / self.budget)))  # Adjusted mutation scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * (0.85 + 0.05 * np.random.rand())))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adjusted the dynamic scaling factor and added adaptive population resizing for enhanced convergence.", "configspace": "", "generation": 32, "fitness": 0.4638359815191469, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8700785222725982, 0.8753202997590667, 0.8587548767445629, 0.8823604473222235, 0.8707559562383175, 0.8779310209532103, 0.8626922685912521, 0.8787922034891327, 0.8636451851684432, 0.7866600784860793, 0.780228376601234, 0.778677219795615, 0.7805236991859861, 0.8063391192691198, 0.8015861998409768, 0.7760227398539928, 0.8047835080560608, 0.7996433828871539, 0.30539848685326654, 0.5286747253196267, 0.4865031121832868, 0.43547438754620305, 0.39052828891975255, 0.47090362543623276, 0.4988276290131006, 0.6068356410439042, 0.32978448684888984, 0.1481126168522212, 0.14249864860691452, 0.13917520359719326, 0.15340475276024923, 0.5282152420021621, 0.16081819658053842, 0.13128739793512556, 0.3959092140962722, 0.15044253420301867, 0.9542086525613407, 0.9585801979730112, 0.9604460038117805, 0.9624411160793207, 0.9768212490947618, 0.9791339591503089, 0.9500746605744774, 0.9740013858381793, 0.9699310471545178, 0.6997827216509553, 0.6834315614438262, 0.6751761782363077, 0.6597322749266332, 0.7074560055967296, 0.6931669377265179, 0.08837510533719417, 0.6929305347053193, 0.683180269141727, 0.8358489711852743, 0.7981810173943079, 0.7532143524782813, 0.8340711508354718, 0.822810099186929, 0.8463221087068195, 0.8388705099581506, 0.8141670093235913, 0.8130848008864595, 0.44067842807296165, 0.5125656826280683, 0.3340925725356265, 0.5858041407946706, 0.5596706411110227, 0.2762376394321866, 0.17086648641664726, 0.3722708841946003, 0.22575521586413771, 0.009940043435877177, 0.11872093394920447, 0.016534293391756938, 0.31199970966813895, 0.3028454930544, 0.35555052488399885, 0.31929655763107434, 0.5767737838666294, 0.2582927740432077, 0.5292627547081015, 0.6053251904719974, 0.495126789349824, 0.5303946539736415, 0.19482065665603254, 0.5147142351050495, 0.6153437972306959, 0.5807005860697252, 0.5809222825813354, 0.576513125862326, 0.6815369062139769, 0.6108592958317046, 0.19345692942354364, 0.6281344350441348, 0.49894841842950943, 0.6483187607111219, 0.4639889827269652, 0.64670097583464, 0.2450163569225423, 0.15517700767468212, 0.2291309322770564, 0.2648898432926732, 0.40294722317178755, 0.3756575398917801, 0.26477485744049833, 0.22949237923677013, 0.31445561975668657, 0.3849898666608491, 0.40393875520730427, 0.383461337542337, 0.4494881193317013, 0.40806691163302666, 0.41386916576695976, 0.3786281200831575, 0.42895886482661094, 0.4176475865157122, 0.7549315419327111, 0.7214947879053373, 0.7790860326214164, 0.783162327169785, 0.8172959287389217, 0.7672158032548209, 0.7884303334620866, 0.813923724322107, 0.7040631505012163, 0.09861458245962185, 0.10106832350491202, 0.10274909972445034, 0.11105994548808595, 0.11422938310205222, 0.33667169730907653, 0.11540149366558194, 0.11898640195288412, 0.11082657209399405, 0.165922381952467, 0.13970313637531995, 0.16911731204223723, 0.1711387220245295, 0.15595920649521644, 0.1451121420756385, 0.24230500029421176, 0.13297504770058677, 0.1314554547885911, 0.5063799305614236, 0.53815184757103, 0.4624414864013544, 0.5249910548903345, 0.5574811619017638, 0.5214413764145767, 0.6084189490743387, 0.6149201349764043, 0.6034652656268769, 0.4011208664653011, 0.47251548030083335, 0.3566590881050977, 0.3684035950548733, 0.36864458569570135, 0.36803640702032037, 0.46365135465580165, 0.4419745186110634, 0.3837850966664197, 0.18230393565251868, 0.2197713888839673, 0.19472931476262456, 0.18503024188718165, 0.19301996827423185, 0.2086257684958569, 0.23299169369156203, 0.18101625319544767, 0.21154183723147324, 0.4856531729790663, 0.4897344293342618, 0.48559427486108186, 0.21989013880486585, 0.5918829909539247, 0.5806109295753089, 0.3724056720140514, 0.6707284100076649, 0.6350565266243025, 0.8605576698574087, 0.7319921710120673, 0.8169045511978109, 0.22320327565333442, 0.2802386668948794, 0.18503867558317766, 0.7507122932011423, 0.1643376259068362, 0.8081464897898236, 0.71671708784597, 0.1675209833862349, 0.8000763457881541, 0.7583256059909018, 0.5396930498959693, 0.20091013008794645, 0.21169672459217792, 0.8554302457309426, 0.1542144359554053, 0.20616388930170215, 0.18037712345739887, 0.188458863163934, 0.19145835058319094, 0.18134853037883736, 0.20115496407942446, 0.1883253841210052, 0.1729424749516375, 0.18631075094169136, 0.07887277088156897, 0.07974432602964299, 0.07450013334230166, 0.07846432872920961, 0.08044190020085895, 0.07457124824071837, 0.07539856780335286, 0.07696565992006321, 0.07480378975639901]}, "mutation_prompt": null}
{"id": "b2147581-7ce6-41bb-8a8c-08ad4d3e1b2e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))  # Adjusted mutation scaling\n                dynamic_F *= np.sin(gen_counter * 0.3)  # New adaptive scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                chaotic_factor = gen_counter % 2 == 0\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * chaotic_factor)  # Chaotic crossover\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introducing adaptive scaling of mutation factor and chaotic map crossover to improve convergence speed by 1.7%.", "configspace": "", "generation": 33, "fitness": 0.30214112104601204, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.9099337265328935, 0.9209631845343801, 0.9272092499879712, 0.9071047230358943, 0.9200053842934293, 0.9256718733782549, 0.9147251125028075, 0.902841800169083, 0.34683751483468006, 0.4451385621464665, 0.13095852847028477, 0.4848336203893372, 0.8427594696595256, 0.8558781445053479, 0.696570633441295, 0.4984486162822158, 0.8841090140995067, 0.5210476019479355, 0.18176701572393916, 0.4736174366758894, 0.1852920740121895, 0.1826064417347667, 0.15659890369908958, 0.13918480885397844, 0.15470780382180893, 0.12276399053027343, 0.16130070575979694, 0.15613441135192585, 0.1528098663815619, 0.13263389534921277, 0.12393912743740254, 0.10934790726416233, 0.11140302184968132, 0.18155061746594714, 0.15393549980252774, 0.157170234441399, 0.4770251830151099, 0.5578465339708146, 0.48957431635887927, 0.3782787885073532, 0.2790722599533275, 0.8163929608614082, 0.5358093244913277, 0.44941958222969214, 0.7685078308292238, 0.15903536641739213, 0.1859601827840215, 0.25011341542301824, 0.3006455164150368, 0.10501333343500263, 0.16219449474322212, 0.1468030224966249, 0.16146687068008891, 0.2555424403242943, 0.21659889739567728, 0.8890243257871795, 0.21228264202754832, 0.2680079660814566, 0.9189662508926437, 0.33409919718377235, 0.35978156363259384, 0.2304947521393722, 0.9078549942419627, 0.1313089275024084, 0.1739002121007821, 0.14145154693911832, 0.15989108433089005, 0.1383762828450983, 0.1588505939405861, 0.14200101164037382, 0.25330321296215663, 0.15254058928558079, 0.10485934071934222, 0.16647280923259877, 0.1440710318437426, 0.14362842429962275, 0.14569293822703688, 0.13446495547537252, 0.16280365908579986, 0.19578224536217892, 0.14806016301197578, 0.059333869964020236, 0.1270585352523389, 0.20001301370527913, 0.044354902043413635, 0.0811639952951404, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.3506016612996318, 0.1409099721886964, 0.15306805651480337, 0.10408935161975674, 0.05641898971917103, 0.03387853724921008, 0.3012343131906624, 0.11756658653341234, 0.12355776047035816, 0.25287916191615367, 0.07422441313283212, 0.27728245689691566, 0.11019753904294771, 0.11191615130252353, 0.4209877462939574, 0.16848392798651934, 0.11040459763540911, 9.999999999998899e-05, 0.3688915819755729, 0.271990111441458, 0.27980961497330037, 0.0014348039562536163, 0.19430236571833193, 0.3116478294557742, 0.286692894157877, 0.0977370301688314, 0.3485553133833368, 0.7106728300098972, 0.3736452564768208, 0.5419805639252362, 0.5299583958476363, 0.54028612608367, 0.4857794475568694, 0.5355100093992143, 0.47998180445531136, 0.5683681732270265, 0.0930885559886574, 0.10798936065351827, 0.14249399206223679, 0.5284164056476008, 0.12354336739758476, 0.12670306702907796, 0.14318170758531668, 0.08227548186739042, 0.14114861559166803, 0.42521276304386413, 0.2796120668533004, 0.22285375381263817, 0.3483258170494594, 0.25565432514082775, 0.32446993963397275, 0.2041996407335439, 0.2508456952676549, 0.25970535897955727, 0.3499458329324807, 0.39900307924851364, 0.4507363942307132, 0.38295031971257354, 0.2817157599072001, 0.42529187962534265, 0.45011194548369726, 0.4183811621657111, 0.5349964729665908, 0.2625305599747366, 0.26151252997669616, 0.3431350168117646, 0.38772332094006623, 0.2829838524272461, 0.2946408247795873, 0.2535066592456243, 0.3533845630393635, 0.41650025230973065, 0.23371439198342436, 0.23835386927800983, 0.20087933937701896, 0.2247188038261697, 0.20895913287956303, 0.26504896168369696, 0.2002570167230684, 0.2401794345380205, 0.22343045577298115, 0.2508140468506338, 0.5861964517708018, 0.22505536651686586, 0.22565788521628727, 0.2501246352266895, 0.2085637778272189, 0.25158124860087483, 0.2544583450333273, 0.24635868037972408, 0.15825168175403814, 0.9320418328604887, 0.15399147465242424, 0.9363498179285039, 0.1996824644930012, 0.4639798657275386, 0.1856928949499188, 0.16975565041799456, 0.9104631923650571, 0.7293019937904213, 0.1686991536476833, 0.5446745868449917, 0.3304940100393122, 0.21217696387187723, 0.8365044584009664, 0.21017128158962461, 0.24377463146074152, 0.09422635040250948, 0.19487498415801408, 0.1802186047790224, 0.1709296025325988, 0.16200980710661605, 0.18863148024825382, 0.20622549330112605, 0.2251365942777186, 0.19842261475051282, 0.19308762827753256, 0.09501299635208671, 0.08978546088227746, 0.10052716633334735, 0.09443220373781169, 0.11252722795556802, 0.08682818181778529, 0.11673818840878813, 0.09431143461945646, 0.09698673264796998]}, "mutation_prompt": null}
{"id": "65ae4603-28b3-4c5d-8537-a86b1f563a06", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n        last_improvement = 0\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n                last_improvement = gen_counter\n\n            if gen_counter - last_improvement > 50 and gen_counter % 10 == 0:\n                self.pop_size = min(40, self.pop_size + 5)\n                added_population = np.random.uniform(self.lb, self.ub, (5, self.dim))\n                added_fitness = np.array([func(ind) for ind in added_population])\n                self.population = np.vstack((self.population, added_population))\n                self.population_fitness = np.concatenate((self.population_fitness, added_fitness))\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population resizing based on convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.4682039157963214, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8810221499453622, 0.8761957455712175, 0.8651602090504003, 0.8731619023673198, 0.8862480148990971, 0.883256002119552, 0.8709392108317866, 0.8886852225063526, 0.8824605565173262, 0.8045651861809117, 0.8086098410918574, 0.7863671713221994, 0.7881646147961111, 0.8200972356400965, 0.8102462908485784, 0.7962729667923106, 0.803714510531037, 0.7938559296653833, 0.11694187505162812, 0.43896719199993184, 0.13026137373269286, 0.15684918956669758, 0.1464413902144015, 0.22032452356906373, 0.14715155734095786, 0.1346361275968897, 0.10700540733682973, 0.13413405779558907, 0.11389657404431508, 0.13526099521419255, 0.1300159450542273, 0.1232793504041878, 0.3169558296415276, 0.378651181448596, 0.3875843891497921, 0.1284049916363561, 0.8070756981906158, 0.7903011205514303, 0.8074723179050769, 0.8029056928806229, 0.7918866628233466, 0.8023208554192971, 0.8147543662139626, 0.7981072049453635, 0.8202088067035825, 0.6872333768600504, 0.73066202307556, 0.6805563823738283, 0.7472849258120178, 0.7075648682437077, 0.6911406545681393, 0.7319384729439434, 0.7066820820533883, 0.7356081080306258, 0.8632888972757257, 0.8559263638674957, 0.8095375019944997, 0.8816693321601309, 0.8552846148934599, 0.8461421028484832, 0.8258374011539105, 0.23268819514511885, 0.8607679653406454, 0.3287928893928178, 0.18690184535752663, 0.5846845824587121, 0.24190649990222002, 0.2596017930404052, 0.5614112353865355, 0.24719741964400133, 0.2013251639059901, 0.24904255461195146, 0.2649525712001758, 0.19885124213887018, 0.2652651092150631, 0.274442454351117, 0.5960583106609636, 0.6598644098002617, 0.1679344817971885, 0.2011669948228162, 0.2959291854640389, 0.34204305185130024, 0.6753197291999689, 0.36933237069824454, 0.6734647633740108, 0.596725144742546, 0.42265891811275247, 0.6017593669849912, 0.6020118283133565, 0.6692017401447654, 0.7466792973351031, 0.28893479479981765, 0.7490742780183763, 0.7384852710220798, 0.425969597683169, 0.7101480147770272, 0.7571773200629761, 0.7673484909502575, 0.7648382317379306, 0.17252895347084818, 0.10350767408946482, 0.202348540951096, 0.3770350347065532, 0.3810691353731548, 0.18081980584976798, 0.34959069686059907, 0.19230973827012876, 0.17096033974599445, 0.38259468061377766, 0.5783653243768578, 0.48219522955288385, 0.5011624992514628, 0.5517499967606816, 0.5308407547066747, 0.37421613999765724, 0.6057095566312769, 0.5498711223777757, 0.7400803875954067, 0.7258401995405677, 0.8108936038037593, 0.8218641201906699, 0.8360485410746838, 0.7401163809261617, 0.6418039989024694, 0.8489501767885598, 0.637895629918623, 0.09602179713743153, 0.4483178150648338, 0.13031418455752442, 0.11552678896475299, 0.1011162727612529, 0.13516131191993863, 0.10351344098735138, 0.12135890842253283, 0.09211035489682595, 0.15622092595744197, 0.1310790213772811, 0.1382080608277314, 0.13736296221945266, 0.1493495905652228, 0.12480341614566237, 0.14261084844193606, 0.13583929206798695, 0.20097617560008652, 0.620207644315558, 0.6377307658871676, 0.6157658342780554, 0.64422602721412, 0.5875920697022259, 0.43252073431905935, 0.6755822578324113, 0.6540362340401238, 0.6531310429424464, 0.4539617248029544, 0.46599026709194036, 0.4756410221184463, 0.5336208891557566, 0.4368947103967079, 0.5126845310375812, 0.5147017628375439, 0.5058629637920693, 0.5033002827980287, 0.19391886991137142, 0.19534825586395832, 0.19551771959589626, 0.20908643803917326, 0.19209591563846085, 0.2080482797284362, 0.20613574122041434, 0.1750051200659931, 0.16915089914236703, 0.19524811981970602, 0.21905472264189052, 0.6498535721840548, 0.6701840840764449, 0.6143504956768202, 0.4513712527749911, 0.6596584519097994, 0.6742552635416823, 0.2308596759683278, 0.8874575984480584, 0.8930556637870563, 0.8059048231758742, 0.8518356073455862, 0.19820947029672364, 0.853277299633688, 0.18975148445294088, 0.7954899923822188, 0.8375980195676556, 0.8407044913576781, 0.21075565742910607, 0.20549393314633202, 0.823527790805427, 0.2075319719021118, 0.7274427916092412, 0.15238308672728695, 0.21214197990596617, 0.8430511137109712, 0.16883951714209344, 0.1967444451573821, 0.18927315952299395, 0.2149853199992876, 0.19182769020185098, 0.1729847458525936, 0.18223574826890743, 0.20267119228652908, 0.23448372394478734, 0.08078522077669859, 0.07612823940056934, 0.08073122686129319, 0.09039451130165876, 0.08830329138168969, 0.07888090021912508, 0.07356843431293913, 0.07741342252781491, 0.0761975158503625]}, "mutation_prompt": null}
{"id": "7313abbe-8417-4d5a-8875-9e01847f4e93", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.stagnation_counter = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n                    self.stagnation_counter = 0  # reset stagnation counter\n                else:\n                    self.stagnation_counter += 1\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0 or self.stagnation_counter > self.pop_size:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n                self.stagnation_counter = 0  # reset after reduction\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic adaptive population resizing mechanism based on stagnation periods to enhance convergence speed.", "configspace": "", "generation": 35, "fitness": 0.3460550399399988, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8810221499453622, 0.8761957455712175, 0.8651602090504003, 0.8731619023673198, 0.8862480148990971, 0.883256002119552, 0.8709392108317866, 0.8886852225063526, 0.8843007099685735, 0.8045651861809117, 0.8086098410918574, 0.7863671713221994, 0.7881646147961111, 0.8200972356400965, 0.8102462908485784, 0.7962729667923106, 0.803714510531037, 0.7938559296653833, 0.14698123461393264, 0.10764077085672286, 0.11694162925023743, 0.12549405826954496, 0.11045927437323755, 0.12731496895877026, 0.13310710050453767, 0.1123912767588443, 0.12202737679935505, 0.10820062728001345, 0.08983977654325648, 0.1243842274518816, 0.1422625288615592, 0.08881089009136556, 0.12194641838039211, 0.09964953734121684, 0.13652220986872088, 0.10804935714841746, 0.8070756981906158, 0.7903011205514303, 0.8074723179050769, 0.8029056928806229, 0.7918866628233466, 0.8023208554192971, 0.8147543662139626, 0.7981072049453635, 0.8202088067035825, 0.6753543122321195, 0.7192231022458555, 0.6895293318448956, 0.7300056831453631, 0.7075648682437077, 0.6912545252218159, 0.6674905959773452, 0.4934436208258055, 0.7356081080306258, 0.870924146519646, 0.3422390366561533, 0.3283532654483958, 0.8816693321601309, 0.8552846148934599, 0.8611612217993545, 0.31980744082531454, 0.23520787557442546, 0.3599342299312367, 0.3287928893928178, 0.18690184535752663, 0.1987993342637775, 0.24190649990222002, 0.2596017930404052, 0.15373247524586153, 0.24719741964400133, 0.2013251639059901, 0.22264700308359775, 0.1746681487030639, 0.13509484191357135, 0.21177510774110264, 0.24794272736004141, 0.43449198927618704, 0.6604307169931487, 0.1679344817971885, 0.2011669948228162, 0.27063124463990185, 0.14079399404297332, 0.10795720126711783, 0.2904816195228047, 0.13043163236732813, 0.1830038745023328, 0.11632897079563786, 0.10735309511269475, 0.0890456308159846, 0.015622238580718095, 0.09948565387504205, 0.07251827457728144, 0.18691925983322422, 0.20942827172390033, 0.21791230767737457, 0.13353080422249208, 0.39052234348189474, 0.36210348597697595, 0.4770221962066976, 0.15352785589859863, 0.07273451782718765, 0.08139436391883448, 0.10556463744512279, 0.27786243799775157, 0.1797778683564255, 0.17311465733961762, 0.13502798540743421, 0.11110588837183155, 0.3033934031908144, 0.3347872361503279, 0.37046452070008773, 0.2663223974781729, 0.3543184012195093, 0.3027291627765296, 0.2976027666269885, 0.2761539278691686, 0.233691984776898, 0.597682860661168, 0.661610410691319, 0.5961900471759897, 0.5643124419567598, 0.8391265139638497, 0.6152834703112517, 0.6206718760873298, 0.6078398660402224, 0.5552252180635843, 0.10430863409211599, 0.07725314746489953, 0.12112534414444032, 0.09844506606034664, 0.06995911135061283, 0.1389681097073271, 0.14691725933110866, 0.075007494675294, 0.0723352363209604, 0.11378449906231802, 0.1357138745729911, 0.21331538714388076, 0.15946349282937844, 0.19319652068195792, 0.1432606642460974, 0.16022148697346406, 0.1286858158842813, 0.1479664959611564, 0.4725959726821729, 0.3963217313537153, 0.3701639694180363, 0.22885049060218599, 0.2565794062889446, 0.3163018763998201, 0.5083423202666628, 0.4800587181346673, 0.49530642429394733, 0.2938523331653037, 0.280924846434051, 0.3708236112289307, 0.2427892870292363, 0.25704365469077606, 0.2673928146740341, 0.22851363794159085, 0.33892920314821184, 0.32486401079570226, 0.1998852907882519, 0.21122204337839734, 0.217781674991944, 0.2036489252535275, 0.19233038913701872, 0.2472919998262143, 0.2016619860996144, 0.2125215868300293, 0.2056475740602608, 0.18520854316933166, 0.19668503624406664, 0.20152174031233505, 0.22778907070474963, 0.17434240343187246, 0.21764898244030195, 0.1899490069447528, 0.17469776851750196, 0.21094034032023867, 0.8874575984480584, 0.9083861363781947, 0.15504946992669688, 0.886786743347087, 0.19820947029672364, 0.18349442272055538, 0.17211922607272767, 0.22892307141124024, 0.1399737585397801, 0.8468176997207475, 0.2099264959849837, 0.8449992408647354, 0.3057054848474542, 0.2075319719021118, 0.16767776747023833, 0.15222633526992702, 0.21214197990596617, 0.2299157741369301, 0.17903269800142385, 0.1914465970388095, 0.19973872271793858, 0.18990502183727676, 0.20872222417698616, 0.1923898652607121, 0.18893243428496131, 0.18129952678435668, 0.2531127998033891, 0.0818299959033697, 0.08661780999168256, 0.07051629580706908, 0.09121917278397429, 0.0857800173940827, 0.06273435527706972, 0.08388836696349333, 0.0925221751373223, 0.06550912447306723]}, "mutation_prompt": null}
{"id": "2da83e8c-5cc7-4431-b77a-27952de814b9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            diversity = np.std(self.population)  # Calculate population diversity\n            dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) + 0.1 * diversity  # Adjusted mutation scaling\n\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                crossover_mask = np.random.rand(self.dim) < (self.CR + 0.15 * np.random.rand())  # Enhanced variability\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a self-adaptive mutation scale factor that dynamically adjusts based on population diversity to enhance convergence speed.", "configspace": "", "generation": 36, "fitness": 0.41372206066601014, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.24.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8293715413752384, 0.8242223108068057, 0.8209021195894206, 0.7834225816792483, 0.7742784951460171, 0.7693143700751428, 0.8502491114248992, 0.8337738430786564, 0.8459992787550905, 0.7310143428672053, 0.737124906220008, 0.7508559473452834, 0.7405777016473246, 0.7304891219234507, 0.7196340440484961, 0.691327713573946, 0.6998586459029661, 0.681257800017012, 0.16586915430612026, 0.15138470254868897, 0.12174323687505095, 0.13552333008822037, 0.4872487818475716, 0.4170537480513009, 0.4889978483715778, 0.12710004276526943, 0.33141307180309554, 0.13965343071417757, 0.1330980370023893, 0.14044175339851295, 0.20010813152531615, 0.15571937570529304, 0.3870603668052315, 0.2940871975474585, 0.14149025924811343, 0.12777666971858326, 0.7279682990362198, 0.6970990997074591, 0.7252262402647197, 0.6856210547605854, 0.6677684791718239, 0.6830138789288493, 0.7133943384803618, 0.7132675844692814, 0.7042703280685162, 0.6105628097237497, 0.5803662591426441, 0.5880598131050786, 0.5179310798051441, 0.5765797608008805, 0.5185633270159178, 0.5545596525116537, 0.564209186905152, 0.5336451008603367, 0.7385946734637716, 0.7792315747336713, 0.7651768096447937, 0.749813944792791, 0.7808585589498171, 0.7416688740211981, 0.7645621271847245, 0.7360536289720451, 0.767374362320335, 0.5123303686889684, 0.6081029500875952, 0.4537770411711849, 0.5707566998470838, 0.5597183205380312, 0.5213915649209953, 0.4706506663327481, 0.5040383668052096, 0.5780196884927613, 0.1477324804186677, 0.20922588997185132, 0.2040891330818524, 0.20789970471700037, 0.4097462548432045, 0.259870003252327, 0.21690536549303618, 0.358098432681628, 0.5645946679380395, 0.4476569143862724, 0.4652470461665482, 0.37425575591043503, 0.4105579196346548, 0.4762064529088398, 0.41658230913294103, 0.5608017217932444, 0.5843831220918769, 0.5774796955705277, 0.6186116119926488, 0.6141471573281098, 0.6075053838427105, 0.554761224953752, 0.5918186682020159, 0.5769411178423467, 0.6818146063512877, 0.6241248651609509, 0.6422574550360682, 0.18470744137455375, 0.23297240455186807, 0.08993955712586754, 0.13875018868576827, 0.1808232317498455, 0.25376580543057614, 0.1481033175055393, 0.16229917334569965, 0.28412821370279595, 0.33825360465545606, 0.3559919209261535, 0.34287207403263564, 0.33455997678965554, 0.33351491845678816, 0.29781365488529277, 0.3585207775045466, 0.30550843178526477, 0.31035145237069917, 0.7713021016822292, 0.7564190619270039, 0.7312399604792419, 0.7259699920217675, 0.7100516987591972, 0.7063936670003068, 0.7750233550606114, 0.7759850406291722, 0.753675652052471, 0.13109271157748448, 0.11606606584526002, 0.18167233224768808, 0.09457684159588375, 0.1351713490872608, 0.10843270391126136, 0.09798140426822244, 0.10010429121138986, 0.09274538496105433, 0.1355000427437102, 0.23016557183833697, 0.14085426481097751, 0.1275099252090227, 0.15950619683038636, 0.13919407700670294, 0.5332642317132121, 0.13213899893573744, 0.13381550451688495, 0.40061049013711814, 0.45396962992624623, 0.41796750186579457, 0.4979575593300487, 0.4953310879156858, 0.4786702744020448, 0.4695896356873237, 0.4373374110621929, 0.39715523466412717, 0.3237669152088184, 0.3592892308308211, 0.33009515536941414, 0.3937189303253684, 0.3855847862480243, 0.37112834841942144, 0.302914420713134, 0.34769596088391863, 0.3278490079256171, 0.19391529825078546, 0.20749881612309873, 0.2008969122055283, 0.17415098956992392, 0.20419568847567193, 0.1838910347830961, 0.1951592233324061, 0.19215466748510712, 0.17479723377690204, 0.3480474355676917, 0.18640464956243963, 0.38877984550059297, 0.37939038554967497, 0.2199051778850596, 0.21376601401396478, 0.45427439086001564, 0.4258656491438746, 0.37154742875686453, 0.8130229427548799, 0.7603753382385559, 0.1790183917805147, 0.7498305864717686, 0.18100452409038992, 0.7521406705074548, 0.7609455470971365, 0.788716251712908, 0.7488269765674729, 0.20008816398407026, 0.1997069501582005, 0.1996437741677184, 0.20443546599854212, 0.19847611618696048, 0.20250307251333444, 0.22300950875136094, 0.20763371630419125, 0.2044235355056816, 0.1799276807936956, 0.19747001590694013, 0.19593741256746855, 0.1763711330306913, 0.18163153657056896, 0.1924159684161243, 0.2155755535447611, 0.19511772035145925, 0.1843481619431585, 0.07681511586511969, 0.08470802101334007, 0.07538458021749628, 0.08311326746106495, 0.07164443840293155, 0.07392178602066402, 0.07936189672948879, 0.07379031109858425, 0.0716434883470578]}, "mutation_prompt": null}
{"id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive scaling of crossover probability based on iteration progress to enhance convergence speed.", "configspace": "", "generation": 37, "fitness": 0.48562127152368084, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "0b443498-cedf-4d0c-840e-394b71dd97ac", "metadata": {"aucs": [0.8782931132286633, 0.8723885788050867, 0.8629084566254809, 0.8763366344543457, 0.8868587291367251, 0.8773989980636685, 0.8763256237946582, 0.8821164874434413, 0.8821465203198563, 0.7874861616045048, 0.8036472488329116, 0.7955910709999362, 0.8085823490716602, 0.8046477369418292, 0.8045744623532087, 0.8069885903966094, 0.8175564200283787, 0.801490390294662, 0.4374521528469728, 0.4278485865116768, 0.4734758220146159, 0.4322263160236055, 0.4110525616829731, 0.15673531514943717, 0.4251244262503947, 0.16349561059324846, 0.2843334944426654, 0.1805909972336418, 0.1422595501428272, 0.1171728310698249, 0.1438200988921302, 0.13536318609995446, 0.13435435868889145, 0.12292599135525417, 0.3748638823609781, 0.12145430131717438, 0.7933651453858646, 0.790591172579798, 0.8081353885562548, 0.8060702899368365, 0.8060649577343733, 0.7965408090519326, 0.7945187588394846, 0.8015641097591368, 0.8036434567384576, 0.6955401231282519, 0.7178450559395848, 0.6765691885847973, 0.6948335433554429, 0.7164565468998949, 0.7128432394766617, 0.725770218882037, 0.7218310227717197, 0.7147611331411201, 0.816502761533457, 0.8551123585291781, 0.8342302116080537, 0.8538279842902933, 0.8182094371860507, 0.8308936763467459, 0.8652370368905113, 0.8364466817553422, 0.8641965742600973, 0.6877628574868215, 0.5840885345974175, 0.5345197373306756, 0.23458146683606262, 0.5252352871500767, 0.48384685124627247, 0.3100621176527, 0.2511951095890389, 0.25922709055798254, 0.22396095754134493, 0.2871958962402933, 0.6410354690655732, 0.3227558295174434, 0.3506351596524625, 0.1975113556347844, 0.2227640241132517, 0.18193434298178623, 0.2494377110182, 0.6846710971283567, 0.6201288746890755, 0.47169268215874915, 0.6371426846412417, 0.154214885109333, 0.5655510711371764, 0.3923263510269509, 0.6302782722546203, 0.5475051480453323, 0.5850593593323681, 0.7590813698918287, 0.7144199852751031, 0.7590356243841343, 0.709834547399857, 0.616412508708005, 0.727260163939882, 0.8134731479413945, 0.7422494557472719, 0.12677116492092722, 0.25838982999144444, 0.20843861546681497, 0.3627834388993133, 0.2583364564658225, 0.40998488500965136, 0.21075811417591328, 0.18665777093011615, 0.29828784548195586, 0.5018066544518758, 0.44091664587251966, 0.471522053265672, 0.4776319885232665, 0.4254051649484383, 0.5045518116830501, 0.41122446649302435, 0.51798526371623, 0.48467429744220103, 0.8207883191160488, 0.8135994035231491, 0.8270926164798953, 0.8206586450963018, 0.8328701441450982, 0.8304150728834282, 0.825913757092261, 0.8263937879721992, 0.8319690340956929, 0.11495222019135165, 0.11739964113346013, 0.11196440802984475, 0.1116713458533104, 0.13327885586435262, 0.09249845485723474, 0.10596252670905282, 0.11450355487726316, 0.12810733539521935, 0.16195108785682455, 0.146262380729544, 0.13927832848396504, 0.12041576203357729, 0.1242739753675487, 0.24597012158238496, 0.15448565834197836, 0.11466913656697508, 0.4710577153552423, 0.5001829707863832, 0.6046271253616067, 0.6194835101057765, 0.6225352177269473, 0.6135252312948003, 0.6169647155221176, 0.6503507224174621, 0.6453786269085531, 0.6393698625151827, 0.38110688051830044, 0.44586870373527476, 0.4361925515202423, 0.49988135322369853, 0.3964830800055633, 0.4540072435538828, 0.4970937868491989, 0.531579982641532, 0.49704604114952977, 0.19517444252871385, 0.19776814530047848, 0.19585793517590278, 0.2019472731354517, 0.2038542008766523, 0.18767608120262225, 0.20320107804331078, 0.20289806146515676, 0.1904377955812634, 0.5646088866486247, 0.6013603177846103, 0.3575432144621775, 0.41196449069198326, 0.6166597945106064, 0.22352208332252066, 0.22942975948829736, 0.5207383364286529, 0.5311241445385424, 0.8186958124859571, 0.8624909538067591, 0.7761625259313124, 0.8634894150726634, 0.19248668312137496, 0.8462434439373585, 0.16668933011417353, 0.8627935383316123, 0.7900311813196532, 0.869145172298112, 0.8551756021969473, 0.2046940055028733, 0.8345064911265815, 0.7908040458417924, 0.7259818558120191, 0.8444311481762901, 0.15545795132548423, 0.20430784191813356, 0.18341541647688797, 0.18986201335717212, 0.17856602555405265, 0.18570046817168506, 0.18645785763920353, 0.19007661863128889, 0.17945287441468194, 0.17993955867148392, 0.18382347119547326, 0.08248195357513655, 0.07278327486768899, 0.08487562302650609, 0.09564781497736052, 0.08798899978946506, 0.08705439496670098, 0.08360982032126518, 0.08145744686049783, 0.07586564865020773]}, "mutation_prompt": null}
{"id": "473c14c5-8d75-4285-ba59-53b9ff4735e1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                # Introduce slight mutation noise\n                mutation_noise = np.random.uniform(-0.01, 0.01, self.dim)\n                mutant += mutation_noise\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration by introducing a slight mutation noise to improve diversity and potential convergence speed.", "configspace": "", "generation": 38, "fitness": 0.35154744682623124, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.6549749131685507, 0.6757922930895719, 0.6680310483627808, 0.6993433838476231, 0.7153330379452144, 0.6807592000754861, 0.6671562817733835, 0.6825435124027961, 0.687369603872952, 0.2983529706166913, 0.2951063763037941, 0.30058266286116664, 0.33240314935977544, 0.3088995596724543, 0.3135868068200238, 0.29897298333890976, 0.3193752837582068, 0.3239892933653249, 0.2391938495085224, 0.15621286301138948, 0.29329209132953415, 0.33275830693423436, 0.1585102587396897, 0.3008999365764101, 0.158578392537426, 0.20171505914214571, 0.30623505871260015, 0.13015091118049837, 0.15990212515627988, 0.15214005970939293, 0.1399806006004206, 0.13817592014059232, 0.14897088794121138, 0.22822673787350167, 0.15593928836391713, 0.22349562370060072, 0.8527635840212356, 0.8302369032515751, 0.8583714830828337, 0.8186552086355683, 0.8555927026440984, 0.8059710651319798, 0.8519579520572925, 0.8622644338738444, 0.8535322441663731, 0.4793295756528674, 0.4737051575551158, 0.4980693836749527, 0.46479318665664626, 0.48684106127676186, 0.4536481098215902, 0.4778384135056398, 0.4666733184918399, 0.4925917470936435, 0.8568282359681267, 0.8302232044712541, 0.8465050578757815, 0.8441343471549039, 0.8890344445840133, 0.8510852653071823, 0.8321526906806873, 0.8257976400398845, 0.8318665620335383, 0.33191717884805916, 0.34042151412188115, 0.3462859243217902, 0.31115686432284184, 0.35664326250639555, 0.33950793012044855, 0.38879428368279656, 0.3659599968808863, 0.29209864542601893, 0.27625809225582376, 0.28420678849860725, 0.30881141923079214, 0.31493914900223385, 0.2981948293778237, 0.3771029707158816, 0.35039063049121166, 0.31685062011043197, 0.33443327755468044, 0.20738122413002558, 0.2308911773149086, 0.20255289315827796, 0.20779717114246443, 0.20580623011420396, 0.18897509904742205, 0.2060665146181373, 0.20065209229125025, 0.23025867153729107, 0.2603181268844915, 0.2449251213521425, 0.2163561548346109, 0.2607794233223413, 0.2373946978364191, 0.2841039076217232, 0.3167296443055132, 0.28303989429975196, 0.26839533738300925, 0.09561605165994114, 0.10488176279764283, 0.06090003427449686, 0.10166117163022048, 0.08176832699422176, 0.12729745048760432, 0.11893234889627491, 0.10743277394142259, 0.10977995178957822, 0.20331176094058112, 0.20385578376434654, 0.19201756225817002, 0.2251580889065824, 0.1986228758846753, 0.20862971348384618, 0.22219887974454355, 0.22002697303651364, 0.2013653891870647, 0.533203949259883, 0.5258795902152692, 0.5682084794120387, 0.5307095951507839, 0.5672621039441212, 0.540507368775751, 0.5636507590794266, 0.5532532312744052, 0.5425254292728253, 0.11625251260488023, 0.134311514393873, 0.10972521621525944, 0.11567060950592711, 0.12197646799784545, 0.09795765692203617, 0.12545162145781052, 0.10858673796203422, 0.11374348093226383, 0.19538639923943368, 0.2175386691199216, 0.30181904046993835, 0.14255530345636347, 0.21558984632751477, 0.16531753722494724, 0.14693569568382858, 0.1647522951885334, 0.13392172450596695, 0.38607282804923604, 0.39220213045727137, 0.3868170194975763, 0.39528125581572615, 0.3864385705984431, 0.3860620519315957, 0.3953171216292817, 0.38665821264583633, 0.3897119539812963, 0.31598572857945983, 0.30971138730060954, 0.3219022261848765, 0.3165972627160065, 0.3131389024221497, 0.3230421344059097, 0.3166565033784732, 0.32320562802335795, 0.3242349276239421, 0.19048539033108858, 0.20198751427284511, 0.20411083344125158, 0.19292637525833356, 0.20290933450242865, 0.1922254720307054, 0.2056781624418329, 0.1855340170460258, 0.22295042201042103, 0.44568036949686274, 0.41396417112635586, 0.3823162674457866, 0.2338320544694683, 0.3561211057326644, 0.3860076774208916, 0.22957812206547057, 0.421054793205065, 0.3851928128004273, 0.1826003245044182, 0.1682546281584597, 0.8792069251782053, 0.8152118280348204, 0.1925898729419131, 0.81662084592157, 0.16732774068089362, 0.7691702344481974, 0.8472282851559392, 0.8510380368187418, 0.8087434134897169, 0.7629927586006205, 0.20643413379954345, 0.551427330573787, 0.20284858477820678, 0.14841687654800995, 0.8344315798206118, 0.1518231811674694, 0.20213414323945156, 0.17838455474141413, 0.17387926992143843, 0.21406571680059072, 0.1973442786978511, 0.19377606825860727, 0.19248603941170506, 0.19130112299839863, 0.20125146818179906, 0.08702047936760315, 0.08328565800758791, 0.08817468346643931, 0.07742508437908091, 0.08323376455114662, 0.08440278966108583, 0.08276959377743309, 0.08952932647237555, 0.07586734713634324]}, "mutation_prompt": null}
{"id": "6c64fd23-c739-42d0-8ab3-f66ac815bceb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                diversity_factor = np.std(self.population) / (self.ub - self.lb)\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)) * diversity_factor)\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                diversity_level = np.std(self.population_fitness)\n                if diversity_level < 0.1:\n                    self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by introducing a novel dynamic mutation scaling factor and adaptive population size adjustment based on diversity.", "configspace": "", "generation": 39, "fitness": 0.34865564964927553, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.9230419657451309, 0.7604105192898465, 0.9067156543868482, 0.9098094239779574, 0.9198412723548556, 0.9137318593499808, 0.9202731091129371, 0.7188684346672974, 0.5746840113487404, 0.6980433544661808, 0.6048697416248887, 0.8544349119500865, 0.17086330816966833, 0.5441460172011918, 0.3166296378739438, 0.8619929720704481, 0.7056005103282987, 0.26328258674178595, 0.5722388862735499, 0.5487296224772918, 0.20301925033897072, 0.7018803352134706, 0.17149811177464558, 0.39418373941393214, 0.5574791847316565, 0.25346538640870575, 0.43459262225273243, 0.1515766432197435, 0.1431172883612809, 0.1550738235520035, 0.15463774870787705, 0.27469918295540796, 0.14862406400834605, 0.13341514074942207, 0.16357725526118172, 0.11293149527734936, 0.9859008521670061, 0.904193347305742, 0.9115311326315172, 0.9095504030407636, 0.9734106944963989, 0.9581341996768908, 0.9458561783614187, 0.9692410383483573, 0.9402863153405916, 0.21133715678037257, 0.09452209510765841, 0.1901231126126245, 0.19678159447015386, 0.2346340038217436, 0.1521612302046622, 0.1570797705489333, 0.1531782560028272, 0.2943318901020019, 0.9423022264722638, 0.8996069992985022, 0.9219203455458285, 0.2142728660612353, 0.27589947773012813, 0.8948285119721417, 0.17807142751451488, 0.8749549636510165, 0.9072907554446648, 0.15211515744599124, 0.22060365290913342, 0.40348363837274615, 0.15370083056003137, 0.13496557570593593, 0.13299124029682463, 0.5617690211698205, 0.21288423612117846, 0.17969543757464856, 0.13927484217451713, 0.14031831293774488, 0.16016045989628114, 0.1357258047230565, 0.1484646393486686, 0.14505036776079827, 0.1879404265673601, 0.13289135732133983, 0.14345082072174742, 0.08296819602394467, 0.00020726509127977355, 0.11863217172268847, 0.15747960055081311, 0.14700041825991828, 0.06783899830402895, 0.01893097872519045, 0.3162940938822709, 0.12131352169304377, 0.2962023773661514, 0.2258983237710107, 0.3785067840538865, 0.2706759177987449, 0.11718115329400858, 0.03147754734068953, 0.12787158402622478, 0.20893891672250298, 0.22606672479106005, 0.06185979185076085, 0.21955261358978895, 0.19628341643630143, 0.08694289459481375, 0.10724178079457358, 0.2501702313908237, 0.18723661611968212, 0.3226416305502827, 0.13122022639462316, 0.3029679892827366, 0.2639791790909346, 0.3277720494342634, 0.36872131351053516, 0.35674752144631217, 0.24461156206253176, 0.3622185718671235, 0.34174969311647974, 0.17964918313439793, 0.5493218790936898, 0.5276628281536773, 0.490580467625903, 0.467880494401824, 0.5547601535548957, 0.5860967006575284, 0.5206667065161815, 0.5167966625899385, 0.5419853395840688, 0.15485890015823411, 0.1277060848784507, 0.124014469914145, 0.15435754270161273, 0.17659662481226046, 0.1451715514061509, 0.13948267810559556, 0.13217786545497168, 0.10152461566429138, 0.2544263181426395, 0.13752993425858318, 0.23570969818118315, 0.22310191542189073, 0.2129489414923451, 0.22113625368277368, 0.20950905666925757, 0.15158961746305943, 0.2655885721416055, 0.5412407048424837, 0.3587280348258841, 0.5319752874585586, 0.6312971575362463, 0.4694798205617029, 0.4976623654806417, 0.7848272125939968, 0.816138580611806, 0.6530009468422028, 0.39114421915782394, 0.4099955884822363, 0.4418398076307192, 0.3386298558981664, 0.3812879746831478, 0.29846772878462813, 0.44028446506607355, 0.47420107358837116, 0.3919824659277459, 0.21206428987153492, 0.22868122227472554, 0.1999793403656458, 0.22605087488249787, 0.20676539539644745, 0.2271470559604748, 0.21821042978886795, 0.20789842535263858, 0.20503683327663424, 0.22421215924516869, 0.24477929080718197, 0.19039982545436418, 0.20785305669397403, 0.21746601213864714, 0.24312395903363304, 0.1889600047493314, 0.5434932820991998, 0.20775613990809727, 0.9334752272032858, 0.15690745526324423, 0.44540888902847586, 0.9262622171256666, 0.8648114599172545, 0.18641205696579266, 0.19482881273560804, 0.20299408896480897, 0.374866379046656, 0.2050270347450689, 0.16858580790091782, 0.20934638536267647, 0.4080223345147308, 0.8634447207775697, 0.21058110642251526, 0.21083470782149494, 0.21241118224929934, 0.2092500654998275, 0.1843255150042733, 0.17795040019840092, 0.19425419083239537, 0.2091147287576811, 0.1856735147655475, 0.19615145530458988, 0.18338200984596598, 0.1862003039474177, 0.1903807445762361, 0.08473098596181994, 0.08261301066526938, 0.09396702872409912, 0.08770602469010413, 0.08979553797317674, 0.09121511917670433, 0.08721634272529777, 0.09452626303036626, 0.08778788048115205]}, "mutation_prompt": null}
{"id": "d2ab3bc7-1d33-4eea-884f-9dac4edb50bd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * (0.9 + 0.1 * (1 - self.evaluations / self.budget))  # Adjusted F\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Implemented a dynamic reduction of differential weight factor (F) based on iteration progress to potentially improve convergence speed.", "configspace": "", "generation": 40, "fitness": 0.476182097718185, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8822411324898102, 0.873583375824946, 0.8780531166404839, 0.8817430743508013, 0.888549178893247, 0.872315484512901, 0.8788630960604171, 0.887648200476108, 0.8757066190717773, 0.8068081560632194, 0.8252699403555017, 0.7903887376387089, 0.7962159666714362, 0.7981178564908258, 0.8021643798105866, 0.7959618862225537, 0.8085291435368562, 0.8015152069760707, 0.16049332910165215, 0.15393617340518506, 0.16116542059366223, 0.15103506685650614, 0.32368631808817705, 0.45186141301133753, 0.4425656445491183, 0.5474617497446759, 0.5169115853092867, 0.1532431499391167, 0.468754033074985, 0.12425891066433359, 0.48830667753695267, 0.15510270364668355, 0.3981558094681211, 0.13640604137389944, 0.13248428232506626, 0.14006244788404676, 0.8007114762293768, 0.7967149625099887, 0.8178555431160136, 0.8039171467233812, 0.811680453648537, 0.8120228930893642, 0.8108189787863798, 0.779087583262795, 0.7997424036365505, 0.6503926473290085, 0.7034406499185447, 0.7064936209315023, 0.6863070652020878, 0.63226686920246, 0.7051385612599329, 0.7026756609452285, 0.6934413848804221, 0.7061304663659033, 0.8432493780018493, 0.8426535689766934, 0.8248687175192013, 0.8266197064113361, 0.8364717487958292, 0.8460150166031086, 0.8483950122676831, 0.8366437165567568, 0.8747165288547148, 0.593895026070075, 0.24902328466406476, 0.24645329522043902, 0.38509133410865737, 0.18290353449632413, 0.16680131815564714, 0.41852166662723744, 0.7306602335305684, 0.19377282140162233, 0.17134985303159866, 0.5945850825136803, 0.2555358971326145, 0.21953586628808275, 0.736898067454796, 0.2442304535331462, 0.18064445291539577, 0.21075184630784283, 0.18604759062159548, 0.4965717640330587, 0.6917925636253126, 0.6572702123295562, 0.43202605639122704, 0.06130759685440823, 0.7159795089109882, 0.6798277740191523, 0.6131881929251009, 0.5903857177702971, 0.7513735568901961, 0.3800209013434259, 0.6632203228018718, 0.7028168576153189, 0.6385128629314167, 0.6643536163062755, 0.6594085273187312, 0.747465029360522, 0.7675057570302594, 0.2073873621859894, 0.2191772037449501, 0.1591852151199482, 0.2913165323031097, 0.23194750586864465, 0.14941655681079957, 0.3202553401079211, 0.2162041104609712, 0.09093168990476919, 0.35816371738075814, 0.4570921255081738, 0.3218618240471761, 0.5316721868264387, 0.5092046028642429, 0.5851499398595463, 0.442942264279809, 0.307823944425208, 0.376177077110077, 0.8245429471959428, 0.8218374944418393, 0.8110541350382253, 0.770079349890477, 0.8325391735692866, 0.8104034585555238, 0.8233355153610789, 0.8415698711849307, 0.8182812950368852, 0.1292676144468622, 0.12056319139221783, 0.12962363749524553, 0.10122949580227902, 0.10625113152873178, 0.1043837101299756, 0.1198774406325881, 0.10134845775129364, 0.0983837727892578, 0.1538757555342245, 0.14707881884833218, 0.17985687294882047, 0.14183183479783368, 0.1957533637772364, 0.1613274103417951, 0.14766889869265964, 0.1644644323802451, 0.17524833352531732, 0.588469133672711, 0.5309638237273806, 0.5734506166357056, 0.6613080407441314, 0.6020740827520246, 0.6345313844607625, 0.6633835404657835, 0.6653759946840442, 0.6722800766317913, 0.5291810517953011, 0.4452200111045056, 0.4639462671769736, 0.47676615314529813, 0.4397111121729801, 0.4414151318999079, 0.5063563313032202, 0.4662634385444272, 0.4385614944016343, 0.20085049408894384, 0.21217211241331924, 0.19424073435009293, 0.205307727115825, 0.196871092792252, 0.18925549490281823, 0.21021365515324875, 0.21421213838115294, 0.21629782438306333, 0.6517105672730491, 0.2088338186241392, 0.23698751451812394, 0.44089909642736347, 0.6941078785339909, 0.5136107445662954, 0.6303850296104095, 0.212463035857129, 0.6391193751320575, 0.8665669841237775, 0.8658329240712808, 0.1768819910520424, 0.8503741845342909, 0.18091273571103728, 0.8561949269140907, 0.16628525149119833, 0.8618257185458553, 0.8511779812339509, 0.8221791416547161, 0.8496292992654542, 0.20729281540386346, 0.8221132193934411, 0.6251056957482092, 0.8231783666016037, 0.6626973151885367, 0.15559061738596247, 0.2044720163396606, 0.19473508115779115, 0.1784229396935183, 0.20382877934094668, 0.1840820617298211, 0.1755184746690105, 0.1819939274796991, 0.18295092476525965, 0.1816953150447218, 0.18082504247988795, 0.08102550264280983, 0.08183486019006703, 0.09232170001575102, 0.07824647969360266, 0.09046487923108726, 0.08028557334141495, 0.08406094690889931, 0.07351589009955606, 0.07906540043145327]}, "mutation_prompt": null}
{"id": "962a5cde-eaa0-428e-b573-a13622e86aef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                \n                # Dynamic mutation strategy adjustment\n                population_std = np.std(self.population, axis=0)\n                diversity_factor = np.mean(population_std) / (self.ub - self.lb)\n                adjusted_F = dynamic_F * (0.9 + 0.1 * diversity_factor)\n                \n                mutant = a + adjusted_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Utilize a dynamically adjusted mutation strategy with feedback from population diversity to enhance convergence speed.", "configspace": "", "generation": 41, "fitness": 0.4600362582079456, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8927175523739849, 0.8749568241923387, 0.8837226396014173, 0.8964298003430279, 0.8918012401056714, 0.8839087554133778, 0.8830279384935157, 0.8930136339951891, 0.8992119722648706, 0.8284839342086101, 0.8251742490784539, 0.8170767141391577, 0.8063954691940587, 0.8314117377692711, 0.8228442515729526, 0.8304623392079906, 0.8243482975468717, 0.8202240398470906, 0.4499257629876774, 0.557980190460299, 0.23677205895713693, 0.17068558558978897, 0.5419191920598971, 0.5828622369752875, 0.47246124162609426, 0.5758928797039676, 0.16471478108841653, 0.14785025029009702, 0.13914884043245324, 0.12731469431319398, 0.16518967941757945, 0.158616150066047, 0.12822178797918082, 0.5589280447347384, 0.2563767535684074, 0.14525197352203612, 0.8079283507213532, 0.8207164433869228, 0.8157686442372927, 0.8268562276068329, 0.8302415019842047, 0.7981782914061359, 0.8144278686299526, 0.8209396761729675, 0.8278262984146598, 0.7188222269926261, 0.5276237905966159, 0.5720879670524535, 0.45405423377564325, 0.6149743967414989, 0.7470214363482017, 0.7349564540789887, 0.43970052114883273, 0.4262448920515619, 0.8385533518074758, 0.8584442136723469, 0.8553660807505931, 0.8647532465357394, 0.8745121864547307, 0.8760723746280389, 0.874109472362616, 0.8518783321773431, 0.8617186838116687, 0.166462390961854, 0.19108873630654255, 0.21169006042484484, 0.20790659560431446, 0.15712972959401483, 0.23203330624261587, 0.26702910600178653, 0.19352181667620383, 0.18408440277560778, 0.28681768818286546, 0.20302166803201016, 0.22893533578123948, 0.2798672676069158, 0.2439918685145155, 0.5078413425585522, 0.21846734462443107, 0.1584230920761207, 0.16348813012684826, 0.11639298684818111, 0.5982730669960474, 0.4837952896543648, 0.13931942014139187, 0.6826624075170292, 0.1248752934558417, 0.2220161500889476, 0.23523668488744243, 0.32126594016154686, 0.68036216787494, 0.32853963158684296, 0.44349125915602783, 0.7450035406137632, 0.4928372027094795, 0.13323263426340437, 0.6963804106611333, 0.7794155155277126, 0.7344742594305624, 0.14415392715249964, 0.18749809055259237, 0.30705621053928944, 0.21898043588677452, 0.23969180129016265, 0.19539662602586694, 0.20732923958635763, 0.13654997730556584, 0.18435600035862376, 0.4347115019176646, 0.5415337519336272, 0.31147667093477027, 0.37597578561319, 0.43819925263412063, 0.5539420589733643, 0.44005750882638295, 0.39287134545809743, 0.4145540701382886, 0.665564935989593, 0.7220511449222871, 0.8545138692950203, 0.7466427028437718, 0.752723619667278, 0.8543406218125056, 0.8661840566136109, 0.8548009664381468, 0.7701466705450017, 0.1041783253224452, 0.11542539451192335, 0.48381447181632986, 0.10998485941223357, 0.1467419972125339, 0.13771731553508615, 0.10360308431431442, 0.10363931010594629, 0.12079908982998988, 0.15899637407102296, 0.1583207517727867, 0.21922390317529894, 0.22774763606142956, 0.16859894907001927, 0.16117089177832455, 0.579899241431543, 0.22874766850232497, 0.15902755215485664, 0.6308224735552417, 0.5394676852535442, 0.5294331181686638, 0.6326118281785025, 0.6513490969644036, 0.6788513398338227, 0.5282989940129413, 0.6855741439237687, 0.5730688588266255, 0.47319450341366076, 0.577658097899773, 0.3795744416053637, 0.5417585585189907, 0.46655269097724805, 0.4502493625087238, 0.5788417216574705, 0.5235738714266578, 0.5138568882902554, 0.2164837232363459, 0.18650352934778935, 0.19105786033813732, 0.22907658791864483, 0.19816924145952985, 0.1953919955551784, 0.21297361168241002, 0.21028539559437787, 0.1931906229742273, 0.6049331079258174, 0.19421575258182555, 0.5730006131686531, 0.7507661015179261, 0.6322944640578965, 0.6468670437332795, 0.7277437856100176, 0.7113294340450267, 0.5629169453213554, 0.8457783056875339, 0.8796253135130626, 0.8422440524396482, 0.866830721470186, 0.8507492389194024, 0.7917614873832372, 0.20106649387516362, 0.8823444465758067, 0.7990885865020964, 0.8612774049125572, 0.16838594474829638, 0.8104926599913912, 0.20765498743197064, 0.2067541152977943, 0.2096892318146777, 0.15457295201187315, 0.20891413316438334, 0.2100612128291085, 0.20005345129960284, 0.1946811773560031, 0.18084878738753896, 0.1859764442833628, 0.18852587030182022, 0.18466129582515844, 0.18517250835584842, 0.18659221301982043, 0.21223882263837135, 0.08760098275553774, 0.0834707495993261, 0.08613661311838128, 0.08011335366530037, 0.09491675719317283, 0.07506645624470498, 0.09037668940622168, 0.09109268886736521, 0.07366407228018002]}, "mutation_prompt": null}
{"id": "a6255852-7d70-48e5-b1f8-5a29bd7cdec9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                # Modified mutation by incorporating the current individual influence\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c + self.population[i] - a)  # Parent influence added\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced modified mutation strategy by incorporating parent influence to increase exploration capability while preserving diversity.", "configspace": "", "generation": 42, "fitness": 0.416198060298825, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8824649129452532, 0.8808801470088006, 0.887768464317032, 0.878036214536588, 0.8778803784346437, 0.8726674964397878, 0.8836942646193607, 0.8797721771656519, 0.8793025774398187, 0.7937067373157909, 0.8130739045839702, 0.8055499736841398, 0.7925145429056841, 0.8151570004047829, 0.8012505426678648, 0.7922219904004244, 0.8064629730289166, 0.8043945844615032, 0.1418555560100485, 0.21030273491826634, 0.1451678548758466, 0.15612815652873946, 0.21231591947177697, 0.1499840525069983, 0.13806708922080924, 0.26632933243145185, 0.1906452313601914, 0.12251915318056594, 0.11745152862274588, 0.11237766515355307, 0.1131006386566723, 0.11706491059295898, 0.12339928144185996, 0.1126231730263918, 0.12074749897474102, 0.11992833433249672, 0.6288581067433995, 0.6455640023557903, 0.6363533816054203, 0.6402079045273132, 0.6022022835764387, 0.6003097449550634, 0.6483579235202531, 0.5601635636019273, 0.6520487777115892, 0.6516779016116556, 0.5516209785488102, 0.5902217162481025, 0.37737185151504715, 0.7090042865912602, 0.6445806881721574, 0.42392808721588837, 0.5275183215382737, 0.4676697077420352, 0.8361820043655549, 0.8475330031834011, 0.832286402743728, 0.8309713275068104, 0.8539961467050525, 0.8253143279509317, 0.8359842317511654, 0.8557256610037239, 0.8478019327737055, 0.20026415741872283, 0.1555509015544605, 0.24874542324389848, 0.21627019625355415, 0.18517637282897248, 0.1675485856205714, 0.164760141841368, 0.21795716786223773, 0.24008714390413166, 0.28149924274432236, 0.16948682358908718, 0.19219572083960434, 0.18039217189894885, 0.17434648144216447, 0.17270701586935888, 0.1628816461492717, 0.1568738681907178, 0.2010344096426223, 0.7069508228206998, 0.6758349340944574, 0.674100570481766, 0.6900414874554341, 0.6960948418597508, 0.488841117322678, 0.6962621372385834, 0.7250637907055281, 0.6610860942065826, 0.7654027892082993, 0.7519452327574283, 0.7508438720931685, 0.7300191174563921, 0.7445064934013479, 0.7239983753668107, 0.5554533295848848, 0.7707202554250395, 0.5249087208198122, 0.16146800145313667, 0.2696506770397109, 0.1674051111820345, 0.17994387193321404, 0.4383205859982219, 0.21934763538269464, 0.17112793411196925, 0.2004236383099004, 0.17708267623903629, 0.581150181589422, 0.5385240642780899, 0.4056511482107902, 0.47643636379032217, 0.33551949831002614, 0.6221956179435326, 0.6256315317446904, 0.4425920863998999, 0.5346948329438133, 0.8459351039419571, 0.8443171059312429, 0.835226887645149, 0.8414497607416093, 0.8424223969961095, 0.8386862084247484, 0.8428902407727352, 0.7920262275854653, 0.8402288417195833, 0.10905260050496579, 0.16593854580489442, 0.10991963304248586, 0.1017551007202766, 0.13189021029338, 0.10682198635299833, 0.10443518088517467, 0.12055982820476352, 0.12560955893333536, 0.15704817293559403, 0.16408203904831586, 0.1574212266875895, 0.13754196742246327, 0.1426059743731226, 0.1268663601581398, 0.13667298014273088, 0.14200903831964073, 0.17958527330580676, 0.513615047368786, 0.5107971680255236, 0.5336112598666972, 0.5276091599440385, 0.5079538470500331, 0.5115377727096273, 0.5052262790051343, 0.5339419783382182, 0.5192528893740849, 0.3498398665095911, 0.3531902355873541, 0.3368431616906289, 0.38859362806505193, 0.37327000053708903, 0.36514388710420553, 0.4070365470101548, 0.42698738648554, 0.40569846246837693, 0.20509943066176628, 0.20440564032202835, 0.1918547824200858, 0.20351585754306412, 0.2104630449326942, 0.20424334392680088, 0.21877916676897902, 0.2023510622914093, 0.2254882173213414, 0.2150251016776833, 0.1888478975981931, 0.19578016002297316, 0.1912312551378209, 0.1957220971119037, 0.18946835904922332, 0.19770638403694318, 0.18670744156996733, 0.1834071794590787, 0.8037379179398503, 0.6510727524422717, 0.4875537376229335, 0.61107647516889, 0.17302996392817382, 0.6830865613168144, 0.553920143250522, 0.3826211827246443, 0.4520926782775152, 0.2437130523851505, 0.5215106215839764, 0.2591884126839241, 0.2028204842617305, 0.4543940927932626, 0.5312748143802727, 0.19640859563748259, 0.15350852698795425, 0.1605673887766863, 0.19976650390940154, 0.21464225756064803, 0.1907882164098358, 0.191534912645148, 0.17974779038423316, 0.1724045567380159, 0.19240638810636546, 0.18555009197486205, 0.18247643935066526, 0.09147850584072059, 0.07667380079850994, 0.07889236987846893, 0.0844292016620446, 0.07424834224368737, 0.08160607405956433, 0.08220314272054652, 0.08213828726954597, 0.08569512146169855]}, "mutation_prompt": null}
{"id": "cdceaf65-e46e-45e2-83e2-0d8e1c0b9b32", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.18 * np.random.rand() * (1 - self.evaluations / self.budget)  # Slightly adjusted adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploitation by adjusting crossover probability scaling to improve convergence speed.", "configspace": "", "generation": 43, "fitness": 0.46117527202022557, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8820505634878404, 0.8750766198878794, 0.870764828727856, 0.8922075214867804, 0.879718380315952, 0.8766331253148419, 0.8801836873682597, 0.8923654403359913, 0.875766983544663, 0.7796985217636389, 0.8240191240985255, 0.7961126612815008, 0.7651246476965606, 0.8031411927964873, 0.7952269651770383, 0.7993677263461063, 0.8005769181424633, 0.8082042389497552, 0.16144380275588388, 0.422088201079884, 0.5653771314121161, 0.13670980185006343, 0.4120774777013123, 0.17470221579282896, 0.16557341014177396, 0.16406770169431983, 0.4170125309774374, 0.164062866186919, 0.27534209084303474, 0.1276321066104854, 0.16503717311221044, 0.13792905230545582, 0.150866411154701, 0.1324995183176223, 0.15447036015677695, 0.1336758292685838, 0.8083661645112837, 0.8104318111226633, 0.8182407914773849, 0.819748432160126, 0.8108444054843513, 0.8152225032817159, 0.8189161574055059, 0.7698674067328826, 0.7843959503379673, 0.724295577623848, 0.7001512851690994, 0.6851416651198693, 0.5742302125274985, 0.7008081019929049, 0.7133755416249634, 0.6909170025720864, 0.719782393671738, 0.7305548673552023, 0.8524222866207929, 0.8557336963574466, 0.8292298168325205, 0.8708412776368986, 0.8221008828335928, 0.8489340621268939, 0.8375025040279179, 0.8639179408436042, 0.8556634625929238, 0.2546537253871327, 0.24560203258243474, 0.6007131082023834, 0.30982722223961445, 0.21926973103569802, 0.26660230657669526, 0.22755052593472658, 0.21471733880361643, 0.24031436377015036, 0.25010528976095425, 0.18700546726162093, 0.19534121056908793, 0.6286462436988153, 0.18179276112651432, 0.2628434489559516, 0.29316589314972685, 0.22057449057015632, 0.30033649472485047, 0.6697312040667147, 0.5265455431673285, 0.6655521376866035, 0.6886237271442265, 0.3203588744896224, 0.6760382383873291, 0.527415098517513, 0.3668474671476186, 0.7174678596842753, 0.5494154273300622, 0.47736991580135424, 0.6427924960007233, 0.7511821667519181, 0.49444316687563306, 0.6672401701907642, 0.5353217877888932, 0.6703767888903994, 0.7641662518794792, 0.1315868231966606, 0.14645754639480457, 0.1339846599739556, 0.24774596871298804, 0.3028054259909594, 0.1713931310456459, 0.259651161883794, 0.24323637768140371, 0.14437473324923744, 0.42379293892172365, 0.43686025625724023, 0.39483298356094787, 0.5160404144235686, 0.550147581433649, 0.5405046788439332, 0.5139120886214434, 0.3728686769768188, 0.4409559944557031, 0.7756801387122461, 0.8118999665221054, 0.8119437498245359, 0.7293091644597995, 0.8238835123664666, 0.7170639289312515, 0.6556308994730433, 0.7345178911027177, 0.824597161064633, 0.1535879015368402, 0.11799543645410626, 0.1436937055826646, 0.10087932824550949, 0.15829647024350668, 0.11426139858343998, 0.10707140116793012, 0.1508808043041343, 0.11727876178338537, 0.1956243571600933, 0.5830570496720417, 0.14311001193746542, 0.13755286682252776, 0.1537680210064969, 0.13228874857996376, 0.12307258753988604, 0.20650524793999736, 0.29074093880080787, 0.615319561942264, 0.6388388675124526, 0.5875573003155508, 0.5960813753189631, 0.6575051474556051, 0.5418892116656348, 0.6792170779064237, 0.6576001092131043, 0.6466543091937412, 0.44208276621394316, 0.4636460449387185, 0.4602385640955333, 0.5069878883958882, 0.4978077207791253, 0.4057819838034652, 0.49359561398316765, 0.5226487120123795, 0.511631429527866, 0.19104395331753743, 0.19739900504464947, 0.19012754566371837, 0.23150493814454154, 0.21294832984313217, 0.1965149098708182, 0.20904286143429152, 0.18653480318532278, 0.19301582174309284, 0.20665003287762806, 0.6229928958140513, 0.469627375303719, 0.6939564094590915, 0.4807041165020949, 0.6360505805544945, 0.44046608969745926, 0.5881116413377252, 0.6035449922509498, 0.8487672650707933, 0.8880201363506041, 0.8372030194509245, 0.19344933184622204, 0.19842882670947726, 0.8687736675167642, 0.16849108103731247, 0.8531391896487308, 0.8078292905642174, 0.8364323747567374, 0.20897260879463342, 0.16424386031455052, 0.16465244728695183, 0.16704634465546608, 0.8000272608381519, 0.20932375619690158, 0.20743279355603317, 0.1996761994730326, 0.1895315197800418, 0.18391533843969432, 0.17943124073697125, 0.18768480618503203, 0.1821717739035391, 0.194977245348116, 0.18736658262853834, 0.1761457872675526, 0.19812234999126732, 0.09013438486176417, 0.0928980279572692, 0.07567691711301994, 0.07928222133681206, 0.08603202110973451, 0.08712196130552641, 0.08458114484253454, 0.07791413822046866, 0.07990595923530452]}, "mutation_prompt": null}
{"id": "b03e575e-7c5c-439b-ba23-b440672683d9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                pop_diversity = np.std(self.population, axis=0).mean()\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (pop_diversity / (self.ub - self.lb))))  # Dynamic mutation strategy\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic mutation strategy that adjusts the mutation factor based on population diversity to potentially enhance convergence speed.", "configspace": "", "generation": 44, "fitness": 0.48105378018024325, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.870969625898417, 0.8643509763659871, 0.8658803225861305, 0.8783429816383054, 0.8764112249401723, 0.8864716515671932, 0.8817114057165393, 0.8719926775208697, 0.8827328083486153, 0.7916055101966674, 0.7956344119618577, 0.781517991537138, 0.8035020304899683, 0.7869689985039624, 0.7736632061187882, 0.806775837758059, 0.7836142104384064, 0.7876246904008237, 0.1438570031103522, 0.11964769372349038, 0.4067401625543623, 0.4238183469096193, 0.14257809399396737, 0.1449388147963384, 0.14844933628848977, 0.42477738535901766, 0.5104956774359024, 0.1630848095602243, 0.2246027564884675, 0.1416577180358709, 0.24776864795316444, 0.11811779693994995, 0.1567664432730409, 0.15345416344104723, 0.15139676907865274, 0.16064342615021154, 0.7950957147270822, 0.7994238446262838, 0.7979704849168668, 0.8014698283432178, 0.7879725217191742, 0.7908699463988981, 0.7958848527280804, 0.7804338409592765, 0.7576714775160192, 0.6814279370432548, 0.6827408495285723, 0.6928103192828559, 0.6434253348759511, 0.6960431979089747, 0.6563629795230425, 0.6896044667495449, 0.7180592440756666, 0.7340254733740778, 0.8270166002729014, 0.8326975437409136, 0.8694835947380356, 0.8283023268597574, 0.8508801895467863, 0.8261650639622341, 0.8474669527740741, 0.8638320756508058, 0.7989638144468179, 0.631622000433018, 0.683838917005869, 0.5371784609510738, 0.5226921836765066, 0.46308709393486214, 0.5887940845994325, 0.5886996072609958, 0.5431063550944111, 0.6290181152480984, 0.27796204228155386, 0.5312277681202299, 0.6416419781361402, 0.6084592175672159, 0.6432118598146102, 0.60932793990999, 0.5059746351757426, 0.3095821908137002, 0.33755354185912945, 0.6165884367487687, 0.47372607346815254, 0.6214396702058778, 0.6922751150787784, 0.50100449264307, 0.5934268565117038, 0.600916091745638, 0.6468951045883902, 0.5857702052314264, 0.7119821608045116, 0.7425663742452091, 0.6981192760601823, 0.7031871520732709, 0.7077077569941973, 0.7292618410614958, 0.7453943981979415, 0.7190789299587079, 0.7259187799169577, 0.1766489235272275, 0.15892042230743342, 0.1521021239559679, 0.24543216772149112, 0.47864932568233576, 0.537606290005592, 0.21509695763084524, 0.23345140691759247, 0.230422791908935, 0.4558377520165927, 0.5281561364444439, 0.4734377600593712, 0.4654609227233595, 0.535331766329517, 0.5263247209847822, 0.4689319253235539, 0.43649464901628154, 0.5145100711689412, 0.8133581605068629, 0.7960259201952171, 0.8015313279798847, 0.7980296993024381, 0.8108992280368278, 0.7066177404839542, 0.8085465076660662, 0.805067843246217, 0.8050450909648055, 0.09986752015945366, 0.1100390247054489, 0.11693418269736144, 0.17141993403568956, 0.1177405595575074, 0.10246011924541853, 0.09520147108403776, 0.10541523150330245, 0.1266584353063568, 0.291118465343579, 0.18500340598944554, 0.14871524642138156, 0.17795792608909777, 0.1468442602465284, 0.23018244193902015, 0.17307299643423846, 0.15810071243624646, 0.13934993183060118, 0.5313783930389716, 0.46518571494961647, 0.520015400727528, 0.5289548690671841, 0.544322467983323, 0.5341532398127702, 0.5800989738483113, 0.5523857577708478, 0.5504013045459892, 0.36474529702388625, 0.4230887739260233, 0.33939836826331093, 0.3507471506819857, 0.3960985388224839, 0.40278533596158905, 0.40903480695466665, 0.42180593049000104, 0.35434204309181216, 0.1788612026629689, 0.22083352628868314, 0.19803559851090613, 0.21079369355573074, 0.18396406469507665, 0.1953857990345389, 0.20260997734125608, 0.18759553672416818, 0.20429197635657714, 0.22998658130796723, 0.6902975012679102, 0.5840337837388412, 0.5799777879082373, 0.4666966102169692, 0.5314306437093571, 0.41268207284084524, 0.5787860722844392, 0.23906183984160712, 0.182832461977951, 0.8696966567558715, 0.8356725482426516, 0.8706371315784212, 0.18727758805314365, 0.80746450062338, 0.8375379833312661, 0.8445366693636303, 0.8398166309600759, 0.20528884640730383, 0.8306223949613418, 0.7516651637813911, 0.210015787201824, 0.16515066955935054, 0.20834860249872555, 0.15412854066541581, 0.15497315719972116, 0.2084847971906839, 0.20916388815315556, 0.17406973856087993, 0.1788440135516044, 0.18380781541773772, 0.18567262982553656, 0.18217318659483295, 0.1718423197112594, 0.1948597653849351, 0.19508573936232554, 0.07773225098963865, 0.07451880963589652, 0.08442052778642106, 0.09025036055060087, 0.09286951784024144, 0.0766068448744972, 0.08128948857248741, 0.07683089789244768, 0.08823967071215633]}, "mutation_prompt": null}
{"id": "63235189-c5f7-4497-b889-98a91fc5f321", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                best_individual = self.population[np.argmin(self.population_fitness)]\n                mutant = 0.5 * mutant + 0.5 * best_individual  # Weighted combination with best individual\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a weighted combination of the best individual with the mutant vector to improve convergence speed.", "configspace": "", "generation": 45, "fitness": 0.16602568538627002, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.12.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.4048366854735036, 0.33674586870497547, 0.4046914979144549, 0.1923381029933786, 0.34125656344504895, 0.6232635949164742, 0.4836245642586572, 0.3411852614270029, 0.3908173024204019, 9.999999999998899e-05, 0.051072443938065426, 9.999999999998899e-05, 0.06765378979632153, 0.059159238344424936, 9.999999999998899e-05, 0.0025767658415319916, 9.999999999998899e-05, 0.12728234621580103, 0.13072271207946506, 0.09888080441836156, 0.1479775178457352, 0.091815109753276, 0.1075343953875958, 0.14586943056916357, 0.12002512810049026, 0.13694735619368292, 0.11279993154678503, 0.09477844453291995, 0.052590699909187966, 0.09803814850632975, 0.08158009582692216, 0.09001861632892727, 0.07123150317723126, 0.03640349934700493, 0.09279113529861538, 0.08715040887728265, 0.06676571932170483, 0.07424353786870419, 0.079106874007709, 0.0740324444509699, 0.09782144592764652, 0.09921814375576432, 0.08798965450796681, 0.18022817896799248, 0.08635891312631916, 0.08942073707963938, 0.17252491385291724, 0.27742616829817135, 0.15937268999221943, 0.17645238306229094, 0.06181666399505248, 0.09819677348241418, 0.1312387379499791, 0.07450432576233634, 0.3563845204969396, 0.17247827234004032, 0.16752483595420087, 0.31595718072663326, 0.3490202020648133, 0.15089700816851914, 0.1171738733998342, 0.24048129285480369, 0.07594077201329874, 0.16095499082556886, 0.13673724851832536, 0.19934238034896978, 0.17695139448072683, 0.11366326734050869, 0.11577400280083472, 0.1513622476689852, 0.12613902340324112, 0.03741678685142491, 0.13390711332689043, 0.1509686072432832, 0.13314685728810238, 0.16642872115310403, 0.012786067081304808, 0.16177994277522723, 0.17623531205641774, 0.1520968452859479, 0.12859177095519425, 0.08357261366279944, 9.999999999998899e-05, 9.999999999998899e-05, 0.03497406015270954, 9.999999999998899e-05, 0.03833748852074603, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09171865500649368, 0.06023729337138173, 0.10504052999450264, 0.1026823825282841, 0.018664172658680034, 0.026231695427894164, 0.10006170425678806, 0.07991383944843333, 0.04638949681853133, 0.15273742890335884, 0.1570743477851142, 0.00020848614565782686, 9.999999999998899e-05, 9.999999999998899e-05, 0.09623880100965254, 9.999999999998899e-05, 0.20578594177613385, 9.999999999998899e-05, 0.0700689805601773, 0.005659226828182318, 0.14738865339986662, 0.016542653428573084, 0.0834547409921732, 0.09244644229190035, 0.03487627810869176, 9.999999999998899e-05, 0.10224309491302774, 0.35931589586577684, 0.46802813512848884, 0.42113218968108856, 0.32507321736545314, 0.3006617399732532, 0.313047574742397, 0.2603462763160077, 0.3214668723337276, 0.48949076043155204, 0.06691125995807756, 0.09769252068641032, 0.10427573197510431, 0.1198523051460807, 0.11927197973974812, 0.1645299476178207, 0.40161524298578677, 0.11716246235384409, 0.16470689485263734, 0.31427331023577154, 0.1305701176891746, 0.19940097149419245, 0.19429579075287662, 0.16690222378894837, 0.206497436275769, 0.22837252896890847, 0.41773287144704074, 0.2401480819736247, 0.17495093363107794, 0.2257361255442194, 0.29720587155321176, 0.32803942452606216, 0.360035488427078, 0.26029992370042876, 0.2098990719176531, 0.37409934329437566, 0.378670762938908, 0.21504113836210392, 0.1791303954895186, 0.21564912304320538, 0.26727635370044567, 0.26706254823393916, 0.365957970828078, 0.208145120025233, 0.20319044534330366, 0.3079914720255158, 0.2237890592073153, 0.266457764085562, 0.2057271646690405, 0.21366990749988324, 0.24172697231470142, 0.28157125332067523, 0.24099499639113175, 0.21766599762920658, 0.20541056376825728, 0.17374405947655958, 0.1959328226531255, 0.16504035444790932, 0.17071513263020266, 0.18434080480418014, 0.17443350443652939, 0.21537075767092717, 0.17966895509666525, 0.20856455328105028, 0.5305460636522754, 0.15814017281307113, 0.14915257993314512, 0.1693583376591189, 0.20190572762774717, 0.17352807673222725, 0.1200106797047833, 0.16870503653160196, 0.3571784897352108, 0.485786286897115, 0.1569532414431487, 0.2138378847684418, 0.21356890581533472, 0.32621945137767827, 0.20578944131547683, 0.10520077636651437, 0.0950088025114344, 0.16693437791144883, 0.17922096909605023, 0.18713916753484128, 0.19147717390242636, 0.18764912374059017, 0.17417026064977725, 0.1779708940136988, 0.17386056883576362, 0.1897865324676904, 0.19230435793140965, 0.0955575984307403, 0.09652931201907378, 0.08322557502473793, 0.09311882107208114, 0.08768309647420336, 0.09504041278271147, 0.09858123550497477, 0.09112793748907666, 0.10873338371014996]}, "mutation_prompt": null}
{"id": "516d9d37-56fb-4609-a907-3f3e52a7b220", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                performance_factor = 0.5 + 0.5 * (self.population_fitness[i] - np.min(self.population_fitness)) / (np.max(self.population_fitness) - np.min(self.population_fitness) + 1e-8)\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * performance_factor\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic scaling for mutation factor based on both iteration and individual performance to boost convergence speed.", "configspace": "", "generation": 46, "fitness": 0.3911360034255722, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.906177269386925, 0.8964934329855687, 0.9134536830658322, 0.9153881168905889, 0.8919343595601172, 0.8949724896087129, 0.9013979125021225, 0.9037315882438968, 0.902211282319026, 0.8419145620964374, 0.8409712678412586, 0.8294849374123916, 0.8413850725808044, 0.8505875700413047, 0.8424245055400295, 0.8288701205160129, 0.841418265619514, 0.8530339028681511, 0.1451213810284533, 0.5189796060060053, 0.24005898923324842, 0.16357382143363253, 0.48939496269275773, 0.3051254443691154, 0.17464267443968018, 0.20985489634899113, 0.15586441742893165, 0.11007008079954317, 0.13581963617832082, 0.14925435686560973, 0.16786917065030083, 0.1567768146272449, 0.15071320632317453, 0.13938576342627906, 0.13340856720369865, 0.17594882110060794, 0.9354674369017023, 0.9843677613950809, 0.9433190319102249, 0.9532794685839815, 0.9717264308575809, 0.9127339389175144, 0.9334338466541132, 0.9427693022999052, 0.9562580093896977, 0.4937168090668571, 0.6691177716068252, 0.5767167328327363, 0.41352917797934985, 0.1631276445315194, 0.2135035018304452, 0.28584084706260104, 0.3042675332053093, 0.3054948340624416, 0.3917986041446342, 0.8784404493248023, 0.874875606622304, 0.9056536068352581, 0.8760274341669726, 0.2753603777040625, 0.39820589174694787, 0.8811640684571435, 0.9021033940588531, 0.3181675514371134, 0.23744972176334533, 0.18654929059777037, 0.15118764137990215, 0.495737308035718, 0.20777913974972162, 0.17756921932697645, 0.16332429778383284, 0.20695071545872823, 0.15325647005620868, 0.18353485123378255, 0.1358016817300579, 0.2332869346791785, 0.13330991412664606, 0.19781326444726022, 0.13581063313051112, 0.24239185768267935, 0.17057743542154347, 0.006053301813008671, 0.13067009446833144, 0.283209378645766, 9.999999999998899e-05, 0.12484498015046352, 0.18591774457477983, 0.09537451864984525, 0.15630761912036795, 0.271789162774992, 0.43743274402699595, 0.1713974281520656, 0.2031960294069639, 0.6472528145786058, 0.13321973214790528, 0.15564430021947007, 0.27282353970628226, 0.36981677244724287, 0.38458493103558955, 0.06135992547315072, 0.124587182340692, 0.33581271758025366, 0.08928622388993912, 0.13340314219276495, 0.14145596426593998, 0.14636339081964156, 0.1839551931252259, 0.24422960576377883, 0.2819899676675752, 0.29799307819268905, 0.43679002034142256, 0.33496453212340105, 0.4023012862110752, 0.42969401091943515, 0.31484434159390073, 0.44657380550499337, 0.5457256761243974, 0.7354314483180506, 0.6550839049747018, 0.6937198697729854, 0.5830843284792744, 0.7081657044556118, 0.6389763723223886, 0.5543496666223416, 0.5906256129048373, 0.5221273565079714, 0.19334544796925912, 0.1343012990562611, 0.12783224571079022, 0.10864611140440539, 0.14010652869117257, 0.1501792773050009, 0.1251087895661387, 0.13091464933422992, 0.14222576936202735, 0.31001135403740265, 0.1688335137015069, 0.2812130709036257, 0.22163980007361728, 0.19332999233106962, 0.17486920610251677, 0.15033736492018546, 0.21381653945707435, 0.17977279746891384, 0.565359442742408, 0.5915379890673005, 0.6786199708498155, 0.5147508970870169, 0.6911153015751298, 0.6646059992388698, 0.7143674369734194, 0.7054938911647513, 0.45788000308653765, 0.4948960022991076, 0.4335927045816972, 0.45041899863491197, 0.321045236526886, 0.5087955340081172, 0.45653789465904915, 0.3559531819023375, 0.40839459337666717, 0.5282324049300173, 0.20936796866748297, 0.1917668872055559, 0.19272196725341806, 0.20631954446916656, 0.20079134167693968, 0.21095698722672251, 0.20027899472868627, 0.2176832202037624, 0.20672453650468503, 0.5417474149785575, 0.24109078315993016, 0.6557879231233295, 0.4004790089280331, 0.7069795809212823, 0.20894800936235902, 0.49223641825486564, 0.7192921954996507, 0.21957589525188737, 0.9061661932918376, 0.18214925318544894, 0.18360687053939795, 0.8647205736706352, 0.8837928000614231, 0.16689519563512456, 0.18438346031491948, 0.18398269345183016, 0.9122197439226513, 0.20720982133035715, 0.15545681134895062, 0.4938266549668542, 0.20555524688887483, 0.16604869200262784, 0.35735852379276867, 0.5718402609309754, 0.20958086948420773, 0.20863270509359222, 0.19053658275609853, 0.19260858848831408, 0.18566423528709053, 0.18675248406320266, 0.1938905927148481, 0.1812159015539324, 0.22042828105168966, 0.23796944846615598, 0.2053839828046754, 0.08893380068388324, 0.08693802900434511, 0.07686739589727964, 0.08801027707617992, 0.08542996125171942, 0.09646043308031715, 0.08194220160619992, 0.08963959256546472, 0.08940885431291923]}, "mutation_prompt": null}
{"id": "461043fc-3d21-4478-a858-4d23c3159d4a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            # Introduce a dynamic factor to scale population reduction\n            if self.evaluations % (self.budget // 8) == 0:\n                reduction_factor = 0.7 + 0.15 * (self.evaluations / self.budget)\n                self.pop_size = max(5, int(self.pop_size * reduction_factor))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic scaling factor for population reduction to maintain diversity and improve convergence.", "configspace": "", "generation": 47, "fitness": 0.45528419338237425, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8882490454054902, 0.8786905432313025, 0.8755105280695418, 0.8870932948316718, 0.8963458593156541, 0.8783437415557933, 0.8898105101733932, 0.8908688692379434, 0.8876642159420041, 0.8128845105556181, 0.8172573878414688, 0.8081769293529798, 0.8135658450687783, 0.8253236217624134, 0.8163136127618579, 0.8255411508502294, 0.8142367675243177, 0.8234686426518186, 0.14400845081003333, 0.4760353756715603, 0.6259853069507813, 0.4953098992825412, 0.14558046650351375, 0.1416283071200669, 0.35467495687989203, 0.16214729297922026, 0.6556470913820669, 0.14073609584491964, 0.13224787301537322, 0.15663564493196214, 0.15465818048491875, 0.4512680411581823, 0.12684756983153833, 0.1406019093530897, 0.1386864258983167, 0.12678177123403622, 0.8064955726772205, 0.8081741128882576, 0.8220952295784305, 0.8091567115471756, 0.8372591185417274, 0.8261899671180828, 0.8140639342838352, 0.8212646254649071, 0.812452986275015, 0.5943368770022901, 0.7305174363300766, 0.7281893557770255, 0.6812218210407983, 0.7078776050504791, 0.7383879355267424, 0.7363199131831522, 0.7312448072317932, 0.6806869827685073, 0.8585835272842512, 0.7884746058310546, 0.8516182864131305, 0.8679963217145529, 0.8134109858641019, 0.8641110576158121, 0.8589536837238185, 0.8371099498653451, 0.8710605109254119, 0.31373187330340135, 0.30823587720314105, 0.1828456541107989, 0.7356701121196225, 0.2509688016446021, 0.2075512500324067, 0.20855953682225004, 0.2359827274116607, 0.17194053157569922, 0.17347013158025015, 0.23132829653293607, 0.3231798874599503, 0.419431864417691, 0.24896434119363686, 0.1728991361745913, 0.2373984597624753, 0.14791717175636443, 0.1848301751333088, 0.5382249574084239, 0.18833714434353355, 0.5585980354416911, 0.30099450088960655, 0.24287039235417696, 0.2907188969044381, 0.16529850944397817, 0.5019601081460041, 0.3519037762226499, 0.7492904076528413, 0.48094363775411797, 0.6311358495559871, 0.6125292917630223, 0.19889296983671378, 0.26754958043255694, 0.3531867199634724, 0.7988639839880641, 0.6688266075207631, 0.2928702182444517, 0.16728409886067652, 0.07937380777596081, 0.3526419392077823, 0.24690059091950034, 0.10472976948112134, 0.23310425839525029, 0.18674653903985172, 0.2546767288305516, 0.48680369236102106, 0.4392467074319114, 0.3673963009443748, 0.45769105237620944, 0.42164232887387465, 0.5381543801784607, 0.30503619236154766, 0.45691059147062285, 0.38445803539024215, 0.7499981347450191, 0.7840669449501937, 0.5863401318159649, 0.7749352534023938, 0.852492048131684, 0.701930816269468, 0.779748498050548, 0.7485676712518166, 0.5622730629864945, 0.1401836862007544, 0.15838886101240335, 0.13611345817281562, 0.12059736685846367, 0.10674971374690523, 0.11942491083086848, 0.12728230532578855, 0.2923892749495022, 0.09978571968737837, 0.5257171365324886, 0.1280356226042062, 0.5678964969103286, 0.14034035757806052, 0.1283204810438041, 0.15436064303195873, 0.18135820361884258, 0.15686953047578822, 0.21135738873843402, 0.6446665591268924, 0.6413025736538633, 0.5516854675747707, 0.5552466632245272, 0.6583684796128756, 0.6867427951373964, 0.7039638167823994, 0.70433232661771, 0.6805091522435068, 0.5419295359066985, 0.5011016644265153, 0.38140556454704533, 0.5404667401779213, 0.4618293477298566, 0.47340059901979903, 0.41842615452979703, 0.603461932001691, 0.5226930566550418, 0.18806023566137287, 0.20110003099409024, 0.1972667105780782, 0.19880738130329678, 0.21452328697946366, 0.1907761941548506, 0.20737288236246842, 0.20579156442387425, 0.19032409696999975, 0.21668042986195502, 0.2324503477125056, 0.6060093457939828, 0.5217684245685363, 0.7257683776227436, 0.1987269374800681, 0.5269543242414251, 0.47188252123519847, 0.6526388298256788, 0.8560464257780298, 0.8640401741512965, 0.17864235662214456, 0.8716018229768515, 0.19208868450683492, 0.8423409897483902, 0.16645037902810478, 0.8608356295899044, 0.7728275875395885, 0.8788570987085865, 0.8490804157918503, 0.20470066813762056, 0.616982930466129, 0.25957779017561466, 0.19933188341220243, 0.8690084248395025, 0.15545725695049317, 0.20436573037435113, 0.18902838322955617, 0.17775352751876106, 0.1836408221152005, 0.19337132603647011, 0.19216350288243877, 0.19007661863128889, 0.19092944320830796, 0.17427714294214636, 0.18724027367059193, 0.08739000387927243, 0.08055750838365039, 0.07768093108359886, 0.07752307659827362, 0.08088756707402267, 0.08682494291461973, 0.08784598793771181, 0.07942367556798036, 0.08179863147365718]}, "mutation_prompt": null}
{"id": "a37bddd9-cf8f-4bc0-90b0-9a1da1461a21", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.6 + 0.4 * (1 - (self.evaluations / self.budget)))  # Adjusted scaling factor\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)  # Simplified boundary handling\n\n                adaptive_CR = self.CR + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adjusted adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.3 * np.random.rand()  # Adjusted random CR\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced crossover strategy using adaptive scaling and dynamic mutation improvements for better convergence.", "configspace": "", "generation": 48, "fitness": 0.4321195958654878, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8837281957747184, 0.8783949803263676, 0.8697395975164961, 0.8825637657683059, 0.8858396900663336, 0.8687964530660751, 0.8724759700287488, 0.8846329978803339, 0.8730941947949179, 0.7953625220309049, 0.8016078147753338, 0.7870487102894108, 0.7970430185408208, 0.8045266233095264, 0.7863678114218704, 0.7779888146368562, 0.8010519091908189, 0.7982652553640657, 0.1525278071203604, 0.16420185225299633, 0.5388201688413141, 0.4946342327329082, 0.36415317489770127, 0.4053740695025986, 0.5481538668472086, 0.36607038804527536, 0.4796144905410501, 0.1429361301632085, 0.16534136993908088, 0.1535092589979935, 0.47705008221019907, 0.13958725962023621, 0.15051341411172214, 0.15940668687520143, 0.35530810261606605, 0.12718956402761727, 0.9761401876245471, 0.976159001454998, 0.9777429294389756, 0.9723915108387391, 0.9722795752246333, 0.9543695867364242, 0.9784864215603561, 0.9723773794709729, 0.9704585450536313, 0.6748984307878938, 0.6418105866202084, 0.6623029455162166, 0.6758127645193761, 0.6571643430976056, 0.7045766473604171, 0.6701326817019393, 0.71679507053494, 0.6700305390362131, 0.7925630469289358, 0.8308090897944915, 0.7899833447139243, 0.839449232086907, 0.8497006529812244, 0.810758093880062, 0.8324253883281023, 0.8338910110385054, 0.835519910403918, 0.1264842912413664, 0.1828594314460522, 0.3531228298294652, 0.20004566872444662, 0.16261849927694272, 0.25167293791188283, 0.3340656313870223, 0.1994328543585575, 0.1884138310807265, 0.22853069026082617, 0.3193911036184848, 0.2282941599582894, 0.15736986620899096, 0.20660135458992512, 0.2170278694457678, 0.2875920592170854, 0.1837842982960034, 0.2544324112416959, 0.36672485818376976, 0.48727914167971464, 0.43040271999227686, 0.4786222501928964, 0.518539230619012, 0.3823231514446249, 0.3225871696749991, 0.5225548045765029, 0.3314385869608033, 0.4062740555122535, 0.5851230246022139, 0.5982021689188343, 0.3886371771690419, 0.4585511840893619, 0.5192704667567003, 0.6352931172418053, 0.5268378424565738, 0.5163945430365044, 0.11533204618057857, 0.16833451123051368, 0.12284778641428151, 0.20222574847621244, 0.25387172769793986, 0.4208140497542372, 0.11435701752054106, 0.2427997683717228, 0.25504687583579444, 0.3225372240976123, 0.3541879443625875, 0.3533023213924289, 0.38235579773996275, 0.43127391661500225, 0.40731812870073714, 0.3256956260129674, 0.36316699067816194, 0.2909766607997196, 0.7313469219506123, 0.7471623650295129, 0.7834140756286267, 0.5832697103801763, 0.7959605007217861, 0.7796148159518379, 0.7722010272970898, 0.7962246612088026, 0.76588984979548, 0.10876802084329629, 0.09824202400535909, 0.10980736209991881, 0.12809588361273583, 0.0982754129897172, 0.118362301035842, 0.12555856535218468, 0.10697889807990046, 0.11272544429003517, 0.1548496162364178, 0.40501850331292455, 0.1344877808168412, 0.18447659159205498, 0.16752467445625574, 0.23774129853606696, 0.140494308227739, 0.20373268660679011, 0.14024769135609838, 0.5394238748819069, 0.6085488545263475, 0.6080900334569576, 0.5144339587300196, 0.4994917260621574, 0.5274078458593843, 0.6154907862206551, 0.5682092126537601, 0.6056586816712177, 0.3609815514455432, 0.36689207447603445, 0.33055748981716493, 0.3940164930078841, 0.4266279465707602, 0.42978257831812494, 0.4295241495766725, 0.46516805694644203, 0.43873198824897597, 0.21233041042195222, 0.22773208417465807, 0.19196327501567678, 0.18824582467300244, 0.19230955447367482, 0.20862708128143348, 0.1939711163698149, 0.19399948182114957, 0.20200482989417534, 0.3941136305910292, 0.205169610389194, 0.4463506465047108, 0.46846704588639554, 0.4527929955351133, 0.6164941838266768, 0.3410977675582564, 0.21426447886249278, 0.5654955969147908, 0.804247168620934, 0.1648734701684612, 0.16057130623838056, 0.18663389376130157, 0.20391541528510848, 0.18028033223722595, 0.16788063425178312, 0.8397380460005746, 0.7556503460095964, 0.2053087963331932, 0.16589444386394314, 0.8041845558870541, 0.1991790808430708, 0.20206188097628974, 0.5623672427121283, 0.2088160971549139, 0.21150732639129033, 0.8036740371213547, 0.18905533908530736, 0.17922905465486527, 0.18709356211850436, 0.18326916922806447, 0.16956738812753125, 0.1827942738291669, 0.17983045241188245, 0.19737744521052403, 0.17605941114447887, 0.08925495873807343, 0.07700067344297223, 0.08425812513697861, 0.0782361659154791, 0.08146691936161865, 0.08693387021013954, 0.07570336851289672, 0.08232507366166752, 0.08146689027907761]}, "mutation_prompt": null}
{"id": "bffe7e48-06ff-4bdf-a413-f76a607fac94", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best = self.population[current_best_idx]\n\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (current_best - a)  # Enhanced mutation\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a dynamic component based on best individual's influence to improve exploration and convergence.", "configspace": "", "generation": 49, "fitness": 0.46309183731096015, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.898959250535427, 0.8845094112248418, 0.8920907478755347, 0.8974088119283249, 0.9058545727195677, 0.9032680463488466, 0.8977707219679625, 0.8976580961105279, 0.8996365509314894, 0.8305865874713833, 0.8297312972548854, 0.8208056784883672, 0.8094514042604503, 0.837372738331174, 0.8270489688644146, 0.8247582895753515, 0.8174496200739965, 0.8211957975013582, 0.25144907003274597, 0.15183833001440983, 0.34896895624232105, 0.4608348057442102, 0.15824952420695737, 0.5257203888257016, 0.1718211655026456, 0.476080404156211, 0.5370595153238419, 0.1287779037686798, 0.15074370577316754, 0.1271138409710968, 0.40668491608232205, 0.1344339858426662, 0.14866038692184302, 0.15902605849522589, 0.1528479809242732, 0.14931546682563568, 0.8342617370194849, 0.8196039677425044, 0.8145320294958155, 0.8236113453574356, 0.8220148954566568, 0.8350256575008714, 0.8265749553007118, 0.8271417613225642, 0.8245676891486259, 0.760210050824944, 0.7413445050255218, 0.7286933019353191, 0.7807208656535676, 0.7616878769666879, 0.7547427656917882, 0.756151181731551, 0.7718689895183711, 0.5545925920585122, 0.8597653269853572, 0.8868983794124661, 0.8443421697657567, 0.8952905277742582, 0.8562971916923386, 0.8514187033046186, 0.8517134249016347, 0.8781196020963349, 0.8527813557612847, 0.1911312200769255, 0.38427338052934723, 0.19891820039735408, 0.611915946816944, 0.20812559154869092, 0.21337085542581957, 0.19099523953519537, 0.406641951347653, 0.3076154068853699, 0.2562439852211875, 0.20723522046347587, 0.22700642354709522, 0.22594476866117164, 0.3284722872299277, 0.21852278868126618, 0.21266171659157662, 0.20847566396346895, 0.2841216468747251, 0.5037052350503739, 0.5188850119212683, 0.28376831590003104, 0.5778816268977296, 0.5929016748348137, 0.6942977852144815, 0.7281283150215009, 0.7017239180082472, 0.6966186680797433, 0.7561005061168353, 0.7009285727170975, 0.7549288091692974, 0.4548581398991369, 0.7860455442784908, 0.5272793084034604, 0.761009331582025, 0.4748050715219867, 0.7367402456956482, 0.2638584785599122, 0.16077478453530658, 0.24899275956670164, 0.6447490481906535, 0.4173323656949618, 0.13128782302927955, 0.1893573521739862, 0.20631951057105835, 0.1948911401983605, 0.42149077022627146, 0.37082911541565033, 0.380744217575567, 0.544565294565071, 0.6088751967174659, 0.5867895357673028, 0.4373569485706589, 0.3099591172008779, 0.5147582673270928, 0.7619681046727357, 0.8455364563857493, 0.7814637612912805, 0.7766786156117663, 0.6886693236978294, 0.856789135033954, 0.8419292631510202, 0.8575647727605354, 0.6480836592831055, 0.1130753979512994, 0.1102493897433191, 0.10646115445698201, 0.3597673044148896, 0.10322293273413796, 0.14570640096585408, 0.1090447985137134, 0.12067258674296721, 0.10120779189459295, 0.1438229125644782, 0.13219897512436962, 0.1293452450810344, 0.20965658209709492, 0.13861919664882594, 0.141340941807634, 0.13127003713802987, 0.18725365611820144, 0.14783811097225985, 0.5589858265722093, 0.689751330557571, 0.5507334344676506, 0.6647328486619487, 0.7027268505518935, 0.6648012080313691, 0.6879356019019874, 0.7116608622566956, 0.7023625997526967, 0.5391701788868064, 0.4787250545911398, 0.5114889898934478, 0.5332704629632268, 0.3551422194282048, 0.5324785872384172, 0.5099648373232186, 0.5634929361111802, 0.45238773905421636, 0.19290486622248493, 0.19582429913901467, 0.2123545788648732, 0.21074038225889935, 0.20022716403192875, 0.19852999252501347, 0.20892941448449687, 0.1842597852470622, 0.20994738686101555, 0.23751657093310097, 0.6236732409442078, 0.5566053282099006, 0.587482149829001, 0.24431232829947724, 0.21016717227214943, 0.507934542846812, 0.21690907580044472, 0.2347440650547883, 0.8752239636115303, 0.18700276210730293, 0.1838465903469949, 0.8534040446183655, 0.1701429131385639, 0.8439606555449621, 0.8367954073103777, 0.17162296061483884, 0.8539932537383406, 0.8553244467620147, 0.49464453650499385, 0.15395830505795982, 0.2067167295455934, 0.1644957530115131, 0.16487734043089552, 0.15616431312834378, 0.1548299350920106, 0.2110205266117301, 0.1889606545237591, 0.19440433871268048, 0.20176928744690625, 0.18196726936028795, 0.17663624624720065, 0.19148317564028572, 0.19075016529571176, 0.17679331707050294, 0.19639964947621857, 0.07703897296316387, 0.09336438000651359, 0.08059304708483672, 0.08041619155343083, 0.07917071402041276, 0.08865028546528042, 0.07907578572900331, 0.08679474506619789, 0.07886783084408455]}, "mutation_prompt": null}
{"id": "221436fa-e72e-4e3e-8c48-68b4785a79ae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * (0.95 + 0.05 * np.random.rand())\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR * (0.9 + 0.1 * np.random.rand())  # Slight reduction\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolutionImproved", "description": "Introduced a dynamic reduction in both F and CR parameters based on the budget utilization for enhanced adaptability and convergence.", "configspace": "", "generation": 50, "fitness": 0.3621390347570696, "feedback": "The algorithm AdaptiveDifferentialEvolutionImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8317660156423101, 0.8402044276110712, 0.8552443733944943, 0.840915932650018, 0.8471220455997293, 0.8388898345023712, 0.8433371651149929, 0.8438128739912885, 0.8574250792785427, 0.7462674841264957, 0.7352083037903971, 0.7426824549678135, 0.738443743993206, 0.7185045215168744, 0.7396233741886185, 0.7372657690284727, 0.7424701930393811, 0.7442885244006532, 0.4555633199243272, 0.4694279015177726, 0.4176456980540437, 0.5246065655581797, 0.16357706977904252, 0.5520648863395825, 0.41687653037168404, 0.4952970074650468, 0.5956685450107373, 0.16120760840799198, 0.15099882386580288, 0.374394913363317, 0.417279067170385, 0.16372214838490895, 0.3697832668803731, 0.14132951039099406, 0.1315956945936989, 0.45028350093410596, 0.8139294887374372, 0.8003096929763873, 0.7678985385631678, 0.7875008069463971, 0.7960411223882577, 0.8011788919903853, 0.7796279293038797, 0.7813670235456196, 0.8036727442455996, 0.5769973317443371, 0.5554140869544346, 0.5711608043730498, 0.5324872849498896, 0.4912673329784557, 0.5403967232702613, 0.5092638450497246, 0.5249806205720375, 0.585898024200302, 0.6603194276629117, 0.5860395228758357, 0.653521566181549, 0.6614702823469296, 0.6424453764838224, 0.6871644274109784, 0.6411217503001776, 0.6775627982895465, 0.6466833049802097, 0.2201510797533841, 0.2821273006418594, 0.23206465496328665, 0.2055421560388515, 0.24072399185696214, 0.2481570959447601, 0.28446103699322145, 0.2668427517874903, 0.24850490076570642, 0.23098374434050228, 0.240548087385565, 0.24449664441630536, 0.29380159322238786, 0.2126096343334125, 0.2524846231341771, 0.25188261193115324, 0.2427578165722577, 0.2813685519676745, 0.12981083253014936, 0.1315759118392119, 0.07643263689383983, 0.07951494897326816, 0.06473160562695046, 0.06994374539473702, 0.12222882429452875, 0.12808761957774406, 0.05456468179962615, 0.187430706780484, 0.19763960602500696, 0.23881596392034166, 0.2714416731957502, 0.1723322151006894, 0.18655291582374256, 0.22110113569795709, 0.2196180646115775, 0.22145410716337321, 0.08730587945427126, 0.06544785170504908, 0.03285030443610726, 0.04914010605423591, 0.010235060838097887, 0.0911052920950477, 0.08901054673414177, 0.0995824009450198, 0.08347844177151509, 0.20112079323459497, 0.1707285336166655, 0.1805027918913289, 0.2173619882399329, 0.21039743289169788, 0.23003606587514924, 0.16833916802520055, 0.18333071262297063, 0.1760777951062984, 0.5941814133409566, 0.5927179065922064, 0.5641705676217983, 0.579883932504997, 0.5791052398099804, 0.6081733854432945, 0.5932428897868135, 0.6180967730023629, 0.5493046526007948, 0.10667860879715996, 0.11139759180425102, 0.09620284777861321, 0.09383019323262798, 0.10183285408160736, 0.09471669483511336, 0.10948633211821945, 0.09100892489411994, 0.09449639051704872, 0.14566113878340425, 0.1458104260631804, 0.1407612834100419, 0.14004832719275595, 0.14625372319613283, 0.1542813511096992, 0.183810164481509, 0.1387698118760161, 0.13360008026384096, 0.37587913412955953, 0.3828610111592752, 0.3746437191234946, 0.36698740287392284, 0.38177807017028476, 0.36128730461177505, 0.44671395879451214, 0.4161197763098682, 0.4545839395164185, 0.2528246887117027, 0.25380209945234866, 0.24715253738491283, 0.2382204216996362, 0.22181252683101216, 0.23410802473256753, 0.3224104936114307, 0.29588324344733674, 0.29113363669423276, 0.2059370386673406, 0.17981334957521844, 0.18136971907755484, 0.18628496043787046, 0.20388623438935516, 0.20688371098689928, 0.18971454713556246, 0.19088061416862723, 0.18459236505168986, 0.2566541963719735, 0.3221866059081332, 0.20990646281765968, 0.20149374257243713, 0.33050794304253817, 0.4627483284073789, 0.4329624603803103, 0.5044530048796038, 0.2636295134706801, 0.6571018110029966, 0.1779260149924905, 0.6221419843991216, 0.7042035645010142, 0.7380883283716309, 0.6618299906058767, 0.6359788708753675, 0.16162870056954182, 0.49571350847199, 0.5494898831251827, 0.5435617553190468, 0.5194733660640651, 0.509751417398984, 0.5876020519799428, 0.5866889400199546, 0.5863628694584382, 0.2010877634920949, 0.6142473563099091, 0.1813307933049476, 0.1876881488016625, 0.18157756245789392, 0.1714581190897968, 0.1987466835197046, 0.1902394899641937, 0.1861535803743335, 0.1818277049668129, 0.176099583606514, 0.07337443517980502, 0.07851226136166811, 0.07718247177509674, 0.07586858679228448, 0.07590231795247016, 0.07697892369094295, 0.07519061370013258, 0.08301193695147957, 0.08902826434040689]}, "mutation_prompt": null}
{"id": "82bb9c93-f3cc-44e2-bf68-bf58e9f0bb29", "solution": "import numpy as np\n\nclass AdaptiveSelfAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_F = self.F * (0.5 + 0.5 * np.random.rand() * (1 - self.evaluations / self.budget))  # Self-adaptive F\n                mutant = a + adaptive_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)  # Slightly adjusted CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.3 * np.random.rand()  # Reduced range for faster convergence\n            self.F = 0.6 + 0.15 * np.random.rand()  # Adjusted range for F\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveSelfAdaptiveDifferentialEvolution", "description": "Implemented self-adaptive mutation factor and enhanced selection strategy to boost convergence speed.", "configspace": "", "generation": 51, "fitness": 0.41441707651071347, "feedback": "The algorithm AdaptiveSelfAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.9077937048508351, 0.9148624184809975, 0.9151668061711058, 0.9025108092097816, 0.92292189861563, 0.9130755214286337, 0.9131655705460844, 0.9012999618277872, 0.914229155250281, 0.8487732060726713, 0.8370955269285468, 0.8542862967949506, 0.8583376722285667, 0.8446586339379523, 0.8467758245413909, 0.8434797310392731, 0.857622473189211, 0.8286294406228834, 0.5342720139947623, 0.6090246594242807, 0.16279268829970128, 0.16878526025451723, 0.5252113075587592, 0.5388162663849627, 0.6566697815580559, 0.634232221960356, 0.69780580465843, 0.1461688512150262, 0.1300609604759163, 0.16001621013234557, 0.3176025018619585, 0.14949633099810433, 0.11862877010784101, 0.534400534395568, 0.16355533691269142, 0.1511265949995988, 0.8337516086308487, 0.819536979318554, 0.8254842718449471, 0.8459450999081284, 0.832475172481973, 0.8136843628309156, 0.830866182645099, 0.83571977648255, 0.8555057809207344, 0.4620500477002627, 0.3806540883334645, 0.6388926626745596, 0.7400889772716968, 0.6555741582212068, 0.2550778031699459, 0.39613620251744186, 0.2721509750471014, 0.24403596582866616, 0.8491072442335075, 0.8295628070109962, 0.8414289553207766, 0.8598614035696456, 0.9059307863578386, 0.8752973534258671, 0.856049191442827, 0.8809585664709373, 0.8910931619192324, 0.28437951369223224, 0.2179460529330669, 0.15409263099637793, 0.18439466369039315, 0.2223729075561589, 0.196879196771235, 0.20718405289769204, 0.1903871710155196, 0.19707316132813346, 0.1564331207675197, 0.16648256040192433, 0.2018431307748937, 0.1671623125069437, 0.20386862473102396, 0.2848106170561022, 0.23114981855122108, 0.22364466370679914, 0.13697709747481235, 9.999999999998899e-05, 9.999999999998899e-05, 0.12548895159205908, 0.22554553783078335, 0.13635568155019084, 0.25713911885228546, 0.04820872425591338, 0.11780584622634704, 0.21152075627080735, 0.44034466918919224, 0.17996510867640192, 0.44959497315211205, 0.23469796852473568, 0.44353027992769267, 0.06902775525398797, 0.3883111050944882, 0.2843422626847668, 0.3311793956353871, 0.06908452322350056, 0.11079187940787394, 0.17079418793511236, 0.1089597032957943, 0.24905955019781778, 0.15059321857001928, 0.17039617007058638, 0.3080224706593646, 0.2151521250053321, 0.31146351485594237, 0.4276018924273811, 0.3215329057196542, 0.4612288262774248, 0.27703893385869693, 0.39157283504714135, 0.2870071323782022, 0.32553825491829214, 0.18131545867672105, 0.6698053225135738, 0.8132798626832355, 0.7988912059547151, 0.5536278145443303, 0.6916224786600911, 0.8348299434319735, 0.8156381328506865, 0.5962340434343494, 0.583259099097867, 0.10822474862270992, 0.11321885877187965, 0.1316188348470423, 0.1253963565559294, 0.18965087014850002, 0.10246891006612546, 0.11212512973695898, 0.1341770793878162, 0.13133370602167072, 0.14955360206671342, 0.15602468581813989, 0.22320711476864086, 0.13265209159992297, 0.21919225428087208, 0.15935570203771798, 0.16035735161846332, 0.15398958851712308, 0.3053058106106381, 0.5661798460159596, 0.5991780499088246, 0.6900043019469159, 0.5424228316030986, 0.6637905298359852, 0.7289545162798605, 0.7136987636595591, 0.7551168330232951, 0.604664733832925, 0.4981914851730914, 0.463354286906556, 0.5213965577928368, 0.39485705232026036, 0.38381803232665634, 0.39045952669387407, 0.5136980743062312, 0.5266758982651274, 0.6093427011913377, 0.19978456201852468, 0.2206052359514632, 0.19303484349649658, 0.19772524152771342, 0.18961348014484103, 0.1942207878996849, 0.21025032508649266, 0.21157690877028845, 0.20385406319652533, 0.22984060156933794, 0.22696346444909965, 0.23709804681738356, 0.572908320968943, 0.6874519216565509, 0.22633903235383845, 0.27987410163415993, 0.684357805053639, 0.2327696256555244, 0.9108964576517479, 0.18423337865011047, 0.18553005075952156, 0.35748250018208283, 0.8064109996593647, 0.8804652888967006, 0.7942271246285921, 0.20260345089941634, 0.1819866766894883, 0.6145447498753909, 0.7387942718595839, 0.20945845938954166, 0.2284171186398225, 0.31822501503455236, 0.46524789875351535, 0.7751070908021004, 0.1559615303364541, 0.8335545960857369, 0.1921621925370276, 0.17245093616207563, 0.19591312082339318, 0.20300466135228556, 0.18226642334272503, 0.17955898705866546, 0.1953860687930873, 0.1808817508194165, 0.1922742907650863, 0.08578949661445623, 0.08578441099210499, 0.0856279823439674, 0.08897827135939584, 0.09713530800196457, 0.10499222734753366, 0.07608374366157478, 0.08388379546885039, 0.08189186549294458]}, "mutation_prompt": null}
{"id": "4fd27fbd-9d51-4c81-bb75-df09cbb969b8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            next_population = self.population.copy()\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    next_population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.population = next_population  # Elitism: keep the best trial solutions\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced selection pressure by combining elitism with adaptive strategies for better convergence.", "configspace": "", "generation": 52, "fitness": 0.4627725616840787, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.26.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8631824870677841, 0.8501800807978644, 0.8611680115125298, 0.8655357638009299, 0.8512263593579161, 0.86715353734314, 0.8577364610893483, 0.8635370639388493, 0.862981725701045, 0.7525038899683252, 0.756177078886384, 0.7831219791865971, 0.7829019531426378, 0.7756261762478609, 0.7712522276180337, 0.7683724582307893, 0.7606019018821877, 0.7689124633251838, 0.1575923138225871, 0.3350928460414839, 0.32400410481960185, 0.31819154278506734, 0.499573668556466, 0.3868794312026286, 0.327971564237481, 0.44358416602922, 0.42799170963159694, 0.14103016884911446, 0.16133231471191245, 0.1327021458892721, 0.4070483435420892, 0.14640207082550316, 0.1309949544799398, 0.1430918543801446, 0.1348480047940921, 0.28464494244071503, 0.7650997965323337, 0.7475558989844686, 0.7655425903042656, 0.7665335981070529, 0.7667106565702564, 0.776050341654131, 0.7500499626563035, 0.7697272918515012, 0.7574176433867092, 0.6598078268926731, 0.6243191356841655, 0.6755467710842158, 0.6769967250361831, 0.6942423349858209, 0.6988060300944701, 0.5930786987469854, 0.6632746385863538, 0.698762573405671, 0.7874644047964772, 0.797054808178177, 0.8092667858739993, 0.8338835740476571, 0.850600242506812, 0.821733796073868, 0.8342381513954846, 0.8557267938529446, 0.8140079534941779, 0.20687251605654378, 0.25672815492943213, 0.27460454205527085, 0.15233914135168347, 0.31286898756420345, 0.3137582871598833, 0.2505979290133937, 0.34226650144247983, 0.17085100028056144, 0.19714439320782007, 0.18567037868295577, 0.17765026581927146, 0.20885382422887155, 0.19682489792737778, 0.18241718822454156, 0.7171190217548349, 0.1722350367731944, 0.21396741840487032, 0.5926625519985873, 0.5823846590522825, 0.6070134979394052, 0.5079081294456266, 0.6334628850782631, 0.5933946133150172, 0.542440310415566, 0.6429378195344579, 0.620306233960835, 0.7096423779418041, 0.6660798313793177, 0.6772045928094893, 0.6904694345523386, 0.6701371537709007, 0.23749982753592047, 0.5777538424403394, 0.7408921135955312, 0.7207615513407297, 0.19596836992881828, 0.255692274489704, 0.25522686949435935, 0.4073833973882799, 0.32236032255781455, 0.457549383193006, 0.1526571159061203, 0.27052483147753115, 0.15124496042252644, 0.4611692422935202, 0.43915590283736794, 0.5063892843618364, 0.43129195597638004, 0.5060410079579832, 0.4253230777421464, 0.4420449216556869, 0.5031829450174804, 0.3016691097289934, 0.725158307444492, 0.8080993014241962, 0.7927645595393562, 0.7824424330288345, 0.7445517796072236, 0.805041334473205, 0.8003486906234405, 0.7963978950188586, 0.7911471624190078, 0.10068126093158536, 0.09991885841073977, 0.10139508382284967, 0.1017180917362237, 0.11243502631380875, 0.124138472459977, 0.20896291877493112, 0.09375786595523128, 0.10909563463197502, 0.1512054381427741, 0.14054384836014688, 0.14330374346901276, 0.3944252297550722, 0.13289433388869898, 0.41343155979649504, 0.12984333108999868, 0.14051116107310846, 0.13432146277292267, 0.5289610299914345, 0.5011712053872146, 0.5160170060915055, 0.5529416729941528, 0.5339390903639527, 0.5533598322267845, 0.6230667196171322, 0.5804731317596317, 0.5982959123566355, 0.406432559407069, 0.40862498991351737, 0.39438952840690134, 0.45812910052888933, 0.4217854169268255, 0.4025895910145574, 0.49062453389008287, 0.45557572497495213, 0.44214112616266044, 0.18084409168920823, 0.22031699598412835, 0.19766728778665232, 0.2368621173650698, 0.19736695105176139, 0.21446752661623358, 0.19707893420956857, 0.20750034203503487, 0.18999854523133408, 0.5833093196591296, 0.23067110776811128, 0.5879394960216758, 0.6176566631624365, 0.556276417707942, 0.33947839907757915, 0.3943389063847512, 0.6613513621145888, 0.5469497842663935, 0.8631981104410008, 0.18292601102870698, 0.8314283050049043, 0.8075587257856374, 0.19256722896755718, 0.7687646242822013, 0.7565035715634743, 0.8215216936113221, 0.7548257864237292, 0.8026806712333661, 0.7992839488689214, 0.16480325087632974, 0.8224381757029482, 0.1630304557274117, 0.6507609521066211, 0.205528345967245, 0.7921480793743825, 0.20401406277999967, 0.17443173777892118, 0.18595032567670733, 0.17485714083017956, 0.19018078871630606, 0.18836906267186526, 0.18355681476423147, 0.18515458641445814, 0.18565535949488388, 0.19180548368000772, 0.08806243806131808, 0.08058480328785067, 0.07840024518197464, 0.09643714664968317, 0.08253464879542316, 0.08189503112605567, 0.07736466547451581, 0.08882711357306394, 0.08445405239549053]}, "mutation_prompt": null}
{"id": "579f2a41-b90b-429c-8afd-3a4ffaac3dd8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n        success_rate = 0.5  # initialize success rate\n\n        while self.evaluations < self.budget:\n            successful_trials = 0\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n                    successful_trials += 1\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            success_rate = successful_trials / self.pop_size\n            self.CR = 0.6 + 0.4 * np.random.rand() * success_rate\n            self.F = 0.6 + 0.2 * np.random.rand() * success_rate\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a dynamic adjustment of scaling factor and crossover probability based on the success rate of candidate solutions to enhance convergence speed.", "configspace": "", "generation": 53, "fitness": 0.41263004696354233, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8785586558965482, 0.8802537689344356, 0.8921710866236573, 0.8898171294351018, 0.8950498394946068, 0.8849979545067616, 0.8795462107036817, 0.8978718518259027, 0.8836463310065376, 0.8110451869493872, 0.8183776515528869, 0.811908834163994, 0.8259817743611104, 0.8089993936032281, 0.8095714614150022, 0.8162469784117068, 0.8093562712151562, 0.8162827778573227, 0.5948501477791905, 0.5564030880986526, 0.54715186072622, 0.16346906810257356, 0.5897799120056919, 0.5645837222739576, 0.6360184803596503, 0.6018241878956669, 0.5742515909804979, 0.1608421399647848, 0.17167029824280966, 0.5347080410227565, 0.565647742192138, 0.5328500982326478, 0.15126803873629546, 0.16157588218048202, 0.6130072637641172, 0.5707929050264287, 0.8273312463993252, 0.825008308939518, 0.8287008613943669, 0.8380653782847716, 0.8113474157316257, 0.819718712601516, 0.822543967462341, 0.8257173651176413, 0.8253205022952159, 0.6842129847502585, 0.688365037213639, 0.685008808744895, 0.6582284179833069, 0.7139167493643974, 0.694798646580211, 0.6754119911014289, 0.5497389785884685, 0.6598927640945036, 0.6708582166784209, 0.7606350566939705, 0.769063302747333, 0.7648096512409509, 0.8251606043009828, 0.7994342471612021, 0.7771528607660692, 0.802080122780343, 0.7670100804782292, 0.20368884894632522, 0.19790589179945628, 0.21504794471874755, 0.2259785543049645, 0.2634151051892002, 0.20152754937416995, 0.17308533389641856, 0.18038342074143365, 0.1916211020625903, 0.23691950627846448, 0.18125442415779291, 0.1635068499998883, 0.15876339476652868, 0.355006394015021, 0.19870753606671943, 0.2523053212158318, 0.17077656741826175, 0.19391095526474011, 0.1854265820058707, 0.10646861118218076, 0.25550769780492033, 0.15780364265303726, 0.09762938630188678, 0.2003927596566456, 0.1817367457938277, 0.19723245017366442, 0.10356186035118298, 0.38115698281572785, 0.2724848974509567, 0.19518700473725203, 0.3336027168703265, 0.3210974058522341, 0.3175065193165518, 0.3412743165200812, 0.3009954238510443, 0.28224927816769463, 0.11758622923370388, 0.12846560998426282, 0.06807103806818049, 0.12654083947647177, 0.21986363693164235, 0.16912520030780964, 0.22064590889552138, 0.10247453684993979, 0.13176487067829856, 0.23995248820785087, 0.26921906150744024, 0.24386419169602302, 0.2977775731981035, 0.32016022847221415, 0.31359803433020994, 0.25204105778936814, 0.27986657194540243, 0.23950804219706145, 0.6789831575905323, 0.7008676716924, 0.665597143499967, 0.6218419389598204, 0.6461079634478464, 0.6861239887694794, 0.638669656683831, 0.6200178476699607, 0.6769974890165184, 0.11624470425872446, 0.10895749996814952, 0.11682169309557522, 0.13035828523524573, 0.11537028991468046, 0.11726990174315666, 0.10676914831080264, 0.10549310382277055, 0.13080481765642704, 0.15832114451020884, 0.15070752156247835, 0.1466407757330408, 0.14519205552686232, 0.13141161780846322, 0.15450236694612007, 0.14144853983090033, 0.1311367659245236, 0.13457156863416475, 0.421788235036629, 0.5257674417652961, 0.592664259820885, 0.43808235822743413, 0.5610961901619396, 0.4845351241870851, 0.5965227128080621, 0.6197603071095323, 0.6497561046435789, 0.30851018975845945, 0.37736512205107686, 0.33965427213325616, 0.3273815696490737, 0.32136895981082736, 0.34986783908893937, 0.3647669180395714, 0.3782199319127785, 0.3214226890872288, 0.22694778413127592, 0.2164068842184702, 0.20269514521192933, 0.21091814512025575, 0.2062345160277692, 0.19185801125035196, 0.19945021619087844, 0.19261102829987553, 0.2032969776083473, 0.29367894427030916, 0.46492855642416464, 0.5467664637469946, 0.6568919549529594, 0.3741511098527941, 0.21898725800209018, 0.23850752200393044, 0.5805596564202375, 0.5841887485121415, 0.8628817812286278, 0.20213641868156096, 0.6687448421119746, 0.7418252674722196, 0.7191039225722111, 0.8643535374385117, 0.1875581214694617, 0.18042127573895506, 0.6070801462253802, 0.20251602244078526, 0.20601703897557244, 0.6493507132078293, 0.20311096371307402, 0.20506705888113352, 0.7763131956242998, 0.7139265943832992, 0.2085330868430606, 0.7277479051377619, 0.1843430214824624, 0.18776973660959928, 0.1777595086086754, 0.20238449881161336, 0.1880017450084679, 0.1915109173318943, 0.18402476154233793, 0.18045613950770623, 0.18145846197917537, 0.08116511309977581, 0.08974259545070129, 0.08253740190948577, 0.08363519798304275, 0.07892352286675941, 0.07456059518550606, 0.09710250391718578, 0.07899406553264066, 0.08664065327563952]}, "mutation_prompt": null}
{"id": "c3b7132b-0452-453b-a9dd-d6ee3b7aa22f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.75  # Slightly increased initial CR\n        self.F = 0.85  # Slightly decreased F\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.7 + 0.3 * (1 - (self.evaluations / self.budget)))  # Adjusted dynamic_F range\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)  # Fine-tuned adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.3 * np.random.rand()  # Further fine-tuned CR range\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adjusted the scale factor F's dynamic range and fine-tuned crossover probability CR for improved balance between exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.44786521613499475, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8721687593872689, 0.8750984010293636, 0.8712627274324408, 0.8787308624719508, 0.8788595187993186, 0.8691668455746184, 0.877860342066189, 0.8746901207396047, 0.870884547729015, 0.8062142143623432, 0.7842756598130051, 0.8005790470763007, 0.7871023521585357, 0.8049776156551284, 0.7873548808183397, 0.796030417436675, 0.8062192396716996, 0.787007055228226, 0.5122930050885786, 0.4937910117830905, 0.4100737345377261, 0.5688680031959904, 0.38701595270295786, 0.5112946362600329, 0.5452156898395155, 0.15129963138937852, 0.5568744525090328, 0.15529215862715517, 0.374013397948457, 0.14013947731146148, 0.15761283382003655, 0.4767703508134269, 0.5513939884875125, 0.15245894835683516, 0.15698536513521488, 0.4231859650982063, 0.7930693744109378, 0.7978439820508504, 0.814343826703592, 0.8199382875795935, 0.8038160601265414, 0.7929279856179061, 0.8128067023650236, 0.8093664602861758, 0.823462601541706, 0.666702825719141, 0.701982517233944, 0.7252483881506161, 0.704720838332388, 0.679024923492073, 0.6999857916560599, 0.6838084805893986, 0.6977117409551343, 0.6438621132442117, 0.8010913179892644, 0.840111533985669, 0.7881718985908985, 0.8050570089200588, 0.8250631300789598, 0.8324701257666102, 0.8129049162003603, 0.802186314450894, 0.821046029800031, 0.46396752043678635, 0.24223136084951724, 0.48867011961489326, 0.3800888832732988, 0.27011651172271, 0.23196710099338558, 0.2704955527965244, 0.2943802288310198, 0.27600451216687727, 0.2630654523468373, 0.16409641115693108, 0.28935735311530075, 0.24974758310695377, 0.49450788453679606, 0.5265505907284763, 0.2538084387184122, 0.18130507661767392, 0.5293749486722017, 0.19370479078731462, 0.41102324003053936, 0.502841393259612, 0.4339284346759622, 0.241818095355269, 0.456391894126839, 0.4254112228675879, 0.36927319807071757, 0.42157623907631603, 0.5627687855260933, 0.5576604226294255, 0.19332773973103168, 0.44782195478744447, 0.3829991198051541, 0.5758302535658446, 0.34297042617962303, 0.6268804733192881, 0.6512312150834123, 0.05800165496841836, 0.12916899924822522, 0.10034349588454317, 0.3064484284157508, 0.11632283321356385, 0.1696116883093458, 0.24296908294164254, 0.22294884552009664, 0.10146103078463298, 0.37503781551865567, 0.4068809759139089, 0.36282816836211973, 0.434646207627817, 0.4495325904874585, 0.36338184964061127, 0.375749655225706, 0.28688313552189226, 0.27098333922219986, 0.7824572258240999, 0.7943295143298382, 0.7861274193340274, 0.7868188265672108, 0.7949144068410965, 0.7955738030228195, 0.781421374267774, 0.7100112943409073, 0.7840217320349686, 0.10831181280518143, 0.11396966169603662, 0.08978480702929081, 0.10145752398943098, 0.1000296677184982, 0.12034999474901142, 0.10131576778337714, 0.09889607200792638, 0.11880861365364781, 0.42957923469226367, 0.15974713803253981, 0.2020050988169646, 0.16439596841217352, 0.13626820549473884, 0.14420143073734348, 0.15203256481764182, 0.14996985344970903, 0.12873764745846805, 0.5218547819149691, 0.5897311623030816, 0.5636508433879773, 0.5408385529149691, 0.568943804397547, 0.555091519000029, 0.5881773227638781, 0.619264370163515, 0.5543616335853483, 0.40345732640268106, 0.4220918993712628, 0.38746122130752936, 0.35067676102782575, 0.4188474319740799, 0.3989202933964838, 0.4197642765217796, 0.4311061792388301, 0.38738948298803244, 0.21671992052434863, 0.1980450721903162, 0.20677003875406996, 0.21378697474187536, 0.1874025260419182, 0.17187535717316083, 0.18122515026530317, 0.21711924001434757, 0.20333609261198482, 0.4222065951447973, 0.5244913668025305, 0.5804235917162845, 0.5728037618964154, 0.22681128421777363, 0.22099267929757793, 0.3465523722904551, 0.6644536556422478, 0.2091071957537458, 0.7961607835888287, 0.8159884797024228, 0.8321009679391363, 0.167957730475656, 0.19467112595235736, 0.8085545456233353, 0.19804394072449882, 0.8112497108394183, 0.8283436536318138, 0.6928766766402797, 0.813000901187134, 0.20053174047480116, 0.1630263629782408, 0.8062964389982196, 0.7250041079532706, 0.15474273454342002, 0.21223769971518325, 0.20704456124787307, 0.1880801056122383, 0.19182991543632755, 0.17528134940136475, 0.18036864576981948, 0.1834363301979176, 0.18662910895846385, 0.1792957811647693, 0.19316045174142438, 0.18429762554960616, 0.0852130962740052, 0.08515399448863958, 0.0845186797596561, 0.0846606418313971, 0.08695011476758086, 0.07269678278469327, 0.07932072410049928, 0.07078470932130021, 0.08590745657598364]}, "mutation_prompt": null}
{"id": "afeddc6a-bc3a-4c89-9bb0-80f94c737400", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            # Modified adaptive parameters with crowding distance\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence speed by introducing crowding distance approach to preserve population diversity during selection.", "configspace": "", "generation": 55, "fitness": 0.48562127152368084, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8782931132286633, 0.8723885788050867, 0.8629084566254809, 0.8763366344543457, 0.8868587291367251, 0.8773989980636685, 0.8763256237946582, 0.8821164874434413, 0.8821465203198563, 0.7874861616045048, 0.8036472488329116, 0.7955910709999362, 0.8085823490716602, 0.8046477369418292, 0.8045744623532087, 0.8069885903966094, 0.8175564200283787, 0.801490390294662, 0.4374521528469728, 0.4278485865116768, 0.4734758220146159, 0.4322263160236055, 0.4110525616829731, 0.15673531514943717, 0.4251244262503947, 0.16349561059324846, 0.2843334944426654, 0.1805909972336418, 0.1422595501428272, 0.1171728310698249, 0.1438200988921302, 0.13536318609995446, 0.13435435868889145, 0.12292599135525417, 0.3748638823609781, 0.12145430131717438, 0.7933651453858646, 0.790591172579798, 0.8081353885562548, 0.8060702899368365, 0.8060649577343733, 0.7965408090519326, 0.7945187588394846, 0.8015641097591368, 0.8036434567384576, 0.6955401231282519, 0.7178450559395848, 0.6765691885847973, 0.6948335433554429, 0.7164565468998949, 0.7128432394766617, 0.725770218882037, 0.7218310227717197, 0.7147611331411201, 0.816502761533457, 0.8551123585291781, 0.8342302116080537, 0.8538279842902933, 0.8182094371860507, 0.8308936763467459, 0.8652370368905113, 0.8364466817553422, 0.8641965742600973, 0.6877628574868215, 0.5840885345974175, 0.5345197373306756, 0.23458146683606262, 0.5252352871500767, 0.48384685124627247, 0.3100621176527, 0.2511951095890389, 0.25922709055798254, 0.22396095754134493, 0.2871958962402933, 0.6410354690655732, 0.3227558295174434, 0.3506351596524625, 0.1975113556347844, 0.2227640241132517, 0.18193434298178623, 0.2494377110182, 0.6846710971283567, 0.6201288746890755, 0.47169268215874915, 0.6371426846412417, 0.154214885109333, 0.5655510711371764, 0.3923263510269509, 0.6302782722546203, 0.5475051480453323, 0.5850593593323681, 0.7590813698918287, 0.7144199852751031, 0.7590356243841343, 0.709834547399857, 0.616412508708005, 0.727260163939882, 0.8134731479413945, 0.7422494557472719, 0.12677116492092722, 0.25838982999144444, 0.20843861546681497, 0.3627834388993133, 0.2583364564658225, 0.40998488500965136, 0.21075811417591328, 0.18665777093011615, 0.29828784548195586, 0.5018066544518758, 0.44091664587251966, 0.471522053265672, 0.4776319885232665, 0.4254051649484383, 0.5045518116830501, 0.41122446649302435, 0.51798526371623, 0.48467429744220103, 0.8207883191160488, 0.8135994035231491, 0.8270926164798953, 0.8206586450963018, 0.8328701441450982, 0.8304150728834282, 0.825913757092261, 0.8263937879721992, 0.8319690340956929, 0.11495222019135165, 0.11739964113346013, 0.11196440802984475, 0.1116713458533104, 0.13327885586435262, 0.09249845485723474, 0.10596252670905282, 0.11450355487726316, 0.12810733539521935, 0.16195108785682455, 0.146262380729544, 0.13927832848396504, 0.12041576203357729, 0.1242739753675487, 0.24597012158238496, 0.15448565834197836, 0.11466913656697508, 0.4710577153552423, 0.5001829707863832, 0.6046271253616067, 0.6194835101057765, 0.6225352177269473, 0.6135252312948003, 0.6169647155221176, 0.6503507224174621, 0.6453786269085531, 0.6393698625151827, 0.38110688051830044, 0.44586870373527476, 0.4361925515202423, 0.49988135322369853, 0.3964830800055633, 0.4540072435538828, 0.4970937868491989, 0.531579982641532, 0.49704604114952977, 0.19517444252871385, 0.19776814530047848, 0.19585793517590278, 0.2019472731354517, 0.2038542008766523, 0.18767608120262225, 0.20320107804331078, 0.20289806146515676, 0.1904377955812634, 0.5646088866486247, 0.6013603177846103, 0.3575432144621775, 0.41196449069198326, 0.6166597945106064, 0.22352208332252066, 0.22942975948829736, 0.5207383364286529, 0.5311241445385424, 0.8186958124859571, 0.8624909538067591, 0.7761625259313124, 0.8634894150726634, 0.19248668312137496, 0.8462434439373585, 0.16668933011417353, 0.8627935383316123, 0.7900311813196532, 0.869145172298112, 0.8551756021969473, 0.2046940055028733, 0.8345064911265815, 0.7908040458417924, 0.7259818558120191, 0.8444311481762901, 0.15545795132548423, 0.20430784191813356, 0.18341541647688797, 0.18986201335717212, 0.17856602555405265, 0.18570046817168506, 0.18645785763920353, 0.19007661863128889, 0.17945287441468194, 0.17993955867148392, 0.18382347119547326, 0.08248195357513655, 0.07278327486768899, 0.08487562302650609, 0.09564781497736052, 0.08798899978946506, 0.08705439496670098, 0.08360982032126518, 0.08145744686049783, 0.07586564865020773]}, "mutation_prompt": null}
{"id": "fbe9e925-99ba-40c7-bce3-9b34d51ac8e9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                if self.evaluations % (self.budget // 10) == 0:  # Periodic adaptive mutation scaling\n                    dynamic_F *= 1.05\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced periodical adaptive mutation scaling to enhance solution diversity and convergence precision.", "configspace": "", "generation": 56, "fitness": 0.485483889297332, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8783045543123145, 0.873344144994073, 0.8629084566254809, 0.8772516369987129, 0.8868587291367251, 0.8793575812903331, 0.8763256237946582, 0.8821164874434413, 0.8821465203198563, 0.7874861616045048, 0.7984621452998775, 0.7923701038616986, 0.8075171500769655, 0.8052623402012082, 0.8045896468193422, 0.7954650702389612, 0.8132657349133536, 0.7930005406236508, 0.548974810402431, 0.4278485865116768, 0.17168066854876707, 0.4319318878691688, 0.41241780937733596, 0.15673531488737757, 0.42510148480979637, 0.16349561059326, 0.2843334944426654, 0.1805909972336418, 0.14417553268437755, 0.11718154318497398, 0.1438200988921302, 0.1353631853694185, 0.12438522238654581, 0.12292599135525417, 0.3748638823609781, 0.12145430131717438, 0.797438327544548, 0.7929553638982075, 0.8086914879242347, 0.7998499396617187, 0.8060649577343733, 0.8114378058955152, 0.7971674166674655, 0.7997045222831303, 0.8036434567384576, 0.6941784971671534, 0.6724225260418796, 0.6862442130778412, 0.6948335433554429, 0.7156473286369341, 0.7128432394766617, 0.7261276004297177, 0.7238353723431767, 0.704494754636771, 0.816502761533457, 0.8551123585291781, 0.8342302116080537, 0.8538279842902933, 0.8182094371860507, 0.8308936763467459, 0.852365518781184, 0.8364466817553422, 0.8641965742600973, 0.6877628574868215, 0.6978713287866585, 0.5130985651812436, 0.23456535876692874, 0.3798014969847815, 0.4058551464044352, 0.31006099220242744, 0.2634265858984326, 0.24141191144836815, 0.22362617222566827, 0.3759845013876385, 0.6410354690655732, 0.6328674932707157, 0.3389039834175609, 0.1796216193738075, 0.22480120080571975, 0.18170754234351127, 0.21500902173286773, 0.6846710971283567, 0.6263101619855749, 0.47167671498443065, 0.628050775032993, 0.5794946106117485, 0.5655510711371764, 0.39189100977762104, 0.6302782722546203, 0.5475051480453323, 0.5850587844823099, 0.7050969023842216, 0.6796815893805714, 0.7580375103503227, 0.7088156216987278, 0.616412508708005, 0.7384684003593842, 0.8134731479413945, 0.7422494557472719, 0.3164226845499094, 0.26272041381802114, 0.2085342390606757, 0.13388684576829146, 0.2530513712563306, 0.40923406038529153, 0.21068080801287792, 0.18665777093011615, 0.29668063059068106, 0.3689439247939137, 0.44091664587251966, 0.471522053265672, 0.5374898690226793, 0.4887338385854072, 0.5639475662735706, 0.39625343578129046, 0.5797033916167638, 0.4411668905246061, 0.8207883191160488, 0.8197701299825291, 0.8266555612872196, 0.8206586450963018, 0.8328701441450982, 0.8304150728834282, 0.8273388853771597, 0.8263360676831858, 0.8249622623156243, 0.11495222019135165, 0.11739964113346013, 0.11196440802984475, 0.1116713458533104, 0.13327885586435262, 0.09249845485723474, 0.10596252670905282, 0.11450355487726316, 0.12657140677263834, 0.16195108785682455, 0.146262380729544, 0.13927832848396504, 0.12041576203357729, 0.12402033129009904, 0.24597012158238496, 0.15448565834197836, 0.11466913656697508, 0.46771441160800087, 0.4996095915527269, 0.6035760896729891, 0.6194835101057765, 0.6279869735914319, 0.5610354635555608, 0.5811280538264105, 0.5814340172900473, 0.6453786269085531, 0.6393698625151827, 0.3808599632244376, 0.5352653427386221, 0.4361925515202423, 0.5028226508406433, 0.3964830800055633, 0.45338417198910663, 0.511033525657776, 0.5287900275426418, 0.36107827542249726, 0.19517444252871385, 0.1962283360967838, 0.19585793517590278, 0.2019472731354517, 0.2038542008766523, 0.18767608120262225, 0.20320107804331078, 0.20289806146515676, 0.1904377955812634, 0.5646088866486247, 0.605680490265418, 0.3575432144621775, 0.41047251170012466, 0.61561554639238, 0.22352208332252066, 0.22942975947090838, 0.5802324725569195, 0.5311241445385424, 0.8186958124859571, 0.8624909538067591, 0.7761625259313124, 0.8644041341825524, 0.1924869699850973, 0.8462434439373585, 0.1666891295325209, 0.8627935383316123, 0.7900379238506188, 0.869145172298112, 0.8563820459400866, 0.2046940055028813, 0.8345064911265815, 0.7851957551201504, 0.525483679477798, 0.8465143789652714, 0.155457951304928, 0.20430784191813356, 0.18341541647688797, 0.18986201335717212, 0.17856602555405265, 0.18570046817168506, 0.18645785763920353, 0.19007661863128889, 0.1791074615995203, 0.17993955867148392, 0.18382347119547326, 0.08248195357513655, 0.07278327486768899, 0.08788513072794246, 0.09564781497736052, 0.08806900435158072, 0.08705439496670098, 0.08360982032126518, 0.08145744686049783, 0.09375071300129767]}, "mutation_prompt": null}
{"id": "10b499f9-7df0-499e-ac2f-49cf310c2e05", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            pop_std = np.std(self.population, axis=0)\n            diversity_factor = 1 + 0.1 * np.mean(pop_std) / (self.ub - self.lb)  # New diversity adjustment\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) * diversity_factor  # Apply diversity factor\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced differential vector scaling based on population diversity to improve convergence speed.", "configspace": "", "generation": 57, "fitness": 0.4715061083152189, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8776947477220369, 0.8829217952480679, 0.8770466900558216, 0.8872415661570411, 0.8874031632352328, 0.8787510939138814, 0.8871736128728394, 0.8827915822366832, 0.8776405057838852, 0.8019127627681484, 0.8013080996767934, 0.8139814615049576, 0.7854743341774792, 0.7948899152252009, 0.7774620585561389, 0.8101162986319235, 0.8088043629522554, 0.8102834217594771, 0.3942951007726022, 0.3116769300769756, 0.4609419735515927, 0.3561087863138037, 0.5504119986994123, 0.5023109137677952, 0.4295035516586456, 0.4088022305785227, 0.1439292108514788, 0.1458871372636259, 0.13147148730656077, 0.13974055059058865, 0.13908584779887456, 0.38903165606332346, 0.12611293096429566, 0.1566390579914323, 0.14440471701854551, 0.14889984085099583, 0.8091684746905782, 0.7831116397763612, 0.8172128940192963, 0.8146267313340103, 0.8103166635010963, 0.7938348033856598, 0.8099548514655835, 0.811913551270567, 0.8248013774559935, 0.6822812896240642, 0.7042595667950841, 0.7143305390846743, 0.711137714522803, 0.733849238725396, 0.7097226878741105, 0.6966193216336807, 0.7060494417896158, 0.7275455282105515, 0.8173098945782769, 0.8422457827332176, 0.8108616042481096, 0.8274980493031472, 0.858071857952724, 0.8430146224971282, 0.8445383543835133, 0.8339341876413091, 0.8268613100425588, 0.20302167864409693, 0.7002939069886573, 0.21691316098951818, 0.2720862098214032, 0.5227913939412797, 0.17881028402205212, 0.5534735191835498, 0.1781239517065606, 0.3733874060215059, 0.1705074631641872, 0.25110783439919837, 0.20932187796773227, 0.35757939967740626, 0.2271323583699696, 0.2922696564469265, 0.27545017342589917, 0.19633812502611758, 0.23007712034631167, 0.646064358843321, 0.5870221429789588, 0.5486681654043822, 0.6901773749478894, 0.18970651435671104, 0.5430699327584706, 0.5686367841633289, 0.620025212917214, 0.6362209343611439, 0.7241685092224098, 0.404723459885705, 0.5134875845968782, 0.6690603687706722, 0.1936847602424786, 0.7128142635740361, 0.703814011730552, 0.7548004164895892, 0.763781697776932, 0.1967326210506748, 0.3434994864296588, 0.14381660527949147, 0.37173488204595373, 0.4099823410378721, 0.3516112099851404, 0.1713409617440671, 0.29710833021288885, 0.340234689112615, 0.4100536589153332, 0.3833269130402166, 0.3048995328136803, 0.510695919365951, 0.48649829435483694, 0.49920732844285587, 0.24859923349588786, 0.4113404903492308, 0.493831320018026, 0.8186416949050701, 0.832061602190706, 0.7618569483054616, 0.8177700362947087, 0.6748929386559899, 0.811705074362322, 0.8148612643231204, 0.7544626505121061, 0.8186653780412265, 0.12385727795471158, 0.113299222555577, 0.11512551524261794, 0.1213179717460331, 0.157360017714678, 0.10818988669058505, 0.23645844982322473, 0.11901225124457249, 0.09506553865914791, 0.5284867287251667, 0.13654972654865305, 0.13068430305613365, 0.12133175261482865, 0.16266147680787013, 0.16443733314262132, 0.1683826970552793, 0.16160222858713658, 0.18521134509107684, 0.6230781742793348, 0.5249569951631261, 0.6083544777798422, 0.6290545913698941, 0.6343104121128188, 0.6407826881695812, 0.662573483333498, 0.6865652139235523, 0.5746490075684334, 0.4456203689662662, 0.40495730905174954, 0.3717245979558176, 0.486479879453806, 0.43179251120218054, 0.5378031782296135, 0.480269447434311, 0.47425336204994695, 0.5057044621528759, 0.18544531455822877, 0.20787449599142616, 0.19765402461956416, 0.21771978309730944, 0.20388368661913303, 0.20021805509879287, 0.22774325014349805, 0.20110303442583533, 0.21253215998209984, 0.4325274611524774, 0.21985209376489612, 0.662361375044046, 0.5390945690919644, 0.4713896720280184, 0.21253928272744582, 0.5333390263817324, 0.6249888021660278, 0.6055827402930081, 0.8469190273825952, 0.8464217263354203, 0.18569812582058676, 0.7787629018784386, 0.8501767054211626, 0.8735169953913489, 0.1623612740214445, 0.8466151366788247, 0.8824824201221165, 0.698013636438173, 0.20810790213441355, 0.20514010677907846, 0.7933759156113154, 0.20880418621415553, 0.20770213333838827, 0.8016555987643073, 0.20722702807171922, 0.20828695238165096, 0.18758879153707164, 0.18814594739464696, 0.1947142327108211, 0.19904944989583995, 0.19523907898392556, 0.17962425094070456, 0.19754679178516477, 0.19054588238003467, 0.17954298097731558, 0.08395169703845062, 0.08457998679238721, 0.07919178441080998, 0.08241835521502472, 0.07515379029573088, 0.08374630346575596, 0.08837807207433745, 0.08884565472205797, 0.08270907045580478]}, "mutation_prompt": null}
{"id": "57d23a8c-0ba9-4a98-88b9-b1d45bf24cf7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                fitness_variance = np.var(self.population_fitness)\n                self.pop_size = max(5, int(self.pop_size * (0.85 + 0.1 * fitness_variance)))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic population size adjustment based on fitness variance to enhance convergence.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 27 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 27 is out of bounds for axis 0 with size 25')", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {}, "mutation_prompt": null}
{"id": "3a3d8d9d-96c6-467e-8d77-46b3b4b44eb3", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.7 + 0.3 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            self.CR = 0.5 + 0.3 * np.random.rand()\n            self.F = 0.5 + 0.3 * np.random.rand()\n\n            if self.evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "EnhancedDifferentialEvolution", "description": "Enhanced dynamic scaling of mutation factors and adaptive crossover with elitist selection to improve convergence speed.", "configspace": "", "generation": 59, "fitness": 0.4204109817538885, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8854952747987217, 0.8844572924244967, 0.8790105930870802, 0.8942175358107475, 0.8758509691987928, 0.8929251964072833, 0.8908226806273156, 0.8767997193085725, 0.8753193877722929, 0.7978112601448335, 0.8087049780214276, 0.8050042416798404, 0.7955165248974989, 0.8025912775086477, 0.8011291007655831, 0.799286335940504, 0.7952118845999059, 0.8036786215526164, 0.6352973988176078, 0.47860568798326253, 0.49984560189480176, 0.49885034727285726, 0.6072859710266647, 0.610086861103593, 0.4269724789850633, 0.5244356520938631, 0.5715599074828148, 0.14482562670225996, 0.4604393020315296, 0.42517813902640245, 0.15850143075843648, 0.4231573365628891, 0.6013946717003578, 0.5414739810887155, 0.1660474658198926, 0.16015904814303417, 0.9668737236320329, 0.9690251625138915, 0.9775678764454505, 0.9569257835535652, 0.9685375983500334, 0.9754566443336318, 0.9839162238642437, 0.9655319453192213, 0.9704143129748316, 0.6473951339901565, 0.6561428274972312, 0.6193108188160701, 0.6750023863775618, 0.6585641950269537, 0.6831640737070621, 0.62256125608827, 0.6375600691325473, 0.667490124879613, 0.7820077777531044, 0.7443489140818964, 0.7736273816500384, 0.7829204959481855, 0.775119019147983, 0.8086767578275611, 0.7798624653500897, 0.7696677022554305, 0.7998188005658612, 0.5429502806993833, 0.23974947006864822, 0.45351105244050793, 0.2133829952885229, 0.23412366932177864, 0.30903670646214654, 0.17102171781632247, 0.3744644336002294, 0.18029806720641395, 0.15950834031416727, 0.17790233833105318, 0.18134395994687524, 0.1954547121085316, 0.25434443800528683, 0.18346590488055503, 0.25046830697805755, 0.16773745764801729, 0.22838501573898884, 0.21553691300693967, 0.24609219275720873, 0.24383786696170096, 0.23797211494316572, 0.1824881261892538, 0.22457723881962788, 0.17328450431712594, 0.1201885423675294, 0.15788878450042299, 0.2671543684257649, 0.3238396831063043, 0.40301915036690283, 0.39486325971519765, 0.34521675556426523, 0.3346601599405653, 0.4599372269140517, 0.380265831766082, 0.4016010700432996, 0.17633522954824443, 0.09348648509297686, 0.10338829345835365, 0.09660566791881497, 0.15120783124010762, 0.12981129915095957, 0.12327808234647053, 0.14718748815247018, 0.13231829747239932, 0.23221586109867354, 0.2366136421220102, 0.2718339196281476, 0.22797330823283513, 0.32845008713006396, 0.28028227674766304, 0.24994822622295632, 0.2460524524079215, 0.24475102236482216, 0.6802455272881386, 0.6664709472973638, 0.6968511679836285, 0.6530032894783896, 0.6530514584688126, 0.6618055169551955, 0.7170835013073109, 0.6771668762499538, 0.7049856226997159, 0.11257291110998247, 0.10360009253289904, 0.10941091841594885, 0.10595028756335856, 0.1141684300420267, 0.10931446997804617, 0.10918880900110617, 0.09524087821614702, 0.10141772315757303, 0.14235433372450534, 0.1538425405745385, 0.1381810145415029, 0.19720302144594393, 0.12362049920761542, 0.14031624699000167, 0.16397357167734494, 0.14364475986111336, 0.15111503418078132, 0.504969847035079, 0.47040344036208825, 0.5060292252934508, 0.540541777008071, 0.48700701308418526, 0.48052994085718204, 0.6136775830189856, 0.5826490044664605, 0.5465725092059595, 0.3376537152930329, 0.3246457203475053, 0.33800018093871986, 0.3461543125910743, 0.31463517692476783, 0.30854573665230334, 0.3590627985486825, 0.3727334006778189, 0.308896740342966, 0.20699992859810334, 0.18964640482607587, 0.20527413216094137, 0.182583287403704, 0.220051093253946, 0.2136044568517954, 0.1890770652300735, 0.19297511587032246, 0.20552502806883566, 0.2999637575861608, 0.4872105643055532, 0.483561519238516, 0.39726690997654646, 0.4980988565884019, 0.42768595035869605, 0.6181000929674043, 0.5229858716327518, 0.5372659534287352, 0.19992189364937718, 0.6849547767535966, 0.8102524742698969, 0.7534025381578547, 0.17855920804481484, 0.18891465271857666, 0.30982760733688797, 0.8133095359627486, 0.6005089513539582, 0.6069926789326947, 0.19889366133274833, 0.20330455724947738, 0.19864694847880815, 0.6400163826399092, 0.7429495108411689, 0.6210472818101969, 0.2105080618357662, 0.31423429651405943, 0.18268806538866567, 0.21691871746961255, 0.1803032440458281, 0.19682370623215406, 0.18292343361800112, 0.18268872040494366, 0.17258175417781785, 0.18863856384386823, 0.19466448056730368, 0.07912071372162022, 0.0867498855275779, 0.09019401095265744, 0.08901246816213937, 0.08527730177538984, 0.07801723423163331, 0.08779859902588849, 0.08919975185229345, 0.08581144799664708]}, "mutation_prompt": null}
{"id": "2a03335a-7f43-4978-b2af-1d912172481a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.convergence_counter = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n                self.convergence_counter = 0\n            else:\n                self.convergence_counter += 1\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0 or self.convergence_counter > self.pop_size:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic population resizing strategy based on early convergence detection to improve optimization effectiveness.", "configspace": "", "generation": 60, "fitness": 0.4343819819551915, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8782931132286633, 0.8723885788050867, 0.8629084566254809, 0.8763366344543457, 0.8868587291367251, 0.8773989980636685, 0.8763256237946582, 0.8821164874434413, 0.8821465203198563, 0.7874861616045048, 0.8036472488329116, 0.7955910709999362, 0.8085823490716602, 0.8046477369418292, 0.8045744623532087, 0.8069885903966094, 0.8175564200283787, 0.801490390294662, 0.09553905033151511, 0.10529997286590553, 0.14828734189586334, 0.1624939510540464, 0.1374160320341462, 0.11105817418427144, 0.12976870012716335, 0.129438828320524, 0.11250036946370201, 0.12023138867197503, 0.11474115662086226, 0.09961945441390185, 0.11423316205823741, 0.10780816105291502, 0.11084384012002724, 0.1441919537390255, 0.10092995287576101, 0.09292682637959992, 0.7933651453858646, 0.790591172579798, 0.8081353885562548, 0.8060702899368365, 0.8060649577343733, 0.7965408090519326, 0.7945187588394846, 0.8015641097591368, 0.8036434567384576, 0.6038590832080977, 0.7178450559395848, 0.6765691885847973, 0.6948335433554429, 0.7164565468998949, 0.7128432394766617, 0.725770218882037, 0.7595878471497101, 0.4529538938387412, 0.816502761533457, 0.8551123585291781, 0.8383912161341299, 0.8538279842902933, 0.8182094371860507, 0.8308936763467459, 0.8652370368905113, 0.8364466817553422, 0.8641965742600973, 0.6877628574868215, 0.5840885345974175, 0.5345197373306756, 0.23458146683606262, 0.5252352871500767, 0.48384685124627247, 0.20313994556969073, 0.2511951095890389, 0.25922709055798254, 0.22396095754134493, 0.2871958962402933, 0.6410354690655732, 0.3227558295174434, 0.3506351596524625, 0.1975113556347844, 0.2227640241132517, 0.18193434298178623, 0.2494377110182, 0.7126160457037195, 0.6201288746890755, 0.47169268215874915, 0.6371426846412417, 0.154214885109333, 0.5655510711371764, 0.3923263510269509, 0.6302782722546203, 0.5475051480453323, 0.5850593593323681, 0.7590813698918287, 0.4684567644030443, 0.7590356243841343, 0.709834547399857, 0.15616329535709372, 0.727260163939882, 0.8134731479413945, 0.7422494557472719, 0.12677116492092722, 0.25838982999144444, 0.20843861546681497, 0.3627834388993133, 0.2583364564658225, 0.40998488500965136, 0.21075811417591328, 0.12282797312601401, 0.29828784548195586, 0.4827754903342172, 0.44091664587251966, 0.471522053265672, 0.4776319885232665, 0.4254051649484383, 0.5045518116830501, 0.41122446649302435, 0.51798526371623, 0.48467429744220103, 0.8207883191160488, 0.8135994035231491, 0.8270926164798953, 0.627966846498303, 0.8328701441450982, 0.8304150728834282, 0.825913757092261, 0.7518986010352606, 0.8319690340956929, 0.10550289537044266, 0.1086975844530883, 0.12347638506765779, 0.09906196538943568, 0.10832444159406873, 0.09322979673355547, 0.11335160206182882, 0.08721923561073619, 0.0629263941661915, 0.18205864360449087, 0.11697325202375175, 0.16921994335293333, 0.15300052017707588, 0.17777507334957532, 0.13456690440357089, 0.1394545056701898, 0.15458897132476668, 0.19808345614083067, 0.5147056889588755, 0.4115488517951478, 0.6309627845010424, 0.6225352177269473, 0.5407324182715287, 0.6169647155221176, 0.4266403294009603, 0.6453786269085531, 0.6393698625151827, 0.2959806169891074, 0.364524380940459, 0.4861887981048184, 0.336076532537667, 0.35502409169421745, 0.2979896253485306, 0.4970937868491989, 0.531579982641532, 0.3921915948820397, 0.21243860154880312, 0.2163416901422308, 0.2231382433724185, 0.22421134731103343, 0.20345943417415935, 0.22305276872256385, 0.22520896035146365, 0.20293555781122297, 0.23914462777288104, 0.19536911559843706, 0.19808540519405282, 0.18155157416508805, 0.19740305779557898, 0.20756992730660506, 0.18786232805120584, 0.20934513012239797, 0.2177177954509547, 0.18235797634827655, 0.8186958124859571, 0.8624909538067591, 0.12037492413919026, 0.8634894150726634, 0.16570665039466292, 0.19237366890928842, 0.16668933011417353, 0.8627935383316123, 0.24039802470733607, 0.869145172298112, 0.33990684119435044, 0.2046940055028733, 0.19479165508426977, 0.25957779017561466, 0.7259818558120191, 0.8444311481762901, 0.15545795132548423, 0.20430784191813356, 0.19398462519186133, 0.17484170246071384, 0.18133563128892238, 0.19253863405277571, 0.18645785763920353, 0.19730753828760528, 0.18393322696597214, 0.17165386473411293, 0.17448872195251375, 0.09330431359134328, 0.06709889329267693, 0.08618018774583902, 0.08904826002932764, 0.0866774142427661, 0.08692263336536088, 0.07936387212285101, 0.08298533904105321, 0.09551279812034608]}, "mutation_prompt": null}
{"id": "79ae975a-d18b-4a17-ad81-625aa15c4f5c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            fitness_diversity = np.std(self.population_fitness)  # Compute fitness diversity\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85 + 0.05 * fitness_diversity))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic mutation strategy based on fitness diversity to enhance exploration and convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 29 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 29 is out of bounds for axis 0 with size 25')", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {}, "mutation_prompt": null}
{"id": "fff9f999-75a5-4edd-b43b-0eb222fef35b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                if np.random.rand() < 0.1:  # Introduce rare stronger mutation\n                    dynamic_F *= 2.0\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic mutation strategy based on convergence speed to improve exploration-exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.4727699417066731, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8624978724991589, 0.8689328456796237, 0.8769199979295182, 0.8678073621596802, 0.8738694361654739, 0.8717955306340643, 0.8694313541247567, 0.8734483511197308, 0.864992654285395, 0.7828604244754617, 0.7794733467100303, 0.7940455053682258, 0.777553770766264, 0.7723903239713059, 0.7799212892262717, 0.7710583123056998, 0.8066598090070486, 0.7683306248607409, 0.3222098097677326, 0.28837603763819564, 0.36773033393377896, 0.3932460539478779, 0.37001231954704916, 0.4108930216185126, 0.25500346404006535, 0.15362071060855287, 0.21734567208122357, 0.1532861808546213, 0.15451881570989867, 0.14176578334871515, 0.13238797333838626, 0.12587943934966517, 0.13633261235723126, 0.33762522754771096, 0.11863932985032588, 0.1584285132095714, 0.7981130923388127, 0.8094822524130296, 0.7924808827046578, 0.8073479711792197, 0.7782075246632416, 0.8118535292745827, 0.7967663530696041, 0.7930162376119919, 0.7862510082562174, 0.702902895716441, 0.6786804875638517, 0.6720926243064926, 0.7149799509577737, 0.6822973214533428, 0.6782031341351882, 0.681417776916647, 0.6641667568137295, 0.7169418554257698, 0.841568894912837, 0.7970621075522841, 0.7987858260910277, 0.8082713257639207, 0.8276155325845752, 0.8303156403916355, 0.8489062950457241, 0.8425203341054335, 0.8562910831743779, 0.5235603525373154, 0.6289192684262852, 0.24719919776746535, 0.2153954456744428, 0.20531657560703653, 0.28712130077838083, 0.31001211357771896, 0.5155153858056153, 0.3554103753431207, 0.61136294919625, 0.21158336646597553, 0.28318776711936167, 0.6320467460299538, 0.5171462768812221, 0.2241969199417525, 0.6033891792763963, 0.5208428116047241, 0.21649776058820014, 0.3818116024060241, 0.5388325563744958, 0.5644554792972039, 0.5822516958694656, 0.4583396248347984, 0.6146997805380855, 0.595464893803153, 0.5308535635733953, 0.633795548155722, 0.6628447532027144, 0.6722938701953298, 0.7326077705659169, 0.7088665774092425, 0.6418436244086554, 0.719995892928637, 0.7057842678318534, 0.7329631966064669, 0.7097863373225468, 0.33679457244470545, 0.1400529914875599, 0.1395576862211001, 0.19966842557557407, 0.3402805089251095, 0.31282306794406856, 0.2354552497883884, 0.17255947476464994, 0.15995687146102333, 0.4882054478037935, 0.39847546220993824, 0.43608055586696925, 0.5362071367198473, 0.47198947030603244, 0.491300185408416, 0.5241937184099715, 0.5468999820914672, 0.39084926720854507, 0.8122892973656722, 0.805703606280319, 0.8062473859841903, 0.8103021178959974, 0.7906338570660867, 0.6533407125912509, 0.8100873815961646, 0.8186483819603156, 0.7731633934568849, 0.4949149885662366, 0.12108143760871604, 0.12435387893687222, 0.11618116298867931, 0.09892277212175882, 0.10773728433312568, 0.09480912827850985, 0.12347159890652926, 0.09702650570278692, 0.1478992415285566, 0.28187342646244173, 0.15076944441280593, 0.15743968344075931, 0.21260175327910025, 0.13908401745306143, 0.19984020133365554, 0.1447725667789138, 0.13411383977789593, 0.5999267321059265, 0.5881947728745225, 0.5069149743222842, 0.6011220581847415, 0.6027479625031997, 0.5508406477127523, 0.6424426560038262, 0.6400335284602803, 0.5937199552546857, 0.4339178043846935, 0.4289722887123196, 0.4117218922386908, 0.4205886594364029, 0.4735790512258974, 0.4182815909265927, 0.42468549487649765, 0.5145418177304593, 0.482729775255891, 0.18938458505755063, 0.19794114654834882, 0.2045631277653649, 0.20778174175404196, 0.1903778858526809, 0.1961443812690824, 0.19404584899779798, 0.18914123681649753, 0.22511724623839025, 0.49130342600802324, 0.4568954867129803, 0.5312586857340416, 0.21987433085542885, 0.4938720513050484, 0.617885863651433, 0.2024104093411191, 0.22428776461381794, 0.6039201883788627, 0.8198070708629276, 0.2030061481752603, 0.8395200387148296, 0.1849977204984432, 0.8612424604474177, 0.6977547451266473, 0.8106570176265959, 0.8287243629660107, 0.7831025571756413, 0.20353522141884883, 0.20554673579187532, 0.20862890510147614, 0.1668278903473469, 0.1674379169289576, 0.7600970447641, 0.8015864699547566, 0.817356982439376, 0.8101280837715641, 0.20226182317466523, 0.18228085507561975, 0.18659906359335832, 0.19387423984981955, 0.1880489256967891, 0.17857593497615887, 0.18231242333879927, 0.17648381347753817, 0.18882103693867724, 0.08125850850086458, 0.08140511699686026, 0.08566918076696695, 0.06952676880276665, 0.07742558251285048, 0.08486705901586722, 0.0830814731352637, 0.09535299466610758, 0.07865539375082731]}, "mutation_prompt": null}
{"id": "bc624fb6-4df3-4a1f-bb70-18b791ba42a9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                fitness_variance = np.var(self.population_fitness)\n                if fitness_variance > 0.01:\n                    self.pop_size = min(50, int(self.pop_size * 1.1))\n                else:\n                    self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic population resizing strategy based on fitness variance to enhance convergence speed.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 26 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 26 is out of bounds for axis 0 with size 25')", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {}, "mutation_prompt": null}
{"id": "f790c489-49b0-4ede-b4ee-193b4d2eda82", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionLevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def levy_flight(self, dim):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, dim)\n        v = np.random.normal(0, 1, dim)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            if np.random.rand() < 0.1:\n                for j in range(self.pop_size):\n                    self.population[j] += self.levy_flight(self.dim)\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolutionLevy", "description": "Enhanced exploration by introducing Levy Flight strategy for better global search capabilities.", "configspace": "", "generation": 64, "fitness": 0.12346188503397444, "feedback": "The algorithm AdaptiveDifferentialEvolutionLevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.34862446013341764, 0.21000400056129942, 0.26913508550942034, 0.3838022614278833, 0.29423597095160714, 0.3364547783531542, 0.2833456886277238, 0.21526912809257726, 0.36234246683006976, 0.014529361884045855, 9.999999999998899e-05, 9.999999999998899e-05, 0.024210592149831234, 9.999999999998899e-05, 0.009444633605280472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09271204366225305, 0.054877250470780736, 0.06819328019593107, 0.06623666750269153, 0.0745573221141752, 0.0830638989908985, 0.08184834745567626, 0.05515035691421266, 0.0940270933057169, 0.07102308966550641, 0.03921665669781704, 0.06260811896041718, 0.08368885875722354, 0.05177746447376008, 0.05137801077948767, 0.054271787191166765, 0.0541162563032056, 0.10623310325982604, 0.19467615504252989, 0.1529759073286041, 0.1801290056292819, 0.18773216166767426, 0.16532924922360204, 0.20761102610135496, 0.2041153757263533, 0.15562560335415887, 0.4750215413021388, 0.08862403320688661, 0.1309715958864317, 0.11452718101000647, 0.10620451011131571, 0.09240382714687678, 0.11007115639878995, 0.12930799319215203, 0.12901037433494889, 0.11092229054939684, 0.17062100209129438, 0.1512081928341047, 0.16165319999243444, 0.1824949418219316, 0.20210577072235725, 0.18113115020901482, 0.21954975975426472, 0.1678581424668657, 0.21187169754988255, 0.04890579100873038, 0.059342774066039605, 0.0639655692057961, 0.09987506621879816, 0.09961056216137476, 0.12761818491128452, 0.052359359354712476, 0.07362423021944309, 0.12238563686747528, 0.061109493604725174, 0.0027291503355676427, 0.05786111205090916, 0.0644858892255783, 0.01938641239945904, 0.06179757699185939, 0.11353517004301994, 9.999999999998899e-05, 0.02473722969008374, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1380390642006616, 0.08032144709602562, 0.12652490774053693, 0.08860235437425146, 0.02986286640376512, 0.08910369624655834, 0.10774553792756636, 0.06449480256321583, 0.08040482208698718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028768155091731806, 9.999999999998899e-05, 0.031342400691715344, 0.01683778279128112, 0.005723171212389078, 0.05655366420713692, 0.06703430115776532, 0.017392859990147724, 0.08877656460187644, 0.2657427486963253, 0.23826016751063384, 0.26684647464479105, 0.2880645708128028, 0.28264328924877713, 0.27736872235290744, 0.2637113773743299, 0.21195552835315867, 0.2747107796693624, 0.08032807862138702, 0.07985408622011492, 0.07031958818343043, 0.05083961455577479, 0.06120168625095235, 0.07406450527008035, 0.07338861968490851, 0.05759775714630233, 0.06134453449808297, 0.14789764189619947, 0.13686381673121972, 0.1732717650812341, 0.11602823880338042, 0.14516285670275852, 0.12705540395418013, 0.16316186299952895, 0.13895151720479315, 0.16899583013646657, 0.2050416996058262, 0.2120930846849831, 0.1888128612540193, 0.21175655517247383, 0.17091020160857406, 0.18201782994437243, 0.24719810876502502, 0.17704163624486047, 0.20197315067623245, 0.15261394009779783, 0.11700950928593268, 0.12244782823346578, 0.13528708785453925, 0.11222429181260718, 0.13780821854275005, 0.1320582777080901, 0.133992580761516, 0.1549841286652045, 0.1927450806443085, 0.17684096168037322, 0.1899830000299476, 0.16212265289868355, 0.17368237832497124, 0.18737259960458064, 0.1602301103492313, 0.1611805333755819, 0.1531190709009681, 0.1671634710968507, 0.15586535011641067, 0.17114767662739017, 0.18042723910882796, 0.15353633847271597, 0.16998022223409992, 0.172551783765871, 0.15311612913371742, 0.15885889357314975, 0.2645072904692054, 0.16653503733250252, 0.20422768307641237, 0.18177802918997255, 0.15211887806800917, 0.12857851948939458, 0.18622245422246542, 0.1920361352107418, 0.18986940035284694, 0.16282198534471715, 0.1683559483323146, 0.19512133930052844, 0.15190251214783235, 0.20873488147434627, 0.16798645742891527, 0.1564289073692675, 0.19053564394771816, 0.21943738748891106, 0.17568941190912613, 0.19839556736763708, 0.18736753940366235, 0.17369201023384262, 0.17254152168585646, 0.17510526377086588, 0.19481005789510553, 0.17221078274427726, 0.20115979416990237, 0.0561291607675346, 0.05517426181590257, 0.06139337564737157, 0.0650242771393651, 0.05509372203809637, 0.058318745293997165, 0.064551473098303, 0.0639152738054567, 0.06558240662606207]}, "mutation_prompt": null}
{"id": "c63362b1-a899-40d9-8412-2119e77cf9d2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 30  # Increased initial population size\n        self.CR = 0.7\n        self.F = 0.8  # Adjusted mutation factor\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.initial_pop_size, self.dim))\n        self.population_fitness = np.full(self.initial_pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.initial_pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(len(self.population)):\n                idxs = [idx for idx in range(len(self.population)) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.75 + 0.25 * (1 - (self.evaluations / self.budget)))  # Adjusted dynamic scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)  # Simplified boundary handling\n\n                adaptive_CR = self.CR + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adjusted CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adjusted random component for CR\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adjusted random component for F\n\n            if self.evaluations % (self.budget // 10) == 0:  # Modified frequency of population resizing\n                self.population = self.population[:max(5, int(len(self.population) * 0.9))]  # Finer adjustment\n                self.population_fitness = self.population_fitness[:len(self.population)]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Implemented an adaptive population resizing strategy based on convergence progress and fine-tuned mutation factor for improved convergence.", "configspace": "", "generation": 65, "fitness": 0.4116899757969264, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8671244157914472, 0.8476029331492527, 0.8599069645609351, 0.8559369241503457, 0.8601077828205488, 0.8639954155605521, 0.8510586952203278, 0.8530180227004754, 0.846360324652404, 0.7583012314105918, 0.7516049306989291, 0.7441239805751962, 0.7385436169548125, 0.7395609759606256, 0.7578178663084987, 0.743058958466132, 0.7362635890468225, 0.7688477342488313, 0.2508008588276509, 0.19798302143613156, 0.49864259021091517, 0.30070425538351797, 0.2400679203840962, 0.36800741346453547, 0.4598523671634521, 0.2520215263463619, 0.3005840599932552, 0.15087901359794664, 0.14159012627055623, 0.12725704001258997, 0.15652785952949966, 0.140111728122849, 0.263352585276994, 0.12716609501749776, 0.1421648001590058, 0.15822538120283058, 0.9646464800556955, 0.9534316880327578, 0.9454959067403936, 0.9604018866757478, 0.945252115237222, 0.9658417808212034, 0.9531118054510541, 0.943936133139067, 0.9482472847358924, 0.6515242741004776, 0.6225189949471885, 0.5927355358181885, 0.6413029936362401, 0.6448975532303738, 0.6182176801639034, 0.6005717533990708, 0.6484863419449332, 0.653383596266743, 0.74927507751156, 0.7581069456134527, 0.7612541470881891, 0.8155764886151532, 0.8157551991053162, 0.8294732822766978, 0.825117926935809, 0.7780425830380338, 0.7583382988953877, 0.2826320287626626, 0.18527487797758035, 0.4411381605877348, 0.17858975553541367, 0.2774922199842995, 0.21580460636584375, 0.18865838329659124, 0.23653908436200854, 0.17275685596704204, 0.22934960157909723, 0.6098310073174152, 0.16280435918667846, 0.2702427586020103, 0.2729867387653402, 0.19467502897680955, 0.29153189825013626, 0.2807815114403812, 0.2860931134066149, 0.5022867262059195, 0.4336230164012732, 0.44492772458045937, 0.519170743124715, 0.47166560447074746, 0.28738552497821146, 0.5030391980655875, 0.4565161285663, 0.46878083117943115, 0.6003380441573538, 0.5521033076839819, 0.4882444854350634, 0.584535246199698, 0.5634800838732594, 0.535643297475429, 0.6236850306475534, 0.6111649248952777, 0.5949895982135571, 0.12337168351167771, 0.1334372692772171, 0.12072937071477774, 0.20411117148911817, 0.1284313769118497, 0.25556376001512093, 0.1423146256734943, 0.16221597421733114, 0.2547448439542863, 0.3650358642292276, 0.33523339675581243, 0.38186580469233056, 0.4233874319614215, 0.411011398469877, 0.36806653324078575, 0.38577176591504847, 0.34907069516056854, 0.34772840045123143, 0.7290321358102567, 0.7440544959977893, 0.7299582574750094, 0.7436766894106133, 0.7390672817449381, 0.754665823782803, 0.7745468620318938, 0.6653092644344345, 0.7725659267973017, 0.10104263442917583, 0.10238759323758817, 0.10272743333975864, 0.08654290340191806, 0.11057258568752404, 0.10869149374940212, 0.11303321985847925, 0.10404422778051525, 0.10038172707607995, 0.19106298306964786, 0.23091852033338156, 0.16327795140283485, 0.2508067436603375, 0.1662018112191863, 0.138046605068481, 0.15028099883067259, 0.13874608991213622, 0.1744234909296407, 0.4997124751203743, 0.4533012838794992, 0.4900544712813476, 0.5001741441366641, 0.4913529977550426, 0.4708372793067841, 0.5187161379790032, 0.5546632213148193, 0.5409082792315478, 0.345137511707412, 0.34509321480959876, 0.3313336564537669, 0.3502244294518012, 0.3592997348770144, 0.3142340596803911, 0.32479954674239453, 0.3528542954074223, 0.393828248904431, 0.20329817641164327, 0.21231914972299637, 0.19712930232204484, 0.21072664638672678, 0.1840682168160539, 0.17702392584224802, 0.19407445609666796, 0.2188977754070025, 0.20606839988171255, 0.5110840556343348, 0.3982632279382533, 0.27219199987169873, 0.39962306951720616, 0.3692010375635528, 0.40604321398602095, 0.20115425643933704, 0.28475660820143034, 0.5304659157055812, 0.17068795871236775, 0.1700121953272019, 0.8412481787802861, 0.7582383714399433, 0.19414010142639504, 0.19832337294703228, 0.42696479451798275, 0.17962345991172302, 0.18382159118074992, 0.818365682553058, 0.1978955694409772, 0.19936575789565814, 0.20135030830054113, 0.19762495313509876, 0.1946232053543644, 0.20346975314366011, 0.19396488623483255, 0.20972238331518, 0.19987806770965977, 0.19518826533193656, 0.1835645890498404, 0.19795229570701023, 0.1635215454429304, 0.16906734074013852, 0.20809112767268678, 0.18922888196473453, 0.1894203874743916, 0.06815917807431493, 0.07537558081014684, 0.07670896264025018, 0.08181813019921524, 0.08257044372566902, 0.08816131353416334, 0.07871756224221449, 0.08597503145603336, 0.07824374117726052]}, "mutation_prompt": null}
{"id": "0bbbe9d7-96f7-40a1-ae77-b8d419124900", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            ranked_indices = np.argsort(self.population_fitness)\n            \n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                \n                rank_factor = 1 - (ranked_indices[i] / self.pop_size)\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * rank_factor\n                \n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a slight modification to the mutation strategy by dynamically adjusting the scaling factor based on individual fitness rank to promote diversity and convergence.", "configspace": "", "generation": 66, "fitness": 0.26630294578502006, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.47333407738466526, 0.8466934157621193, 0.9002581244819842, 0.5031187680306385, 0.9339871448218202, 0.6860782899818758, 0.8851924090511429, 0.5260173092988462, 0.9220480049853542, 0.1668208669448823, 0.4894027267908526, 0.2248710445456521, 0.8442918391417124, 0.12218552452473719, 0.6064234239579739, 0.3112270112814418, 0.6933326047872505, 9.999999999998899e-05, 0.15826728975774262, 0.14486377952320473, 0.11689125813198131, 0.48060258249166043, 0.18191418372435697, 0.18290667494318635, 0.16208206106422096, 0.1559812608450577, 0.8382355259256118, 0.14435760119421592, 0.10583604569335181, 0.11651480284489213, 0.12264417764858826, 0.13304088941374415, 0.12199747193502464, 0.09734565936895723, 0.12234545332397884, 0.17634579498312264, 0.37756651868094115, 0.4322937955579317, 0.2881090443278802, 0.4283074999040767, 0.17507531965133216, 0.40690150117272783, 0.4986413640347527, 0.3293225703745736, 0.4651584126544559, 0.08791207724396322, 0.22289440518505266, 0.14102027770075198, 0.10527116958102856, 0.1294332040075269, 0.3256158326204206, 0.14791972938067943, 0.11281278576148435, 0.17874811458777617, 0.21092069292374682, 0.23532296307720257, 0.22285417738495916, 0.27997455319147513, 0.9321769815775952, 0.2802455110621225, 0.9017719020632139, 0.8994383557976328, 0.17932101186813343, 0.13349613713316688, 0.14099188545672403, 0.17281831886017918, 0.2585741839789951, 0.0007509054822996131, 0.15850913338410388, 0.12907791599570972, 0.2335370163820376, 0.19289045132070037, 0.14327051011806857, 0.14787252478060797, 0.12756490230581152, 0.12888627900425476, 0.1283361240472044, 0.16427707630396804, 0.12910023587731123, 0.13821511014845234, 0.239539497671989, 0.03182008423449201, 0.1780384703262209, 0.053717018155583385, 0.02395937732746256, 0.1234826427554423, 9.999999999998899e-05, 0.030343384748734215, 9.999999999998899e-05, 9.999999999998899e-05, 0.08584780496764566, 0.10779225168374995, 0.1076336194273505, 0.14505632865461193, 0.12349420069407602, 0.09804949701846144, 0.17343495091431782, 0.1237849334106862, 0.15514784854164432, 0.05931826092811532, 0.1867119895553928, 0.1395308943746224, 0.10429806851225676, 0.35830007945072717, 0.19431819041711063, 0.21933948539740988, 0.2261733139084151, 0.1296501218218904, 0.05240551973121288, 0.2350764795883835, 0.28251840978175147, 0.07033645521233045, 0.24849091351367103, 0.26140822978898925, 0.32997942087367227, 0.09212977708022807, 0.2943095017034918, 0.6247774584824451, 0.31468796719447123, 0.5190573783034824, 0.435581158170693, 0.44276193952506215, 0.5961500845097352, 0.3824993188665202, 0.3892150609223479, 0.4879765577819075, 0.09524177991982818, 0.1089572848011301, 0.13367759983679994, 0.2212563456760689, 0.16045100294100134, 0.1545482250221507, 0.1041229157885798, 0.14434654898278565, 0.12177078249484352, 0.18438527606456379, 0.2629528159333462, 0.26042255103115397, 0.414196875445643, 0.603277419467469, 0.2556749847701272, 0.22942239268706566, 0.21194086163944725, 0.3017646166479201, 0.46980476254675874, 0.43795670730734926, 0.3446295576476458, 0.3314136047656657, 0.2575280923357903, 0.4096182800795336, 0.35372854558398803, 0.4400142535832361, 0.42602506071303237, 0.18243181983629742, 0.25797009250637304, 0.32927427184048097, 0.3067321927163402, 0.27752182734423836, 0.2495856299955227, 0.25137117331073155, 0.2925241416179055, 0.34919630524538214, 0.23233197108434112, 0.2311762280310442, 0.3158858308536664, 0.20133223492315677, 0.24203613963239645, 0.24944020973676084, 0.21459596105397816, 0.28226144166965306, 0.21462396373805614, 0.22288586097071794, 0.25199189170745306, 0.20651775220796165, 0.253278741843286, 0.1699217924100188, 0.19749014357529981, 0.25107601614779673, 0.19606829879690257, 0.24921193706919265, 0.7794236028515462, 0.5279326444808199, 0.1534304990317562, 0.15789379803159032, 0.2002344711120021, 0.1992363970914265, 0.1686811687444777, 0.17328808991791012, 0.9418455250642773, 0.34508801134503664, 0.15542122737575192, 0.6776587203989735, 0.32167835132727385, 0.1686363328015903, 0.3635169651259159, 0.12749388140140472, 0.5045167243511384, 0.1562756629166735, 0.17738925816964435, 0.18945066478388328, 0.1774437076858958, 0.18282671314585408, 0.17474451951691883, 0.1835888128535833, 0.1794594469301548, 0.19152134237554552, 0.18232688271116704, 0.09096527002030619, 0.12439742707056134, 0.10140016630546433, 0.101005497340796, 0.09200100318393889, 0.10277414687323494, 0.1349617615942127, 0.10119951418734252, 0.09466754140070721]}, "mutation_prompt": null}
{"id": "3950ee01-29f9-4033-b7c4-185f6248c93e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.05 * (best_solution - a) if best_solution is not None else a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced the mutation strategy by incorporating a dynamic component based on the best solution found so far to improve convergence speed.", "configspace": "", "generation": 67, "fitness": 0.46797823279290246, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8892584182029507, 0.8752161223108113, 0.888353600356424, 0.9018454292189182, 0.8876031548436966, 0.8845266981550994, 0.8853399470835511, 0.8903785826240114, 0.8924992485084605, 0.8275057608787524, 0.8294812637865643, 0.81428271600011, 0.7943697063973594, 0.8277007737699242, 0.8166394152218053, 0.8203968855980857, 0.8278293741341884, 0.8190229576096827, 0.13968860564348984, 0.17011551047200335, 0.156215740851109, 0.33789094086463156, 0.12411744492605536, 0.15175470874789332, 0.15363905060663707, 0.6282031225615106, 0.15547618765569438, 0.14236744769294296, 0.13585171723927592, 0.3624161901452678, 0.139114368760883, 0.1404361541551885, 0.12080327974662819, 0.15845711359893067, 0.14279252978983947, 0.18093641887644418, 0.8193708836865892, 0.8086187036573473, 0.8082047553302261, 0.8196062395395154, 0.8103760845414357, 0.8285028343975861, 0.8117493957789484, 0.8171675561222044, 0.8098654914390816, 0.7503231392903603, 0.7355734418512315, 0.7387919790993629, 0.7215348906619417, 0.7522364584873608, 0.7232533701037884, 0.7391979857308915, 0.7694591549110962, 0.7320032816347473, 0.8448967528884042, 0.8600092757490702, 0.8714218289659497, 0.378460812008914, 0.8744960082527683, 0.8836495095722956, 0.8374271000711984, 0.8555351889770124, 0.8598106238054076, 0.2257245601488056, 0.20095707092583848, 0.20908481644976273, 0.18191027555929773, 0.19460130274992804, 0.17454382203811947, 0.27131401304267355, 0.22608857758954792, 0.27035362825712317, 0.17109472714140972, 0.24958641936605774, 0.16099882275631172, 0.2051998032869321, 0.18385993968126835, 0.22779502509203553, 0.2031783836757436, 0.3292822093062565, 0.2003846569207005, 0.6733054820642619, 0.5163235549922545, 0.6916235029269281, 0.6254958911030877, 0.7035437554142109, 0.6863975113056368, 0.6743127023530641, 0.4523284177695732, 0.6380981702291819, 0.5948615236306879, 0.748449665367592, 0.5177718667377775, 0.7487917369634279, 0.778670331848843, 0.7457035273994215, 0.6368000081458425, 0.7779775230498979, 0.7659924325623111, 0.33148913619222076, 0.12543693935313494, 0.20770909621231282, 0.5363132142257603, 0.17209454193349372, 0.283389608879273, 0.3197784198929342, 0.19059878903697514, 0.15301699730963958, 0.600953041856333, 0.4416551813172179, 0.36446164810851245, 0.5676862799190219, 0.49706395253986935, 0.5759876573886873, 0.36571574680614927, 0.4948986232106245, 0.4256988594115836, 0.6951269591529108, 0.8284840915123076, 0.7954065843636492, 0.7640293105437684, 0.8387039492180537, 0.8155914646962283, 0.7804726444898614, 0.8039973181441659, 0.8287687560552147, 0.10183561731228308, 0.11633772101730078, 0.13222770025627084, 0.09321513435095496, 0.12010461539340633, 0.12803500094905906, 0.11659242197969066, 0.1716159322930484, 0.10815493396352305, 0.3458246014276726, 0.17600911714817935, 0.16180671096353993, 0.19644399423861014, 0.13976257709991913, 0.18219976639979063, 0.19455910973462565, 0.2136957896651528, 0.13535453241785866, 0.6618667783018772, 0.6558675497978161, 0.6148797255359246, 0.5965525495208821, 0.6757603462270588, 0.5387250580233023, 0.6665705738349053, 0.6757815603055861, 0.6688991998999149, 0.5107880274631815, 0.4863025895364752, 0.42555310710976724, 0.5657161487627123, 0.4944504979655735, 0.4334437393147639, 0.5203709338480138, 0.5126845436423475, 0.5078111730447915, 0.23358831500679578, 0.18038085147518268, 0.19087559915851338, 0.1779490376681946, 0.18927881147089176, 0.1992592624721452, 0.19285080973071966, 0.19264584354818914, 0.20464234938990722, 0.2167577865093957, 0.21576913534149833, 0.6207709240542401, 0.22929227905535077, 0.2425755274028809, 0.6790691862410616, 0.7295628345322605, 0.6865365351456663, 0.5740541718023557, 0.8951610133306994, 0.8533534334817453, 0.21183629538236703, 0.8439813678759072, 0.845768043603412, 0.8392632837676264, 0.1710682374974789, 0.8616331172400638, 0.7532504446753574, 0.7486102985817529, 0.8495673606273639, 0.2051239465208594, 0.16672387674145972, 0.20696059816333845, 0.20806301728114274, 0.8049675168224139, 0.1551433183415697, 0.1644925103744883, 0.19983284565022774, 0.1847225481845045, 0.18496742303348002, 0.1983532103776413, 0.18303781794298912, 0.19598707476363797, 0.1833180200171689, 0.18640997339647558, 0.1824512705266833, 0.07885705959170008, 0.08534605884822599, 0.08712178325139308, 0.09432751827032027, 0.09117767668404997, 0.07659670799742357, 0.08500524256888198, 0.07686959798632487, 0.08128633190444634]}, "mutation_prompt": null}
{"id": "ef139e0e-3402-4b96-9833-917bdc5d811f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                diversity_measure = np.var(self.population) / (self.ub - self.lb)\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * (1 + diversity_measure)\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive mutation scaling based on the population's diversity to enhance convergence speed.", "configspace": "", "generation": 68, "fitness": 0.29901878427560197, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.7975520506021754, 0.8036563644679583, 0.7957220670847137, 0.15875548393667105, 0.6376449573073448, 0.6457815600285013, 0.8210713465461671, 0.8213459177428183, 0.8100457024880268, 0.6848757823909392, 0.6969672795014243, 9.999999999998899e-05, 9.999999999998899e-05, 0.6359243910166354, 0.6214691291227913, 0.5307117887418737, 0.05065580407866932, 0.49038361739266956, 0.3122652053487426, 0.4219262352730585, 0.2560386807029873, 0.34286852453453043, 0.24982146488984613, 0.2944256242585205, 0.2235773847669189, 0.1112191101371367, 0.13937259741092511, 0.17514352529895005, 0.12818564674598587, 0.33766825807435064, 0.12640597233055018, 0.2816531883035097, 0.12823995193203774, 0.30228882391009315, 0.14710428909010298, 0.11136202656032512, 0.9804664132520073, 0.9951038614973161, 0.9876758465234162, 0.987394226158218, 0.9868402436796645, 0.9806034139881731, 0.9759937299811642, 0.9871366174821634, 0.9828437618097199, 0.5249239793885997, 0.5046377365741346, 0.43362786877472614, 0.39396534683876494, 0.14496707459956726, 0.3936313267419502, 0.4155654290864119, 0.08548856499314494, 0.082430236598249, 0.7331582987241968, 0.687106948632318, 0.6898632577378572, 0.6914853152964319, 0.6465329825878573, 0.6732305276628366, 0.16146128563755813, 0.6620180646479399, 0.7028605797716743, 0.49564387735482274, 0.43955524231251697, 0.48846886006988754, 0.47443132153435685, 0.38419604935858775, 0.47515686159855164, 0.34168874484902845, 0.3826696510181381, 0.33518311439938864, 0.009745806856234607, 0.009801383913199402, 0.12323960155136315, 0.2658112089783363, 0.19795256377375747, 0.5865836048008227, 0.18190674031367282, 0.24306857195347287, 0.16326049565141987, 0.10461034711935913, 0.06133003851795871, 0.2198684515779884, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2585596238374175, 0.33329400780352725, 9.999999999998899e-05, 0.14330157735515137, 0.3456607792006091, 0.06083710650737961, 0.0728930373219564, 0.2433875670424357, 0.19400106834013364, 0.014996192312507817, 0.46011054880900437, 0.04688324414385714, 0.06138617405354285, 0.061128765600709456, 0.005516656625583538, 0.1066602190784326, 0.09678712895594876, 0.09113134365019937, 0.1352948198378192, 0.15237389448029504, 0.15280859958846937, 0.035491906146570384, 0.20115282612229335, 0.1963889792987945, 0.12569100063323624, 9.999999999998899e-05, 0.16385707043899622, 9.999999999998899e-05, 0.15780937324366073, 0.15140191400059377, 0.6676577983732721, 0.6663422251903433, 0.6959286621238696, 0.5876296061339974, 0.5753006978149375, 0.5722088064495114, 0.7432124382003088, 0.7192767228685886, 0.7390000744026193, 0.08359833981724585, 0.08184207553978795, 0.0866592613259769, 0.09781907047514526, 0.10250832716576419, 0.08798540931853716, 0.09413229046843352, 0.09318714118434435, 0.08069500451795353, 0.12814895505580515, 0.15999801870572028, 0.13893828039096312, 0.14902865856567094, 0.11308641433234656, 0.13898072711270015, 0.1214745413728393, 0.1000888996484548, 0.17010319538765384, 0.22897573388184023, 0.34711715875335003, 0.37599103157683733, 0.4465106045374121, 0.40617859225611697, 0.3996024996073848, 0.2974111119629229, 0.3439697508902715, 0.32238831078805086, 0.2555598206215842, 0.29307477369638757, 0.26539889146010887, 0.298591641782989, 0.06406947898089654, 0.2625610461922735, 0.20847005144817587, 0.24710440154657287, 0.21588776437977386, 0.16371298643783816, 0.15514806452772167, 0.17375309224157665, 0.1712529603406463, 0.17635501381304586, 0.1896441963965858, 0.17437664498174776, 0.19260950423754986, 0.18120316413738347, 0.21100404968578346, 0.20369164236380488, 0.2068135132571981, 0.202107747109736, 0.2480959061685546, 0.19303423232451034, 0.19892873668229016, 0.5186222360947936, 0.3047827738292964, 0.13696494700634698, 0.11140398740780544, 0.1628105352471857, 0.15899921536286077, 0.18744812733116323, 0.17399854153585126, 0.11914505004813658, 0.1725637929957704, 0.16250971939707926, 0.1980295522365756, 0.16336348414662116, 0.1527786345364055, 0.4873861793541062, 0.18102710763120333, 0.4748384561021092, 0.29386434147792884, 0.1870978939661352, 0.18193776283356722, 0.17442447327737065, 0.14976243829216096, 0.1767755679236288, 0.16726898996961193, 0.15872503593395593, 0.16852665725111693, 0.14969714796693134, 0.18416464349796036, 0.14689007985489466, 0.07554502814777975, 0.06899355850190547, 0.06652636360131658, 0.07155856812399108, 0.06539569544744295, 0.07189527294902365, 0.07104668640642775, 0.06922194103752444, 0.06972050317834089]}, "mutation_prompt": null}
{"id": "ba8231be-e217-48f4-b98e-e58a500664e0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            population_std = np.std(self.population, axis=0).mean()  # Introduced population standard deviation\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * (1 + 0.2 * population_std / self.dim)  # Adjusted mutation factor\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence speed by dynamically adapting the mutation factor based on the population's diversity.", "configspace": "", "generation": 69, "fitness": 0.4683973777734482, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8845789124830277, 0.8826897594789376, 0.8751610417970697, 0.8690304938095257, 0.8810912624136282, 0.8787082127151087, 0.874417121189746, 0.8707548991938111, 0.8711721650271391, 0.7951262461282963, 0.7937995059149028, 0.7885260449542321, 0.7946324891171459, 0.7986854711772742, 0.7874449516542781, 0.8039075936923931, 0.7981770550479842, 0.790952562068913, 0.4931765137808326, 0.3174585285350787, 0.1962003048397617, 0.16935109946276117, 0.14474075122664742, 0.4684445557214534, 0.15434074099439254, 0.1486300758532656, 0.34783045101544763, 0.15825450411111108, 0.1433069600428276, 0.16081400969317838, 0.16189015390945372, 0.1364122987666888, 0.136733051034583, 0.43408386861603476, 0.13141842246627544, 0.15039401060496183, 0.7983616854868283, 0.8171744679358002, 0.8034571127541354, 0.8173587465706671, 0.7876767652168338, 0.7918792081062098, 0.8001482282576564, 0.7943199851993458, 0.7978508481910682, 0.7133706113159051, 0.7324095986938588, 0.7247811482832005, 0.7122188787548276, 0.6821203230799697, 0.6747191160237757, 0.7301616243492672, 0.7130687927078213, 0.438534465333983, 0.8193537225225518, 0.8003548466306267, 0.8402768222831596, 0.8330268072670433, 0.8572386262221422, 0.85239581268676, 0.8102612923761427, 0.8355726331639127, 0.8437494400104101, 0.30551348645049414, 0.6889150247952147, 0.5534068056433976, 0.19625757147775114, 0.19839515767730764, 0.18215662046855663, 0.24047417004944915, 0.21727174109945868, 0.18357258203812565, 0.2898470210588141, 0.2193953496195542, 0.2778530022257669, 0.3403530239447137, 0.23271212898911575, 0.6697646958677874, 0.22829997540267466, 0.20267946672749826, 0.20967519662777234, 0.6398821115409778, 0.6792318554076603, 0.20599666765401214, 0.6497857708336998, 0.6388262142839927, 0.568562813719792, 0.2913648954512351, 0.2834392260442541, 0.5959280761084034, 0.4696206109768074, 0.651025884137513, 0.7224244069736685, 0.3390297698617155, 0.7245680455768015, 0.405485496945872, 0.7309119535605966, 0.7464399269121375, 0.7193153931886126, 0.10025986805453335, 0.39576623918244147, 0.06979229676566678, 0.1826184545645454, 0.24274354834702205, 0.23132120188891048, 0.2784051511905016, 0.12389739622581997, 0.16754134258608522, 0.402527727807378, 0.4485230233087606, 0.5196161737330232, 0.4784282992389449, 0.590035591104908, 0.5042795350122111, 0.4956534174367886, 0.39783785042864495, 0.540832684372768, 0.7738503670651351, 0.8176350908424967, 0.7682814560316483, 0.7276552149314177, 0.8134539962785639, 0.7985070343836005, 0.8319997070741625, 0.8235282079054056, 0.6827555914369547, 0.15274607700953802, 0.13813473488875883, 0.10329335229108694, 0.42737739720201884, 0.10386685146769237, 0.11578739629458801, 0.10051515213396212, 0.10408140007856725, 0.12102009954255988, 0.15333619986105118, 0.13529367564398398, 0.15403793656523035, 0.1248949671539249, 0.1494280865970874, 0.16307771101437207, 0.13224865555026133, 0.15128203532646856, 0.1333657223639857, 0.6439999705754992, 0.597348569191055, 0.596322217688505, 0.6279918905115407, 0.6345940296183629, 0.5930873133183041, 0.5626070756255723, 0.6777831790923349, 0.6320907540313525, 0.41685841278015834, 0.4442726845708854, 0.4586658427972219, 0.4365112661388134, 0.46979129986739376, 0.4622310083204614, 0.5169958329766298, 0.565679621715923, 0.5271747555853348, 0.20957588454190768, 0.19524032517521428, 0.190131576254008, 0.22337270091296524, 0.21143251882644376, 0.19676591187611425, 0.20760017345847137, 0.18678230684770203, 0.19503205424347902, 0.6431631336473983, 0.6549905401098485, 0.6124393216284385, 0.5639015535031067, 0.22227547554881744, 0.4404130094676729, 0.20558541144339593, 0.55039399073704, 0.2132992344312029, 0.8736502199181873, 0.8538601390939324, 0.1824573305126993, 0.8438572490992684, 0.8381562474139255, 0.8090237276000838, 0.8036573976097277, 0.7980503567914652, 0.8461810346562012, 0.8021049803912247, 0.20463673314257036, 0.8267882008419036, 0.20916413953155544, 0.16560803331358454, 0.20965331921634944, 0.7993089605239432, 0.8130019013591281, 0.7980597181489473, 0.19126204045078876, 0.1969947331783508, 0.184211235723312, 0.19250915849195127, 0.19420800762918844, 0.19482075257128217, 0.1947536215550354, 0.18109554806333394, 0.17312136906625852, 0.08201992313366846, 0.07697437262574602, 0.08173083394284664, 0.08320174767711996, 0.08354589576394578, 0.08346098198574547, 0.07709043016539108, 0.08015927399517475, 0.07495938133564672]}, "mutation_prompt": null}
{"id": "e522fcf1-3a9b-4312-8c54-46a1ecc22383", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                \n                # Calculate diversity and adjust F\n                diversity_factor = np.std(self.population)\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * (1 + diversity_factor / 10)\n                \n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by adjusting scaling factor dynamically based on population diversity to improve convergence.", "configspace": "", "generation": 70, "fitness": 0.4484684044653466, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.25.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.838274973087853, 0.8428297615538041, 0.846989208739975, 0.8297035071962382, 0.8236366107149009, 0.8255214367398065, 0.855753587868832, 0.8582553058663027, 0.849604250084367, 0.7770088498681444, 0.7628543814410806, 0.7784929011730981, 0.7593954642040053, 0.7778046452121277, 0.7569833995704757, 0.7226001605024224, 0.7526933708312875, 0.733653595521552, 0.45630048924113187, 0.1461728503158296, 0.29335023814465233, 0.15546668130835495, 0.2748060523761373, 0.17048133337159233, 0.36999301204280277, 0.28788743105140224, 0.14699738274607732, 0.16031065862902139, 0.12883630459457251, 0.13510206299127425, 0.3103515724159014, 0.3658308220124564, 0.12500704168764953, 0.14579554443724774, 0.13938566096395355, 0.2933665514296394, 0.7312072220883872, 0.7352911741937846, 0.753482342486064, 0.7457649576855171, 0.7422492111029126, 0.7703201640361543, 0.756337117057317, 0.7090309333122926, 0.7383773732969066, 0.6505400317057248, 0.6420539365575924, 0.6107875589296333, 0.6328973649301547, 0.6084656699719447, 0.5995956520126047, 0.5992892315035964, 0.5768075322500463, 0.6381642789541003, 0.7823753613920326, 0.8002053517009161, 0.7792088924303253, 0.8188978208163616, 0.8013277161361284, 0.7686486855161015, 0.7991808119405497, 0.7862160431182288, 0.7788887636577557, 0.5742303225117384, 0.5558529972445562, 0.5924086086904864, 0.6057767435937932, 0.4765443553792996, 0.507229038683267, 0.46571453771709115, 0.6591728696196151, 0.5488894826622815, 0.18748616347037472, 0.19765949761230672, 0.48264565586803043, 0.24552880517048348, 0.5650042514323237, 0.6859697324894948, 0.21176118985299364, 0.38020408429933017, 0.2292948305647755, 0.4999658583622336, 0.5446090908344143, 0.38123725634241734, 0.49601315084438335, 0.5243346786885573, 0.47195636878436065, 0.5457890477109044, 0.6251256154635869, 0.5780760316604889, 0.629906348944522, 0.634482595042076, 0.6502790476018625, 0.6627087411892065, 0.6202228600440473, 0.582237369974538, 0.6589930330776782, 0.7016614530510518, 0.6549519284900001, 0.15639744422470214, 0.11821061991117676, 0.24723715575728533, 0.2565801587961115, 0.24182390005048304, 0.3756423758184565, 0.2516427210319663, 0.1853451643716969, 0.13819286821811672, 0.3705797918733722, 0.3616291096018516, 0.3456400632476825, 0.4022650358743143, 0.38612674393506285, 0.37596721766807506, 0.3882677130803891, 0.30036113703495493, 0.39669195261146084, 0.8018440052388389, 0.7651635816932929, 0.7851231885684292, 0.7643031745744194, 0.749617223497204, 0.7565552679676628, 0.7927439285817115, 0.7874965295401033, 0.7817536980547369, 0.12431033123434976, 0.0923275170277098, 0.09602385524577217, 0.14518690987312655, 0.12035027708047308, 0.1038568019578503, 0.10677440981524922, 0.10381674023528908, 0.1169434266518018, 0.2044219742685729, 0.13720454135410687, 0.17671423266851582, 0.2957167496219395, 0.13066286365150104, 0.13302576537136668, 0.12639329837417612, 0.16904228433020219, 0.14533936622631138, 0.47550136828281886, 0.5478876506572745, 0.4776469802330081, 0.5128120837707357, 0.5948372837629982, 0.48269194314467134, 0.49969206387175713, 0.45984864183764396, 0.453641741121544, 0.359338841902747, 0.36327924507918175, 0.37547551925616796, 0.36421313448903225, 0.4079714539761944, 0.3942399198152966, 0.36062915917907645, 0.37963160880462943, 0.3596872479331088, 0.17809233474801223, 0.2001448645393279, 0.17438221705139223, 0.184684673568553, 0.1913353340338474, 0.1703484969109148, 0.2091046193011733, 0.18658529881890995, 0.192041300912987, 0.45889134382151187, 0.4533705206272447, 0.20228811773171473, 0.534222038132848, 0.21186282829685843, 0.48617179026550306, 0.5012279450174251, 0.4969010935680822, 0.527650552730289, 0.7726027405218073, 0.733842251423429, 0.7877462289545666, 0.16997429088304938, 0.19349029051789957, 0.7474026756557337, 0.6876284467949911, 0.19818343556657403, 0.8126314372057692, 0.6775623550775867, 0.8098241735367484, 0.7929590859435367, 0.20306680592621928, 0.7659763218440858, 0.20693831530024476, 0.7710448247381302, 0.20566589570087968, 0.2068142373638988, 0.17351708119446763, 0.18094355824830066, 0.18965103843039732, 0.18226757886770972, 0.18461933093873473, 0.20115383839126177, 0.19515402989118424, 0.1799929158394007, 0.17698457162551984, 0.08478894379717372, 0.07734066855603616, 0.09029831546687661, 0.0864657582976961, 0.07955084921643996, 0.07613947641078489, 0.0771938982893029, 0.08684331457874872, 0.07624006882564804]}, "mutation_prompt": null}
{"id": "95f7726a-900f-4499-bfb6-0a4392883aea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                dynamic_F = dynamic_F if np.random.rand() < 0.9 else dynamic_F * 0.5  # Enhanced dynamic scaling\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n                \n            # Elitism: Ensure best solution is retained\n            if best_solution is not None and best_solution not in self.population:\n                worst_idx = np.argmax(self.population_fitness)\n                self.population[worst_idx] = best_solution\n                self.population_fitness[worst_idx] = best_fitness\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic scaling for the mutation factor and added elitism to retain the best solution in each generation for improved convergence.", "configspace": "", "generation": 71, "fitness": 0.4704893979065339, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8794697238967267, 0.8804568127331285, 0.8889465387669244, 0.8834551825529582, 0.8962108232624347, 0.8839230008299895, 0.8843357807223731, 0.8790638829502304, 0.8879724466073542, 0.7996795748073993, 0.8076067542646596, 0.8181785530021326, 0.804897456979695, 0.8177036628632567, 0.823606111366411, 0.8067381009115795, 0.7900037962382126, 0.8053325653762207, 0.3245831520236466, 0.1623118793250038, 0.5254250977047933, 0.40596692392954237, 0.4726155231458372, 0.4540157913243743, 0.45235625073355457, 0.4151147922403218, 0.3938396336047264, 0.20307962268808133, 0.134937273381333, 0.13387333235398569, 0.16397898874421857, 0.4943265925811926, 0.35065283292912486, 0.15655073849088463, 0.456107996851852, 0.15151382695993576, 0.8271221723139753, 0.8190010747789556, 0.7971943166117552, 0.8186469869183728, 0.8232259116754347, 0.7970332840144404, 0.8270207247191271, 0.8279788073333733, 0.8175442310224765, 0.7003490500466439, 0.7290894202102927, 0.6904433203840419, 0.7003389435587801, 0.7289595013400425, 0.7107815724301481, 0.7183596662140395, 0.7391359870351368, 0.7105736749223528, 0.8560705379621718, 0.8536135398177771, 0.8302825929905661, 0.8447523670108813, 0.8327416402087588, 0.8769846641373683, 0.8405364196740874, 0.8615569676516786, 0.8698995688509258, 0.2695862146744731, 0.25161039767404414, 0.18028316252611076, 0.7135008820894768, 0.22280986276877224, 0.18359500120393135, 0.1857252119965931, 0.3169793763070293, 0.7479706907722812, 0.4463367976798799, 0.20384999710007345, 0.18499310663272628, 0.2127194724354382, 0.2066637157313077, 0.41390695131824573, 0.280032020683182, 0.1989686738614974, 0.18736395644102133, 0.4783632132674993, 0.607260058630134, 0.5521496588424043, 0.2977522456185441, 0.7074521311980437, 0.6415405976206534, 0.1786163810861604, 0.5295755171670895, 0.2447552499867962, 0.7426364723446639, 0.452531289452625, 0.6918128848122074, 0.7109919107992835, 0.2736579666736092, 0.627547369294712, 0.37409322192532934, 0.6953207748666808, 0.8014411633296805, 0.1552887768229273, 0.19126865303396612, 0.21547779358627372, 0.22961396430321468, 0.20821164490373956, 0.33775982198767884, 0.25950592604002654, 0.19294881532204955, 0.3023418821668886, 0.3464581546686579, 0.5216886317762623, 0.47059613150156754, 0.35629775660627816, 0.36923432189021355, 0.373813498535835, 0.4366177902127709, 0.3651262944621243, 0.3536127070980335, 0.8248468256168777, 0.819579914442942, 0.7621665364640442, 0.8008947458632527, 0.6933952427531718, 0.8125399216172793, 0.713124037770698, 0.836247328668042, 0.797208187068543, 0.12992882843057318, 0.14938038748005367, 0.1246136759837293, 0.12293174144787933, 0.09214293684569508, 0.12698588889683649, 0.10738891289488073, 0.3663282955670448, 0.10263999818414016, 0.12647716038183843, 0.1616840360326245, 0.2182184160314974, 0.1483448949710815, 0.18345614739819305, 0.2506966005750082, 0.12975211549904275, 0.1539440925661475, 0.30375874079020015, 0.6545875183622055, 0.6110455249062101, 0.5683047586774816, 0.6186177055771178, 0.699267304546778, 0.6733258582161294, 0.6744001135622022, 0.5017336100885765, 0.5899556424056687, 0.47249016291648605, 0.5028308283425755, 0.4774413163913608, 0.3875389507131979, 0.446207400915103, 0.5315570993008065, 0.4858590106265188, 0.5195595748672319, 0.581362090476887, 0.19579132870972138, 0.20482645926548282, 0.19871300132447123, 0.19867242898284454, 0.21053227301492472, 0.18507329301003994, 0.18949840921063665, 0.18927215147264853, 0.2105299762660362, 0.6124615486787877, 0.2271021450024947, 0.2222812242659804, 0.20063156461024367, 0.20359211594260085, 0.6796325631600897, 0.5742495252502235, 0.22164977545883469, 0.5739435767084646, 0.9045388289315439, 0.8920832183085884, 0.8489205274566742, 0.1804186696860567, 0.8569971954491071, 0.8765598433535805, 0.16697840090490845, 0.8635141843556564, 0.8184434910200028, 0.8025306903662441, 0.8202242122773364, 0.16741404316431618, 0.20462884640892076, 0.16603589955461162, 0.20377590688438962, 0.8275321673566816, 0.8186364722694075, 0.15559999125870605, 0.1899678146500694, 0.2027532021828008, 0.19932076872087456, 0.19029058114544972, 0.19751908608145197, 0.1844307928044715, 0.17665114877350896, 0.18241228493312034, 0.1792376909915494, 0.08492513845837124, 0.08234032733940644, 0.08586547345279782, 0.08776587978816552, 0.07928005367852242, 0.0789041402062266, 0.0936994764063993, 0.07785215138629942, 0.08612378162829937]}, "mutation_prompt": null}
{"id": "d2e0a816-10b4-4474-a4ed-50fc445110f0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                improvement_rate = (best_fitness - current_best_fitness) / (abs(best_fitness) + 1e-10)\n                if improvement_rate < 0.01:\n                    self.pop_size = max(5, int(self.pop_size * 0.9))\n                elif improvement_rate > 0.05:\n                    self.pop_size = min(25, int(self.pop_size * 1.1))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic population size adjustment based on convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.4828316445244021, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.875978793915078, 0.8721245079449622, 0.862494910087288, 0.8796662438838355, 0.8891087402253743, 0.8705328473916052, 0.8695491437659462, 0.8838629579217516, 0.871192944732019, 0.7906701933308253, 0.7944735019708876, 0.7798314926734952, 0.799453965404345, 0.8012136809824095, 0.8016411186782455, 0.8051033895904587, 0.7990976771242178, 0.7978137283074991, 0.30811167269755513, 0.3990361450855018, 0.43342468377416765, 0.2799419580902657, 0.4351119223427692, 0.4062548667853836, 0.35329665173892877, 0.1499668699838438, 0.5144585374576447, 0.14235195457988925, 0.1564281194966004, 0.1454380734388676, 0.15732378237947509, 0.15386407839379623, 0.1692779354004319, 0.13371589511108273, 0.35837264211807573, 0.13975954941995683, 0.7993458938995331, 0.7815086106015099, 0.8100227204017345, 0.7840363877963628, 0.8183657603747855, 0.7911470394839275, 0.8103857085503028, 0.7909465229270418, 0.7825459578136387, 0.714103361187103, 0.6868949229209123, 0.6429792239034213, 0.6829386512817099, 0.7330514192230899, 0.6985369660246585, 0.7064991357691008, 0.72001858629359, 0.7239770231210885, 0.8530317475572972, 0.8010019482077475, 0.8101877845011726, 0.8544250587092348, 0.8563852300298945, 0.8322638686376365, 0.856992435623111, 0.8295789478636862, 0.8800327881861182, 0.6229453999537896, 0.67950174111691, 0.27514234746129274, 0.6462534053420805, 0.6017322172774457, 0.6548730492755324, 0.5992534723225242, 0.4382797577365227, 0.2349042272666777, 0.2059106712962, 0.19377950500218433, 0.35089505851630665, 0.6650916846989072, 0.616855967985459, 0.2705568187852291, 0.20418729129701396, 0.1918840490742434, 0.23292167992965562, 0.6555398090966122, 0.27230679330270535, 0.6303523196226098, 0.4422469267416509, 0.6146682341653922, 0.6166231399115067, 0.4109216050249779, 0.6327727795910938, 0.6168122543730268, 0.7041975528480706, 0.7182594831236147, 0.6952204244685559, 0.307483695418307, 0.6254689101184491, 0.7325430085524027, 0.6848045915751071, 0.7567145224053617, 0.7054460294999133, 0.19317987710761397, 0.16923007687039404, 0.3211704457705117, 0.3488475627345353, 0.19689106339136653, 0.45496290272557094, 0.18816043701143303, 0.19022027314267453, 0.29597888762134983, 0.3582348758073225, 0.39317641985294927, 0.4655580265558158, 0.43380409396936537, 0.5443418982887724, 0.4680807321201732, 0.47577602747053216, 0.3643400123808931, 0.36314430132565734, 0.7969203753867462, 0.7189910840694995, 0.8176808460918474, 0.815915780138116, 0.8080343211159542, 0.8102078284121974, 0.8265998815219615, 0.8270862263237754, 0.8040390958248212, 0.10296033640267144, 0.10393465208845976, 0.10698906392236918, 0.1278608776719815, 0.10058645674606448, 0.12207295353770442, 0.11347571711714421, 0.09448929302077813, 0.1009277148296045, 0.15498408511709783, 0.1590848993444044, 0.2710099832793481, 0.1951235169574479, 0.13622439579763235, 0.15366972169556126, 0.18624555674653376, 0.14753641737826184, 0.12978140937427873, 0.5446736472522625, 0.5486153339255386, 0.5367286822572404, 0.5638902844231861, 0.5889384788645995, 0.5547685305633925, 0.629955641366829, 0.6288748251794742, 0.672899179887342, 0.4197358341094991, 0.4763721943465232, 0.46985799115268123, 0.4447922769032352, 0.5436773902481119, 0.3744291595491014, 0.500995197817814, 0.5711142833845657, 0.42587961520731643, 0.19456848975522245, 0.19905597672570607, 0.21868222060443765, 0.19748326419881945, 0.19326226221411547, 0.183884294540554, 0.199172950573984, 0.19944762507525315, 0.18786745676238747, 0.5077839211084183, 0.4634500032872032, 0.5089328372219364, 0.5971893820953939, 0.559775679019768, 0.4659248603731989, 0.39869691755483727, 0.563837909406225, 0.6318553362285471, 0.8399251304174363, 0.8502497517383012, 0.17543370796512003, 0.8650142331318249, 0.19255824879081274, 0.8480125299796514, 0.1667670213792808, 0.8559904025528404, 0.7947772358185294, 0.8776725951691078, 0.8325988007339892, 0.20480013317405255, 0.8216316512336312, 0.7815988993051302, 0.1993848650176997, 0.8565687572267444, 0.15545839860504185, 0.20423718282878844, 0.18339810026073478, 0.18176718057162333, 0.18075481702090068, 0.18456404513594993, 0.19254307127750425, 0.19035675728728985, 0.17957977401238856, 0.16871459217263562, 0.1888490209047603, 0.08174163128434597, 0.08067089423560225, 0.08496986008161822, 0.09175671276480402, 0.08008712192321366, 0.08358447512735512, 0.08005552291677998, 0.08254156351594866, 0.08992089317426599]}, "mutation_prompt": null}
{"id": "8a5512f0-689c-4d27-9505-13ffb7cf0bad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c, d = self.population[np.random.choice(idxs, 4, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c + 0.5 * (d - a))  # Adjusted mutation strategy\n                mutant = np.clip(mutant, self.lb, self.ub)  # Simplified boundary check\n\n                adaptive_CR = self.CR + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.3 * np.random.rand()  # Slightly adjusted\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with a dynamic exploration-exploitation balance to improve convergence speed.", "configspace": "", "generation": 73, "fitness": 0.4210095860021586, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.9107584113471432, 0.9121901350255023, 0.9155948293702142, 0.9111425508210463, 0.9145806558015147, 0.9081930408218998, 0.9084338899248023, 0.9140289213211402, 0.9165826540965486, 0.8535211204400992, 0.8643671886512402, 0.8509554606489208, 0.8392788163937671, 0.8499710742136799, 0.8440061424234134, 0.8597336056849723, 0.842180992952739, 0.8463055340935526, 0.26591735196777644, 0.5372040536647495, 0.16287400259263907, 0.17778487960775324, 0.14610366502636096, 0.1292903633442991, 0.1612759312681915, 0.17443765523729304, 0.40609843606197193, 0.13045309563935092, 0.10922014477620212, 0.15231927277910073, 0.13124456680540175, 0.14086130335897573, 0.1324173542496424, 0.14331363662344954, 0.14175460725971167, 0.13697965516305433, 0.86937760912874, 0.8964707394141579, 0.9213359129805918, 0.8644125178663402, 0.9282460370161438, 0.8752069035910904, 0.8677799766853147, 0.8703634815218776, 0.8571714060343748, 0.641572650952611, 0.3928951258550296, 0.6243057153771857, 0.38052897519753737, 0.3592892449260887, 0.5270415610584847, 0.3770990024459874, 0.22792512086518857, 0.4066140604887749, 0.8759753047771976, 0.8479218105879341, 0.846024823786313, 0.8818818981195838, 0.8873264880962993, 0.8807490010328384, 0.8723268568145143, 0.8489314652968842, 0.8668469444041522, 0.23057245149145233, 0.15324569607555583, 0.15410725334112307, 0.1733469842045361, 0.15835887746378596, 0.13166607716080447, 0.20126112334058666, 0.5429821051164434, 0.20794338315074945, 0.13153488169464, 0.15086745514879762, 0.15393906737569163, 0.17532228526407667, 0.17934469302050748, 0.15533021349728993, 0.1586156155806664, 0.18405509518886798, 0.15850882435758396, 0.5462238458250548, 0.037670112334927564, 0.6734147739549281, 0.3165396915178661, 0.6900756024078831, 0.6809284296810669, 0.13858085501683004, 0.30328743189744767, 0.4187319034361977, 0.48341644308039844, 0.6989931630155022, 0.7368883909639564, 0.35388893437023383, 0.37215587807290174, 0.0933293970075818, 0.762659534669436, 0.7629073951895011, 0.5152188040202114, 0.08874317986601488, 0.1322147229233568, 0.15940567352524215, 0.2172834889232791, 0.3368736134355623, 0.24262623453209486, 0.22460315462911185, 0.2175590089059486, 0.25506601461332945, 0.32596160716385936, 0.3161665151606827, 0.5609193985892409, 0.25232461321550004, 0.5134001374684876, 0.4206744826400435, 0.4234341194930247, 0.287628091256956, 0.4642893007125878, 0.8570186651568941, 0.8568117547352982, 0.8448387020192403, 0.8561896650788259, 0.5932363990050665, 0.8407811218981945, 0.8332660844278608, 0.8346307158727236, 0.8021430308891955, 0.1147296556003019, 0.1290200417943108, 0.09562694111337167, 0.11600490942044706, 0.1078535324906994, 0.10731772452317401, 0.09884372425729726, 0.13032743273165925, 0.11467274113378767, 0.14087876761087736, 0.13938801352592123, 0.1258572904684725, 0.12762279495288154, 0.13491815480739078, 0.14341301744819235, 0.14376051351205466, 0.14584600442086448, 0.17777725167907543, 0.6998396885982068, 0.6025273010650136, 0.587497374395971, 0.5982781700954132, 0.6500701946517726, 0.6946512376353733, 0.7487455908587726, 0.7474957437736642, 0.7086936354893274, 0.5280685638068313, 0.3737645679371334, 0.5294368055163423, 0.2735256701021527, 0.49241503474633175, 0.47019458116043045, 0.5348686944534842, 0.5929657018357151, 0.5183465506115783, 0.19474258305446834, 0.211034704917763, 0.1936636072625768, 0.2067658874318059, 0.2044637100532195, 0.22653652473528207, 0.22283361957326564, 0.20658896873856236, 0.19748389197140503, 0.505449491691828, 0.5061570429530753, 0.5601093566745277, 0.7434872167140237, 0.354751502441094, 0.19828384843673486, 0.2492259889953501, 0.614352183398251, 0.34772125986389457, 0.1846914773100219, 0.18313760011668323, 0.15221368237798705, 0.16272644779212808, 0.1840817836266555, 0.6944435533513527, 0.18546935597771785, 0.1890899805112115, 0.7832632171270404, 0.20490852848378305, 0.20784309461018124, 0.20812577301038448, 0.8187091939644291, 0.20395104545345355, 0.2025907019377775, 0.7816931672465994, 0.19844938219482877, 0.6531698696282296, 0.18359630842699926, 0.19565904759235042, 0.17732547109398256, 0.17823865304182074, 0.18052320976952763, 0.18657477391124222, 0.2124196165901343, 0.184083148858596, 0.18825045671517326, 0.08737064974863551, 0.08905086711180865, 0.08659085695049107, 0.08794829963370776, 0.08128860309916142, 0.08796967483972584, 0.08747334821037311, 0.09156710083561304, 0.08368982933296354]}, "mutation_prompt": null}
{"id": "881b3e85-2fc7-4664-8fa9-261a9379132a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n\n                # Adaptive mutation strategy\n                if self.evaluations % (self.budget // 10) == 0:  # Modify mutant generation periodically\n                    dynamic_F *= 1.1\n\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration by introducing a periodic adaptive mutation strategy based on historical performance.", "configspace": "", "generation": 74, "fitness": 0.48450275403076093, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8782245293861168, 0.8741120201507299, 0.8629084566254809, 0.8772148640735771, 0.8868587291367251, 0.880394669534853, 0.8763256237946582, 0.8821164874434413, 0.8821465203198563, 0.7874861616045048, 0.7987145032584588, 0.7928344812646471, 0.7922455658307811, 0.8052989275468013, 0.8045870927149759, 0.7969391245535428, 0.8030879754222406, 0.8098614904035785, 0.3933908534096038, 0.4278485865116768, 0.153024077164017, 0.4327389147148457, 0.41011534558173623, 0.1567353149903281, 0.4249901161648171, 0.1630658628122985, 0.2843334944426654, 0.1805909972336418, 0.14417553268437755, 0.11711037442496874, 0.1438200988921302, 0.1353631804776827, 0.13660854993314608, 0.12292599135525417, 0.3748638823609781, 0.12145430131717438, 0.8037878826751537, 0.7934387018440336, 0.8144101494221966, 0.808596668160477, 0.8060649577343733, 0.8114378058955152, 0.8099299467599755, 0.8095540827685159, 0.8036434567384576, 0.6782014354392968, 0.7056995407363214, 0.6604690127845689, 0.6948335433554429, 0.7061819048814628, 0.7128432394766617, 0.7271730914782216, 0.7214862981432852, 0.7105625065157046, 0.816502761533457, 0.8551123585291781, 0.8342302116080537, 0.8538279842902933, 0.8182094371860507, 0.8308936763467459, 0.8519128666127074, 0.8364466817553422, 0.8641965742600973, 0.6877628574868215, 0.38744779341623903, 0.5129858202134083, 0.23451660761880477, 0.30752468954634726, 0.5301704829229743, 0.310056786397519, 0.2823787915383149, 0.2558289812081266, 0.22387272496862398, 0.41250023843738104, 0.6410354690655732, 0.21518191362613615, 0.4054757028814576, 0.19947663509296776, 0.1773521140127412, 0.17748895175360846, 0.2835438241514676, 0.6846710971283567, 0.6257471489154223, 0.6488872544436302, 0.6307319241084881, 0.20013561231263843, 0.5655510711371764, 0.3917543363509225, 0.6302782722546203, 0.5475051480453323, 0.5850603850019607, 0.7425630753897743, 0.7169954323295595, 0.7626869507963066, 0.7091471031708723, 0.616412508708005, 0.7384684003593842, 0.8134731479413945, 0.7422494557472719, 0.23229996499652572, 0.2988921182870511, 0.20867317836071386, 0.18194940420258687, 0.2689137898899787, 0.4082720098513076, 0.21073982656490586, 0.18665777093011615, 0.30067461499761783, 0.36895611347607526, 0.44091664587251966, 0.471522053265672, 0.5248266881932218, 0.49033307643647595, 0.5059077724745717, 0.4927528468899752, 0.4933484729592569, 0.46269075843346685, 0.8207883191160488, 0.8197701299825291, 0.8164778223595432, 0.8206586450963018, 0.8328701441450982, 0.8304150728834282, 0.8348799772959614, 0.8263212789080638, 0.8399086461616475, 0.11495222019135165, 0.11739964113346013, 0.11196440802984475, 0.1116713458533104, 0.13327885586435262, 0.09249845485723474, 0.10596252670905282, 0.11450355487726316, 0.1258510923348618, 0.16195108785682455, 0.146262380729544, 0.13927832848396504, 0.12041576203357729, 0.12402033129009904, 0.24597012158238496, 0.15448565834197836, 0.11466913656697508, 0.4629815186815215, 0.4987025701049179, 0.6438914391772588, 0.6194835101057765, 0.6184261801456584, 0.6246825616640863, 0.609807461775978, 0.6753558046254069, 0.6453786269085531, 0.6393698625151827, 0.3809805516798449, 0.46841551621889754, 0.4361925515202423, 0.49827652658638555, 0.3964830800055633, 0.4113156551700424, 0.49671119209830994, 0.5287900275426418, 0.5492556612846502, 0.19517444252871385, 0.19776814530047848, 0.19585793517590278, 0.2019472731354517, 0.2038542008766523, 0.18767608120262225, 0.20320107804331078, 0.20289806146515676, 0.1904377955812634, 0.5646088866486247, 0.6059413160877823, 0.3575432144621775, 0.41483388855994485, 0.6112622715238972, 0.22352208332252066, 0.22942975948876554, 0.6700699597414024, 0.5311241445385424, 0.8186958124859571, 0.8624909538067591, 0.7761625259313124, 0.8632946178351486, 0.19248457043993872, 0.8462434439373585, 0.16668908500566326, 0.8627935383316123, 0.7900411277025146, 0.869145172298112, 0.8544993014940785, 0.20469400550291628, 0.8345064911265815, 0.7902198997553156, 0.7162558550227127, 0.846098957454229, 0.15545795133704288, 0.20430784191813356, 0.18341541647688797, 0.18986201335717212, 0.17856602555405265, 0.18570046817168506, 0.18645785763920353, 0.19007661863128889, 0.17945287441468194, 0.18021835752277515, 0.18382347119547326, 0.08248195357513655, 0.07278327486768899, 0.08788513072794246, 0.09564781497736052, 0.08798899978946506, 0.08705439496670098, 0.08360982032126518, 0.08145744686049783, 0.09375071300129767]}, "mutation_prompt": null}
{"id": "c1d91455-3895-4b22-9bf9-7e5f0f4e35b2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 10) == 0:  # Adjusted frequency of population reduction\n                self.pop_size = max(5, int(self.pop_size * 0.9))  # Adjusted population decay rate\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence speed by dynamically adjusting population size based on convergence progress and iteration decay.", "configspace": "", "generation": 75, "fitness": 0.4759076759914464, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8778988645267254, 0.8861615661967615, 0.8656414705456372, 0.8819223515833937, 0.8876997664845955, 0.874871487837595, 0.8680931618764192, 0.8778794725378006, 0.8729255961334119, 0.7925907707010045, 0.7918535930856111, 0.8005191386659609, 0.803497073384343, 0.8014312122350915, 0.8036334792016108, 0.7970509030830399, 0.7946333336441646, 0.7950445144092754, 0.5109075873216553, 0.5477033191156899, 0.16203747187014872, 0.1534285216827891, 0.5142133232141087, 0.27940888754951443, 0.1527976217439857, 0.14625182884824495, 0.34448502075754694, 0.15324216134856983, 0.13296417729055432, 0.14023545717063624, 0.13443571328657888, 0.13794400693937392, 0.11808933818950718, 0.39167298687552443, 0.1465890632253959, 0.1301689486456089, 0.8112100885388273, 0.7863884544168827, 0.8136315380062905, 0.7852555504414882, 0.8146662437289599, 0.8104334753338894, 0.7861930929848218, 0.7884659717875084, 0.8044866934104632, 0.6592673348381781, 0.6741959286106711, 0.6838433776579922, 0.7079912972882145, 0.7154125883053496, 0.7237797278028357, 0.7068143977344907, 0.6761530328166432, 0.7366087415390015, 0.806144851003569, 0.8415601246232458, 0.8153297600594703, 0.8631568113794645, 0.8415454572028244, 0.8480747683278322, 0.8691532121042242, 0.7555415209738857, 0.8581371815677177, 0.2878297689514038, 0.6642358160001791, 0.27871237207298116, 0.24572444386054482, 0.28073842000785465, 0.23358720150401846, 0.42780544141044696, 0.20448864794023114, 0.2153624310219513, 0.25365233747173344, 0.371714888236073, 0.6125336259824441, 0.4591279590764845, 0.31977787517143386, 0.39918853568324053, 0.39831624473518257, 0.6163692600001478, 0.3513262496207914, 0.5634348977590906, 0.6248748170819216, 0.6636284630523441, 0.6164961265887869, 0.4155374302114787, 0.15180326647521325, 0.6451553388828561, 0.5125588018048883, 0.6735860755359108, 0.46088282962337124, 0.7301934847177642, 0.7167865469832415, 0.6697845423986585, 0.7055373134058158, 0.5760584107480553, 0.7346191083746378, 0.7507671697682116, 0.7263578094151288, 0.14370949111926, 0.1565892258771222, 0.17002664447307492, 0.5294859439154299, 0.28400480709297304, 0.23309945812534538, 0.2336903706824659, 0.36553661544964067, 0.1901267567836057, 0.4538365572369607, 0.49745994661175275, 0.5479539641416463, 0.4869402069164551, 0.5565575872035836, 0.4416085521398857, 0.4969861652724554, 0.4396339735147444, 0.41419321878220394, 0.8124381329521614, 0.6854018758371595, 0.7946498283420304, 0.8225525436854803, 0.8130213249188077, 0.8071084671055336, 0.8280554906794726, 0.8106147231753293, 0.8083861033941082, 0.09853454678452744, 0.12574806965618557, 0.12090551442034081, 0.13497652497479318, 0.10234368081792833, 0.1172667706823537, 0.10273470699934029, 0.1098080145761533, 0.10778193475951026, 0.13800733871563375, 0.13448193202315473, 0.48732779277749605, 0.15029623825951766, 0.14784842526080466, 0.13173217161006212, 0.2011877666386842, 0.1377292279171335, 0.14945835973395638, 0.5040984212524947, 0.593596991159244, 0.5616908930401334, 0.5652101792545889, 0.5827757988825613, 0.44869987583978743, 0.5747345686852001, 0.610080330041513, 0.5419574213747846, 0.47559501583186303, 0.46919415575732815, 0.4341756677650591, 0.46102358445056846, 0.43615707598561804, 0.4296777337812161, 0.4572914843091751, 0.517571022651353, 0.46960031466214036, 0.19061190699314978, 0.18593871379336657, 0.1977877983855466, 0.22400735224246293, 0.18327939234214896, 0.19859018367461934, 0.22026415727350956, 0.20277228124045754, 0.20692464842592106, 0.22994120068225765, 0.2374552527540973, 0.22185099739389202, 0.4903550978197325, 0.6507338094051065, 0.6238220268704642, 0.1934210980301524, 0.6304527491842942, 0.5674515927533227, 0.8606486090680735, 0.849566221323328, 0.179247527849124, 0.865022717405636, 0.19380168004139553, 0.8505372310535215, 0.7904331282786269, 0.8578526433120743, 0.7634220267869165, 0.864938870390551, 0.8129732902708648, 0.20477636164033064, 0.7979077814348977, 0.7973174134868823, 0.20150931712524112, 0.8576699515180357, 0.155461591620921, 0.2038445275077324, 0.20780577207755357, 0.20926221951467827, 0.18040008533218876, 0.18456404513594993, 0.18645785763920353, 0.19007661863128889, 0.18144692552639918, 0.18434729333445543, 0.1873840013516549, 0.08922288928988709, 0.08338506247595145, 0.0867299045515838, 0.0914022362850716, 0.08552548405287053, 0.07897278633081495, 0.07810738255111593, 0.08360071025308113, 0.07788969841199]}, "mutation_prompt": null}
{"id": "e3f93e5b-4565-4161-93cc-15ad43dcd63b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.2 * (self.population[current_best_idx] - self.population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced trial vector generation by integrating weighted local-best and global-best strategies to improve convergence speed.", "configspace": "", "generation": 76, "fitness": 0.4460033441465484, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.874136070786521, 0.8631620545556793, 0.8512884997668674, 0.8720826312322092, 0.8748750458982091, 0.8782885044778256, 0.8882948507306035, 0.8763356208218359, 0.8731729693737508, 0.7832712968951145, 0.8055950651611197, 0.7865392764470308, 0.7916291452921362, 0.7850766815692662, 0.7670743052126132, 0.772989476148034, 0.7922296937509856, 0.766574670282621, 0.14155982481523222, 0.12085118017719865, 0.12268660667046993, 0.12637427705146587, 0.10874234373502567, 0.1327712699499649, 0.11895873270754287, 0.1168012089036653, 0.1246628535711094, 0.12657508236744053, 0.13104886168196572, 0.1306315186610606, 0.11340063737737294, 0.11854534345545342, 0.11124099059286197, 0.11078383043033246, 0.11694114905979991, 0.10484019146179957, 0.9573158996787942, 0.98356781520627, 0.9861110099625695, 0.9866886817806905, 0.9771225288547495, 0.9639222647035154, 0.9451708396177854, 0.9732195949070432, 0.9826441350880325, 0.6759497915465411, 0.7290892396857227, 0.6876396436164498, 0.7228002494316481, 0.7247264784985334, 0.6897830567055306, 0.7240153426001823, 0.7045698107175042, 0.08610968208668113, 0.8448533704946742, 0.8344075191182436, 0.7991305287468602, 0.8434505104355402, 0.8172611637601552, 0.8161613598089468, 0.7887390517482777, 0.8504610359284882, 0.8120369833126294, 0.6622770695751992, 0.6100114992744882, 0.6555630393805392, 0.5110571164956477, 0.4710760223049266, 0.5856697466807752, 0.623853937736357, 0.6936072262246891, 0.4987076437617176, 0.05029146694224551, 0.02220737955477947, 0.45123561791466893, 0.6366393664141506, 0.718383509068808, 0.561904546388581, 0.38890898053503264, 0.5584313300224191, 0.5243178323455677, 0.6802998882920721, 0.6601318837563186, 0.6200784354870463, 0.6233261084722184, 0.6125809845421548, 0.5906343040839854, 0.6359916307357374, 0.6216681061843675, 0.645266046196671, 0.6993354908006287, 0.6168316735102785, 0.6993120153345738, 0.7080502888703033, 0.6962637446773315, 0.3573870524558882, 0.7142098871635816, 0.7329837763662284, 0.7023641288347592, 0.34731252511312505, 0.18155335048345567, 0.1909516689989691, 0.16773744938677027, 0.19312116058649254, 0.33345903445215674, 0.14400604116844806, 0.13744698940522682, 0.21799792322804457, 0.3796728965236522, 0.5280362734038822, 0.5324235927674507, 0.5101554913719164, 0.54177078505357, 0.5583586327866519, 0.5267600721118761, 0.44054732305476785, 0.5523902644168885, 0.8291282724267404, 0.8318012498659474, 0.8311924553120844, 0.8026815688629207, 0.8124062690863566, 0.8006424887958099, 0.8072308793322469, 0.8242614553585602, 0.77991407896341, 0.11877107723355274, 0.09639376477290462, 0.104979193199351, 0.0976913228195756, 0.1093980889394166, 0.10076123363092993, 0.10130567439774096, 0.10824951371738245, 0.0992541488911931, 0.14101828037444541, 0.13644422158760972, 0.31001478522209847, 0.17302337075642404, 0.13613806147168184, 0.19241309491542935, 0.13198269417119335, 0.1358113492541645, 0.14149327924177102, 0.5275575378590381, 0.535947241673979, 0.49685206792357584, 0.5689279504618121, 0.5499300038971262, 0.5495908021092322, 0.587711565052444, 0.6603194859052842, 0.5493828236895664, 0.397196919954827, 0.37987104827655727, 0.37724145415468135, 0.20199488246233754, 0.41915495128249114, 0.3544850771339636, 0.4612945494442323, 0.4395821422888221, 0.4263036384607972, 0.19468843332641195, 0.18028357893584313, 0.27371608389011504, 0.17913289720124081, 0.24338516328303972, 0.19699690574968265, 0.18413737563329946, 0.19853278998196777, 0.20988547605551355, 0.22187526603545227, 0.20089435600346206, 0.2071750799541885, 0.20265830158408926, 0.1803482391531419, 0.19003971425420985, 0.2266622346654794, 0.22108367727493672, 0.3423141919904472, 0.8124814084929632, 0.16282829282417244, 0.17065839857108023, 0.16237366250955199, 0.19984057694787993, 0.18420798706932295, 0.16881684097099992, 0.6950533856824568, 0.8436859284820317, 0.16492734307757018, 0.16707957623677505, 0.22995388864478405, 0.20626442047225657, 0.5348658835745432, 0.208253780085344, 0.21188941380930115, 0.21170117275550515, 0.15414674474421242, 0.2034287347115762, 0.20579047292455754, 0.1877779352785871, 0.18639895506177295, 0.18547574573502645, 0.18596577943269754, 0.19150896737733902, 0.17660396945543433, 0.19278387285184528, 0.08655705964113791, 0.08833267079061558, 0.06939666870697347, 0.07289174011752275, 0.08472523849021385, 0.07710750997729388, 0.09056471303360647, 0.08252864134862248, 0.07675957635232733]}, "mutation_prompt": null}
{"id": "3d4dc1c1-0314-4159-928a-ba5202aa0da8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        gen_counter = 0\n\n        best_solution = None\n        best_fitness = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c)\n                mutant = np.where(mutant < self.lb, self.lb + (self.lb - mutant) % 10, mutant)\n                mutant = np.where(mutant > self.ub, self.ub - (mutant - self.ub) % 10, mutant)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            fitness_variance = np.var(self.population_fitness)\n            if fitness_variance < 0.01 and self.pop_size > 15:\n                self.pop_size = int(self.pop_size * 0.95)\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            gen_counter += 1\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic population resizing strategy based on fitness variance to enhance convergence speed.", "configspace": "", "generation": 77, "fitness": 0.44364081716293036, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8933212061110807, 0.8933642644907318, 0.8836503066847392, 0.9018637398148075, 0.9101734477518528, 0.8960861720092403, 0.8867465442905127, 0.9014181255163864, 0.8988493306480482, 0.7982173580288977, 0.8054234196319765, 0.8143243905354384, 0.8047267155857123, 0.8129642872431224, 0.811764671883275, 0.8133653326526727, 0.8217945951026421, 0.8092487208656811, 0.2960686879192391, 0.31606488217346573, 0.2942203265539194, 0.2809311628682841, 0.1571614083013253, 0.37549857265564, 0.22243961003603085, 0.4243928364636812, 0.4881047115962657, 0.16170535957749255, 0.13916614404686212, 0.11874109186330173, 0.15012217985157716, 0.1325633741593889, 0.12509248833609177, 0.12882852424027025, 0.1942782797684941, 0.13013536645791723, 0.8273272454160533, 0.8178501864063366, 0.8471315747381871, 0.8237498015119992, 0.8460744311919892, 0.8360300768728469, 0.8247415413465542, 0.8364820756905229, 0.8396309765957086, 0.6367948575858099, 0.664217899817229, 0.6373374483677297, 0.37172494611543405, 0.5885005645909998, 0.7557429396309613, 0.48876553834764824, 0.6678530682626882, 0.7376593316435407, 0.8360841259880907, 0.7769357651948217, 0.8162882829916598, 0.869866593022631, 0.833880877383308, 0.8292830189575753, 0.8631294532828718, 0.8060312650779654, 0.8696288654520049, 0.2629967118587495, 0.28560588829078326, 0.22348611768941862, 0.3569346613442126, 0.2394454230777756, 0.497662239638881, 0.2918528451658442, 0.26057847759379815, 0.22592735376650586, 0.19618526918753365, 0.21264589632640085, 0.19196210405488445, 0.3210920530711756, 0.3128351428846756, 0.1727150852992554, 0.235933702060941, 0.20421196502996364, 0.2604429205613553, 0.6509294067520908, 0.5521929686475231, 0.5346470411138271, 0.42416252045233704, 0.2542096062061602, 0.34781845162206093, 0.4763827047677748, 0.4212075722559071, 0.4461914915089331, 0.5622732336309202, 0.6010287909724601, 0.5426013063477592, 0.5867425745921733, 0.46959445975947456, 0.3890836580041901, 0.582605654763126, 0.5403412849818855, 0.5992451706982604, 0.07301083772218009, 0.1439081043725169, 0.2519487928440214, 0.53650788642839, 0.1924132475158401, 0.24341686822146835, 0.21543217925302116, 0.19245398796849644, 0.20892596302652933, 0.4705245821001759, 0.413168114549045, 0.3952562782607866, 0.4166949941266205, 0.38850766636052214, 0.36807037746975113, 0.40104880166316237, 0.3961800012868324, 0.3437499963548303, 0.6124917201566391, 0.5411962665740561, 0.7167777310998512, 0.5869173010041242, 0.6803143528385887, 0.7102671598137891, 0.7752791511153754, 0.7596792873526245, 0.6027933904844913, 0.11585706857356692, 0.12423251249675649, 0.10673551481814558, 0.1064222385948893, 0.1078190777406397, 0.09320900694745782, 0.107219500463831, 0.09799358600754493, 0.10746341141581783, 0.15731182579604797, 0.17048774257111932, 0.15782819618889266, 0.12251242654565808, 0.1459644064413398, 0.14072610860467316, 0.16488637606474055, 0.15058048942592472, 0.15037194049888292, 0.5051140225467501, 0.7066836163955826, 0.7050497360925898, 0.5754481683811181, 0.6277900791162634, 0.6810164928402151, 0.5106518551364001, 0.7355773831547494, 0.546427490625595, 0.5200583329357794, 0.3783681917627396, 0.3924138569401039, 0.4010447306484909, 0.4806957392666743, 0.37942370102909395, 0.4113590212255315, 0.4937907813351454, 0.42344369060721343, 0.19568199486993365, 0.1964562062161772, 0.20963776325142836, 0.2044817333614325, 0.19549940359314133, 0.18549020892869816, 0.1994757687360218, 0.1910467852328933, 0.2499037450699504, 0.6143124749284701, 0.357075665208173, 0.43725505582924684, 0.42458870308820906, 0.6092282443912489, 0.5200386327284374, 0.22917195527287781, 0.33776508189981946, 0.540851849855407, 0.8064919370123887, 0.846451679898845, 0.17709236470274448, 0.8614685990832285, 0.1933252976116976, 0.8522527877937156, 0.16659512133073262, 0.8670015396602614, 0.8035916021515848, 0.8782251859524803, 0.8397589024726335, 0.20476071828878029, 0.8258256723910499, 0.661320871639989, 0.19969991647612984, 0.7421373879254933, 0.15545686193905262, 0.204327991852722, 0.189339211082315, 0.19557085463538448, 0.1883890021595953, 0.18562568355281184, 0.1869569174693927, 0.1928596411876078, 0.19283074213734086, 0.18154661000636374, 0.19857102055998677, 0.07849303583432388, 0.07728021933357032, 0.08218432937244546, 0.08113658965925497, 0.08141699829852367, 0.0880204567771008, 0.07496455151633641, 0.07653350470446707, 0.07670592788310437]}, "mutation_prompt": null}
{"id": "31395251-01f3-44c5-a008-b21181be2838", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)  # Perturb using best_solution\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by utilizing a weighted average of the best individual to improve convergence.", "configspace": "", "generation": 78, "fitness": 0.4913017685181471, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "fb110d85-3b43-4281-b8e3-be75e7214bcc", "metadata": {"aucs": [0.8946967510466002, 0.8955258904902207, 0.8860672859978587, 0.8970249838023492, 0.8790248335276685, 0.9001605597348178, 0.8983785624912013, 0.9026044915782061, 0.8806190594373595, 0.82555166157387, 0.8343436402456585, 0.8145575063255889, 0.8027340516635856, 0.8321044439109614, 0.8180062086370709, 0.8238122902522163, 0.8159527910348893, 0.8212550389379883, 0.4165753216218112, 0.4473071177334388, 0.44794321772014756, 0.3203404657292104, 0.14993263522661404, 0.1331920475351751, 0.4293700874379197, 0.6700232776599881, 0.6653582572998196, 0.10616999017046258, 0.3658601520980921, 0.14013475136543496, 0.1290303680838666, 0.12404643883644917, 0.14026361657518904, 0.13207194302341196, 0.1522753116133001, 0.16254728240684158, 0.9359091410942906, 0.9655693849461198, 0.9778008199700204, 0.9767713735205241, 0.9682861005053086, 0.961688534556605, 0.9701116104245756, 0.9624702565377744, 0.948161334855338, 0.7720715199762571, 0.7277411875861892, 0.7546244263099791, 0.7575615851279751, 0.7431422433545014, 0.6794813108164459, 0.7462127045094843, 0.6520593731581723, 0.08733735418998889, 0.9153532676375763, 0.8548982571702828, 0.8370503541804707, 0.8933013687229743, 0.8671988009673971, 0.8503499897283076, 0.8665712111688602, 0.8764360559918218, 0.85659672569355, 0.26483131321086006, 0.29150891507664634, 0.18263403557019886, 0.19107142236943842, 0.19166782456621512, 0.6046364781715924, 0.20013640952243483, 0.25966625521379416, 0.20809045913466284, 0.6085852786508466, 0.2856555892326894, 0.5688059120245448, 0.16615636715319415, 0.20600814555506042, 0.1900212580084918, 0.2967938107156056, 0.23191631622596842, 0.1886964605572925, 0.7215924481831701, 0.7163897422532887, 0.6817682457900043, 0.7342580847110689, 0.691194644291447, 0.20580928663992315, 0.7399206222837897, 0.6106659323493254, 0.6844066620864055, 0.7274177739057724, 0.3666908682826985, 0.707080087336309, 0.7613127011730708, 0.7475112704901976, 0.7185500856800462, 0.7867299677857871, 0.7973892992447009, 0.7688124795395266, 0.20938797937806697, 0.12608202151702075, 0.11031288305296127, 0.3889352749379259, 0.31568112372761714, 0.35552366653857137, 0.20141730931053858, 0.23084349012453997, 0.21294049170851725, 0.32887844112299236, 0.35256479058999735, 0.5727964483745185, 0.48625631393406343, 0.4630058471688663, 0.563421663228479, 0.5214205694528877, 0.5936719424598419, 0.402652259327947, 0.8405128599417874, 0.8466725699174922, 0.8371550730271389, 0.8547291179205031, 0.7593376300981896, 0.6734815718534874, 0.8274153071708055, 0.8239068689774971, 0.6505315531025924, 0.12503350088246112, 0.09638752306364728, 0.24072634468061183, 0.1084555499130021, 0.11829741796650728, 0.09931495194949946, 0.16785962321378067, 0.10718098102682072, 0.11087003485904767, 0.13135289064885258, 0.17325193216546486, 0.5967243685293924, 0.13881622961777118, 0.16252897600482086, 0.18265421518960334, 0.15917360737074837, 0.2319930666726404, 0.15464125134376505, 0.6650859990295386, 0.6260313511197816, 0.6304010749562423, 0.6587907450333385, 0.5529386776695222, 0.6713356831869228, 0.6608119612749367, 0.6068378704922179, 0.7153327667653002, 0.42588948454909437, 0.5181951501792539, 0.4768368142878099, 0.4467324864544071, 0.4882652639513788, 0.4921025566059981, 0.555724697881929, 0.5656030829632696, 0.5648239774121011, 0.20006247978708502, 0.19549058913489314, 0.1877201945661522, 0.1988167350530774, 0.20382639531096813, 0.20226246472295262, 0.1969759730993731, 0.22672350658615037, 0.197444518309851, 0.6228079504334046, 0.6354004364248823, 0.3983327086871067, 0.7497391322236215, 0.661810822875303, 0.6272695222878424, 0.21149868280268036, 0.5791922947612808, 0.22275586899799127, 0.17983741711037438, 0.8731831141919725, 0.1523534971960092, 0.8560070666123426, 0.19466385994809343, 0.8588584060472719, 0.8488590266092267, 0.16244665739568553, 0.8959768639331486, 0.8695929319614175, 0.8315099852494476, 0.827826780116307, 0.20817386679426786, 0.1689557288998873, 0.782476629761876, 0.21132726962556458, 0.21055488328043237, 0.8363181797263189, 0.1700292054086403, 0.1782482775793578, 0.19175713117051452, 0.19250105599600875, 0.17593112005103828, 0.17159768792195695, 0.18336941099196513, 0.21517752352784447, 0.17793805818085817, 0.08526355201117242, 0.08242813213837996, 0.08171845901695818, 0.07454118821838018, 0.08299656552295853, 0.07676480652140638, 0.08621261791539814, 0.08653714992077, 0.08057936191343107]}, "mutation_prompt": null}
{"id": "f9735d5d-8fc1-4bf8-93dc-f44fb44aa5fd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            dynamic_pop_size = max(5, int(self.pop_size * (1.2 - 0.2 * (self.evaluations / self.budget))))\n            for i in range(dynamic_pop_size):\n                idxs = [idx for idx in range(dynamic_pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic adjustment of the population size based on the current evaluation progress for improved convergence speed.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 26 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 26 is out of bounds for axis 0 with size 25')", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {}, "mutation_prompt": null}
{"id": "e658b0ca-098b-4609-ade6-0e9f03093e63", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.elite_fraction = 0.1  # Introducing elite population fraction\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            elite_threshold = int(self.pop_size * self.elite_fraction)\n            elite_population = self.population[np.argsort(self.population_fitness)[:elite_threshold]]\n            \n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = elite_population[np.random.choice(elite_threshold, 3, replace=False)]\n                dynamic_F = self.F * (0.85 + 0.15 * (1 - (self.evaluations / self.budget)))  # More adaptive scaling factor\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introducing an elite population mechanism and adaptive scaling factor to enhance convergence speed.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {}, "mutation_prompt": null}
{"id": "8670082d-d540-4ae4-b90f-1d51f713a5cc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_rates = np.zeros(self.pop_size)  # Track success rates\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n                    self.success_rates[i] += 1  # Increment success rate\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            success_weight = np.sum(self.success_rates) / self.pop_size\n            self.CR = 0.6 + 0.4 * np.random.rand() * success_weight  # Adjusted by success rate\n            self.F = 0.6 + 0.2 * np.random.rand() * success_weight\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n                self.success_rates = self.success_rates[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce memory-based guidance by adapting exploration parameters based on historical success rates to enhance convergence speed.", "configspace": "", "generation": 81, "fitness": 0.3363562511662624, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.6248387321434525, 0.6642019889453056, 0.6205886774143667, 0.6827472432966901, 0.6193593191689895, 0.681849367516108, 0.6403437244170891, 0.6250971848882247, 0.6177901321659295, 0.2798223021118139, 0.30166537564563667, 0.3051951623786232, 0.3586703040434751, 0.3699945267020548, 0.35030199265506234, 0.3319135393525664, 0.2745003562570758, 0.3366717334958834, 0.08270070957837639, 0.11281764073165146, 0.19345796926326275, 0.12135646917862819, 0.10026452423940568, 0.12368592802248535, 0.09117345446236413, 0.09558881723412271, 0.09001987546581947, 0.08504761319317367, 0.10577369964764238, 0.09538672781786595, 0.09117829669952149, 0.0961132360550655, 0.08320500250420992, 0.08740542788399741, 0.08470409947357127, 0.0808868843780961, 0.9242619393793667, 0.948851300248476, 0.9882272903958249, 0.961333306353911, 0.9858571663500797, 0.9050089627248238, 0.9637860404573729, 0.9726923446327311, 0.9688662518813614, 0.3396566109329875, 0.30500241388681415, 0.3392129771973674, 0.329326771272479, 0.35889440548223617, 0.3678659182085299, 0.36208906016031306, 0.34514462055163975, 0.3288145457239142, 0.7254845416186524, 0.8687869925555489, 0.6535098414331698, 0.8140074093842636, 0.7153389267514962, 0.6527917202963803, 0.7483191043832259, 0.6287896326535153, 0.636396574535509, 0.28808345962229753, 0.379743393445065, 0.20668580875918185, 0.26619290186259315, 0.32663438554668456, 0.34506911782456773, 0.33903499071183973, 0.31674656791771216, 0.3369500112983459, 0.00980285763307076, 0.30885900328961713, 0.25554969698276153, 0.3819861928040167, 0.26872568781917305, 0.17403622087603599, 0.3309834001098074, 0.2691120258962837, 0.2466421145449359, 0.24634775450379887, 0.34347094424799973, 0.28541552334962206, 0.29387612228403936, 0.2823423841568261, 0.33872322945080546, 0.35927220807382654, 0.2673130197382153, 0.25917364801418075, 0.44715444818029715, 0.5149814018973001, 0.3938084218896982, 0.5023569004648692, 0.45198836141766363, 0.4981281707645363, 0.4550949121237511, 0.4537646560091313, 0.3852003337862109, 0.06626635555342342, 0.06497769537500753, 0.11099359496088113, 0.07141446085731118, 0.12247092085956279, 0.1132831810766125, 0.12507196319070568, 0.09423420057117637, 0.14680247340547448, 0.2365809546221499, 0.22748089727767395, 0.2172901171870527, 0.22492797566566625, 0.22698146586598, 0.24351952009028732, 0.23962430766032272, 0.24544615126758096, 0.21576647593472775, 0.557340821644704, 0.5459971182805072, 0.5682932984948308, 0.5969352647802467, 0.5453856124589802, 0.555614004189414, 0.5317678466471231, 0.584839162657338, 0.5564385307885988, 0.11806452982288096, 0.09865142255996417, 0.09572179201190156, 0.08619048432794885, 0.11538747395370608, 0.1266930187652484, 0.11287277614270952, 0.09008046839044959, 0.0840626446218059, 0.17041913961560273, 0.12493376454713945, 0.13494705124605522, 0.3177417396463844, 0.2739607635280009, 0.21998229964459226, 0.18407486160034825, 0.1598892055282356, 0.17119557099473548, 0.3565310448288945, 0.32235143486324, 0.3469117938940832, 0.3164465941373602, 0.35154584621380724, 0.30390335613693464, 0.32969938026578194, 0.3177051205784728, 0.30709725861153847, 0.2748067818986626, 0.2557317544506811, 0.2833589134439014, 0.27052927677698824, 0.24776313049844312, 0.26910818175041507, 0.2715969934644239, 0.2898825393912977, 0.24827166192325467, 0.20168319266004586, 0.169903952380269, 0.18165831686907818, 0.18316312013644798, 0.20388397971808947, 0.18963674240720496, 0.19821799412049756, 0.24329472507668126, 0.21685080080680907, 0.2099112282236082, 0.22378522866903694, 0.1723857422126619, 0.2495197205556362, 0.20992761939357407, 0.20937842477220936, 0.29931678184665156, 0.18171419718763693, 0.2040037641138175, 0.16257830741040724, 0.8035421773453243, 0.78199255203196, 0.18396202804243467, 0.1911356123041228, 0.7624698474123568, 0.8063562184360527, 0.20021974776626172, 0.7750522883559923, 0.7850815164491594, 0.7360892772559583, 0.8140953837458864, 0.7918306704902861, 0.19350451460831486, 0.8271688882376982, 0.7860134455969637, 0.20823213301479393, 0.1521195479445483, 0.18682059750463165, 0.1989030313332012, 0.1874608275773363, 0.18438820714035797, 0.1647582321819182, 0.23351467418837546, 0.1747387365019637, 0.17501525336341206, 0.2064763919534537, 0.0691273948922082, 0.07312929952122271, 0.07682748711554199, 0.07441577000907051, 0.074434604255595, 0.07799460393637603, 0.07285064014029963, 0.07064262208647631, 0.08403276399717374]}, "mutation_prompt": null}
{"id": "4683b8cf-1b26-4125-a4d5-a985da8d97b3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            decay_factor = 1 - (self.evaluations / self.budget) * 0.1  # Introduce decay factor\n\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85 * decay_factor))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by introducing a decay factor to dynamically adjust the population size, ensuring diversity and faster local exploration.", "configspace": "", "generation": 82, "fitness": 0.46817757338955013, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8958107814062618, 0.8969226747813728, 0.8915752418891281, 0.8980840497622055, 0.878514017331396, 0.8983376020135978, 0.8939448783515621, 0.9038620626781687, 0.8831891311421801, 0.8151023052434515, 0.8301516871908385, 0.8146077342935583, 0.8125736964382481, 0.8282579248773694, 0.8164708614494876, 0.8255046115396101, 0.8293011293302985, 0.8214318293400767, 0.15351491720157295, 0.16466709948304792, 0.15005371299628645, 0.16236420686942388, 0.35343120494576574, 0.5647079985975414, 0.16850097815643117, 0.5291232444197176, 0.16330574099165096, 0.13252489765520237, 0.12261014152369276, 0.1296603507766051, 0.15310394148521023, 0.14150970226676873, 0.13441002850056794, 0.14985535056496102, 0.13327765667057867, 0.11575735272535981, 0.9359091410942906, 0.9655693849461198, 0.9778008199700204, 0.9767713735205241, 0.9682861005053086, 0.961688534556605, 0.9701116104245756, 0.9624702565377744, 0.948161334855338, 0.7725403384667686, 0.5974789332299162, 0.7573454581147179, 0.7781824251489892, 0.7301563129573746, 0.7691578837437087, 0.7473311482447186, 0.6520660436167296, 0.08733747587762664, 0.9153532676375763, 0.8648454589905206, 0.8616131242683838, 0.8805370939134521, 0.877165103458794, 0.8444145359914661, 0.8776263572100962, 0.8706677472859206, 0.86700636657506, 0.1276593461066694, 0.191141982354612, 0.20620726884672436, 0.15818517078148853, 0.20622882288977884, 0.322338713553719, 0.2145073422318129, 0.1971346610793676, 0.24602217745231214, 0.4683593264054884, 0.27978908747241527, 0.24233268978189315, 0.1691217523372328, 0.20583327279734753, 0.2805397610723166, 0.6494697006043881, 0.26332095938755407, 0.22277499990333527, 0.1966186939196698, 0.5984856533432693, 0.31541367932836606, 0.7279127849822429, 0.7171208205142954, 0.16139810608173044, 0.6893172687455091, 0.685618467271315, 0.5823824337238843, 0.7212124456354929, 0.439337581256382, 0.6924476033676072, 0.7875158272907131, 0.3201372305919784, 0.7147377365463075, 0.5112044666040785, 0.8046807399173889, 0.7557671832515778, 0.2571633127725006, 0.18823606554884764, 0.16474763749114374, 0.23409193441405574, 0.16075214296983065, 0.27835342614619474, 0.14725890939279995, 0.3428938770125869, 0.30209264063925023, 0.4556725546131475, 0.4321129977093291, 0.4057192686833996, 0.4561744212219089, 0.44201863577887757, 0.5145666813130461, 0.5498994480479709, 0.46131305806454925, 0.45751408783857384, 0.8420254968431401, 0.8471933161727776, 0.762904668892192, 0.8549064394730397, 0.8199338627644581, 0.6903265303169674, 0.6139283671035811, 0.8306725172669087, 0.7010316402861991, 0.28896309272817255, 0.10712060275103463, 0.3692471422756616, 0.10352237961458921, 0.11235658038648488, 0.1406186645369899, 0.10044591480472886, 0.12436223321000217, 0.12907406943349908, 0.15303558343707901, 0.23360880404545337, 0.14597947504227593, 0.1367166242896648, 0.19388987722547257, 0.2091765472019529, 0.16429495686275675, 0.18841292534838172, 0.14313834758554222, 0.6879245859628027, 0.5642744707428733, 0.6780381782773985, 0.7187839781658226, 0.6604456541338821, 0.57646838966146, 0.7097990179704834, 0.7206938058096342, 0.6060035419012281, 0.40738726685979143, 0.4386108551008575, 0.3392349015310787, 0.4151884425568779, 0.4634264576304197, 0.3891288307294273, 0.4864452091551934, 0.4483869224574806, 0.5821663455545464, 0.19484655305586085, 0.22216590853948137, 0.19003168140449644, 0.20430142700792953, 0.19898429400509965, 0.19661366039860007, 0.19261515400705276, 0.21753373800646592, 0.19469596963196578, 0.6962534812784069, 0.5175337882748952, 0.4186391322257368, 0.7475895406101629, 0.7211305263715857, 0.40789341737691365, 0.6138557471064318, 0.6914332415580879, 0.22650839985544957, 0.18011962325483277, 0.8750121399354457, 0.15235312737671558, 0.8570121685361771, 0.1947623498718306, 0.8605488836577114, 0.8559158239762595, 0.1604481494603981, 0.889150211769686, 0.8604405844760565, 0.6543521348880439, 0.7927727091166071, 0.20817746440633156, 0.16895580053606285, 0.16304478288684565, 0.21132724394424862, 0.21055186280539795, 0.8405059454652725, 0.1834008917289326, 0.18962847436782926, 0.19175713117051452, 0.19498284048609704, 0.1846380777810972, 0.1849734607736937, 0.178563311857306, 0.19603026002250956, 0.18416751620628236, 0.09387979786117817, 0.08193684329645745, 0.07905500634443818, 0.0807216607935145, 0.08213880430983189, 0.08614635376708124, 0.0865083118227079, 0.08030925620289653, 0.08367643905178557]}, "mutation_prompt": null}
{"id": "df2d0c73-7a31-441d-b312-b2137cab200e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Increased initial population size\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.15 * (best_solution - a)  # Enhanced perturbation\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 6) == 0:  # More frequent resizing\n                self.pop_size = max(5, int(self.pop_size * 0.80))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population resizing and enhanced mutation strategies for improved convergence speed.", "configspace": "", "generation": 83, "fitness": 0.47930148095186764, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8802764325644606, 0.8653757781572836, 0.8795876002943169, 0.8924001473360663, 0.8681366006825432, 0.8825255271667765, 0.8727669065181823, 0.8832556842224543, 0.8783805280147005, 0.7754746445353816, 0.7895145794734283, 0.784393224165314, 0.7797727833972607, 0.783242278935223, 0.7963587182390692, 0.7916307103076902, 0.801517465486137, 0.7891612380312854, 0.2916234542056604, 0.36000162880203423, 0.13181949388364667, 0.3240769242281727, 0.15958271132959168, 0.14299768269175106, 0.3585525768107408, 0.3178154604185218, 0.14556720353790265, 0.13734713266806942, 0.11711199409821038, 0.12183618522900763, 0.27555438107852404, 0.13382590910869352, 0.13265878325034686, 0.14186148708206892, 0.11288126932051801, 0.12341994245942678, 0.9802059519421829, 0.9543948431896491, 0.9606417261153924, 0.9167123769329382, 0.9625925730652485, 0.947206116749419, 0.9507697405993047, 0.9710386869432859, 0.9518341542122871, 0.698911948451084, 0.6884334806605532, 0.6646447912844843, 0.7185710248640924, 0.6524046386868562, 0.677592475987391, 0.6907546458861082, 0.715480457548471, 0.6802496319255507, 0.870332101006901, 0.8159210226427985, 0.8167571518810967, 0.8470161001631228, 0.854869422347359, 0.852013579174563, 0.8626874323405325, 0.8410459414376366, 0.8316334057909442, 0.3323987849054689, 0.18367934457149648, 0.32213936605348503, 0.41222033125856683, 0.3450392557729366, 0.2302761187511705, 0.5939690027544382, 0.22720871949929844, 0.6636238714736915, 0.49134756723799833, 0.3599617545671414, 0.6135649246005892, 0.4329752613824983, 0.6486629296717696, 0.27180715515115494, 0.258265167981756, 0.2534044356999362, 0.2486791189695282, 0.655577794087483, 0.5171238398820168, 0.607829744269762, 0.6681164325497408, 0.629361339489993, 0.6537896208564309, 0.6181932227558938, 0.6387833101693344, 0.6279094494830816, 0.7027770175636583, 0.7226215841248904, 0.7376190216609393, 0.6894847701336236, 0.707583281243384, 0.7010603258903699, 0.7373851998194044, 0.7201951709100627, 0.7309140597836052, 0.25814027710832566, 0.10190702203598045, 0.1880823867053012, 0.17773968528068107, 0.5632887627735585, 0.5341664605499813, 0.1785929415413119, 0.11159861541342875, 0.19243756560157954, 0.5103467729510195, 0.5343745643200928, 0.49439763841273776, 0.5213637249486403, 0.5318495107044965, 0.5403265262749645, 0.4557880418191296, 0.5242530563338147, 0.5375326934662003, 0.7969259256146557, 0.8143037576126597, 0.8014413833317743, 0.8157795036361898, 0.8194406236068457, 0.8087047071198572, 0.8267385566192262, 0.8218725009789695, 0.818193119923991, 0.11320123109919566, 0.09899572641451382, 0.1124758732106369, 0.09664233717647586, 0.11587068593044259, 0.1029787241849004, 0.09508828708132389, 0.11513623391084238, 0.09171848670286853, 0.1742931204535918, 0.13537615179623064, 0.16406767897653374, 0.1580756964164156, 0.1538245828823689, 0.14889548193682822, 0.12713081771176626, 0.18057432237828852, 0.1271055376141198, 0.5665896064113463, 0.5439782752787146, 0.611490166035988, 0.5870652714000347, 0.6160302728264984, 0.5861644921225946, 0.6124509887484735, 0.6229109209949253, 0.6796923137112868, 0.41976356445531726, 0.47387615127817395, 0.4657648262237951, 0.4559248215629337, 0.4496909974913522, 0.4135123137776511, 0.4489068776300491, 0.4984374590123851, 0.5202845682242783, 0.18915592897796552, 0.2049167457152915, 0.20348018048433691, 0.19490054097769305, 0.19604706340975575, 0.18656004857735176, 0.2389183815513507, 0.19007687585724642, 0.19447460632214375, 0.6033714879064298, 0.21881330042263758, 0.3145124728117171, 0.6559409125119022, 0.21885757909132186, 0.4006068286458023, 0.4243558488794199, 0.5166802085857193, 0.3815530438446919, 0.860504702795682, 0.811410155071387, 0.16261189059787684, 0.1785934010541569, 0.18510065479766802, 0.7949607579840358, 0.8105467276566003, 0.7782485598805035, 0.7627459961273688, 0.7820253562671886, 0.1667175465505054, 0.20174258766842745, 0.8147545827199951, 0.791577650868999, 0.754468835961246, 0.20964925907826149, 0.211604425343906, 0.20995539648145223, 0.19612875169413213, 0.20143978700812626, 0.17607332490504446, 0.2035365281797239, 0.17650765803628332, 0.19345315820170594, 0.21647439121167245, 0.17023848987111156, 0.17106396631565224, 0.08315038531106733, 0.08520967032496041, 0.0865599863455695, 0.0760193444582119, 0.09129085909552592, 0.1055559784760084, 0.09318811956270201, 0.08813492512418564, 0.07851404771882642]}, "mutation_prompt": null}
{"id": "f1a04dc6-ecf4-4fdd-8797-e33b7bc13545", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Increased initial population size\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.5 + 0.5 * (1 - (self.evaluations / self.budget)))  # Reduce scaling factor over time\n                mutant = a + dynamic_F * (b - c) + 0.05 * (best_solution - a)  # Less perturbation from the best_solution\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:  # Elitist approach\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            if self.evaluations % (self.budget // 6) == 0:  # More frequent population adjustments\n                self.pop_size = max(5, int(self.pop_size * 0.8))\n                sorted_indices = np.argsort(self.population_fitness)\n                self.population = self.population[sorted_indices][:self.pop_size]\n                self.population_fitness = self.population_fitness[sorted_indices][:self.pop_size]\n\n            self.CR = 0.5 + 0.3 * np.random.rand()  # More exploration-oriented crossover rate\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adjust F randomly in a narrower range\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm utilizing an elitist strategy and dynamic population management for swift convergence. ", "configspace": "", "generation": 84, "fitness": 0.3863596466284715, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.865703676503506, 0.8630227617875836, 0.8800082223585546, 0.8642734077250167, 0.8688933701091915, 0.8599241261170949, 0.8556045317891507, 0.8651549727623271, 0.8610373526237667, 0.7709307923067128, 0.7585662807630298, 0.7558846438229089, 0.7648049569241208, 0.7729588385434802, 0.768731263595162, 0.7636771575546255, 0.7599533997436287, 0.765855920668838, 0.4929596761359165, 0.48122718129944064, 0.39104521058054775, 0.4008124176170874, 0.5463143682130212, 0.4648511962415295, 0.15753938100749842, 0.45565388370319737, 0.5061497589557876, 0.14024647515287292, 0.133272809747087, 0.16253294245944494, 0.15683426552886415, 0.3639788948565055, 0.16281130768222196, 0.1631698623373946, 0.12707714645186174, 0.14026895311883947, 0.9650147188879998, 0.9494622813626399, 0.965963904501435, 0.9466699409743394, 0.9662299568500442, 0.9824887910375768, 0.9482223102420804, 0.9533927110875676, 0.9564684136248787, 0.6064571295623238, 0.6270371878524238, 0.5378082344126354, 0.5604638447616995, 0.6391273264463957, 0.5943762914420967, 0.6453463511389324, 0.5894856213898548, 0.6187479671146292, 0.7228767209151399, 0.7220931967001181, 0.7183341289073111, 0.7619825327092553, 0.8095218599919483, 0.7362150326976944, 0.7789261665406231, 0.7492532754297258, 0.8072256556067002, 0.20012883016003102, 0.40342323131505087, 0.24776869881103958, 0.26002627720836247, 0.18782657047001305, 0.1753842155517814, 0.28516528553188514, 0.18908933121234628, 0.23734421414605944, 0.17322853885948208, 0.177218143488026, 0.1928922741163478, 0.22349850324292142, 0.18015114517904718, 0.26154049623894615, 0.20594504004766967, 0.1678965524472793, 0.1966536828467229, 0.2051904131131681, 0.21214135648082966, 0.21083231241580902, 0.16095580905758378, 0.14404984883726268, 0.18499217997701012, 0.14621977470759995, 0.15614910977909036, 0.06392977251742049, 0.2557269569910633, 0.3372174034993606, 0.30655338305915936, 0.2705067372625235, 0.2736903173878248, 0.20949184995370274, 0.33206088149272706, 0.33772962547970453, 0.33254450908893673, 0.07061584121421105, 0.06650078270593207, 0.10391793127943105, 0.09181590771068204, 0.07326514629411307, 0.08023609966114509, 0.1011645475508618, 0.10109727052965933, 0.10356594111465167, 0.22840768813409784, 0.25342438550244606, 0.24092874582654644, 0.25196004246056714, 0.29802483345978925, 0.27412807448900467, 0.22196612760793544, 0.21682748424939668, 0.21162816096627823, 0.6227894889920514, 0.6517174381120878, 0.6432212417110068, 0.6641750824160191, 0.6351726044224508, 0.6308790063754925, 0.571396644899274, 0.6594548867732046, 0.6601891373459143, 0.10472075685207727, 0.09109151010836758, 0.10313731925087688, 0.10270408837943412, 0.10854698853754363, 0.11051084849601445, 0.10536354088581523, 0.10364335280881565, 0.10086817662277403, 0.13097698518979928, 0.17631947629970113, 0.1580375470845593, 0.15732423585057553, 0.15090013655157986, 0.17964495426227456, 0.1649099563532267, 0.1413752857370829, 0.13858072470427396, 0.5120680270816338, 0.44380979577457313, 0.40571244200451506, 0.4410902574197799, 0.48736655210224733, 0.4608831963173563, 0.5241736127255048, 0.5453497494431412, 0.5310714139047731, 0.27445598704510477, 0.3125974730740271, 0.30560052420680206, 0.2990333156622875, 0.28004223982883825, 0.3249571647700905, 0.376127896456242, 0.3115500191903018, 0.3545703306662188, 0.20483695868190166, 0.1968515590788784, 0.1983284310708232, 0.19816308869041166, 0.19261205022203653, 0.19054209967646418, 0.19344936939143043, 0.20512000596819302, 0.19351091580981394, 0.4225681139612181, 0.36581913128758525, 0.32854575957998344, 0.4568714783588401, 0.36056905089996394, 0.52760599885241, 0.3897786365956576, 0.5048963100790504, 0.40365852755322185, 0.7929015985925844, 0.17467592236139462, 0.7622841811125118, 0.7108208148400206, 0.6513622476919381, 0.17342291202020732, 0.6530350525885333, 0.6692869276577642, 0.703692878903107, 0.6520163802160106, 0.16412943403255598, 0.16491763032590423, 0.5026680828279685, 0.566677547884151, 0.16059681861926056, 0.2065163321060408, 0.2086505791439881, 0.20893829450798596, 0.2019578992725114, 0.18548462207592742, 0.19050994598405435, 0.18644928359431556, 0.19524702948664607, 0.1918377048870279, 0.1713061590420013, 0.18489601395138056, 0.18667691471349335, 0.08795602038705042, 0.08911392094855697, 0.08451350863166229, 0.08084705466820963, 0.08290299408258739, 0.082043520295214, 0.0893110518854604, 0.08527245549602525, 0.09336379675574003]}, "mutation_prompt": null}
{"id": "5eb0c103-6e96-4ee9-801d-f115e120932b", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 30  # Increased initial population size\n        self.pop_size = self.initial_pop_size\n        self.CR = 0.5  # Adjusted crossover rate\n        self.F = 0.8  # Adjusted scaling factor\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.75 + 0.25 * np.random.rand())  # More randomized dynamic F\n                mutant = a + dynamic_F * (b - c) + 0.15 * (best_solution - a)  # Increased influence of best_solution\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.2 * np.random.rand() * (1 - self.evaluations / self.budget)  # More adaptive CR\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            if self.evaluations % (self.budget // 10) == 0:  # More frequent population resizing\n                self.pop_size = max(5, int(self.pop_size * 0.9))  # Adjusted reduction rate\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            self.CR = 0.5 + 0.3 * np.random.rand()  # Adjusted CR range\n            self.F = 0.7 + 0.25 * np.random.rand()  # Adjusted F range\n\n        return best_solution", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with dynamic population size control and adaptive parameter tuning for enhanced convergence.", "configspace": "", "generation": 85, "fitness": 0.38412860052892683, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8618704161453399, 0.8426380971743437, 0.8539022885297773, 0.8669933503105864, 0.8505432754358246, 0.8825200735963807, 0.8620637333508132, 0.8628641388025996, 0.8632391261080516, 0.7441189904051003, 0.7499025309758516, 0.767464507619274, 0.7575769161251761, 0.7451508795770481, 0.7836093015613999, 0.761252050484079, 0.7540153519735157, 0.7596353984186054, 0.1584519266061778, 0.15528213186569706, 0.16518224852309105, 0.45082759593148636, 0.3909637999494199, 0.15616197020353795, 0.4383973010071468, 0.39688991461905687, 0.4738304356195817, 0.3706542406119745, 0.3400495450905828, 0.3039293362459532, 0.13142759183483044, 0.1528680719783253, 0.22168056797946578, 0.1474111397098542, 0.1484413455906506, 0.15152561400824793, 0.9484876931239982, 0.9934758116240459, 0.9685771802231369, 0.9614429171041697, 0.9732945391590498, 0.9412257935330133, 0.9275806463204376, 0.9432433344148579, 0.9537585743663509, 0.6203016826784311, 0.564910109831217, 0.604712059555379, 0.5538757974169457, 0.5660738099455833, 0.6091745158572067, 0.5994004721321418, 0.6004180835759174, 0.6267627795309805, 0.7382550833891028, 0.7021748992121195, 0.7893567970180947, 0.7953643434553446, 0.7449249844914478, 0.7846109102638312, 0.7356580809881519, 0.7593905794963424, 0.7019999701356001, 0.3317095768703283, 0.2900520061552313, 0.3617716435802182, 0.3412361282089309, 0.3596423039168327, 0.29694793098665473, 0.34272137821437465, 0.29138439124464144, 0.34512187728617905, 0.25387817425962145, 0.24557529670236034, 0.2253286433053837, 0.30371135745030586, 0.3580830672467621, 0.3510510608735168, 0.33612970419475885, 0.3043373990313537, 0.26871311132938736, 0.21944417984693676, 0.17045076017397875, 0.21221627167509627, 0.12956189405414786, 0.17340735338761593, 0.20695413088752157, 0.20795147845364814, 0.1661424699081393, 0.1711228975640402, 0.30247080280797567, 0.2607794342554647, 0.37858250168326635, 0.27785805373318484, 0.3154577618761365, 0.3228678675122384, 0.40041904527108685, 0.33678942082151475, 0.3535292493159832, 0.12034759365149672, 0.09315748139508218, 0.0933366323935022, 0.1383293844876684, 0.10307401537243732, 0.11702616024605728, 0.1403100047306891, 0.13375064304948514, 0.10135726757266839, 0.2560734578024281, 0.19726649157734588, 0.24062533792381002, 0.2556507145383058, 0.23655297917661833, 0.27240898445390493, 0.2300519513705397, 0.22724439387030404, 0.23707143832351674, 0.6940155749066435, 0.6373392629676975, 0.6770265871369786, 0.662016488526026, 0.6092521608495673, 0.6437689112803812, 0.6455929482179146, 0.6150291091205742, 0.6873108097669197, 0.10606153606599888, 0.12645913520071694, 0.10358150635564634, 0.09482397720452973, 0.08763659152482484, 0.10948477993628436, 0.09899578784861918, 0.1149415085367762, 0.10109918206356683, 0.16739308546175524, 0.14330258768385717, 0.12258010951815668, 0.14306123539483306, 0.17100436332699176, 0.1483331267432384, 0.16970536338177167, 0.14904828395343084, 0.17249389777852253, 0.4222873199299304, 0.3982802238369786, 0.3933937238395555, 0.4072917246220893, 0.4116987218016249, 0.40920954281955113, 0.5008912388021118, 0.4733040890857201, 0.4858459109840285, 0.27030690189330986, 0.29095196216004704, 0.2698347365392174, 0.2916782933909092, 0.25811633534089296, 0.28771420236483036, 0.35724362646515984, 0.2755057629625154, 0.3235607384745395, 0.1879306407404744, 0.19359271469442285, 0.19734402007335095, 0.1947132019817186, 0.19169472679443766, 0.19374797156054002, 0.21795175128685895, 0.19353490202543944, 0.19199326575445852, 0.32205092660306234, 0.24823488794895243, 0.4274174997329876, 0.23273155044008798, 0.3031732634247105, 0.25824452382180685, 0.49947367091706985, 0.20994985192753668, 0.21779486677516846, 0.7828487519509922, 0.173302294190272, 0.7139778978641302, 0.1765200791413961, 0.6412878820844528, 0.672393112426007, 0.6921737782585329, 0.1662537882924967, 0.692101611153427, 0.7177998243169723, 0.685101930240961, 0.16641907792125532, 0.6216707654982643, 0.16529025162289324, 0.2058102453713757, 0.2019993725164091, 0.2103479244493246, 0.2108877778907745, 0.1893017700778693, 0.17292251213145682, 0.18214151876105467, 0.18510438321639788, 0.19031193148153958, 0.1760220050746475, 0.22018626489948934, 0.18343291263331585, 0.18668097337919398, 0.08859265809688677, 0.08736293174276466, 0.07764592558639594, 0.07738307496861507, 0.0826054332473295, 0.07214420500302965, 0.08214010376152148, 0.0880835408388615, 0.0846597927571493]}, "mutation_prompt": null}
{"id": "41d4c95d-ef1e-4193-be95-efdf60f1f32f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)  # Perturb using best_solution\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            # Adaptive reduction of population size\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(4, int(self.pop_size * 0.83))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n            # Mirrored mutations adjustment\n            if np.random.rand() < 0.1:\n                mirrored_mutation = self.lb + self.ub - mutant\n                mirrored_mutation = np.clip(mirrored_mutation, self.lb, self.ub)\n                mirrored_fitness = func(mirrored_mutation)\n                self.evaluations += 1\n                if mirrored_fitness < best_fitness:\n                    best_solution = mirrored_mutation\n                    best_fitness = mirrored_fitness\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive population size reduction and mirrored mutations to enhance convergence speed.", "configspace": "", "generation": 86, "fitness": 0.4783758230816183, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8857319803633436, 0.8806397532039509, 0.8910264841407898, 0.8902008649039395, 0.8866425158691834, 0.8955848338324564, 0.8971905100773799, 0.8930335398967978, 0.8846839872594154, 0.8195251123981376, 0.824693721212894, 0.8033549700579389, 0.8122341039919851, 0.8020671572539226, 0.8143282969269173, 0.8161638478081428, 0.8020661677201572, 0.8159342799460425, 0.1202549864592265, 0.4129900667601284, 0.45381196134120627, 0.5209602325972158, 0.48555634378928014, 0.1451761277507807, 0.14075517026453277, 0.4677224907349279, 0.393873428302693, 0.1188733642302825, 0.1572222208811236, 0.10581732212037909, 0.15595581690179838, 0.14338895810280794, 0.14894855108222305, 0.12700192505515384, 0.14463249313687865, 0.11248598566619039, 0.942709692798052, 0.9583900672311535, 0.9785729651837347, 0.9411613943575491, 0.9391099724542682, 0.9415931666989081, 0.9731070473894056, 0.9594402129272399, 0.9498674567604669, 0.7300709306636679, 0.7096779772998296, 0.7385790296875462, 0.7284983701434853, 0.7225819041698015, 0.6999529168930401, 0.751354556531221, 0.7118650797454669, 0.7383567128595727, 0.8607256000420099, 0.8211527126729886, 0.8648202980753605, 0.8524896243081741, 0.27354355679508513, 0.9053026366701943, 0.8866613926616033, 0.8363503518624411, 0.8329096896903719, 0.28403859430926603, 0.27665743697969736, 0.2659500459765374, 0.2214443104874334, 0.18884336001164714, 0.20523935745103283, 0.5476697077804953, 0.44197618171320185, 0.4400668746644282, 0.0217086290544094, 0.19827365543592734, 0.19728907083446223, 0.34570764767427553, 0.41681568161341087, 0.3109194561261146, 0.27628697281616177, 0.3326287200369553, 0.2300430752758298, 0.65942074365394, 0.6512140498183242, 0.6654839640740308, 0.08382477614200956, 0.3129811786555655, 0.64880308378175, 0.6388798873645865, 0.6657827909268517, 0.6693047638342544, 0.6986991981184751, 0.730898583207222, 0.7379037339983092, 0.7433072779075884, 0.6353631631988652, 0.7430735970083497, 0.7701540839414212, 0.7315317117757225, 0.7116271494796478, 0.12371740487155125, 0.3241336220651778, 0.12903299890654785, 0.25953080028324926, 0.16696720623191885, 0.2353029285429853, 0.13694629681575277, 0.21173161569003596, 0.2877450875670253, 0.5431408408002313, 0.5113526792178656, 0.4592805980815805, 0.48940596185791496, 0.5756516388277266, 0.5285513178007591, 0.5453155896122799, 0.3578982273250706, 0.5539232424486853, 0.8328723273432592, 0.8359319210857176, 0.8403500360846651, 0.8053241140785984, 0.8261709236505332, 0.8379913048248299, 0.8231186836924336, 0.8636897792678477, 0.8235723970935261, 0.09082860709318452, 0.10221032004293795, 0.1291553158407618, 0.2128427793865455, 0.12055607779695843, 0.14920328867308386, 0.09571412251812927, 0.09996603475211818, 0.09659424189033072, 0.15620091889576415, 0.1337946183814258, 0.1439580758351623, 0.15314578864818418, 0.1450215889107731, 0.17656551032907486, 0.12064149599233764, 0.1273351801423097, 0.16854588938054094, 0.5299533616819028, 0.6214092043471893, 0.6281708162606559, 0.6067809643688094, 0.6356529534347852, 0.6558047279815757, 0.6531031986127269, 0.6332075607259481, 0.6878468645860455, 0.4542604008916308, 0.43873961830286623, 0.48994066999517916, 0.4495460634409514, 0.4621928551727741, 0.5050308554018552, 0.4722546981889709, 0.4713264683891024, 0.4858813612723064, 0.18861717250874133, 0.20249969307791427, 0.19525573963350984, 0.18789616853694957, 0.1803262136231053, 0.18232888668851188, 0.1960233194949318, 0.19737428798766588, 0.21234778268334287, 0.2347583860078185, 0.43644891695050436, 0.32574548938167647, 0.6525926435465019, 0.23021786728820848, 0.5480840522850061, 0.21910907402368907, 0.5910114492768122, 0.44962257467050204, 0.8949406298090795, 0.18033171500562983, 0.8819244749935635, 0.8499452952227492, 0.8414625197476632, 0.8379338306755529, 0.8827277403124097, 0.17541726092264998, 0.8613388366141574, 0.8089431712482273, 0.16796862204917706, 0.8495249070432848, 0.16465342399570604, 0.16871156402822673, 0.7757985571085226, 0.20819180519907277, 0.21019049670589307, 0.8652831860942104, 0.20421649224697436, 0.18421425314476514, 0.18451201147298602, 0.19358389934879772, 0.1859510227867437, 0.1872700637779371, 0.18526359234988654, 0.1798838802996644, 0.17470610910451523, 0.08107436085301978, 0.08031045270499404, 0.08639826518540217, 0.07824041089063705, 0.0885709500866998, 0.08394688350046564, 0.07941095719893565, 0.0708691396230211, 0.09398784123921256]}, "mutation_prompt": null}
{"id": "294a922e-54ff-4d77-983b-9777ed3716d1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            improvement_factor = 1.0\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n                    improvement_factor = max(improvement_factor, (best_fitness - trial_fitness) / abs(best_fitness))\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand() * improvement_factor\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic mutation scaling based on current best fitness improvement to enhance convergence speed.", "configspace": "", "generation": 87, "fitness": 0.4859922151143759, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8946967510466002, 0.8955258904902207, 0.8860672859978587, 0.8970249838023492, 0.8790248335276685, 0.9001605597348178, 0.8983785624912013, 0.9026044915782061, 0.8806190594373595, 0.8186561409452209, 0.831698689269851, 0.809994296699258, 0.8151398831997397, 0.8245497919339367, 0.8044537044380713, 0.8314704927682006, 0.8238347230791211, 0.8112620419098407, 0.4165753216218112, 0.4473071177334388, 0.44794321772014756, 0.3203404657292104, 0.14993263522661404, 0.1331920475351751, 0.4293700874379197, 0.6700232776599881, 0.6653582572998196, 0.10616999017046258, 0.3658601520980921, 0.14013475136543496, 0.1290303680838666, 0.12404643883644917, 0.14026361657518904, 0.13207194302341196, 0.1522753116133001, 0.16254728240684158, 0.9328896128876277, 0.9568925372748889, 0.9778134072454258, 0.9767713735205241, 0.9682861005053086, 0.961688534556605, 0.9701116104245756, 0.9624702565377744, 0.948161334855338, 0.7720715199762571, 0.7277411875861892, 0.7546244263099791, 0.7575615851279751, 0.7431422433545014, 0.6794813108164459, 0.7809107205899735, 0.6520593731581723, 0.08722620306163986, 0.9153532676375763, 0.8548982571702828, 0.8370503541804707, 0.8933013687229743, 0.8671988009673971, 0.8503499897283076, 0.8665712111688602, 0.8764360559918218, 0.85659672569355, 0.26483131321086006, 0.29150891507664634, 0.18263403557019886, 0.17026889159318126, 0.18392576661937043, 0.246578552101278, 0.20013640952243483, 0.25966625521379416, 0.20809045913466284, 0.6085852786508466, 0.2856555892326894, 0.5688059120245448, 0.16615636715319415, 0.20600814555506042, 0.1900212580084918, 0.2967938107156056, 0.23191631622596842, 0.1886964605572925, 0.7144081864068377, 0.7234429678469609, 0.309319176724961, 0.7342580847110689, 0.691194644291447, 0.20580928663992315, 0.5572329091388553, 0.7275651461399675, 0.7176523190503726, 0.7274177739057724, 0.3666908682826985, 0.707080087336309, 0.6097975482020767, 0.2807215999873921, 0.7342448466121607, 0.7867299677857871, 0.7973892992447009, 0.7688124795395266, 0.23618324699695792, 0.1183046622780477, 0.09885404344424098, 0.6080474437571173, 0.3542320946596692, 0.5440869728799771, 0.20141730931053858, 0.23084349012453997, 0.21294049170851725, 0.32887844112299236, 0.35256479058999735, 0.5727964483745185, 0.6534324980355293, 0.5938035369023831, 0.4988656897167292, 0.4862451219735676, 0.39500685265074176, 0.4203065324286722, 0.8405128599417874, 0.8466725699174922, 0.8371550730271389, 0.8547291179205031, 0.7593376300981896, 0.6734815718534874, 0.8274153071708055, 0.8239068689774971, 0.6505315531025924, 0.12503350088246112, 0.09638752306364728, 0.24072634468061183, 0.1084555499130021, 0.11829741796650728, 0.09931495194949946, 0.10163662899238701, 0.12524920890944158, 0.11904905671248378, 0.13135289064885258, 0.17325193216546486, 0.5967243685293924, 0.13881622961777118, 0.16252897600482086, 0.18265421518960334, 0.15917360737074837, 0.2319930666726404, 0.15464125134376505, 0.6650859990295386, 0.6260313511197816, 0.6304010749562423, 0.6587907450333385, 0.5529386776695222, 0.6713356831869228, 0.6608119612749367, 0.6068378704922179, 0.7153327667653002, 0.3248437262818651, 0.5390410295713337, 0.46588560295914216, 0.4467324864544071, 0.4882652639513788, 0.4921025566059981, 0.555724697881929, 0.5656030829632696, 0.5648239774121011, 0.20006247978708502, 0.19549058913489314, 0.1877201945661522, 0.1988167350530774, 0.20382639531096813, 0.20226246472295262, 0.1969759730993731, 0.22672350658615037, 0.197444518309851, 0.6761184857081053, 0.6587956114101599, 0.20886831715135779, 0.7497391322236215, 0.661810822875303, 0.6272695222878424, 0.21149868280268036, 0.5791922947612808, 0.22275586899799127, 0.17983741711037438, 0.8731831141919725, 0.1523534971960092, 0.8759937783471592, 0.19471988910032723, 0.8530777885875158, 0.8488590266092267, 0.16244665739568553, 0.8959768639331486, 0.8695929319614175, 0.8315099852494476, 0.827826780116307, 0.20817386679426786, 0.1689557288998873, 0.782476629761876, 0.21132726962556458, 0.21098790656617783, 0.8363181797263189, 0.1700292054086403, 0.1782482775793578, 0.19175713117051452, 0.19250105599600875, 0.17593112005103828, 0.17159768792195695, 0.18336941099196513, 0.21517752352784447, 0.17793805818085817, 0.08526355201117242, 0.08242813213837996, 0.08171845901695818, 0.07454118821838018, 0.08299656552295853, 0.07676480652140638, 0.08621261791539814, 0.08653714992077, 0.08057936191343107]}, "mutation_prompt": null}
{"id": "7deefcd0-3496-4365-b17d-80e716ad14eb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                dynamic_F += 0.05 * np.sin(np.pi * self.evaluations / self.budget)  # Slight adjustment\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Utilizes a gradual scaling factor adaptation for more dynamic exploration and convergence control.", "configspace": "", "generation": 88, "fitness": 0.476583576468168, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8920436216398031, 0.898871470367547, 0.8849162981238529, 0.8877604142811284, 0.8844797936212389, 0.8963535179056359, 0.884468140443733, 0.9032893557805447, 0.8683866592569847, 0.8000900534796881, 0.8290134690105317, 0.8129354084408095, 0.8070761599403191, 0.810472836944111, 0.8318221929025863, 0.8068544989606444, 0.8225706899865646, 0.8330030690856417, 0.16922427562763787, 0.4273866506061441, 0.12896561075169288, 0.6141411500542486, 0.14962359336231634, 0.5779599127097215, 0.3026088072120793, 0.16546767026253806, 0.24259867920608202, 0.11332206013086377, 0.13042282842775965, 0.12791772190204553, 0.13092398757982593, 0.14204083473541518, 0.14199837459396736, 0.4557664000028311, 0.12870891532491857, 0.136563202938213, 0.9473072077949396, 0.9556687313366493, 0.9778083695515178, 0.9767811313215091, 0.9683115580571775, 0.961742210306747, 0.9700912070428082, 0.9625551936762621, 0.9549043505152198, 0.7447102644240922, 0.7378971581905571, 0.7204534429535803, 0.7150689104221175, 0.7526801268609588, 0.7190422987541476, 0.7438416324497531, 0.7546471410039771, 0.08726934434467237, 0.8821104638772702, 0.8659637627446496, 0.837439972558321, 0.8674963182607315, 0.8575950419718424, 0.836010609012312, 0.8773817916197946, 0.8651026749513662, 0.8336311112652175, 0.24939592440046465, 0.3014155524200349, 0.5271477209935673, 0.31777733655384577, 0.21126617295059036, 0.280981526553131, 0.3926947342484346, 0.5004521359283653, 0.2870141247892216, 0.24025499341810175, 0.3720305168276298, 0.2720663390587055, 0.5422660607392096, 0.3654889206097648, 0.43080488732461686, 0.22516817742577622, 0.6595793870003377, 0.20006946437652573, 0.688132647087722, 0.6693368033897493, 0.6795024277296682, 0.683400406746834, 0.686496920382762, 0.2702491532069652, 0.7008262476843687, 0.6946972801187519, 0.08909011054466831, 0.7453030299792109, 0.6931699335940738, 0.7563950909166315, 0.7607291934542797, 0.7380897601934744, 0.7238450140620492, 0.7762125245157014, 0.7392752975637269, 0.7826640983847034, 0.19095278778904823, 0.15778133577023723, 0.28909846598310784, 0.43629821237293076, 0.19707555012584232, 0.5429213158820261, 0.18290376507575368, 0.3036342227269394, 0.2531479363056739, 0.43267830973272625, 0.5840574544960884, 0.5637458884490282, 0.6177439713468935, 0.5695956533165043, 0.4412557719935326, 0.5351654563469979, 0.6064077198215861, 0.48468934090166615, 0.7623864669361987, 0.8444848097547879, 0.8325133967725198, 0.8347640481499667, 0.835960656787244, 0.8064995023685879, 0.8527391947868596, 0.8262565824976291, 0.8197232927982319, 0.10972656522374435, 0.14389933559139312, 0.11471233689021132, 0.135338777150938, 0.13207103328468506, 0.10841779707706278, 0.09148387796591306, 0.10544626753123487, 0.10310525109514657, 0.13769122949447288, 0.14799855235977777, 0.27067531684084, 0.13580224091548276, 0.13811511785672537, 0.22091205228733357, 0.14839073315822193, 0.14962587175627107, 0.16284244296800776, 0.6536946165972564, 0.6628882467430173, 0.6514671261686822, 0.6130488736837878, 0.6065489817786396, 0.6533086011744837, 0.6652186820754225, 0.68797452256471, 0.6733709786026872, 0.4559869209230726, 0.4758285284821614, 0.4465963533351467, 0.4672731758279407, 0.45397626927395895, 0.4377172170719861, 0.5642720515188075, 0.5618606530254605, 0.5000116381148201, 0.18410595271993913, 0.20973690295991687, 0.185922998986204, 0.18734127523328403, 0.2044203495478475, 0.20054418794044904, 0.20488603848664722, 0.18720378518134395, 0.1848426684288117, 0.6407933094875394, 0.22384631798041021, 0.187107053681962, 0.6586841524936377, 0.23135688500845286, 0.44990523562623697, 0.5890812677781483, 0.5150296319894312, 0.2315440773235653, 0.17525361945806928, 0.16793817391470478, 0.15220356967676874, 0.8785149907917306, 0.16534598079766583, 0.8440684315064311, 0.17028561214674665, 0.16005165931380938, 0.8944436502878788, 0.8412829291908134, 0.1555259837220352, 0.15553241603041768, 0.20870623392637577, 0.8537553812522023, 0.2091648485641815, 0.21132066426867746, 0.21065719027125207, 0.7520468301118997, 0.18842274917822233, 0.18494259366912047, 0.191265833421848, 0.19044554686171233, 0.17842941907244603, 0.18876855909349743, 0.1722541690270014, 0.1869715191682081, 0.1804887506709265, 0.0819131758512851, 0.08250347818687531, 0.08499568668087887, 0.0836224721214196, 0.08240229008128841, 0.07881359806185662, 0.07546466194326862, 0.08343890244588437, 0.08582924376343182]}, "mutation_prompt": null}
{"id": "aacb2447-7bfa-43e0-ac45-3cae8c8bed38", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.11 * (best_solution - a)  # Increased influence\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.155 * np.random.rand() * (1 - self.evaluations / self.budget)  # Slightly increased adjustment\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive differential evolution with a slight increase in mutation influence and dynamic crossover rate adjustment to enhance convergence speed.", "configspace": "", "generation": 89, "fitness": 0.4513074824591308, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.896919237468738, 0.8946575065837972, 0.8896134625491745, 0.8987038309324333, 0.9005700731202475, 0.8957584951167099, 0.8906386750918538, 0.8972534507461408, 0.8801292247835552, 0.8236857388137162, 0.8207575862124251, 0.8215422283873942, 0.819789874789827, 0.8306057855986495, 0.8292197369214458, 0.821602062142159, 0.8221665732428936, 0.8217140565188308, 0.44329982225040165, 0.39924867970907507, 0.3756624888765553, 0.5015711364990368, 0.13370614693175997, 0.16472442262573772, 0.14289434639545073, 0.13843329824109574, 0.17750889416363624, 0.13040064761119607, 0.4663852689305228, 0.12254011639325324, 0.1505805637109725, 0.133995305430748, 0.1631752178849516, 0.12195664596252886, 0.13429473266846004, 0.13937297325988052, 0.955486330923971, 0.9524923540313547, 0.9776443132898892, 0.973202565675779, 0.9796289222372545, 0.9748883826077719, 0.9341741703147655, 0.9586411651842541, 0.9639784219480702, 0.7218182129091522, 0.7530302797036655, 0.7400893935638001, 0.7584549499509627, 0.7077835996755977, 0.742460887183678, 0.08830910161288652, 0.3274389466919636, 0.08819983599606607, 0.8794981765802193, 0.892312836467837, 0.8371071236070742, 0.23475136121769813, 0.8831921915730738, 0.8821546989213848, 0.8611307811829344, 0.8839074200291775, 0.8649632272468828, 0.1921611597267513, 0.26828834541871305, 0.4048567158752606, 0.17087988008702082, 0.18114604770120013, 0.6798787854045942, 0.2363799731075309, 0.20144050355560705, 0.43968669247363334, 0.17283785986207745, 0.1515073790232354, 0.4652170895417064, 0.19735717456235713, 0.20341822110883856, 0.22161858919009503, 0.29083924434234354, 0.22132975665078902, 0.17510664273943877, 0.21010930934412653, 0.41798104786601153, 0.581062391844118, 0.2331278080520396, 0.6937466520382203, 0.37721410639635855, 0.27902129993886726, 0.37429829036926754, 0.4564090357256053, 0.7891508645865755, 0.7741646426268928, 0.7588505333039256, 0.7779668300439757, 0.48531235300571063, 0.5021360777759254, 0.8013225615699617, 0.7968978230384398, 0.7735880105686712, 0.1394645152810151, 0.13979306555011406, 0.145423755690822, 0.5312511131100288, 0.24575785598259903, 0.4064373603316568, 0.18976435542247805, 0.34085613451651775, 0.19825498372891348, 0.34102212928214637, 0.5121916353013101, 0.4066909409655802, 0.5567886718955573, 0.6570752317451789, 0.4901740828058544, 0.508715991634761, 0.5003755355484227, 0.39509823878924366, 0.8056916259961391, 0.8285855371102435, 0.7270729758790193, 0.8486571822987863, 0.8597270490424933, 0.739868753964723, 0.774451849317483, 0.82574310170229, 0.8536892135749737, 0.09779931933600494, 0.10102957096034115, 0.12082304934786658, 0.1620484143783988, 0.09152036286339593, 0.10365025996810795, 0.12203762995610157, 0.10828423879755333, 0.10502320645001528, 0.14919912640745914, 0.2456058983564584, 0.13808513488287044, 0.15020131852054108, 0.13472022128827776, 0.15362800909456276, 0.17923883065001733, 0.19882049770110788, 0.14445317551872427, 0.6569470391118353, 0.691613098818745, 0.5071266162619527, 0.6755474352947486, 0.6636998893147904, 0.6401893298953002, 0.70746186997488, 0.6719329453644518, 0.5899049038878126, 0.46921040672963976, 0.4955461484804651, 0.5603460367763167, 0.5276535681273327, 0.5874996897435392, 0.5815635535842314, 0.6130374111139791, 0.5925238037769972, 0.39481638259413243, 0.18957044541339252, 0.20025225528098067, 0.23373483142270302, 0.20754757552929093, 0.18611589556831554, 0.20087359055547227, 0.19889054086826485, 0.19788977040476952, 0.2021967873726045, 0.22032154773020607, 0.23636821250164552, 0.4630595767393434, 0.2165879931586664, 0.27575279205324965, 0.2068240724723731, 0.23571198560408746, 0.6592970331160735, 0.2331243499421779, 0.1690604113096157, 0.19366691162612937, 0.1529862836340592, 0.8549551531737513, 0.6859377397026476, 0.8302145132526464, 0.18700489025202682, 0.719676842078515, 0.18649693761807884, 0.8063374612243481, 0.20771770850728644, 0.16726196717061848, 0.16142575156612637, 0.8622117156460819, 0.8225383961892769, 0.19296604732196476, 0.7619854571739875, 0.155276935805142, 0.18465998873995737, 0.1770668652692069, 0.20183767873146818, 0.18988900249360252, 0.19387317359199407, 0.18426867906801914, 0.18904610666404886, 0.1906871992718665, 0.17961667413241977, 0.08243915159610793, 0.07827072538245816, 0.08197389903193963, 0.08424654026313672, 0.08250675223200055, 0.08358416404532087, 0.08724726082017165, 0.08295809687681288, 0.07686493882019074]}, "mutation_prompt": null}
{"id": "6967eb2c-fb40-4b00-8833-87346b2e9bbb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            diversity = np.std(self.population, axis=0).mean()\n            self.F = 0.8 + 0.1 * np.random.rand() * (1 - diversity)\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling based on population diversity to improve convergence.", "configspace": "", "generation": 90, "fitness": 0.466956640194618, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8565920038520983, 0.8636779270584397, 0.8537879277091748, 0.8597389542438557, 0.8650489601816225, 0.8648311496811404, 0.8652444656422649, 0.8707813371420887, 0.8683969305700567, 0.777777665319612, 0.7746227435832369, 0.768080125870128, 0.7792464705162061, 0.8006824829031656, 0.7893112203456248, 0.7679217360263979, 0.7808389869224517, 0.7808268404876169, 0.3476507459259509, 0.5603938358819919, 0.1292193055919686, 0.414401730654704, 0.47152104170787257, 0.3921881453491207, 0.13670219127020677, 0.5055482174313544, 0.5275679824845803, 0.13359805792373103, 0.12923070304135742, 0.163132690353317, 0.1552090075081033, 0.12216187593589489, 0.13686926445579006, 0.13635106540947473, 0.1521201215047473, 0.12464366959695194, 0.9696124516820482, 0.9584638523606107, 0.9507798630785688, 0.9802300266653574, 0.9680209785533083, 0.9653313434164179, 0.9640736164952789, 0.961057815262979, 0.9778470016012526, 0.6551788431121359, 0.6930527819252837, 0.6470465493577812, 0.6762559646471265, 0.6917757600349199, 0.6844322074889917, 0.6909690448180306, 0.6735729270819175, 0.6659692934510565, 0.7159298428833621, 0.8275332687078876, 0.8487533607467814, 0.8217884593868742, 0.8537114496326643, 0.8197929734439968, 0.8337546052711169, 0.8245083330011564, 0.8284823947121901, 0.6676064075674233, 0.5859629108397357, 0.5377350716205129, 0.41233637239865906, 0.6081826805062935, 0.5585758356776285, 0.5694947144628234, 0.6110197563930948, 0.6333198669150685, 0.009840327571811969, 0.7110336400072538, 0.05083162616451209, 0.418839823122905, 0.5415211397704808, 0.6636987169395345, 0.6082548055661303, 0.6419932446241889, 0.6616373430681761, 0.6125968994538913, 0.6411066896297891, 0.6245446520794291, 0.6340236401165247, 0.5990257060540418, 0.5848866374258266, 0.6261912192295134, 0.6415515223012549, 0.5688518406541858, 0.6957014686723914, 0.7040861485577055, 0.7404153815353238, 0.7015199229585364, 0.7149573676525451, 0.6819182315305345, 0.7126023981481341, 0.7478192670200566, 0.7069045844079522, 0.1250498343032065, 0.12852595184005966, 0.19104123394697048, 0.4916303684695388, 0.4154821551204475, 0.2698084681984071, 0.23284919247277658, 0.3221035735888409, 0.27013684322380427, 0.5063633540472028, 0.36540864644718773, 0.48301661108444494, 0.5183248939109992, 0.5285855168462024, 0.4549670401173288, 0.4857305056986676, 0.497496858600028, 0.47558889439366414, 0.7811790491376976, 0.8028412317285604, 0.7958997117260835, 0.7689237259479567, 0.796920015603809, 0.7991069099700455, 0.7870867301278226, 0.7876151256082662, 0.7952523489093256, 0.12460747807531902, 0.10911003146065557, 0.10136078599846443, 0.10734197114242672, 0.11123479218550669, 0.11978016650094092, 0.15829992871234244, 0.12815876539008586, 0.10898285512764183, 0.15269654280860145, 0.14842522613073728, 0.1496981654749867, 0.16696041908788706, 0.13609961739326393, 0.1296490466854313, 0.14452112451299892, 0.15526408974842798, 0.15504023892362861, 0.4780361727906721, 0.5119642136365121, 0.5220115863658024, 0.5401630464798381, 0.5405319165225321, 0.5007898308649532, 0.5354347858296811, 0.6243777169898667, 0.5656851527297435, 0.3714959695760054, 0.4155698786105295, 0.3859804911312421, 0.40289809823068323, 0.44475005394543166, 0.42066472361454676, 0.3968169013903484, 0.40750746500832324, 0.39344674029758986, 0.21911635713681166, 0.20546879766572723, 0.18126101701603092, 0.1890520688736177, 0.20132603501294577, 0.18156872943090097, 0.1990400742793449, 0.2085799954389228, 0.19468490538125494, 0.20440436357997283, 0.519043047374953, 0.5553106122181215, 0.22089128755334364, 0.34140559105292545, 0.5078605034620789, 0.596448624739274, 0.5486483462999303, 0.21751209842165797, 0.8480902091160845, 0.1777216625245155, 0.16472056735975726, 0.1668913069394704, 0.19145963725578752, 0.16448261149091814, 0.18527719927620345, 0.16512514854871896, 0.1669659106909468, 0.20727024802714422, 0.20636263372861463, 0.16860995977923154, 0.16310476405462504, 0.16109616936849291, 0.8160089144280483, 0.1275800835998534, 0.20405537498060322, 0.8030172752036252, 0.18802963637481984, 0.18880046658030325, 0.18463913965816903, 0.19071901232859467, 0.18921220529101868, 0.1895537055620623, 0.18272274764304752, 0.19469153044272847, 0.18550581642317954, 0.07689973999048305, 0.07708802065825071, 0.08793396056309555, 0.07482492087948633, 0.08782116295198994, 0.08705681524117481, 0.07457542040088483, 0.08494375460324499, 0.09143286514625093]}, "mutation_prompt": null}
{"id": "0ef6328b-c713-45ae-8d51-de4443bc29f2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.stagnation_count = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            previous_best_fitness = best_fitness\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if current_best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n            else:\n                self.stagnation_count = 0\n\n            if self.stagnation_count > 5:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n                self.stagnation_count = 0\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive population reduction triggered by stagnation to improve convergence speed.", "configspace": "", "generation": 91, "fitness": 0.3564797637346501, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.9099674180574878, 0.8906985842558977, 0.8915431117728869, 0.8956302097010221, 0.8922758462261108, 0.8945622071564553, 0.892356852860173, 0.906321091367953, 0.8731880721107244, 0.808454763832227, 0.818125663129163, 0.8197339688121041, 0.8382788361195748, 0.8388583505573695, 0.82700982086648, 0.8138628613468653, 0.8297366362824534, 0.8059216938935332, 0.12818473329590474, 0.1397718403846957, 0.1678347195442228, 0.17704374883195728, 0.1513028657711396, 0.13950875745540248, 0.13603652569259306, 0.1338527626240893, 0.12380223478621466, 0.0877153540107185, 0.12160067645970452, 0.10325123661343838, 0.12968732277613448, 0.14796271499409364, 0.13381907297647233, 0.12295553505776169, 0.11985688151281315, 0.09345545959235313, 0.9359091410942906, 0.9655693849461198, 0.9778008199700204, 0.9767713735205241, 0.9682861005053086, 0.961688534556605, 0.9701116104245756, 0.9624702565377744, 0.948161334855338, 0.7568755809618765, 0.5586784045309738, 0.5559261846882886, 0.456881248229294, 0.4407220144227354, 0.7344570148024552, 0.638246586763928, 0.5822692191801287, 0.08737714571158772, 0.9258203730914674, 0.38225809271227207, 0.8989247223420235, 0.8848490693144018, 0.8856483275881585, 0.9005089282080019, 0.3597896930727438, 0.8717761282614589, 0.8911171983611634, 0.15221379414724723, 0.18325765653449488, 0.21668316917027297, 0.18324191370905485, 0.19516258457738844, 0.14461017966228684, 0.20531475137189126, 0.21356489383306054, 0.14436965842646732, 0.334250566531774, 0.16129586877642232, 0.17144185695336323, 0.16551496036499613, 0.19948043359871293, 0.1955126048435576, 0.24037837305060183, 0.19446010844132744, 0.25794226184645075, 0.1533675120775051, 0.39189392107003274, 0.1789499745151063, 0.168711024912103, 0.056612801323382866, 0.11126270629516044, 0.2770416160190967, 0.24639618528009644, 0.1865453083648947, 0.16824221168730946, 0.34839540050906437, 0.4626730753540562, 0.27802463434838753, 0.028070008531160928, 0.18481702441079373, 0.206527228340586, 0.4592994698923375, 0.5428662665831235, 0.09914735757839332, 0.14250377041793072, 0.15623792090490862, 0.12009742829093517, 0.45130138494515326, 0.14062425875850038, 0.16380844762083602, 0.1834845307251658, 0.17474759117383387, 0.37845660332266184, 0.378002573244798, 0.29500359647431484, 0.24894924245956496, 0.3654668949220119, 0.3677835124273753, 0.2810743099465345, 0.2483414686958224, 0.32263206031269465, 0.7427061032868449, 0.6006753290922168, 0.5336375778167515, 0.4951103683408742, 0.5823110677330068, 0.5350658930407584, 0.8409747262221035, 0.7416889785390426, 0.5545179440320809, 0.09709711047116998, 0.09406101506402864, 0.09334762794794838, 0.11988169648159164, 0.11310856870838071, 0.1330457292326408, 0.10224679703960249, 0.10078572509192851, 0.12898859413579467, 0.10521728477573489, 0.13192972177212015, 0.1317424667779138, 0.15414133829337373, 0.1941003113012919, 0.14869530391268038, 0.15310813474440332, 0.15515323170922657, 0.19661147979359217, 0.39116658386854375, 0.3106137104489126, 0.4229718520385549, 0.475032955312477, 0.2652955027012288, 0.31623027053347486, 0.28475731060212284, 0.39297246554356113, 0.4033370873062053, 0.32337943107657297, 0.31628898186299836, 0.22778020593253445, 0.2594393104413947, 0.2490684757679874, 0.2530015814717437, 0.38485604359604453, 0.41621854340214404, 0.2622636370619772, 0.20526325937344858, 0.23291568714332012, 0.21477196790484743, 0.1968706307445094, 0.20679738257557012, 0.20668114562026174, 0.26472923707932383, 0.200779705141078, 0.21340718418249105, 0.20133767254822166, 0.22106636401584867, 0.20304192092250561, 0.23695765164022964, 0.1954159887528889, 0.21253655359787516, 0.18201852480382508, 0.1976885218200628, 0.20742765131079588, 0.18210383745277448, 0.19625496232403927, 0.15233267521811378, 0.5650717749749363, 0.1979672889080999, 0.9071772602373411, 0.8996851662538922, 0.16499092394470571, 0.887881682908939, 0.20632439503167188, 0.3319102639824323, 0.1671207696579704, 0.20835232962696526, 0.1689232782795248, 0.20665387985115102, 0.2113272044529515, 0.133120979688803, 0.12650755251146806, 0.1827591903542578, 0.18627957499729064, 0.18600557964622322, 0.19198054368929562, 0.22976119560786978, 0.19503435447745, 0.18292553255293054, 0.19431452333159627, 0.20350154685051736, 0.0812711334255991, 0.08777734084084354, 0.09337511190079695, 0.08673452823574135, 0.08217969261621605, 0.08986631068173068, 0.08804615962168205, 0.08611717315680112, 0.09454424893240487]}, "mutation_prompt": null}
{"id": "2b1f1f6c-7a07-4582-8139-a4847af718cc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                pop_std = np.std(self.population, axis=0).mean()\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget))) * (1 + 0.1 * pop_std)\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)  # Perturb using best_solution\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic scaling for the mutation factor `F` based on the diversity of the population to enhance convergence speed.", "configspace": "", "generation": 92, "fitness": 0.4576108832534978, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8846813506135318, 0.8832371902410965, 0.888796444969947, 0.8859967093695892, 0.8961740590324497, 0.8859317726463138, 0.882296942962717, 0.8882252986010001, 0.8832769068126083, 0.807890241886276, 0.8189283609338981, 0.8039736715021057, 0.8030019048199633, 0.8045189090246709, 0.8061524747537974, 0.789090025241249, 0.8059882426279824, 0.8001993945963349, 0.3044588562485303, 0.52975598310483, 0.13762206783373332, 0.21104602243329418, 0.5550308602325542, 0.14685627603432294, 0.34226206520999736, 0.1342205265945986, 0.4400842296863344, 0.135741767112866, 0.11770180005115216, 0.1324438551211491, 0.141162256439347, 0.13089182518049947, 0.11488426620642855, 0.12892863645997454, 0.28254963707592806, 0.13273476823094532, 0.893167935582166, 0.9656275033497603, 0.9495932737074602, 0.9585765100729288, 0.9581811199367577, 0.9459142720696827, 0.9584106521360035, 0.9839033209203806, 0.9572173250963473, 0.7386212978362282, 0.7365498773909669, 0.6742442108065607, 0.7247701707200986, 0.7142223481750423, 0.7249530448825928, 0.7357233326723004, 0.721251511594924, 0.7537967607828515, 0.8609972205283895, 0.37237631294728857, 0.8133269365321142, 0.8588886029821454, 0.8482321312577447, 0.8637726631034606, 0.8330633144622284, 0.84575773281186, 0.8343637244114751, 0.18133954185761703, 0.2795400670861291, 0.3085281975530172, 0.6905969463000847, 0.21303940438971702, 0.1882157709546315, 0.39929647643451094, 0.33394281047917096, 0.20610013957787676, 0.2501356355418204, 0.21550981792950252, 0.12118712391249942, 0.16676271715292845, 0.2858390429829183, 0.1647805733296045, 0.202076662576823, 0.31574825166626574, 0.19918428849389813, 0.37969868945997487, 0.5470136812645309, 0.06884772842523212, 0.4685650938974606, 0.5109169399143461, 0.04984781486020051, 0.501181759103963, 0.6430449564588805, 0.6447642700225296, 0.7420610620539938, 0.6892898234294494, 0.7391628722629648, 0.6318711660442828, 0.7280414819526959, 0.7028144608606608, 0.3784956102341571, 0.7417374793274057, 0.594105346490064, 0.2538701691384494, 0.37944806878370163, 0.2888007071246834, 0.28321809483677785, 0.30584463008118856, 0.31107049934562814, 0.2931984959776167, 0.25032918633239354, 0.35557416984034773, 0.4868347258873127, 0.5399449239210532, 0.4484738302860055, 0.5249080815151972, 0.4467867216370929, 0.45882893337007, 0.4487742992518019, 0.394312413413053, 0.438974216383363, 0.8351051873419288, 0.7579451916046823, 0.6345158598290574, 0.8068315287854247, 0.8393824775065288, 0.841585338300615, 0.8537356491411588, 0.8386428053126209, 0.623639903557688, 0.10507857401140741, 0.09968327228684115, 0.10320053420178155, 0.09511038656257786, 0.09698284453820194, 0.09882577346554211, 0.11009672311563312, 0.10506118660271402, 0.09616188945068604, 0.21542853349422153, 0.15440173070872276, 0.14915356541742308, 0.1404252598526997, 0.5996715512058899, 0.1473301784648262, 0.31646829586351477, 0.12897272448481123, 0.16348036541443145, 0.601041792829286, 0.6717702595682515, 0.5676933349960225, 0.6258412335303463, 0.6730139890935339, 0.631838410401956, 0.6908558391766506, 0.7119817424967197, 0.6375624103052173, 0.3958471413249647, 0.49260908686341853, 0.35919982464280975, 0.49808555956838285, 0.5340543977095878, 0.5142388026671583, 0.5833134284788604, 0.5473624060454262, 0.5634796874938888, 0.18292272844196888, 0.2071524901909788, 0.18651116477530016, 0.18709084148353017, 0.20237784800690417, 0.18938976971454347, 0.1901452495151308, 0.1797273733765622, 0.18305038919598104, 0.533397839845582, 0.45979379750370597, 0.37135117039469046, 0.5551758929966, 0.5319317375941773, 0.4517505925834937, 0.6321368299655546, 0.5154565540325176, 0.3917251986378, 0.7933114998200422, 0.1666602480113757, 0.15341611154086443, 0.7902988810247541, 0.18389953424925365, 0.18349833605877908, 0.16459186755767918, 0.7851426865553268, 0.8494028283396768, 0.16533028030206565, 0.20261778861486768, 0.207072128899927, 0.7566864692799178, 0.20015430399561296, 0.19775293829979845, 0.20993037037611328, 0.20960751034815361, 0.8510634053274946, 0.18901349967990166, 0.1730838716190507, 0.18759079725252026, 0.1791540260217196, 0.18317698933765636, 0.19351384684567763, 0.21545953812985352, 0.18875819777607317, 0.1805931543220437, 0.09038082090045318, 0.07993979396252215, 0.07904914148133524, 0.07474520373348081, 0.0802134545119112, 0.07261911770641949, 0.08556212231571447, 0.07984519970501969, 0.07830609481401662]}, "mutation_prompt": null}
{"id": "493f7d32-8906-4c98-a8d3-83782a1ec63a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            # Small modification: Adjust scaling factor more frequently\n            if self.evaluations % (self.budget // 12) == 0:\n                self.CR = 0.6 + 0.4 * np.random.rand() \n                self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Employs adaptive scaling factor adjustments in Differential Evolution to enhance convergence.", "configspace": "", "generation": 93, "fitness": 0.39093317568633323, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8347025942006995, 0.8165152628572743, 0.8413952268899022, 0.8428648835994834, 0.8529461176619028, 0.8530467855110003, 0.8518624371736946, 0.8405511473090846, 0.8447951654422701, 0.7529512340924245, 0.7373257727960852, 0.7459459245676501, 0.7463100272345513, 0.7509394837010205, 0.7485636468216696, 0.7524196197680086, 0.7459607408487354, 0.7336519134647308, 0.42620321719418863, 0.5020118186798795, 0.1699586619410164, 0.1577216955652515, 0.5593390094117787, 0.5612014419885107, 0.16988945173456338, 0.4332501926465121, 0.16102759271597022, 0.35406222590581815, 0.1362698166527374, 0.14510088666471344, 0.36803698767553716, 0.4340433690206248, 0.15986577193476748, 0.13360193153974742, 0.15178668788592786, 0.14682280726885255, 0.9494560815269601, 0.9598448871523847, 0.9609774742899866, 0.9705069457123291, 0.9821679943679059, 0.9874641796324977, 0.9809422571639775, 0.9763808064633831, 0.9744836443135992, 0.616979720180399, 0.5847542687938313, 0.5806948202002982, 0.6002107496045881, 0.5958143643642693, 0.6303315048721159, 0.6093005197006376, 0.6395244185852471, 0.6248091815944339, 0.6874593480113815, 0.658189130456524, 0.6674901735149672, 0.7751427712779402, 0.7239436815302447, 0.771923184822093, 0.7034699103070174, 0.6525471853026776, 0.7069182469594821, 0.37517274377316523, 0.3596188857420397, 0.3596850634241783, 0.4785814537914581, 0.35728002671388015, 0.5215527301995574, 0.3979085626868998, 0.36615836076328956, 0.38392169276989774, 0.11798345847859659, 0.39477559447569155, 0.009643605476415407, 0.4050575446825553, 0.4267886272468856, 0.3961791815351817, 0.37444438038393957, 0.3556702244781471, 0.36847768286849036, 0.09484076393780638, 0.1706591214841654, 0.1867364283517765, 0.24297744237668661, 0.19861710910251018, 0.23308189990261385, 0.22379779358569263, 0.17993375845735116, 0.21267256604915508, 0.293821081480493, 0.3172001615747041, 0.28670371640290604, 0.34325196565158533, 0.2985604548809798, 0.3396036604438586, 0.4028395311229578, 0.41323210249503317, 0.37584488092990465, 0.05541579898941784, 0.12515413464204483, 0.11339373867219038, 0.09719923660297958, 0.11442727458606383, 0.10364208819961973, 0.1235539018338162, 0.07484501333595761, 0.12926643094959367, 0.23393855771742345, 0.23278449673467405, 0.23539786336974955, 0.29356247042937467, 0.30754048101125375, 0.2635565851945586, 0.261168940072837, 0.23169584605358828, 0.21652818355129932, 0.6786494452058649, 0.6461702530699239, 0.6606858604942724, 0.6691949268061248, 0.6360497451808671, 0.6458328618696545, 0.6474414245177788, 0.6437726938340724, 0.6908977826989469, 0.10428372389245066, 0.09746729368622709, 0.10512522585205042, 0.09837982330258199, 0.08517452840999429, 0.0984328945484656, 0.08640637032236043, 0.0928770432772611, 0.09162807172199539, 0.20608098636237737, 0.43933517987963544, 0.12539937250375244, 0.13777767627795023, 0.16434757916932285, 0.13020763775688915, 0.14523180347981468, 0.1972548782503757, 0.17750498016713612, 0.43263587974056195, 0.4345070071069015, 0.3783985609554308, 0.397901783981118, 0.42966653349475037, 0.43527685116984427, 0.5133500407362752, 0.4664174770170625, 0.4975004521293166, 0.263378982132526, 0.2788815400391036, 0.25554158115805403, 0.2569068482363288, 0.25184883904801614, 0.2888596385652057, 0.3306833654404159, 0.3222956527884352, 0.32487756849665916, 0.19537251916426257, 0.18054960044022195, 0.17810856880879966, 0.216472996009749, 0.20007605596612343, 0.18462862452498474, 0.17927983165921324, 0.18690599789243112, 0.18694575810200287, 0.4831422223262538, 0.30790500703383517, 0.5583192059022569, 0.40295734308496867, 0.4691795953170337, 0.25409539175958207, 0.2104842826605241, 0.30050934075879443, 0.47334349583124735, 0.6244929985658141, 0.7332334052450288, 0.15286558349495116, 0.684347520124491, 0.6882201970223367, 0.18860434713793506, 0.596227546307847, 0.735446752227946, 0.765595319286943, 0.744750102349949, 0.16724838097701644, 0.16642978413698095, 0.19289011306632597, 0.19277152989276003, 0.19763748934067626, 0.15193271447708157, 0.21130014276867182, 0.1488150423983987, 0.19871500515939167, 0.17508357334320612, 0.18928950244419052, 0.18517231895986863, 0.18096536819216003, 0.18674821403712372, 0.17636565247124458, 0.1930862444947682, 0.18051008799971002, 0.0701008122057194, 0.0807079884773877, 0.07113221469077957, 0.08647702101223109, 0.0724950555764814, 0.07652263201523168, 0.0780192743576168, 0.08273921064631173, 0.07479800059231223]}, "mutation_prompt": null}
{"id": "2c8df12f-2c33-48a9-9a94-18354c0fb45b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                scaling_factor = 1 - 0.5 * (self.evaluations / self.budget)  # New scaling factor\n                mutant = a + dynamic_F * scaling_factor * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic scaling factor to increase exploration in early stages and improve convergence speed.", "configspace": "", "generation": 94, "fitness": 0.4259295857553918, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8963440182457866, 0.8926294688974593, 0.8850435131578767, 0.8960094621529863, 0.899672709228206, 0.9048206015116037, 0.8915203124036222, 0.9090592783662672, 0.8884204201340073, 0.8282259824166939, 0.8472316316208199, 0.8354468247162508, 0.8305871462200618, 0.8342205374620826, 0.8374678454932107, 0.8374668335274831, 0.8325124209460316, 0.8354614958956038, 0.16839567269378297, 0.1703485914640973, 0.15481971055565624, 0.15691551716639385, 0.13906521038993525, 0.27330349827061096, 0.16858222430529402, 0.4528311039239573, 0.13899198276906644, 0.1379318385028495, 0.13083859115222296, 0.13251612631191256, 0.13598427332555452, 0.14832415475609273, 0.11367243663637128, 0.13317707310200622, 0.24271112044965437, 0.14079249637743996, 0.9195976763119846, 0.9679013447357375, 0.957057205686348, 0.9767514043691876, 0.9682349122883509, 0.9306893130761396, 0.9701896755316174, 0.9740820642123876, 0.9477708203263815, 0.5525460349185776, 0.5120484844527713, 0.6606207387748793, 0.3822611199068586, 0.4744713388622379, 0.5991161081577336, 0.6340332440951423, 0.3797740494132271, 0.08749488412435091, 0.8933225143538545, 0.8775359600745141, 0.8835764009759737, 0.8636497941260194, 0.8836739212671181, 0.8802709082998114, 0.8806116088184133, 0.8811422839864834, 0.8691503922216675, 0.16713540968821994, 0.16442656133590483, 0.17843843033942608, 0.17026801180160278, 0.18587805883185127, 0.19411099882653582, 0.21340403216432968, 0.18488126115816894, 0.5688002509380139, 0.3284737384559512, 0.19638235002478688, 0.23835350753601647, 0.15831410852266126, 0.19082164859429618, 0.24796057076998124, 0.19141325834203182, 0.20614687357241235, 0.201676022751753, 0.545375301070982, 0.181531978689501, 0.314850962187748, 0.4112465877744961, 0.3507100528462205, 0.030241264023267322, 0.6250012650313763, 0.39705841772647377, 0.6878200987973053, 0.5168422061712538, 0.4304860968537563, 0.6640808511173167, 0.7326120531107112, 0.5898366923008153, 0.3096761895636939, 0.31593202643706186, 0.8117536385295823, 0.5291276978420616, 0.20210637113576335, 0.1882373667852234, 0.15474885456190313, 0.10317307353966754, 0.19333746045089661, 0.31277024396007724, 0.3332665421051597, 0.19476697063143378, 0.24850005080084947, 0.24842223396998542, 0.5103955972435947, 0.4491663231089543, 0.32184564006793115, 0.4535030500370836, 0.4787571195364797, 0.35037793871484735, 0.181167402603577, 0.3548902205456881, 0.6310868960377511, 0.6709088548176154, 0.699577468723908, 0.7162376374690651, 0.6522054667732089, 0.6303398510289651, 0.7860832634621459, 0.8345460304916129, 0.663166250588598, 0.12979140330677963, 0.143094510987268, 0.13930879694273113, 0.16891217483073284, 0.12941970915043788, 0.11030222976677029, 0.1336022545517731, 0.1337075950721801, 0.11709946653558367, 0.14897307368521417, 0.22198088254543258, 0.14468984316057398, 0.1617692429253812, 0.309774031194901, 0.1963173365537516, 0.1439991335677745, 0.15251262370420138, 0.1482921157486824, 0.5785826709771686, 0.6072869402215568, 0.7403771176595673, 0.5804695616688027, 0.7381990277854426, 0.7173197737817092, 0.590567752789668, 0.5406099035950226, 0.7469041788567063, 0.42057329132811383, 0.5130235730396079, 0.3762905289630085, 0.582719818163973, 0.4033272354017221, 0.5160473945794681, 0.6513840724565187, 0.6686766282811107, 0.6147532281571519, 0.23842379120515877, 0.20086000289870842, 0.19419194748668955, 0.20797857883250925, 0.21386066180319485, 0.19991741374009175, 0.22208571626452112, 0.22141770091990243, 0.198323465111359, 0.23882434393591323, 0.2311770709417197, 0.34171390067715723, 0.7255247259887235, 0.24054986425225844, 0.6178858470587094, 0.212425336168092, 0.6821521249286056, 0.2790325707400041, 0.18292459617509926, 0.16044621512659762, 0.8551530400178057, 0.8426566084375924, 0.8194841065015307, 0.19573081040125895, 0.1702396801917737, 0.6659710201800642, 0.8957238282393345, 0.15487426437453522, 0.27858282291902736, 0.6555825767855971, 0.2067594269556926, 0.34897687387397835, 0.16583590023083383, 0.21150323458198605, 0.21106685194333585, 0.12728655588361393, 0.18068617872601755, 0.199067429442482, 0.17180848783023084, 0.18269053051783324, 0.17258945534644177, 0.1878576719233871, 0.1800152743240968, 0.18191019727742075, 0.18327153543446062, 0.0874784300525494, 0.10470844616783292, 0.08388473890097137, 0.08294263803432622, 0.08895840082742612, 0.08940244007902587, 0.09005414797264388, 0.08573669063497524, 0.08835625112677481]}, "mutation_prompt": null}
{"id": "0214579f-510d-40eb-b831-4febb17350b3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.11 * (best_solution - a)  # Adjusted perturbation\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Slightly adjusted mutation strategy by introducing a small scaling factor to improve exploration.", "configspace": "", "generation": 95, "fitness": 0.4667278238255062, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8976106073649261, 0.9000657532847419, 0.8763859037473892, 0.8950342949258885, 0.9036433714472523, 0.904500926909357, 0.8942533840148472, 0.8914229754553249, 0.8762144866135154, 0.8278982284751639, 0.8296896509650705, 0.8247385763097912, 0.8274146067731593, 0.8270463353919798, 0.8084006173703193, 0.8281061680579538, 0.824946673386561, 0.8297770165622906, 0.19117704967908145, 0.4003708596422819, 0.15721852746975873, 0.3553002102722831, 0.1520031440691122, 0.5750268385193008, 0.15175994755930788, 0.13843329824482176, 0.12988056797151692, 0.1581195948753108, 0.1343977157219649, 0.1357506483145633, 0.1293084356097639, 0.1415723956579672, 0.12987027840067966, 0.10545399092125718, 0.1342612189556347, 0.14302795177598915, 0.9552442027769146, 0.9412693619349852, 0.9776443132898892, 0.95188932700737, 0.9796289222372545, 0.9748883826077719, 0.9703409292780946, 0.9594680383705915, 0.9639784219480702, 0.7518793410272637, 0.7399325669179564, 0.7673989816267824, 0.747708244460169, 0.7543097647744804, 0.7377785888767479, 0.7467455768296114, 0.7627205824801172, 0.08810339557948266, 0.882615859480321, 0.8886802562348242, 0.38438360114924386, 0.8524011788667127, 0.20974128803615122, 0.8672402589800241, 0.8891982376866046, 0.8959904289534582, 0.8580181515351892, 0.2756627584459683, 0.1956501931634811, 0.30211025602114827, 0.18262435885766937, 0.23569483785294976, 0.2856268117979761, 0.23759002701712384, 0.2147232779605327, 0.271709010200039, 0.25376183616542947, 0.1472048580238694, 0.28923494283368023, 0.16399108957809805, 0.21487387568331484, 0.3589016181137388, 0.25769378172603696, 0.2109602210048479, 0.6286907872219006, 0.5370620514468012, 0.6389532120210641, 0.1908792568247647, 0.7202617410661369, 0.6888289109667469, 0.5372860685182117, 0.6842820873998916, 0.7189906806497635, 0.6994670151459563, 0.7782425640853916, 0.35003768020884063, 0.7757060502186159, 0.7396532580368845, 0.49088963861602575, 0.7412026951758851, 0.7946693277777952, 0.7891230271281158, 0.4097255350042791, 0.12058815041233562, 0.14654460632450883, 0.1658519090066728, 0.4328273486470181, 0.2655100547972482, 0.29659778039676243, 0.1945211516212103, 0.25896044438471166, 0.1549488432535665, 0.5416416921464307, 0.30394388853615883, 0.49705076877412013, 0.3168385858086933, 0.5154084988448641, 0.5289766978460155, 0.4645820219432246, 0.5048884067083999, 0.5019241799630266, 0.8256134682692289, 0.8603612139317024, 0.8491848860453028, 0.746167540985682, 0.8610015723044953, 0.848932596425227, 0.7627415068514195, 0.8650203165001652, 0.7141207629408763, 0.12476637280094127, 0.11004588509751789, 0.10771105587606467, 0.1633144378620507, 0.10231756943791881, 0.15469566512088406, 0.1651045828852662, 0.11164026388324078, 0.12968158635987836, 0.14921050112430334, 0.24585038996053332, 0.1312436309903494, 0.15020131852054108, 0.13472022128827776, 0.14169805769658528, 0.14345262417361226, 0.17948905116713654, 0.17062963521959829, 0.6744077026466098, 0.6738095914020568, 0.6483319599648881, 0.6789762563591066, 0.5684155777147462, 0.6801989697346552, 0.6850607489676153, 0.599859170062139, 0.7027323369854355, 0.515756379932318, 0.5203450500578781, 0.45945385985866505, 0.5844044393993971, 0.5132793985300133, 0.5256717527272989, 0.5992082045626987, 0.5434113934457377, 0.5028868082023403, 0.23416165550715462, 0.2037515315005355, 0.2316294389282172, 0.21006492112757358, 0.19652546665469417, 0.20576599988003508, 0.19359167100385455, 0.19898022444836339, 0.21319620223695757, 0.6147672998130651, 0.5752277556613591, 0.201802640268261, 0.6610447449161015, 0.2406222617026711, 0.24041101218353655, 0.7000344817466164, 0.6460492153675328, 0.40696479364566096, 0.16905997583338161, 0.19366667358973289, 0.15294565265306015, 0.888173422303695, 0.6915703054753782, 0.17271810927674291, 0.8371963467111172, 0.14001324232621104, 0.8784272006470559, 0.8847414303400735, 0.20760022161987546, 0.8584294560397014, 0.16142618134795172, 0.8650613361057735, 0.8390483547439904, 0.1929660473074385, 0.640068947013454, 0.15557490585891864, 0.18465998873995737, 0.1770668652692069, 0.18544053002463756, 0.18092663425560296, 0.19387317359199407, 0.1793910375618507, 0.18904610666404886, 0.206331934494002, 0.1816141207142744, 0.08043427377878165, 0.07827072538245816, 0.08695877339233071, 0.08424654026313672, 0.08468502965166413, 0.08358416404532087, 0.08877802652943101, 0.08195414495099818, 0.08469161190535601]}, "mutation_prompt": null}
{"id": "2f6d667d-45bc-4942-a8fa-78ebcdb7ec50", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)  # Perturb using best_solution\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            decay_factor = 0.998  # Introduced decay factor for scaling\n            self.F = (0.6 + 0.2 * np.random.rand()) * decay_factor\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive scaling factor decay to improve convergence speed by dynamically adjusting exploration-exploitation balance.", "configspace": "", "generation": 96, "fitness": 0.46842129448968634, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.9030385882663999, 0.9005631451638856, 0.8851515316868758, 0.9042408688400021, 0.8886669963526322, 0.8937423764889192, 0.8889819579008249, 0.8963538822424322, 0.8858555562191647, 0.8333549856664949, 0.8338969921899817, 0.8168648154773723, 0.8239564607798966, 0.8216081376801986, 0.8154930946924266, 0.8229544922553453, 0.824117064540964, 0.8184422277909406, 0.5318890307856898, 0.1559014929249557, 0.15126861054320595, 0.15280695991396276, 0.31801077240406717, 0.5957299922276539, 0.5770086993568069, 0.4029197618085969, 0.5312913888864588, 0.15509364650622104, 0.11202088325037418, 0.13117406182396085, 0.13221867068196114, 0.1278599035519421, 0.15467662640232016, 0.1252766176880057, 0.12143603361226774, 0.12365846663132485, 0.9530515906893177, 0.9613330837445632, 0.977809854361886, 0.9767575752407357, 0.9682824823816748, 0.9464577457317521, 0.9701461467669317, 0.9723195524347278, 0.9549469232873528, 0.7673398271677485, 0.6676429436454903, 0.7358698771853334, 0.7343214371597668, 0.7477814904769708, 0.7596647016399373, 0.7712137105092005, 0.775439584000804, 0.08742603114889824, 0.8664178047487912, 0.8679793323995131, 0.850124064668432, 0.8667631843468192, 0.8770769096945645, 0.8499333956738991, 0.8219814539464688, 0.8719970943845174, 0.895343145074614, 0.21971138893008368, 0.32236396609847284, 0.2553641851091448, 0.13021214991478303, 0.25059506844261603, 0.3154426007378357, 0.2698396294597857, 0.44167934270609444, 0.5835630465806989, 0.22876465677859215, 0.2224551601036866, 0.3240841691882187, 0.19769966398467975, 0.3510707022463051, 0.2836711052292449, 0.2294475288017871, 0.2065507564891651, 0.23484894378594612, 0.732944444084546, 0.29743532376088155, 0.3028359972639201, 0.679022595278878, 0.27193700656584807, 0.6979231052749566, 0.5683335115295356, 0.182002946007373, 0.7174763318883721, 0.4368672788227729, 0.31682878203673526, 0.759455769698826, 0.6295105607444293, 0.6679576350892502, 0.41657931688646344, 0.5769233544569811, 0.7855343069677818, 0.35211661008147754, 0.11415585096041836, 0.0960669437626066, 0.1932344254009254, 0.20092018894587915, 0.2740019824114338, 0.6403731450370866, 0.1873009984287073, 0.17185539258142835, 0.15062011421702004, 0.5927159213534325, 0.4382724312979218, 0.41911282983632747, 0.46815981310920185, 0.4308229295685059, 0.48290922272490966, 0.5246751191143477, 0.23403154724617548, 0.4775449886393248, 0.8299047215649924, 0.8567527408929232, 0.7665911057975139, 0.8308702500979024, 0.8408949881617551, 0.8375883855425849, 0.8578903960945103, 0.854385302649921, 0.8071910611333941, 0.11252665365123415, 0.12608584073732765, 0.0968044552795887, 0.1409771332778038, 0.10808682383155499, 0.13343642024581237, 0.12962092614080778, 0.11189783770119432, 0.09582223762721154, 0.26515260222763504, 0.1926785758461369, 0.5226101526055473, 0.15649072628707794, 0.13700221108184452, 0.26379937636455075, 0.13884352875188566, 0.13762689073780765, 0.131113933897833, 0.6730604719778612, 0.5894937252774207, 0.5630183589990427, 0.6724756252132938, 0.7052488664379408, 0.6507600630859128, 0.6125538658882754, 0.7259944848902093, 0.692792488804864, 0.5276698303522658, 0.42253383080282114, 0.4927805747041687, 0.5167494466336193, 0.5149306482449447, 0.46975237832180083, 0.6160210516151552, 0.5216287132006068, 0.47925464712452437, 0.1887090783900035, 0.21602996802339314, 0.19497848593893063, 0.22682843509255513, 0.2039025423034767, 0.19774309444800442, 0.20600224323492966, 0.19797435646166195, 0.19037421258930987, 0.6510495060745414, 0.533341290521605, 0.6528388460023469, 0.5662172880269476, 0.23868832997477962, 0.2094093782007822, 0.4490716028726569, 0.22499745809997695, 0.23927061258086346, 0.19756386271253212, 0.1755194647869106, 0.8778563745896735, 0.8767052388907606, 0.194773027867998, 0.8715601834735687, 0.8677188829844091, 0.7356378556421542, 0.8896670712908151, 0.1547538203568587, 0.6043905766059555, 0.8216706022133224, 0.20776219213797942, 0.8802085649878663, 0.1657255725748933, 0.21129227453270727, 0.21050017518446484, 0.12679062583490508, 0.2086294333924651, 0.1868625278954994, 0.20929943365779735, 0.17653161239896942, 0.19449301625962478, 0.18753613134793856, 0.20280750171256956, 0.19826956198482626, 0.17095850538988666, 0.08547957074526347, 0.08285782347814752, 0.07535419473340133, 0.08522823101673638, 0.08047763861086643, 0.09324152906520244, 0.07423197481532529, 0.08653537045360449, 0.08454958609944296]}, "mutation_prompt": null}
{"id": "14072f25-f720-4e42-95bb-3d83a0ab9d6b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.65 + 0.35 * np.random.rand()  # Slightly adjusted CR range\n            self.F = 0.65 + 0.25 * np.random.rand()  # Slightly adjusted F range\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive exploration through dynamic scaling and crossover adjustments for enhanced convergence.", "configspace": "", "generation": 97, "fitness": 0.4826223368691887, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8737768195507682, 0.8739031480977395, 0.8707577946817695, 0.8692794219020914, 0.885902368176991, 0.8878038742306609, 0.8698230986260287, 0.8842812189324463, 0.8767870917650913, 0.7982748980011071, 0.7991734833382743, 0.788042415657292, 0.8151449035751723, 0.8104889444358407, 0.7957006559631886, 0.8066154233741971, 0.7949113875355848, 0.789223801544702, 0.4707908285853376, 0.12212504037056626, 0.14215653929214933, 0.4936719604793749, 0.13845403939996614, 0.1640924818397259, 0.14145171053947347, 0.15650227843503928, 0.15896234498529394, 0.13024740399108048, 0.19977060923187262, 0.1506011122560259, 0.12706931704524627, 0.11821375400122947, 0.12441205929284949, 0.1485380806321135, 0.1321671364910928, 0.336315173198072, 0.9467515102101873, 0.9699093767474896, 0.9588672043885453, 0.9373537550384348, 0.9672528245005765, 0.9854746060576204, 0.9243801481056012, 0.9825057045337272, 0.9253534476058964, 0.7486648231778626, 0.705839114568396, 0.7156555568475109, 0.7328874164207235, 0.7442389184385445, 0.7389780275519047, 0.7325002541513901, 0.7348487534292665, 0.7305469523964412, 0.8415964407235736, 0.8141476175436346, 0.8429929805094891, 0.8190438927563968, 0.8484760244014368, 0.8579517921103638, 0.845997281456224, 0.8412872548119086, 0.8167710470044083, 0.6397078578824518, 0.6227737195976097, 0.20058054487135601, 0.6659187880927686, 0.27287423096947394, 0.4282734801805693, 0.6511570006833627, 0.2932869824020775, 0.30460736153445533, 0.6694443616344725, 0.6138998871163859, 0.35703717981971694, 0.6902556986613737, 0.7402931916576423, 0.48801390999076655, 0.6081545606777137, 0.19353737234353752, 0.5588512642300852, 0.4362333001962686, 0.6988657377219287, 0.6797104205344161, 0.7196812324299272, 0.46865521533628907, 0.6718673496799109, 0.41449447391295047, 0.6889248534058061, 0.6898002891466586, 0.7350882520362452, 0.6923978464495493, 0.7581060377487543, 0.43052861386427643, 0.7509326708577246, 0.6853603440571615, 0.7771462338006362, 0.741373155804315, 0.7580130582004714, 0.09098005173592372, 0.12039606397121094, 0.10893084544948983, 0.48585810560375475, 0.26155017520156276, 0.4580712580481793, 0.23241825705909036, 0.19598454827485234, 0.19102658206840917, 0.4246078485420447, 0.5242859379060699, 0.4826919544667262, 0.5399256955527199, 0.49141448690323686, 0.6196929663639998, 0.4730445999586861, 0.609833127465262, 0.545476981950419, 0.758878891156168, 0.8322711605429225, 0.8235663836753594, 0.8293017346162868, 0.8451712760200548, 0.8274693537533528, 0.8197476199383096, 0.6769099022467818, 0.819363431595054, 0.10801911566453581, 0.10155350213730996, 0.1214243005981307, 0.11399717285872557, 0.09233629584884817, 0.10213603487439593, 0.11244916704174879, 0.09860127301064625, 0.111687027723406, 0.14284525840742734, 0.3349492380457383, 0.12847324128352744, 0.16248755566558026, 0.15058138321609327, 0.36747050876817366, 0.1590361600961282, 0.19423661108420343, 0.16218554255822693, 0.6067389811124433, 0.5419755876015515, 0.6236363154466047, 0.612650251506649, 0.6167499150621136, 0.6533602464213437, 0.5296450122096705, 0.6908632167993265, 0.6424039536998589, 0.46620505026028713, 0.4891291590645993, 0.4290472691487056, 0.5067555321766302, 0.47399627216272644, 0.39158072825994594, 0.5048263779177292, 0.5625167890514416, 0.4314825304591444, 0.18747634625555076, 0.2296496688974008, 0.19648104028021152, 0.19983946689556265, 0.19801622274464326, 0.1907206614012209, 0.18119346502304956, 0.18392762580245148, 0.20769292898942604, 0.5856170019857849, 0.5089246018393341, 0.6047313166557452, 0.4724555202409787, 0.6684485465056473, 0.3980207681131793, 0.22938616694192437, 0.23165034801063666, 0.5121468064776109, 0.18105891589691492, 0.16203084250222477, 0.14242292325839756, 0.16469712884404164, 0.1860859188440177, 0.18635843508506544, 0.8473662646704712, 0.8291988572577065, 0.8822718101431387, 0.1673871375709841, 0.1675542838431746, 0.8018189743380484, 0.20649519436066133, 0.8554276229418144, 0.19917159145545316, 0.2078543739878561, 0.8244571047717324, 0.15530484483811835, 0.17435143589967372, 0.17839652030972464, 0.19607082538642895, 0.19548962510954526, 0.19515796033699206, 0.18200853710650822, 0.18635182879604817, 0.19226203350452964, 0.18793244654215846, 0.07932331582342123, 0.08548101275544273, 0.08002491205263018, 0.0792145761672568, 0.08933766811523491, 0.08697797206370628, 0.07503488779868717, 0.07668615659990896, 0.0745286819250165]}, "mutation_prompt": null}
{"id": "a7b949c3-1e1c-40f0-ab37-4ced722b72fb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            decay_factor = 0.95 + 0.05 * (self.evaluations / self.budget)  # Decay factor\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget)))\n                mutant = a + dynamic_F * (b - c) + 0.1 * decay_factor * (best_solution - a)  # Apply decay\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a decay factor in mutation weight to enhance convergence speed by dynamically adjusting exploitation-exploration balance.", "configspace": "", "generation": 98, "fitness": 0.48265848720621535, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.890995507167897, 0.8941661445882645, 0.8891776092499198, 0.881372648123461, 0.8881152333959245, 0.8987448408185355, 0.8854043668375866, 0.8997713814256847, 0.8892459073232175, 0.7995651038133295, 0.8390926265188949, 0.8123817441391747, 0.8271817555989587, 0.8270955935516848, 0.8162842159211925, 0.8162778253750012, 0.8162478273599364, 0.8191271795449614, 0.1604118248263834, 0.5016348628634624, 0.4524518705859879, 0.2925320878117482, 0.36627511624909126, 0.1152249775981612, 0.47245406214015206, 0.43768483046626294, 0.5088249605668738, 0.3375876542606828, 0.1397613650109748, 0.12691933725254034, 0.13155623841497766, 0.41545611240223335, 0.15760085112233368, 0.150495207184271, 0.16111426753592517, 0.1317565870166607, 0.9399920519169975, 0.9371229106320745, 0.9650171192136184, 0.9768334748999469, 0.9722990584545397, 0.9607610463087303, 0.9650023760654112, 0.9656193234014747, 0.9588845957411096, 0.7087544360883342, 0.7005851960101719, 0.591697705362162, 0.7225868741148602, 0.7618506676919894, 0.7508186756305444, 0.7144392539123778, 0.6502552453621915, 0.08723951040560951, 0.8859299707559514, 0.9020902012092938, 0.8743331251059423, 0.874015501752019, 0.8619500395974349, 0.8590151972090666, 0.8722219023291273, 0.8873763439446916, 0.8696673439489564, 0.15774652423098046, 0.2458347014925567, 0.6563845848207017, 0.2784041686538671, 0.2729256338898697, 0.537526150111872, 0.19784896672236407, 0.22100862312357605, 0.2074085944643207, 0.236678737146089, 0.4484848110228683, 0.19855873388605594, 0.21132125993756878, 0.16967528890198447, 0.21748307717329984, 0.17910122781829707, 0.6798038565309237, 0.22738127524262797, 0.6200503126588658, 0.5516520704704408, 0.6561045510563559, 0.34367138121728624, 0.6899638081637771, 0.7109187350557837, 0.5742506277412353, 0.7251352480188025, 0.6183187215735921, 0.5097485419365582, 0.7520549218712531, 0.7657199611681205, 0.2409742648340334, 0.7614439153299901, 0.7484355817004655, 0.763021020092037, 0.7629854079331114, 0.769372734399715, 0.08912929836220951, 0.1881680677932822, 0.2523857814538022, 0.5352913320834729, 0.2455322870103882, 0.3273955357955327, 0.1807607116937373, 0.33329344340996503, 0.19722323442436718, 0.5784019194634793, 0.43275132823828744, 0.3637065289013792, 0.545069044261325, 0.5794364041882092, 0.5926075431545191, 0.6167476852392064, 0.5058564937417677, 0.5716281944798912, 0.8387388157232679, 0.705872078847787, 0.8574328528745656, 0.7938397787089441, 0.7444783494300506, 0.6804304604193134, 0.8593203191709231, 0.763231323777313, 0.7742012495191815, 0.11596027396679565, 0.11356857281439248, 0.11275313708402224, 0.10218859782731271, 0.1099265089939514, 0.14256328343896274, 0.2620657941660609, 0.10525498539495859, 0.10688345172123193, 0.19342765900643777, 0.12340530590745546, 0.14587765978187794, 0.14748262686030988, 0.12992977236327496, 0.12958813656155, 0.21604556968117583, 0.1928270999966728, 0.14548887759085105, 0.5594781779001571, 0.6451179144576613, 0.6682179744161054, 0.7012451583467451, 0.6919019937148317, 0.6184996295830193, 0.4996109292810347, 0.6887104637625372, 0.6915156568273878, 0.43355990610148043, 0.4832490407945491, 0.4393984953964164, 0.5584921884154, 0.45553191761234946, 0.5416690291360676, 0.5558857681906061, 0.5689676523495029, 0.578661662252306, 0.20202031564693512, 0.19613256389935418, 0.20052308027126475, 0.19091161793076727, 0.19413690596804367, 0.199748254183584, 0.21836014713729524, 0.22009621338749374, 0.18643583238190298, 0.7104872686953503, 0.6298027706458684, 0.22434681541229684, 0.23052174808310888, 0.2825662459306516, 0.7125667838130509, 0.6830505769358486, 0.5897442896627334, 0.5856620690311582, 0.18507696061218282, 0.17806444316144754, 0.15212706271625698, 0.8839744538895487, 0.8615646053383272, 0.8491840509304647, 0.871200706838486, 0.1758783274632646, 0.8927857847281498, 0.7994357295755516, 0.20621337630411984, 0.15629148977240825, 0.8922713493354162, 0.16861646545691433, 0.8226297563291346, 0.21044260816676186, 0.21051915151011225, 0.12661069008727632, 0.1971815661713967, 0.1867524027749201, 0.17795787355458925, 0.19572735474787328, 0.19318669197480154, 0.19232084225291823, 0.17347630663701097, 0.20785869324313122, 0.17776541039118643, 0.08808774493877569, 0.09938648022719698, 0.08458977703054693, 0.07852597382746185, 0.0829331897730804, 0.07218494626336525, 0.07663215829506065, 0.07734920582091587, 0.0906882820059074]}, "mutation_prompt": null}
{"id": "b6534b29-4192-477b-b64c-01e3342eee31", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25\n        self.CR = 0.7\n        self.F = 0.9\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))\n        self.population_fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.population_fitness = np.array([func(ind) for ind in self.population])\n        self.evaluations += self.pop_size\n        best_idx = np.argmin(self.population_fitness)\n        best_solution = self.population[best_idx]\n        best_fitness = self.population_fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_F = self.F * (0.65 + 0.35 * (1 - (self.evaluations / self.budget) ** 2))  # Changed exponent to 2 for dynamic_F\n                mutant = a + dynamic_F * (b - c) + 0.1 * (best_solution - a)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                adaptive_CR = self.CR + 0.15 * np.random.rand() * (1 - self.evaluations / self.budget) \n                crossover_mask = np.random.rand(self.dim) < adaptive_CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness < self.population_fitness[i]:\n                    self.population[i] = trial\n                    self.population_fitness[i] = trial_fitness\n\n            current_best_idx = np.argmin(self.population_fitness)\n            current_best_fitness = self.population_fitness[current_best_idx]\n            if current_best_fitness < best_fitness:\n                best_solution = self.population[current_best_idx]\n                best_fitness = current_best_fitness\n\n            self.CR = 0.6 + 0.4 * np.random.rand()\n            self.F = 0.6 + 0.2 * np.random.rand()\n\n            if self.evaluations % (self.budget // 8) == 0:\n                self.pop_size = max(5, int(self.pop_size * 0.85))\n                self.population = self.population[:self.pop_size]\n                self.population_fitness = self.population_fitness[:self.pop_size]\n\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a slight modification to the mutation factor dynamic_F formula for better exploration-exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.47284219056504606, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "31395251-01f3-44c5-a008-b21181be2838", "metadata": {"aucs": [0.8783232043144547, 0.8927327139240057, 0.8777044880058249, 0.8840106533589587, 0.8799784891890249, 0.8813876943796567, 0.8803404247622298, 0.8947959085227988, 0.8696765447275995, 0.7990626120923112, 0.8081507467070649, 0.8197854821496038, 0.7896022048212107, 0.8065910462279366, 0.8148461057939285, 0.8230302145356806, 0.8173400182094396, 0.8060584453955599, 0.17183731496295518, 0.37710129561785066, 0.1709962174338875, 0.14472213533771394, 0.5169686356638579, 0.14391680236028592, 0.5406610153857333, 0.30677236588157075, 0.1645856824627786, 0.1319964204729588, 0.18640240028892596, 0.14236923510525334, 0.13577425918498243, 0.14041267743962982, 0.14033825417023205, 0.1319653837720567, 0.12415616467909862, 0.3860816994837043, 0.9496231792791412, 0.944499034114358, 0.9778141825534103, 0.9767868424644629, 0.9702080516716945, 0.961772964650411, 0.9700832244403577, 0.9626037435270541, 0.9364165624546141, 0.7260532577613878, 0.7118118127373407, 0.7272485126957122, 0.7756886232699596, 0.7216485361310526, 0.7430215897829058, 0.7398558758881579, 0.740717458827632, 0.0872681605483816, 0.8907395528764463, 0.8642601828653101, 0.8464038163975962, 0.8672148718347822, 0.27048292026624365, 0.8609394639413565, 0.8682134012062313, 0.8760756211662593, 0.8534330399096879, 0.6240661575148031, 0.69345188371819, 0.425513437504488, 0.5397069882263945, 0.6618749797801233, 0.5722648467266984, 0.6752413202507614, 0.234064059235915, 0.2659254651385279, 0.5267608483403925, 0.2516292412317803, 0.23757582974413183, 0.4569216539654918, 0.1905518179606237, 0.36262531837371514, 0.2695682513754605, 0.25363702343556327, 0.39784644507263456, 0.6890635102265737, 0.6150236814809237, 0.6553244372426528, 0.47072888782575095, 0.5905004941847156, 0.6196726580990717, 0.5817978895775917, 0.6976668236983832, 0.6260302805148479, 0.7241142440823284, 0.7718001625571325, 0.44394632231116327, 0.6992388249853467, 0.7701851465549832, 0.6914746542235891, 0.7597663474904409, 0.7672890027690016, 0.7459870626640979, 0.18044061257159205, 0.14445301006331046, 0.06533583037437873, 0.2672931919914988, 0.6243899643071649, 0.4279161213898811, 0.1331008407017078, 0.18658075846637212, 0.1741898990516424, 0.4298160547425113, 0.5886478709878759, 0.38161984886756994, 0.44989890781230657, 0.5555020010632321, 0.445412565248016, 0.5603867762741028, 0.29112537359645685, 0.5657753565409398, 0.8175458996364448, 0.8547739036691329, 0.8496501037007891, 0.7791691402716725, 0.836500416140202, 0.835370901749502, 0.8590879807027677, 0.8327118907058061, 0.834134127848319, 0.09953372080324607, 0.1124435561496584, 0.09454615114889187, 0.10189691280627544, 0.12820864604557303, 0.1044725119517993, 0.11593564389109035, 0.13972677974068282, 0.08767817240655751, 0.14592170723369802, 0.1358090873891863, 0.15794959577422674, 0.22025853908625637, 0.13178200965807574, 0.13275239438354425, 0.41389703961964774, 0.21297164418282621, 0.16068889975402412, 0.6019797780976817, 0.6620107712506184, 0.6103094351067375, 0.6057307063562813, 0.6113142478341589, 0.6106336749418191, 0.650774194744401, 0.6729612758966423, 0.6435343532645122, 0.4770955219932633, 0.45290644703577265, 0.44365797256223105, 0.4580099077650085, 0.5111811989299849, 0.5119830974670263, 0.5449864775553166, 0.5344116601514426, 0.49647305734670644, 0.19595890599850851, 0.19567436140269123, 0.19897206953860813, 0.17831240134340842, 0.1937852569677373, 0.19362223092040542, 0.18087036739268447, 0.19627609382853894, 0.19556981500192994, 0.5844347289539684, 0.2317508610580543, 0.21164561657390724, 0.5363244899681856, 0.6503953916768059, 0.4722873996544992, 0.22335905871881145, 0.686645377704696, 0.2075130878802134, 0.17970342462477895, 0.18072387925550903, 0.19430849518141968, 0.8629686027321372, 0.19205522811657383, 0.8918914138966958, 0.169708370298582, 0.18735579219915954, 0.8895838490207568, 0.8331518788891887, 0.1554892710568061, 0.16664707415764746, 0.20780103547490303, 0.8663413292196742, 0.20875311134984376, 0.2102595685025649, 0.21039386527634418, 0.16035378482222895, 0.20469418877891243, 0.1779011234824136, 0.1966488177268052, 0.18206752578394836, 0.1959183647991487, 0.18164748560443134, 0.19099133259665346, 0.180233407253227, 0.17096264075478007, 0.08769788912223098, 0.07298197990223676, 0.07953688245295454, 0.08222600459926865, 0.0792118974545345, 0.08247541015606652, 0.07271393951018512, 0.0823455642189681, 0.0853196422276602]}, "mutation_prompt": null}
